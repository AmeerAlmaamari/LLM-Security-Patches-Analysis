{
  "VUL4J-1": {
    "vul_id": "VUL4J-1",
    "cve_id": "CVE-2017-18349",
    "project": "alibaba_fastjson",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=com.alibaba.json.bvt.bug.Issue1005#test_for_issue",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/alibaba/fastjson/commit/f5903fa56497c00ed0703ac875b511f9bd5f1d8e",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/com/alibaba/fastjson/serializer/ObjectArrayCodec.java",
        "file_name": "ObjectArrayCodec.java",
        "vulnerable_code": "/*\n * Copyright 1999-2101 Alibaba Group.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.fastjson.serializer;\n\nimport java.io.IOException;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\n\nimport com.alibaba.fastjson.JSONArray;\nimport com.alibaba.fastjson.parser.DefaultJSONParser;\nimport com.alibaba.fastjson.parser.JSONLexer;\nimport com.alibaba.fastjson.parser.JSONToken;\nimport com.alibaba.fastjson.parser.deserializer.ObjectDeserializer;\nimport com.alibaba.fastjson.util.TypeUtils;\n\n/**\n * @author wenshao[szujobs@hotmail.com]\n */\npublic class ObjectArrayCodec implements ObjectSerializer, ObjectDeserializer {\n\n    public static final ObjectArrayCodec instance = new ObjectArrayCodec();\n\n    public ObjectArrayCodec(){\n    }\n\n    public final void write(JSONSerializer serializer, Object object, Object fieldName, Type fieldType, int features)\n                                                                                                       throws IOException {\n        SerializeWriter out = serializer.out;\n\n        Object[] array = (Object[]) object;\n\n        if (object == null) {\n            out.writeNull(SerializerFeature.WriteNullListAsEmpty);\n            return;\n        }\n\n        int size = array.length;\n\n        int end = size - 1;\n\n        if (end == -1) {\n            out.append(\"[]\");\n            return;\n        }\n\n        SerialContext context = serializer.context;\n        serializer.setContext(context, object, fieldName, 0);\n\n        try {\n            Class<?> preClazz = null;\n            ObjectSerializer preWriter = null;\n            out.append('[');\n\n            if (out.isEnabled(SerializerFeature.PrettyFormat)) {\n                serializer.incrementIndent();\n                serializer.println();\n                for (int i = 0; i < size; ++i) {\n                    if (i != 0) {\n                        out.write(',');\n                        serializer.println();\n                    }\n                    serializer.write(array[i]);\n                }\n                serializer.decrementIdent();\n                serializer.println();\n                out.write(']');\n                return;\n            }\n\n            for (int i = 0; i < end; ++i) {\n                Object item = array[i];\n\n                if (item == null) {\n                    out.append(\"null,\");\n                } else {\n                    if (serializer.containsReference(item)) {\n                        serializer.writeReference(item);\n                    } else {\n                        Class<?> clazz = item.getClass();\n\n                        if (clazz == preClazz) {\n                            preWriter.write(serializer, item, null, null, 0);\n                        } else {\n                            preClazz = clazz;\n                            preWriter = serializer.getObjectWriter(clazz);\n\n                            preWriter.write(serializer, item, null, null, 0);\n                        }\n                    }\n                    out.append(',');\n                }\n            }\n\n            Object item = array[end];\n\n            if (item == null) {\n                out.append(\"null]\");\n            } else {\n                if (serializer.containsReference(item)) {\n                    serializer.writeReference(item);\n                } else {\n                    serializer.writeWithFieldName(item, end);\n                }\n                out.append(']');\n            }\n        } finally {\n            serializer.context = context;\n        }\n    }\n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T deserialze(DefaultJSONParser parser, Type type, Object fieldName) {\n        final JSONLexer lexer = parser.lexer;\n        if (lexer.token() == JSONToken.NULL) {\n            lexer.nextToken(JSONToken.COMMA);\n            return null;\n        }\n\n        if (lexer.token() == JSONToken.LITERAL_STRING) {\n            byte[] bytes = lexer.bytesValue();\n            lexer.nextToken(JSONToken.COMMA);\n            return (T) bytes;\n        }\n\n        Class componentClass;\n        Type componentType;\n        if (type instanceof GenericArrayType) {\n            GenericArrayType clazz = (GenericArrayType) type;\n            componentType = clazz.getGenericComponentType();\n            if (componentType instanceof TypeVariable) {\n                TypeVariable typeVar = (TypeVariable) componentType;\n                Type objType = parser.getContext().type;\n                if (objType instanceof ParameterizedType) {\n                    ParameterizedType objParamType = (ParameterizedType) objType;\n                    Type objRawType = objParamType.getRawType();\n                    Type actualType = null;\n                    if (objRawType instanceof Class) {\n                        TypeVariable[] objTypeParams = ((Class) objRawType).getTypeParameters();\n                        for (int i = 0; i < objTypeParams.length; ++i) {\n                            if (objTypeParams[i].getName().equals(typeVar.getName())) {\n                                actualType = objParamType.getActualTypeArguments()[i];\n                            }\n                        }\n                    }\n                    if (actualType instanceof Class) {\n                        componentClass = (Class) actualType;\n                    } else {\n                        componentClass = Object.class;\n                    }\n                } else {\n                    componentClass = TypeUtils.getClass(typeVar.getBounds()[0]);\n                }\n            } else {\n                componentClass = TypeUtils.getClass(componentType);\n            }\n        } else {\n            Class clazz = (Class) type;\n            componentType = componentClass = clazz.getComponentType();\n        }\n        JSONArray array = new JSONArray();\n        parser.parseArray(componentClass, array, fieldName);\n\n        return (T) toObjectArray(parser, componentClass, array);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private <T> T toObjectArray(DefaultJSONParser parser, Class<?> componentType, JSONArray array) {\n        if (array == null) {\n            return null;\n        }\n\n        int size = array.size();\n\n        Object objArray = Array.newInstance(componentType, size);\n        for (int i = 0; i < size; ++i) {\n            Object value = array.get(i);\n\n            if (value == array) {\n                Array.set(objArray, i, objArray);\n                continue;\n            }\n\n            if (componentType.isArray()) {\n                Object element;\n                if (componentType.isInstance(value)) {\n                    element = value;\n                } else {\n                    element = toObjectArray(parser, componentType, (JSONArray) value);\n                }\n\n                Array.set(objArray, i, element);\n            } else {\n                Object element = null;\n                if (value instanceof JSONArray) {\n                    boolean contains = false;\n                    JSONArray valueArray = (JSONArray) value;\n                    int valueArraySize = valueArray.size();\n                    for (int y = 0; y < valueArraySize; ++y) {\n                        Object valueItem = valueArray.get(y);\n                        if (valueItem == array) {\n                            valueArray.set(i, objArray);\n                            contains = true;\n                        }\n                    }\n                    if (contains) {\n                        element = valueArray.toArray();\n                    }\n                }\n\n                if (element == null) {\n                    element = TypeUtils.cast(value, componentType, parser.getConfig());\n                }\n                Array.set(objArray, i, element);\n\n            }\n        }\n\n        array.setRelatedArray(objArray);\n        array.setComponentType(componentType);\n        return (T) objArray; // TODO\n    }\n\n    public int getFastMatchToken() {\n        return JSONToken.LBRACKET;\n    }\n}\n",
        "human_patch_code": "/*\r\n * Copyright 1999-2101 Alibaba Group.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage com.alibaba.fastjson.serializer;\r\n\r\nimport java.io.IOException;\r\nimport java.lang.reflect.Array;\r\nimport java.lang.reflect.GenericArrayType;\r\nimport java.lang.reflect.ParameterizedType;\r\nimport java.lang.reflect.Type;\r\nimport java.lang.reflect.TypeVariable;\r\n\r\nimport com.alibaba.fastjson.JSONArray;\r\nimport com.alibaba.fastjson.parser.DefaultJSONParser;\r\nimport com.alibaba.fastjson.parser.JSONLexer;\r\nimport com.alibaba.fastjson.parser.JSONToken;\r\nimport com.alibaba.fastjson.parser.deserializer.ObjectDeserializer;\r\nimport com.alibaba.fastjson.util.TypeUtils;\r\n\r\n/**\r\n * @author wenshao[szujobs@hotmail.com]\r\n */\r\npublic class ObjectArrayCodec implements ObjectSerializer, ObjectDeserializer {\r\n\r\n    public static final ObjectArrayCodec instance = new ObjectArrayCodec();\r\n\r\n    public ObjectArrayCodec(){\r\n    }\r\n\r\n    public final void write(JSONSerializer serializer, Object object, Object fieldName, Type fieldType, int features)\r\n                                                                                                       throws IOException {\r\n        SerializeWriter out = serializer.out;\r\n\r\n        Object[] array = (Object[]) object;\r\n\r\n        if (object == null) {\r\n            out.writeNull(SerializerFeature.WriteNullListAsEmpty);\r\n            return;\r\n        }\r\n\r\n        int size = array.length;\r\n\r\n        int end = size - 1;\r\n\r\n        if (end == -1) {\r\n            out.append(\"[]\");\r\n            return;\r\n        }\r\n\r\n        SerialContext context = serializer.context;\r\n        serializer.setContext(context, object, fieldName, 0);\r\n\r\n        try {\r\n            Class<?> preClazz = null;\r\n            ObjectSerializer preWriter = null;\r\n            out.append('[');\r\n\r\n            if (out.isEnabled(SerializerFeature.PrettyFormat)) {\r\n                serializer.incrementIndent();\r\n                serializer.println();\r\n                for (int i = 0; i < size; ++i) {\r\n                    if (i != 0) {\r\n                        out.write(',');\r\n                        serializer.println();\r\n                    }\r\n                    serializer.write(array[i]);\r\n                }\r\n                serializer.decrementIdent();\r\n                serializer.println();\r\n                out.write(']');\r\n                return;\r\n            }\r\n\r\n            for (int i = 0; i < end; ++i) {\r\n                Object item = array[i];\r\n\r\n                if (item == null) {\r\n                    out.append(\"null,\");\r\n                } else {\r\n                    if (serializer.containsReference(item)) {\r\n                        serializer.writeReference(item);\r\n                    } else {\r\n                        Class<?> clazz = item.getClass();\r\n\r\n                        if (clazz == preClazz) {\r\n                            preWriter.write(serializer, item, null, null, 0);\r\n                        } else {\r\n                            preClazz = clazz;\r\n                            preWriter = serializer.getObjectWriter(clazz);\r\n\r\n                            preWriter.write(serializer, item, null, null, 0);\r\n                        }\r\n                    }\r\n                    out.append(',');\r\n                }\r\n            }\r\n\r\n            Object item = array[end];\r\n\r\n            if (item == null) {\r\n                out.append(\"null]\");\r\n            } else {\r\n                if (serializer.containsReference(item)) {\r\n                    serializer.writeReference(item);\r\n                } else {\r\n                    serializer.writeWithFieldName(item, end);\r\n                }\r\n                out.append(']');\r\n            }\r\n        } finally {\r\n            serializer.context = context;\r\n        }\r\n    }\r\n    \r\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n    public <T> T deserialze(DefaultJSONParser parser, Type type, Object fieldName) {\r\n        final JSONLexer lexer = parser.lexer;\r\n        if (lexer.token() == JSONToken.NULL) {\r\n            lexer.nextToken(JSONToken.COMMA);\r\n            return null;\r\n        }\r\n\r\n        if (lexer.token() == JSONToken.LITERAL_STRING) {\r\n            byte[] bytes = lexer.bytesValue();\r\n            lexer.nextToken(JSONToken.COMMA);\r\n            return (T) bytes;\r\n        }\r\n\r\n        Class componentClass;\r\n        Type componentType;\r\n        if (type instanceof GenericArrayType) {\r\n            GenericArrayType clazz = (GenericArrayType) type;\r\n            componentType = clazz.getGenericComponentType();\r\n            if (componentType instanceof TypeVariable) {\r\n                TypeVariable typeVar = (TypeVariable) componentType;\r\n                Type objType = parser.getContext().type;\r\n                if (objType instanceof ParameterizedType) {\r\n                    ParameterizedType objParamType = (ParameterizedType) objType;\r\n                    Type objRawType = objParamType.getRawType();\r\n                    Type actualType = null;\r\n                    if (objRawType instanceof Class) {\r\n                        TypeVariable[] objTypeParams = ((Class) objRawType).getTypeParameters();\r\n                        for (int i = 0; i < objTypeParams.length; ++i) {\r\n                            if (objTypeParams[i].getName().equals(typeVar.getName())) {\r\n                                actualType = objParamType.getActualTypeArguments()[i];\r\n                            }\r\n                        }\r\n                    }\r\n                    if (actualType instanceof Class) {\r\n                        componentClass = (Class) actualType;\r\n                    } else {\r\n                        componentClass = Object.class;\r\n                    }\r\n                } else {\r\n                    componentClass = TypeUtils.getClass(typeVar.getBounds()[0]);\r\n                }\r\n            } else {\r\n                componentClass = TypeUtils.getClass(componentType);\r\n            }\r\n        } else {\r\n            Class clazz = (Class) type;\r\n            componentType = componentClass = clazz.getComponentType();\r\n        }\r\n        JSONArray array = new JSONArray();\r\n        parser.parseArray(componentType, array, fieldName);\r\n\r\n        return (T) toObjectArray(parser, componentClass, array);\r\n    }\r\n\r\n    @SuppressWarnings(\"unchecked\")\r\n    private <T> T toObjectArray(DefaultJSONParser parser, Class<?> componentType, JSONArray array) {\r\n        if (array == null) {\r\n            return null;\r\n        }\r\n\r\n        int size = array.size();\r\n\r\n        Object objArray = Array.newInstance(componentType, size);\r\n        for (int i = 0; i < size; ++i) {\r\n            Object value = array.get(i);\r\n\r\n            if (value == array) {\r\n                Array.set(objArray, i, objArray);\r\n                continue;\r\n            }\r\n\r\n            if (componentType.isArray()) {\r\n                Object element;\r\n                if (componentType.isInstance(value)) {\r\n                    element = value;\r\n                } else {\r\n                    element = toObjectArray(parser, componentType, (JSONArray) value);\r\n                }\r\n\r\n                Array.set(objArray, i, element);\r\n            } else {\r\n                Object element = null;\r\n                if (value instanceof JSONArray) {\r\n                    boolean contains = false;\r\n                    JSONArray valueArray = (JSONArray) value;\r\n                    int valueArraySize = valueArray.size();\r\n                    for (int y = 0; y < valueArraySize; ++y) {\r\n                        Object valueItem = valueArray.get(y);\r\n                        if (valueItem == array) {\r\n                            valueArray.set(i, objArray);\r\n                            contains = true;\r\n                        }\r\n                    }\r\n                    if (contains) {\r\n                        element = valueArray.toArray();\r\n                    }\r\n                }\r\n\r\n                if (element == null) {\r\n                    element = TypeUtils.cast(value, componentType, parser.getConfig());\r\n                }\r\n                Array.set(objArray, i, element);\r\n\r\n            }\r\n        }\r\n\r\n        array.setRelatedArray(objArray);\r\n        array.setComponentType(componentType);\r\n        return (T) objArray; // TODO\r\n    }\r\n\r\n    public int getFastMatchToken() {\r\n        return JSONToken.LBRACKET;\r\n    }\r\n}\r\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-2": {
    "vul_id": "VUL4J-2",
    "cve_id": "CVE-2017-5662",
    "project": "apache_batik",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl batik-dom -Dtest=org.apache.batik.dom.util.TestCVE_2017_5662",
    "test_all_cmd": "mvn test -pl batik-dom",
    "human_patch_url": "https://github.com/apache/xmlgraphics-batik/commit/660ef628d637af636ea113243fe73f170ac43958",
    "vulnerable_files": [
      {
        "file_path": "batik-dom/src/main/java/org/apache/batik/dom/util/SAXDocumentFactory.java",
        "file_name": "SAXDocumentFactory.java",
        "vulnerable_code": "/*\n\n   Licensed to the Apache Software Foundation (ASF) under one or more\n   contributor license agreements.  See the NOTICE file distributed with\n   this work for additional information regarding copyright ownership.\n   The ASF licenses this file to You under the Apache License, Version 2.0\n   (the \"License\"); you may not use this file except in compliance with\n   the License.  You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n */\npackage org.apache.batik.dom.util;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InterruptedIOException;\nimport java.io.Reader;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.w3c.dom.DOMImplementation;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.DocumentType;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.ErrorHandler;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.Locator;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXNotRecognizedException;\nimport org.xml.sax.SAXNotSupportedException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.ext.LexicalHandler;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\nimport org.apache.batik.util.HaltingThread;\nimport org.apache.batik.util.XMLConstants;\n\n/**\n * This class contains methods for creating Document instances\n * from an URI using SAX2.\n *\n * @author <a href=\"mailto:stephane@hillion.org\">Stephane Hillion</a>\n * @version $Id$\n */\npublic class SAXDocumentFactory\n    extends    DefaultHandler\n    implements LexicalHandler,\n               DocumentFactory {\n\n    /**\n     * The DOM implementation used to create the document.\n     */\n    protected DOMImplementation implementation;\n\n    /**\n     * The SAX2 parser classname.\n     */\n    protected String parserClassName;\n\n    /**\n     * The SAX2 parser object.\n     */\n    protected XMLReader parser;\n\n    /**\n     * The created document.\n     */\n    protected Document document;\n\n    /**\n     * The created document descriptor.\n     */\n    protected DocumentDescriptor documentDescriptor;\n\n    /**\n     * Whether a document descriptor must be generated.\n     */\n    protected boolean createDocumentDescriptor;\n\n    /**\n     * The current node.\n     */\n    protected Node currentNode;\n\n    /**\n     * The locator.\n     */\n    protected Locator locator;\n\n    /**\n     * Contains collected string data.  May be Text, CDATA or Comment.\n     */\n    protected StringBuffer stringBuffer = new StringBuffer();\n\n    /**\n     * The DTD to use when the document is created.\n     */\n    protected DocumentType doctype;\n\n    /**\n     * Indicates if stringBuffer has content, needed in case of\n     * zero sized \"text\" content.\n     */\n    protected boolean stringContent;\n\n    /**\n     * True if the parser is currently parsing a DTD.\n     */\n    protected boolean inDTD;\n\n    /**\n     * True if the parser is currently parsing a CDATA section.\n     */\n    protected boolean inCDATA;\n\n    /**\n     * Whether the parser still hasn't read the document element's\n     * opening tag.\n     */\n    protected boolean inProlog;\n\n    /**\n     * Whether the parser is in validating mode.\n     */\n    protected boolean isValidating;\n\n    /**\n     * Whether the document just parsed was standalone.\n     */\n    protected boolean isStandalone;\n\n    /**\n     * XML version of the document just parsed.\n     */\n    protected String xmlVersion;\n\n    /**\n     * The stack used to store the namespace URIs.\n     */\n    protected HashTableStack namespaces;\n\n    /**\n     * The error handler.\n     */\n    protected ErrorHandler errorHandler;\n\n    protected interface PreInfo {\n        Node createNode(Document doc);\n    }\n\n    static class ProcessingInstructionInfo implements PreInfo {\n        public String target, data;\n        public ProcessingInstructionInfo(String target, String data) {\n            this.target = target;\n            this.data = data;\n        }\n        public Node createNode(Document doc) {\n            return doc.createProcessingInstruction(target, data);\n        }\n    }\n\n    static class CommentInfo implements PreInfo {\n        public String comment;\n        public CommentInfo(String comment) {\n            this.comment = comment;\n        }\n        public Node createNode(Document doc) {\n            return doc.createComment(comment);\n        }\n    }\n\n    static class CDataInfo implements PreInfo {\n        public String cdata;\n        public CDataInfo(String cdata) {\n            this.cdata = cdata;\n        }\n        public Node createNode(Document doc) {\n            return doc.createCDATASection(cdata);\n        }\n    }\n\n    static class TextInfo implements PreInfo {\n        public String text;\n        public TextInfo(String text) {\n            this.text = text;\n        }\n        public Node createNode(Document doc) {\n            return doc.createTextNode(text);\n        }\n    }\n\n    /**\n     * Various elements encountered prior to real document root element.\n     * List of PreInfo objects.\n     */\n    protected List preInfo;\n\n    /**\n     * Creates a new SAXDocumentFactory object.\n     * No document descriptor will be created while generating a document.\n     * @param impl The DOM implementation to use for building the DOM tree.\n     * @param parser The SAX2 parser classname.\n     */\n    public SAXDocumentFactory(DOMImplementation impl,\n                              String parser) {\n        implementation           = impl;\n        parserClassName          = parser;\n    }\n\n    /**\n     * Creates a new SAXDocumentFactory object.\n     * @param impl The DOM implementation to use for building the DOM tree.\n     * @param parser The SAX2 parser classname.\n     * @param dd Whether a document descriptor must be generated.\n     */\n    public SAXDocumentFactory(DOMImplementation impl,\n                              String parser,\n                              boolean dd) {\n        implementation           = impl;\n        parserClassName          = parser;\n        createDocumentDescriptor = dd;\n    }\n\n    /**\n     * Creates a Document instance.\n     * @param ns The namespace URI of the root element of the document.\n     * @param root The name of the root element of the document.\n     * @param uri The document URI.\n     * @exception IOException if an error occured while reading the document.\n     */\n    public Document createDocument(String ns, String root, String uri)\n        throws IOException {\n        return createDocument(ns, root, uri, new InputSource(uri));\n    }\n\n    /**\n     * Creates a Document instance.\n     * @param uri The document URI.\n     * @exception IOException if an error occured while reading the document.\n     */\n    public Document createDocument(String uri)\n        throws IOException {\n        return createDocument(new InputSource(uri));\n    }\n\n    /**\n     * Creates a Document instance.\n     * @param ns The namespace URI of the root element of the document.\n     * @param root The name of the root element of the document.\n     * @param uri The document URI.\n     * @param is The document input stream.\n     * @exception IOException if an error occured while reading the document.\n     */\n    public Document createDocument(String ns, String root, String uri,\n                                   InputStream is) throws IOException {\n        InputSource inp = new InputSource(is);\n        inp.setSystemId(uri);\n        return createDocument(ns, root, uri, inp);\n    }\n\n    /**\n     * Creates a Document instance.\n     * @param uri The document URI.\n     * @param is The document input stream.\n     * @exception IOException if an error occured while reading the document.\n     */\n    public Document createDocument(String uri, InputStream is)\n        throws IOException {\n        InputSource inp = new InputSource(is);\n        inp.setSystemId(uri);\n        return createDocument(inp);\n    }\n\n    /**\n     * Creates a Document instance.\n     * @param ns The namespace URI of the root element of the document.\n     * @param root The name of the root element of the document.\n     * @param uri The document URI.\n     * @param r The document reader.\n     * @exception IOException if an error occured while reading the document.\n     */\n    public Document createDocument(String ns, String root, String uri,\n                                   Reader r) throws IOException {\n        InputSource inp = new InputSource(r);\n        inp.setSystemId(uri);\n        return createDocument(ns, root, uri, inp);\n    }\n\n    /**\n     * Creates a Document instance.\n     * @param ns The namespace URI of the root element of the document.\n     * @param root The name of the root element of the document.\n     * @param uri The document URI.\n     * @param r an XMLReaderInstance\n     * @exception IOException if an error occured while reading the document.\n     */\n    public Document createDocument(String ns, String root, String uri,\n                                   XMLReader r) throws IOException {\n        r.setContentHandler(this);\n        r.setDTDHandler(this);\n        r.setEntityResolver(this);\n        try {\n            r.parse(uri);\n        } catch (SAXException e) {\n            Exception ex = e.getException();\n            if (ex != null && ex instanceof InterruptedIOException) {\n                throw (InterruptedIOException) ex;\n            }\n            throw new SAXIOException(e);\n        }\n        currentNode = null;\n        Document ret = document;\n        document = null;\n        doctype = null;\n        return ret;\n    }\n\n    /**\n     * Creates a Document instance.\n     * @param uri The document URI.\n     * @param r The document reader.\n     * @exception IOException if an error occured while reading the document.\n     */\n    public Document createDocument(String uri, Reader r) throws IOException {\n        InputSource inp = new InputSource(r);\n        inp.setSystemId(uri);\n        return createDocument(inp);\n    }\n\n    /**\n     * Creates a Document.\n     * @param ns The namespace URI of the root element.\n     * @param root The name of the root element.\n     * @param uri The document URI.\n     * @param is  The document input source.\n     * @exception IOException if an error occured while reading the document.\n     */\n    protected Document createDocument(String ns, String root, String uri,\n                                      InputSource is)\n        throws IOException {\n        Document ret = createDocument(is);\n        Element docElem = ret.getDocumentElement();\n\n        String lname = root;\n        String nsURI = ns;\n        if (ns == null) {\n            int idx = lname.indexOf(':');\n            String nsp = (idx == -1 || idx == lname.length()-1)\n                ? \"\"\n                : lname.substring(0, idx);\n            nsURI = namespaces.get(nsp);\n            if (idx != -1 && idx != lname.length()-1) {\n                lname = lname.substring(idx+1);\n            }\n        }\n\n\n        String docElemNS = docElem.getNamespaceURI();\n        if ((docElemNS != nsURI) &&\n            ((docElemNS == null) || (!docElemNS.equals(nsURI))))\n            throw new IOException\n                (\"Root element namespace does not match that requested:\\n\" +\n                 \"Requested: \" + nsURI + \"\\n\" +\n                 \"Found: \" + docElemNS);\n\n        if (docElemNS != null) {\n            if (!docElem.getLocalName().equals(lname))\n                throw new IOException\n                    (\"Root element does not match that requested:\\n\" +\n                     \"Requested: \" + lname + \"\\n\" +\n                     \"Found: \" + docElem.getLocalName());\n        } else {\n            if (!docElem.getNodeName().equals(lname))\n                throw new IOException\n                    (\"Root element does not match that requested:\\n\" +\n                     \"Requested: \" + lname + \"\\n\" +\n                     \"Found: \" + docElem.getNodeName());\n        }\n\n        return ret;\n    }\n\n    static SAXParserFactory saxFactory;\n    static {\n        saxFactory = SAXParserFactory.newInstance();\n        try {\n            saxFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            saxFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n        } catch (SAXNotRecognizedException e) {\n            e.printStackTrace();\n        } catch (SAXNotSupportedException e) {\n            e.printStackTrace();\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Creates a Document.\n     * @param is  The document input source.\n     * @exception IOException if an error occured while reading the document.\n     */\n    protected Document createDocument(InputSource is)\n        throws IOException {\n        try {\n            if (parserClassName != null) {\n                parser = XMLReaderFactory.createXMLReader(parserClassName);\n            } else {\n                SAXParser saxParser;\n                try {\n                    saxParser = saxFactory.newSAXParser();\n                } catch (ParserConfigurationException pce) {\n                    throw new IOException(\"Could not create SAXParser: \"\n                            + pce.getMessage());\n                }\n                parser = saxParser.getXMLReader();\n            }\n\n            parser.setContentHandler(this);\n            parser.setDTDHandler(this);\n            parser.setEntityResolver(this);\n            parser.setErrorHandler((errorHandler == null) ?\n                                   this : errorHandler);\n\n            parser.setFeature(\"http://xml.org/sax/features/namespaces\",\n                              true);\n            parser.setFeature(\"http://xml.org/sax/features/namespace-prefixes\",\n                              true);\n            parser.setFeature(\"http://xml.org/sax/features/validation\",\n                              isValidating);\n            parser.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            parser.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            parser.setProperty(\"http://xml.org/sax/properties/lexical-handler\",\n                               this);\n            parser.parse(is);\n        } catch (SAXException e) {\n            Exception ex = e.getException();\n            if (ex != null && ex instanceof InterruptedIOException) {\n                throw (InterruptedIOException)ex;\n            }\n            throw new SAXIOException(e);\n        }\n\n        currentNode  = null;\n        Document ret = document;\n        document     = null;\n        doctype      = null;\n        locator      = null;\n        parser       = null;\n        return ret;\n    }\n\n    /**\n     * Returns the document descriptor associated with the latest created\n     * document.\n     * @return null if no document or descriptor was previously generated.\n     */\n    public DocumentDescriptor getDocumentDescriptor() {\n        return documentDescriptor;\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ContentHandler#setDocumentLocator(Locator)}.\n     */\n    public void setDocumentLocator(Locator l) {\n        locator = l;\n    }\n\n    /**\n     * Sets whether or not the XML parser will validate the XML document\n     * depending on the specified parameter.\n     *\n     * @param isValidating indicates that the XML parser will validate the XML\n     * document\n     */\n    public void setValidating(boolean isValidating) {\n        this.isValidating = isValidating;\n    }\n\n    /**\n     * Returns true if the XML parser validates the XML stream, false\n     * otherwise.\n     */\n    public boolean isValidating() {\n        return isValidating;\n    }\n\n    /**\n     * Sets a custom error handler.\n     */\n    public void setErrorHandler(ErrorHandler eh) {\n        errorHandler = eh;\n    }\n\n    public DOMImplementation getDOMImplementation(String ver) {\n        return implementation;\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ErrorHandler#fatalError(SAXParseException)}.\n     */\n    public void fatalError(SAXParseException ex) throws SAXException {\n        throw ex;\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ErrorHandler#error(SAXParseException)}.\n     */\n    public void error(SAXParseException ex) throws SAXException {\n        throw ex;\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ErrorHandler#warning(SAXParseException)}.\n     */\n    public void warning(SAXParseException ex) throws SAXException {\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ContentHandler#startDocument()}.\n     */\n    public void startDocument() throws SAXException {\n        preInfo    = new LinkedList();\n        namespaces = new HashTableStack();\n        namespaces.put(\"xml\", XMLSupport.XML_NAMESPACE_URI);\n        namespaces.put(\"xmlns\", XMLSupport.XMLNS_NAMESPACE_URI);\n        namespaces.put(\"\", null);\n\n        inDTD        = false;\n        inCDATA      = false;\n        inProlog     = true;\n        currentNode  = null;\n        document     = null;\n        doctype      = null;\n        isStandalone = false;\n        xmlVersion   = XMLConstants.XML_VERSION_10;\n\n        stringBuffer.setLength(0);\n        stringContent = false;\n\n        if (createDocumentDescriptor) {\n            documentDescriptor = new DocumentDescriptor();\n        } else {\n            documentDescriptor = null;\n        }\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ContentHandler#startElement(String,String,String,Attributes)}.\n     */\n    public void startElement(String     uri,\n                             String     localName,\n                             String     rawName,\n                             Attributes attributes) throws SAXException {\n        // Check If we should halt early.\n        if (HaltingThread.hasBeenHalted()) {\n            throw new SAXException(new InterruptedIOException());\n        }\n\n        if (inProlog) {\n            inProlog = false;\n            if (parser != null) {\n                try {\n                    isStandalone = parser.getFeature\n                        (\"http://xml.org/sax/features/is-standalone\");\n                } catch (SAXNotRecognizedException ex) {\n                }\n                try {\n                    xmlVersion = (String) parser.getProperty\n                        (\"http://xml.org/sax/properties/document-xml-version\");\n                } catch (SAXNotRecognizedException ex) {\n                }\n            }\n        }\n\n        // Namespaces resolution\n        int len = attributes.getLength();\n        namespaces.push();\n        String version = null;\n        for (int i = 0; i < len; i++) {\n            String aname = attributes.getQName(i);\n            int slen = aname.length();\n            if (slen < 5)\n                continue;\n            if (aname.equals(\"version\")) {\n                version = attributes.getValue(i);\n                continue;\n            }\n            if (!aname.startsWith(\"xmlns\"))\n                continue;\n            if (slen == 5) {\n                String ns = attributes.getValue(i);\n                if (ns.length() == 0)\n                    ns = null;\n                namespaces.put(\"\", ns);\n            } else if (aname.charAt(5) == ':') {\n                String ns = attributes.getValue(i);\n                if (ns.length() == 0) {\n                    ns = null;\n                }\n                namespaces.put(aname.substring(6), ns);\n            }\n        }\n\n        // Add any collected String Data before element.\n        appendStringData();\n\n        // Element creation\n        Element e;\n        int idx = rawName.indexOf(':');\n        String nsp = (idx == -1 || idx == rawName.length()-1)\n            ? \"\"\n            : rawName.substring(0, idx);\n        String nsURI = namespaces.get(nsp);\n        if (currentNode == null) {\n            implementation = getDOMImplementation(version);\n            document = implementation.createDocument(nsURI, rawName, doctype);\n            Iterator i = preInfo.iterator();\n            currentNode = e = document.getDocumentElement();\n            while (i.hasNext()) {\n                PreInfo pi = (PreInfo)i.next();\n                Node n = pi.createNode(document);\n                document.insertBefore(n, e);\n            }\n            preInfo = null;\n        } else {\n            e = document.createElementNS(nsURI, rawName);\n            currentNode.appendChild(e);\n            currentNode = e;\n        }\n\n        // Storage of the line number.\n        if (createDocumentDescriptor && locator != null) {\n            documentDescriptor.setLocation(e,\n                                           locator.getLineNumber(),\n                                           locator.getColumnNumber());\n        }\n\n        // Attributes creation\n        for (int i = 0; i < len; i++) {\n            String aname = attributes.getQName(i);\n            if (aname.equals(\"xmlns\")) {\n                e.setAttributeNS(XMLSupport.XMLNS_NAMESPACE_URI,\n                                 aname,\n                                 attributes.getValue(i));\n            } else {\n                idx = aname.indexOf(':');\n                nsURI = (idx == -1)\n                    ? null\n                    : namespaces.get(aname.substring(0, idx));\n                e.setAttributeNS(nsURI, aname, attributes.getValue(i));\n            }\n        }\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ContentHandler#endElement(String,String,String)}.\n     */\n    public void endElement(String uri, String localName, String rawName)\n        throws SAXException {\n        appendStringData(); // add string data if any.\n\n        if (currentNode != null)\n            currentNode = currentNode.getParentNode();\n        namespaces.pop();\n    }\n\n    public void appendStringData() {\n        if (!stringContent) return;\n\n        String str = stringBuffer.toString();\n        stringBuffer.setLength(0); // reuse buffer.\n        stringContent = false;\n        if (currentNode == null) {\n            if (inCDATA) preInfo.add(new CDataInfo(str));\n            else         preInfo.add(new TextInfo(str));\n        } else {\n            Node n;\n            if (inCDATA) n = document.createCDATASection(str);\n            else         n = document.createTextNode(str);\n            currentNode.appendChild(n);\n        }\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ContentHandler#characters(char[],int,int)}.\n     */\n    public void characters(char[] ch, int start, int length)\n        throws SAXException {\n        stringBuffer.append(ch, start, length);\n        stringContent = true;\n    }\n\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ContentHandler#ignorableWhitespace(char[],int,int)}.\n     */\n    public void ignorableWhitespace(char[] ch,\n                                    int start,\n                                    int length)\n        throws SAXException {\n        stringBuffer.append(ch, start, length);\n        stringContent = true;\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ContentHandler#processingInstruction(String,String)}.\n     */\n    public void processingInstruction(String target, String data)\n        throws SAXException {\n        if (inDTD)\n            return;\n\n        appendStringData(); // Add any collected String Data before PI\n\n        if (currentNode == null)\n            preInfo.add(new ProcessingInstructionInfo(target, data));\n        else\n            currentNode.appendChild\n                (document.createProcessingInstruction(target, data));\n    }\n\n    // LexicalHandler /////////////////////////////////////////////////////////\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ext.LexicalHandler#startDTD(String,String,String)}.\n     */\n    public void startDTD(String name, String publicId, String systemId)\n        throws SAXException {\n        appendStringData(); // Add collected string data before entering DTD\n        doctype = implementation.createDocumentType(name, publicId, systemId);\n        inDTD = true;\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link org.xml.sax.ext.LexicalHandler#endDTD()}.\n     */\n    public void endDTD() throws SAXException {\n        inDTD = false;\n    }\n\n    /**\n     * <b>SAX</b>: Implements\n     * {@link org.xml.sax.ext.LexicalHandler#startEntity(String)}.\n     */\n    public void startEntity(String name) throws SAXException {\n    }\n\n    /**\n     * <b>SAX</b>: Implements\n     * {@link org.xml.sax.ext.LexicalHandler#endEntity(String)}.\n     */\n    public void endEntity(String name) throws SAXException {\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ext.LexicalHandler#startCDATA()}.\n     */\n    public void startCDATA() throws SAXException {\n        appendStringData(); // Add any collected String Data before CData\n        inCDATA       = true;\n        stringContent = true; // always create CDATA even if empty.\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ext.LexicalHandler#endCDATA()}.\n     */\n    public void endCDATA() throws SAXException {\n        appendStringData(); // Add the CDATA section\n        inCDATA = false;\n    }\n\n    /**\n     * <b>SAX</b>: Implements\n     * {@link org.xml.sax.ext.LexicalHandler#comment(char[],int,int)}.\n     */\n    public void comment(char[] ch, int start, int length) throws SAXException {\n        if (inDTD) return;\n        appendStringData();\n\n        String str = new String(ch, start, length);\n        if (currentNode == null) {\n            preInfo.add(new CommentInfo(str));\n        } else {\n            currentNode.appendChild(document.createComment(str));\n        }\n    }\n}\n",
        "human_patch_code": "/*\n\n   Licensed to the Apache Software Foundation (ASF) under one or more\n   contributor license agreements.  See the NOTICE file distributed with\n   this work for additional information regarding copyright ownership.\n   The ASF licenses this file to You under the Apache License, Version 2.0\n   (the \"License\"); you may not use this file except in compliance with\n   the License.  You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n */\npackage org.apache.batik.dom.util;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InterruptedIOException;\nimport java.io.Reader;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.w3c.dom.DOMImplementation;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.DocumentType;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.ErrorHandler;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.Locator;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXNotRecognizedException;\nimport org.xml.sax.SAXNotSupportedException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.ext.LexicalHandler;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\nimport org.apache.batik.util.HaltingThread;\nimport org.apache.batik.util.XMLConstants;\n\n/**\n * This class contains methods for creating Document instances\n * from an URI using SAX2.\n *\n * @author <a href=\"mailto:stephane@hillion.org\">Stephane Hillion</a>\n * @version $Id$\n */\npublic class SAXDocumentFactory\n    extends    DefaultHandler\n    implements LexicalHandler,\n               DocumentFactory {\n\n    /**\n     * The DOM implementation used to create the document.\n     */\n    protected DOMImplementation implementation;\n\n    /**\n     * The SAX2 parser classname.\n     */\n    protected String parserClassName;\n\n    /**\n     * The SAX2 parser object.\n     */\n    protected XMLReader parser;\n\n    /**\n     * The created document.\n     */\n    protected Document document;\n\n    /**\n     * The created document descriptor.\n     */\n    protected DocumentDescriptor documentDescriptor;\n\n    /**\n     * Whether a document descriptor must be generated.\n     */\n    protected boolean createDocumentDescriptor;\n\n    /**\n     * The current node.\n     */\n    protected Node currentNode;\n\n    /**\n     * The locator.\n     */\n    protected Locator locator;\n\n    /**\n     * Contains collected string data.  May be Text, CDATA or Comment.\n     */\n    protected StringBuffer stringBuffer = new StringBuffer();\n\n    /**\n     * The DTD to use when the document is created.\n     */\n    protected DocumentType doctype;\n\n    /**\n     * Indicates if stringBuffer has content, needed in case of\n     * zero sized \"text\" content.\n     */\n    protected boolean stringContent;\n\n    /**\n     * True if the parser is currently parsing a DTD.\n     */\n    protected boolean inDTD;\n\n    /**\n     * True if the parser is currently parsing a CDATA section.\n     */\n    protected boolean inCDATA;\n\n    /**\n     * Whether the parser still hasn't read the document element's\n     * opening tag.\n     */\n    protected boolean inProlog;\n\n    /**\n     * Whether the parser is in validating mode.\n     */\n    protected boolean isValidating;\n\n    /**\n     * Whether the document just parsed was standalone.\n     */\n    protected boolean isStandalone;\n\n    /**\n     * XML version of the document just parsed.\n     */\n    protected String xmlVersion;\n\n    /**\n     * The stack used to store the namespace URIs.\n     */\n    protected HashTableStack namespaces;\n\n    /**\n     * The error handler.\n     */\n    protected ErrorHandler errorHandler;\n\n    protected interface PreInfo {\n        Node createNode(Document doc);\n    }\n\n    static class ProcessingInstructionInfo implements PreInfo {\n        public String target, data;\n        public ProcessingInstructionInfo(String target, String data) {\n            this.target = target;\n            this.data = data;\n        }\n        public Node createNode(Document doc) {\n            return doc.createProcessingInstruction(target, data);\n        }\n    }\n\n    static class CommentInfo implements PreInfo {\n        public String comment;\n        public CommentInfo(String comment) {\n            this.comment = comment;\n        }\n        public Node createNode(Document doc) {\n            return doc.createComment(comment);\n        }\n    }\n\n    static class CDataInfo implements PreInfo {\n        public String cdata;\n        public CDataInfo(String cdata) {\n            this.cdata = cdata;\n        }\n        public Node createNode(Document doc) {\n            return doc.createCDATASection(cdata);\n        }\n    }\n\n    static class TextInfo implements PreInfo {\n        public String text;\n        public TextInfo(String text) {\n            this.text = text;\n        }\n        public Node createNode(Document doc) {\n            return doc.createTextNode(text);\n        }\n    }\n\n    /**\n     * Various elements encountered prior to real document root element.\n     * List of PreInfo objects.\n     */\n    protected List preInfo;\n\n    /**\n     * Creates a new SAXDocumentFactory object.\n     * No document descriptor will be created while generating a document.\n     * @param impl The DOM implementation to use for building the DOM tree.\n     * @param parser The SAX2 parser classname.\n     */\n    public SAXDocumentFactory(DOMImplementation impl,\n                              String parser) {\n        implementation           = impl;\n        parserClassName          = parser;\n    }\n\n    /**\n     * Creates a new SAXDocumentFactory object.\n     * @param impl The DOM implementation to use for building the DOM tree.\n     * @param parser The SAX2 parser classname.\n     * @param dd Whether a document descriptor must be generated.\n     */\n    public SAXDocumentFactory(DOMImplementation impl,\n                              String parser,\n                              boolean dd) {\n        implementation           = impl;\n        parserClassName          = parser;\n        createDocumentDescriptor = dd;\n    }\n\n    /**\n     * Creates a Document instance.\n     * @param ns The namespace URI of the root element of the document.\n     * @param root The name of the root element of the document.\n     * @param uri The document URI.\n     * @exception IOException if an error occured while reading the document.\n     */\n    public Document createDocument(String ns, String root, String uri)\n        throws IOException {\n        return createDocument(ns, root, uri, new InputSource(uri));\n    }\n\n    /**\n     * Creates a Document instance.\n     * @param uri The document URI.\n     * @exception IOException if an error occured while reading the document.\n     */\n    public Document createDocument(String uri)\n        throws IOException {\n        return createDocument(new InputSource(uri));\n    }\n\n    /**\n     * Creates a Document instance.\n     * @param ns The namespace URI of the root element of the document.\n     * @param root The name of the root element of the document.\n     * @param uri The document URI.\n     * @param is The document input stream.\n     * @exception IOException if an error occured while reading the document.\n     */\n    public Document createDocument(String ns, String root, String uri,\n                                   InputStream is) throws IOException {\n        InputSource inp = new InputSource(is);\n        inp.setSystemId(uri);\n        return createDocument(ns, root, uri, inp);\n    }\n\n    /**\n     * Creates a Document instance.\n     * @param uri The document URI.\n     * @param is The document input stream.\n     * @exception IOException if an error occured while reading the document.\n     */\n    public Document createDocument(String uri, InputStream is)\n        throws IOException {\n        InputSource inp = new InputSource(is);\n        inp.setSystemId(uri);\n        return createDocument(inp);\n    }\n\n    /**\n     * Creates a Document instance.\n     * @param ns The namespace URI of the root element of the document.\n     * @param root The name of the root element of the document.\n     * @param uri The document URI.\n     * @param r The document reader.\n     * @exception IOException if an error occured while reading the document.\n     */\n    public Document createDocument(String ns, String root, String uri,\n                                   Reader r) throws IOException {\n        InputSource inp = new InputSource(r);\n        inp.setSystemId(uri);\n        return createDocument(ns, root, uri, inp);\n    }\n\n    /**\n     * Creates a Document instance.\n     * @param ns The namespace URI of the root element of the document.\n     * @param root The name of the root element of the document.\n     * @param uri The document URI.\n     * @param r an XMLReaderInstance\n     * @exception IOException if an error occured while reading the document.\n     */\n    public Document createDocument(String ns, String root, String uri,\n                                   XMLReader r) throws IOException {\n        r.setContentHandler(this);\n        r.setDTDHandler(this);\n        r.setEntityResolver(this);\n        try {\n            r.parse(uri);\n        } catch (SAXException e) {\n            Exception ex = e.getException();\n            if (ex != null && ex instanceof InterruptedIOException) {\n                throw (InterruptedIOException) ex;\n            }\n            throw new SAXIOException(e);\n        }\n        currentNode = null;\n        Document ret = document;\n        document = null;\n        doctype = null;\n        return ret;\n    }\n\n    /**\n     * Creates a Document instance.\n     * @param uri The document URI.\n     * @param r The document reader.\n     * @exception IOException if an error occured while reading the document.\n     */\n    public Document createDocument(String uri, Reader r) throws IOException {\n        InputSource inp = new InputSource(r);\n        inp.setSystemId(uri);\n        return createDocument(inp);\n    }\n\n    /**\n     * Creates a Document.\n     * @param ns The namespace URI of the root element.\n     * @param root The name of the root element.\n     * @param uri The document URI.\n     * @param is  The document input source.\n     * @exception IOException if an error occured while reading the document.\n     */\n    protected Document createDocument(String ns, String root, String uri,\n                                      InputSource is)\n        throws IOException {\n        Document ret = createDocument(is);\n        Element docElem = ret.getDocumentElement();\n\n        String lname = root;\n        String nsURI = ns;\n        if (ns == null) {\n            int idx = lname.indexOf(':');\n            String nsp = (idx == -1 || idx == lname.length()-1)\n                ? \"\"\n                : lname.substring(0, idx);\n            nsURI = namespaces.get(nsp);\n            if (idx != -1 && idx != lname.length()-1) {\n                lname = lname.substring(idx+1);\n            }\n        }\n\n\n        String docElemNS = docElem.getNamespaceURI();\n        if ((docElemNS != nsURI) &&\n            ((docElemNS == null) || (!docElemNS.equals(nsURI))))\n            throw new IOException\n                (\"Root element namespace does not match that requested:\\n\" +\n                 \"Requested: \" + nsURI + \"\\n\" +\n                 \"Found: \" + docElemNS);\n\n        if (docElemNS != null) {\n            if (!docElem.getLocalName().equals(lname))\n                throw new IOException\n                    (\"Root element does not match that requested:\\n\" +\n                     \"Requested: \" + lname + \"\\n\" +\n                     \"Found: \" + docElem.getLocalName());\n        } else {\n            if (!docElem.getNodeName().equals(lname))\n                throw new IOException\n                    (\"Root element does not match that requested:\\n\" +\n                     \"Requested: \" + lname + \"\\n\" +\n                     \"Found: \" + docElem.getNodeName());\n        }\n\n        return ret;\n    }\n\n    static SAXParserFactory saxFactory;\n    static {\n        saxFactory = SAXParserFactory.newInstance();\n        try {\n            saxFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            saxFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\tsaxFactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n        } catch (SAXNotRecognizedException e) {\n            e.printStackTrace();\n        } catch (SAXNotSupportedException e) {\n            e.printStackTrace();\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Creates a Document.\n     * @param is  The document input source.\n     * @exception IOException if an error occured while reading the document.\n     */\n    protected Document createDocument(InputSource is)\n        throws IOException {\n        try {\n            if (parserClassName != null) {\n                parser = XMLReaderFactory.createXMLReader(parserClassName);\n            } else {\n                SAXParser saxParser;\n                try {\n                    saxParser = saxFactory.newSAXParser();\n                } catch (ParserConfigurationException pce) {\n                    throw new IOException(\"Could not create SAXParser: \"\n                            + pce.getMessage());\n                }\n                parser = saxParser.getXMLReader();\n            }\n\n            parser.setContentHandler(this);\n            parser.setDTDHandler(this);\n            parser.setEntityResolver(this);\n            parser.setErrorHandler((errorHandler == null) ?\n                                   this : errorHandler);\n\n            parser.setFeature(\"http://xml.org/sax/features/namespaces\",\n                              true);\n            parser.setFeature(\"http://xml.org/sax/features/namespace-prefixes\",\n                              true);\n            parser.setFeature(\"http://xml.org/sax/features/validation\",\n                              isValidating);\n            parser.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            parser.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\tparser.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            parser.setProperty(\"http://xml.org/sax/properties/lexical-handler\",\n                               this);\n            parser.parse(is);\n        } catch (SAXException e) {\n            Exception ex = e.getException();\n            if (ex != null && ex instanceof InterruptedIOException) {\n                throw (InterruptedIOException)ex;\n            }\n            throw new SAXIOException(e);\n        }\n\n        currentNode  = null;\n        Document ret = document;\n        document     = null;\n        doctype      = null;\n        locator      = null;\n        parser       = null;\n        return ret;\n    }\n\n    /**\n     * Returns the document descriptor associated with the latest created\n     * document.\n     * @return null if no document or descriptor was previously generated.\n     */\n    public DocumentDescriptor getDocumentDescriptor() {\n        return documentDescriptor;\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ContentHandler#setDocumentLocator(Locator)}.\n     */\n    public void setDocumentLocator(Locator l) {\n        locator = l;\n    }\n\n    /**\n     * Sets whether or not the XML parser will validate the XML document\n     * depending on the specified parameter.\n     *\n     * @param isValidating indicates that the XML parser will validate the XML\n     * document\n     */\n    public void setValidating(boolean isValidating) {\n        this.isValidating = isValidating;\n    }\n\n    /**\n     * Returns true if the XML parser validates the XML stream, false\n     * otherwise.\n     */\n    public boolean isValidating() {\n        return isValidating;\n    }\n\n    /**\n     * Sets a custom error handler.\n     */\n    public void setErrorHandler(ErrorHandler eh) {\n        errorHandler = eh;\n    }\n\n    public DOMImplementation getDOMImplementation(String ver) {\n        return implementation;\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ErrorHandler#fatalError(SAXParseException)}.\n     */\n    public void fatalError(SAXParseException ex) throws SAXException {\n        throw ex;\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ErrorHandler#error(SAXParseException)}.\n     */\n    public void error(SAXParseException ex) throws SAXException {\n        throw ex;\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ErrorHandler#warning(SAXParseException)}.\n     */\n    public void warning(SAXParseException ex) throws SAXException {\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ContentHandler#startDocument()}.\n     */\n    public void startDocument() throws SAXException {\n        preInfo    = new LinkedList();\n        namespaces = new HashTableStack();\n        namespaces.put(\"xml\", XMLSupport.XML_NAMESPACE_URI);\n        namespaces.put(\"xmlns\", XMLSupport.XMLNS_NAMESPACE_URI);\n        namespaces.put(\"\", null);\n\n        inDTD        = false;\n        inCDATA      = false;\n        inProlog     = true;\n        currentNode  = null;\n        document     = null;\n        doctype      = null;\n        isStandalone = false;\n        xmlVersion   = XMLConstants.XML_VERSION_10;\n\n        stringBuffer.setLength(0);\n        stringContent = false;\n\n        if (createDocumentDescriptor) {\n            documentDescriptor = new DocumentDescriptor();\n        } else {\n            documentDescriptor = null;\n        }\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ContentHandler#startElement(String,String,String,Attributes)}.\n     */\n    public void startElement(String     uri,\n                             String     localName,\n                             String     rawName,\n                             Attributes attributes) throws SAXException {\n        // Check If we should halt early.\n        if (HaltingThread.hasBeenHalted()) {\n            throw new SAXException(new InterruptedIOException());\n        }\n\n        if (inProlog) {\n            inProlog = false;\n            if (parser != null) {\n                try {\n                    isStandalone = parser.getFeature\n                        (\"http://xml.org/sax/features/is-standalone\");\n                } catch (SAXNotRecognizedException ex) {\n                }\n                try {\n                    xmlVersion = (String) parser.getProperty\n                        (\"http://xml.org/sax/properties/document-xml-version\");\n                } catch (SAXNotRecognizedException ex) {\n                }\n            }\n        }\n\n        // Namespaces resolution\n        int len = attributes.getLength();\n        namespaces.push();\n        String version = null;\n        for (int i = 0; i < len; i++) {\n            String aname = attributes.getQName(i);\n            int slen = aname.length();\n            if (slen < 5)\n                continue;\n            if (aname.equals(\"version\")) {\n                version = attributes.getValue(i);\n                continue;\n            }\n            if (!aname.startsWith(\"xmlns\"))\n                continue;\n            if (slen == 5) {\n                String ns = attributes.getValue(i);\n                if (ns.length() == 0)\n                    ns = null;\n                namespaces.put(\"\", ns);\n            } else if (aname.charAt(5) == ':') {\n                String ns = attributes.getValue(i);\n                if (ns.length() == 0) {\n                    ns = null;\n                }\n                namespaces.put(aname.substring(6), ns);\n            }\n        }\n\n        // Add any collected String Data before element.\n        appendStringData();\n\n        // Element creation\n        Element e;\n        int idx = rawName.indexOf(':');\n        String nsp = (idx == -1 || idx == rawName.length()-1)\n            ? \"\"\n            : rawName.substring(0, idx);\n        String nsURI = namespaces.get(nsp);\n        if (currentNode == null) {\n            implementation = getDOMImplementation(version);\n            document = implementation.createDocument(nsURI, rawName, doctype);\n            Iterator i = preInfo.iterator();\n            currentNode = e = document.getDocumentElement();\n            while (i.hasNext()) {\n                PreInfo pi = (PreInfo)i.next();\n                Node n = pi.createNode(document);\n                document.insertBefore(n, e);\n            }\n            preInfo = null;\n        } else {\n            e = document.createElementNS(nsURI, rawName);\n            currentNode.appendChild(e);\n            currentNode = e;\n        }\n\n        // Storage of the line number.\n        if (createDocumentDescriptor && locator != null) {\n            documentDescriptor.setLocation(e,\n                                           locator.getLineNumber(),\n                                           locator.getColumnNumber());\n        }\n\n        // Attributes creation\n        for (int i = 0; i < len; i++) {\n            String aname = attributes.getQName(i);\n            if (aname.equals(\"xmlns\")) {\n                e.setAttributeNS(XMLSupport.XMLNS_NAMESPACE_URI,\n                                 aname,\n                                 attributes.getValue(i));\n            } else {\n                idx = aname.indexOf(':');\n                nsURI = (idx == -1)\n                    ? null\n                    : namespaces.get(aname.substring(0, idx));\n                e.setAttributeNS(nsURI, aname, attributes.getValue(i));\n            }\n        }\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ContentHandler#endElement(String,String,String)}.\n     */\n    public void endElement(String uri, String localName, String rawName)\n        throws SAXException {\n        appendStringData(); // add string data if any.\n\n        if (currentNode != null)\n            currentNode = currentNode.getParentNode();\n        namespaces.pop();\n    }\n\n    public void appendStringData() {\n        if (!stringContent) return;\n\n        String str = stringBuffer.toString();\n        stringBuffer.setLength(0); // reuse buffer.\n        stringContent = false;\n        if (currentNode == null) {\n            if (inCDATA) preInfo.add(new CDataInfo(str));\n            else         preInfo.add(new TextInfo(str));\n        } else {\n            Node n;\n            if (inCDATA) n = document.createCDATASection(str);\n            else         n = document.createTextNode(str);\n            currentNode.appendChild(n);\n        }\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ContentHandler#characters(char[],int,int)}.\n     */\n    public void characters(char[] ch, int start, int length)\n        throws SAXException {\n        stringBuffer.append(ch, start, length);\n        stringContent = true;\n    }\n\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ContentHandler#ignorableWhitespace(char[],int,int)}.\n     */\n    public void ignorableWhitespace(char[] ch,\n                                    int start,\n                                    int length)\n        throws SAXException {\n        stringBuffer.append(ch, start, length);\n        stringContent = true;\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ContentHandler#processingInstruction(String,String)}.\n     */\n    public void processingInstruction(String target, String data)\n        throws SAXException {\n        if (inDTD)\n            return;\n\n        appendStringData(); // Add any collected String Data before PI\n\n        if (currentNode == null)\n            preInfo.add(new ProcessingInstructionInfo(target, data));\n        else\n            currentNode.appendChild\n                (document.createProcessingInstruction(target, data));\n    }\n\n    // LexicalHandler /////////////////////////////////////////////////////////\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ext.LexicalHandler#startDTD(String,String,String)}.\n     */\n    public void startDTD(String name, String publicId, String systemId)\n        throws SAXException {\n        appendStringData(); // Add collected string data before entering DTD\n        doctype = implementation.createDocumentType(name, publicId, systemId);\n        inDTD = true;\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link org.xml.sax.ext.LexicalHandler#endDTD()}.\n     */\n    public void endDTD() throws SAXException {\n        inDTD = false;\n    }\n\n    /**\n     * <b>SAX</b>: Implements\n     * {@link org.xml.sax.ext.LexicalHandler#startEntity(String)}.\n     */\n    public void startEntity(String name) throws SAXException {\n    }\n\n    /**\n     * <b>SAX</b>: Implements\n     * {@link org.xml.sax.ext.LexicalHandler#endEntity(String)}.\n     */\n    public void endEntity(String name) throws SAXException {\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ext.LexicalHandler#startCDATA()}.\n     */\n    public void startCDATA() throws SAXException {\n        appendStringData(); // Add any collected String Data before CData\n        inCDATA       = true;\n        stringContent = true; // always create CDATA even if empty.\n    }\n\n    /**\n     * <b>SAX</b>: Implements {@link\n     * org.xml.sax.ext.LexicalHandler#endCDATA()}.\n     */\n    public void endCDATA() throws SAXException {\n        appendStringData(); // Add the CDATA section\n        inCDATA = false;\n    }\n\n    /**\n     * <b>SAX</b>: Implements\n     * {@link org.xml.sax.ext.LexicalHandler#comment(char[],int,int)}.\n     */\n    public void comment(char[] ch, int start, int length) throws SAXException {\n        if (inDTD) return;\n        appendStringData();\n\n        String str = new String(ch, start, length);\n        if (currentNode == null) {\n            preInfo.add(new CommentInfo(str));\n        } else {\n            currentNode.appendChild(document.createComment(str));\n        }\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-3": {
    "vul_id": "VUL4J-3",
    "cve_id": "CVE-2015-0263",
    "project": "apache_camel",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl camel-core -Dtest=org.apache.camel.component.xslt.XsltDTDTest",
    "test_all_cmd": "mvn test -pl camel-core",
    "human_patch_url": "https://github.com/apache/camel/commit/7d19340bcdb42f7aae584d9c5003ac4f7ddaee36",
    "vulnerable_files": [
      {
        "file_path": "camel-core/src/main/java/org/apache/camel/converter/jaxp/XmlConverter.java",
        "file_name": "XmlConverter.java",
        "vulnerable_code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.converter.jaxp;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMResult;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXSource;\nimport javax.xml.transform.stax.StAXSource;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\n\nimport org.apache.camel.BytesSource;\nimport org.apache.camel.Converter;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.StringSource;\nimport org.apache.camel.util.IOHelper;\nimport org.apache.camel.util.ObjectHelper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A helper class to transform to and from various JAXB types such as {@link Source} and {@link Document}\n *\n * @version\n */\n@Converter\npublic class XmlConverter {\n    @Deprecated\n    //It will be removed in Camel 3.0, please use the Exchange.DEFAULT_CHARSET\n    public static final String DEFAULT_CHARSET_PROPERTY = \"org.apache.camel.default.charset\";\n\n    public static final String OUTPUT_PROPERTIES_PREFIX = \"org.apache.camel.xmlconverter.output.\";\n    public static final String DOCUMENT_BUILDER_FACTORY_FEATURE = \"org.apache.camel.xmlconverter.documentBuilderFactory.feature\";\n    public static String defaultCharset = ObjectHelper.getSystemProperty(Exchange.DEFAULT_CHARSET_PROPERTY, \"UTF-8\");\n\n    private static final Logger LOG = LoggerFactory.getLogger(XmlConverter.class);\n\n    private DocumentBuilderFactory documentBuilderFactory;\n    private TransformerFactory transformerFactory;\n\n    public XmlConverter() {\n    }\n\n    public XmlConverter(DocumentBuilderFactory documentBuilderFactory) {\n        this.documentBuilderFactory = documentBuilderFactory;\n    }\n\n    /**\n     * Returns the default set of output properties for conversions.\n     */\n    public Properties defaultOutputProperties() {\n        Properties properties = new Properties();\n        properties.put(OutputKeys.ENCODING, defaultCharset);\n        properties.put(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n        return properties;\n    }\n\n    /**\n     * Converts the given input Source into the required result\n     */\n    public void toResult(Source source, Result result) throws TransformerException {\n        toResult(source, result, defaultOutputProperties());\n    }\n\n    /**\n     * Converts the given input Source into the required result\n     */\n    public void toResult(Source source, Result result, Properties outputProperties) throws TransformerException {\n        if (source == null) {\n            return;\n        }\n\n        Transformer transformer = createTransformer();\n        if (transformer == null) {\n            throw new TransformerException(\"Could not create a transformer - JAXP is misconfigured!\");\n        }\n        transformer.setOutputProperties(outputProperties);\n        transformer.transform(source, result);\n    }\n\n    /**\n     * Converts the given NodeList to a boolean\n     */\n    @Converter\n    public Boolean toBoolean(NodeList list) {\n        return list.getLength() > 0;\n    }\n\n    /**\n     * Converts the given byte[] to a Source\n     */\n    @Converter\n    public BytesSource toBytesSource(byte[] data) {\n        return new BytesSource(data);\n    }\n\n    /**\n     * Converts the given String to a Source\n     */\n    @Converter\n    public StringSource toStringSource(String data) {\n        return new StringSource(data);\n    }\n\n    /**\n     * Converts the given Document to a Source\n     * @deprecated use toDOMSource instead\n     */\n    @Deprecated\n    public DOMSource toSource(Document document) {\n        return new DOMSource(document);\n    }\n\n    /**\n     * Converts the given Node to a Source\n     * @throws TransformerException\n     * @throws ParserConfigurationException\n     * @deprecated  use toDOMSource instead\n     */\n    @Deprecated\n    public Source toSource(Node node) throws ParserConfigurationException, TransformerException {\n        return toDOMSource(node);\n    }\n\n    /**\n     * Converts the given Node to a Source\n     * @throws TransformerException\n     * @throws ParserConfigurationException\n     */\n    @Converter\n    public DOMSource toDOMSource(Node node) throws ParserConfigurationException, TransformerException {\n        Document document = toDOMDocument(node);\n        return new DOMSource(document);\n    }\n\n    /**\n     * Converts the given Document to a DOMSource\n     */\n    @Converter\n    public DOMSource toDOMSource(Document document) {\n        return new DOMSource(document);\n    }\n\n    /**\n     * Converts the given String to a Source\n     */\n    @Converter\n    public Source toSource(String data) {\n        return new StringSource(data);\n    }\n\n    /**\n     * Converts the given input Source into text.\n     *\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public String toString(Source source) throws TransformerException {\n        return toString(source, null);\n    }\n\n    /**\n     * Converts the given input Source into text\n     */\n    @Converter\n    public String toString(Source source, Exchange exchange) throws TransformerException {\n        if (source == null) {\n            return null;\n        } else if (source instanceof StringSource) {\n            return ((StringSource) source).getText();\n        } else if (source instanceof BytesSource) {\n            return new String(((BytesSource) source).getData());\n        } else {\n            StringWriter buffer = new StringWriter();\n            if (exchange != null) {\n                // check the camelContext properties first\n                Properties properties = ObjectHelper.getCamelPropertiesWithPrefix(OUTPUT_PROPERTIES_PREFIX, exchange.getContext());\n                if (properties.size() > 0) {\n                    toResult(source, new StreamResult(buffer), properties);\n                    return buffer.toString();\n                }\n            }\n            // using the old way to deal with it\n            toResult(source, new StreamResult(buffer));\n            return buffer.toString();\n        }\n    }\n\n    /**\n     * Converts the given input Source into bytes\n     */\n    @Converter\n    public byte[] toByteArray(Source source, Exchange exchange) throws TransformerException {\n        if (source instanceof BytesSource) {\n            return ((BytesSource)source).getData();\n        } else {\n            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n            if (exchange != null) {\n                // check the camelContext properties first\n                Properties properties = ObjectHelper.getCamelPropertiesWithPrefix(OUTPUT_PROPERTIES_PREFIX,\n                                                                                  exchange.getContext());\n                if (properties.size() > 0) {\n                    toResult(source, new StreamResult(buffer), properties);\n                    return buffer.toByteArray();\n                }\n            }\n            // using the old way to deal with it\n            toResult(source, new StreamResult(buffer));\n            return buffer.toByteArray();\n        }\n    }\n\n    /**\n     * Converts the given input Node into text\n     *\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public String toString(Node node) throws TransformerException {\n        return toString(node, null);\n    }\n\n    /**\n     * Converts the given input Node into text\n     */\n    @Converter\n    public String toString(Node node, Exchange exchange) throws TransformerException {\n        return toString(new DOMSource(node), exchange);\n    }\n\n    /**\n     * Converts the source instance to a {@link DOMSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public DOMSource toDOMSource(Source source) throws ParserConfigurationException, IOException, SAXException, TransformerException {\n        return toDOMSource(source, (Exchange)null);\n    }\n    \n    /**\n     * Converts the source instance to a {@link DOMSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     */\n    @Converter\n    public DOMSource toDOMSource(Source source, Exchange exchange) throws ParserConfigurationException, IOException, SAXException, TransformerException {\n        if (source instanceof DOMSource) {\n            return (DOMSource) source;\n        } else if (source instanceof SAXSource) {\n            return toDOMSourceFromSAX((SAXSource) source);\n        } else if (source instanceof StreamSource) {\n            return toDOMSourceFromStream((StreamSource) source, exchange);\n        } else if (source instanceof StAXSource) {\n            return toDOMSourceFromStAX((StAXSource)source);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Converts the source instance to a {@link DOMSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     */\n    @Converter\n    public DOMSource toDOMSource(String text) throws ParserConfigurationException, IOException, SAXException, TransformerException {\n        Source source = toSource(text);\n        return toDOMSourceFromStream((StreamSource) source);\n    }\n\n    /**\n     * Converts the source instance to a {@link DOMSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     */\n    @Converter\n    public DOMSource toDOMSource(byte[] bytes) throws IOException, SAXException, ParserConfigurationException {\n        InputStream is = new ByteArrayInputStream(bytes);\n        try {\n            return toDOMSource(is);\n        } finally {\n            IOHelper.close(is);\n        }\n    }\n\n\n    /**\n     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     *\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public SAXSource toSAXSource(String source) throws IOException, SAXException, TransformerException {\n        return toSAXSource(source, null);\n    }\n\n    /**\n     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     */\n    @Converter\n    public SAXSource toSAXSource(String source, Exchange exchange) throws IOException, SAXException, TransformerException {\n        return toSAXSource(toSource(source), exchange);\n    }\n\n    /**\n     * Converts the source instance to a {@link StAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     * @throws XMLStreamException\n     */\n    @Converter\n    public StAXSource toStAXSource(String source, Exchange exchange) throws XMLStreamException {\n        XMLStreamReader r = new StaxConverter().createXMLStreamReader(new StringReader(source));\n        return new StAXSource(r);\n    }\n\n    /**\n     * Converts the source instance to a {@link StAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     * @throws XMLStreamException\n     */\n    @Converter\n    public StAXSource toStAXSource(byte[] in, Exchange exchange) throws XMLStreamException {\n        XMLStreamReader r = new StaxConverter().createXMLStreamReader(new ByteArrayInputStream(in), exchange);\n        return new StAXSource(r);\n    }\n\n    /**\n     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     *\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public SAXSource toSAXSource(InputStream source) throws IOException, SAXException, TransformerException {\n        return toSAXSource(source, null);\n    }\n\n    /**\n     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     */\n    @Converter\n    public SAXSource toSAXSource(InputStream source, Exchange exchange) throws IOException, SAXException, TransformerException {\n        return toSAXSource(toStreamSource(source), exchange);\n    }\n\n    /**\n     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     */\n    @Converter\n    public SAXSource toSAXSource(byte[] in, Exchange exchange) throws IOException, SAXException, TransformerException {\n        return toSAXSource(toStreamSource(in, exchange), exchange);\n    }\n\n    /**\n     * Converts the source instance to a {@link StAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     * @throws XMLStreamException\n     */\n    @Converter\n    public StAXSource toStAXSource(InputStream source, Exchange exchange) throws XMLStreamException {\n        XMLStreamReader r = new StaxConverter().createXMLStreamReader(source, exchange);\n        return new StAXSource(r);\n    }\n\n    /**\n     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     */\n    @Converter\n    public SAXSource toSAXSource(File file, Exchange exchange) throws IOException, SAXException, TransformerException {\n        InputStream is = IOHelper.buffered(new FileInputStream(file));\n        return toSAXSource(is, exchange);\n    }\n\n    /**\n     * Converts the source instance to a {@link StAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     * @throws FileNotFoundException\n     * @throws XMLStreamException\n     */\n    @Converter\n    public StAXSource toStAXSource(File file, Exchange exchange) throws FileNotFoundException, XMLStreamException {\n        InputStream is = IOHelper.buffered(new FileInputStream(file));\n        XMLStreamReader r = new StaxConverter().createXMLStreamReader(is, exchange);\n        return new StAXSource(r);\n    }\n\n    /**\n     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     *\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public SAXSource toSAXSource(Source source) throws IOException, SAXException, TransformerException {\n        return toSAXSource(source, null);\n    }\n\n    /**\n     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     */\n    @Converter\n    public SAXSource toSAXSource(Source source, Exchange exchange) throws IOException, SAXException, TransformerException {\n        if (source instanceof SAXSource) {\n            return (SAXSource) source;\n        } else if (source instanceof DOMSource) {\n            return toSAXSourceFromDOM((DOMSource) source, exchange);\n        } else if (source instanceof StreamSource) {\n            return toSAXSourceFromStream((StreamSource) source, exchange);\n        } else if (source instanceof StAXSource) {\n            return toSAXSourceFromStAX((StAXSource) source, exchange);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public StreamSource toStreamSource(Source source) throws TransformerException {\n        return toStreamSource(source, null);\n    }\n\n    @Converter\n    public StreamSource toStreamSource(Source source, Exchange exchange) throws TransformerException {\n        if (source instanceof StreamSource) {\n            return (StreamSource) source;\n        } else if (source instanceof DOMSource) {\n            return toStreamSourceFromDOM((DOMSource) source, exchange);\n        } else if (source instanceof SAXSource) {\n            return toStreamSourceFromSAX((SAXSource) source, exchange);\n        } else if (source instanceof StAXSource) {\n            return toStreamSourceFromStAX((StAXSource) source, exchange);\n        } else {\n            return null;\n        }\n    }\n\n    @Converter\n    public StreamSource toStreamSource(InputStream in) throws TransformerException {\n        return new StreamSource(in);\n    }\n\n    @Converter\n    public StreamSource toStreamSource(Reader in) throws TransformerException {\n        return new StreamSource(in);\n    }\n\n    @Converter\n    public StreamSource toStreamSource(File in) throws TransformerException {\n        return new StreamSource(in);\n    }\n\n    @Converter\n    public StreamSource toStreamSource(byte[] in, Exchange exchange) throws TransformerException {\n        InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, in);\n        return new StreamSource(is);\n    }\n\n    @Converter\n    public StreamSource toStreamSource(ByteBuffer in, Exchange exchange) throws TransformerException {\n        InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, in);\n        return new StreamSource(is);\n    }\n\n    /**\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public StreamSource toStreamSourceFromSAX(SAXSource source) throws TransformerException {\n        return toStreamSourceFromSAX(source, null);\n    }\n\n    @Converter\n    public StreamSource toStreamSourceFromSAX(SAXSource source, Exchange exchange) throws TransformerException {\n        InputSource inputSource = source.getInputSource();\n        if (inputSource != null) {\n            if (inputSource.getCharacterStream() != null) {\n                return new StreamSource(inputSource.getCharacterStream());\n            }\n            if (inputSource.getByteStream() != null) {\n                return new StreamSource(inputSource.getByteStream());\n            }\n        }\n        String result = toString(source, exchange);\n        return new StringSource(result);\n    }\n\n    /**\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public StreamSource toStreamSourceFromDOM(DOMSource source) throws TransformerException {\n        return toStreamSourceFromDOM(source, null);\n    }\n\n    @Converter\n    public StreamSource toStreamSourceFromDOM(DOMSource source, Exchange exchange) throws TransformerException {\n        String result = toString(source, exchange);\n        return new StringSource(result);\n    }\n    @Converter\n    public StreamSource toStreamSourceFromStAX(StAXSource source, Exchange exchange) throws TransformerException {\n        String result = toString(source, exchange);\n        return new StringSource(result);\n    }\n\n    /**\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public SAXSource toSAXSourceFromStream(StreamSource source) throws SAXException {\n        return toSAXSourceFromStream(source, null);\n    }\n    \n    @Converter\n    public SAXSource toSAXSourceFromStream(StreamSource source, Exchange exchange) throws SAXException {\n        InputSource inputSource;\n        if (source.getReader() != null) {\n            inputSource = new InputSource(source.getReader());\n        } else {\n            inputSource = new InputSource(source.getInputStream());\n        }\n        inputSource.setSystemId(source.getSystemId());\n        inputSource.setPublicId(source.getPublicId());\n        XMLReader xmlReader = null;\n        SAXParserFactory sfactory = null;\n        //Need to setup XMLReader security feature by default\n        try {\n            // use the SAXPaserFactory which is set from exchange\n            if (exchange != null) {\n                sfactory = exchange.getProperty(Exchange.SAXPARSER_FACTORY, SAXParserFactory.class);\n            }\n            if (sfactory == null) {\n                sfactory = SAXParserFactory.newInstance();\n                try {\n                    sfactory.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);\n                } catch (Exception e) {\n                    LOG.warn(\"SAXParser doesn't support the feature {} with value {}, due to {}.\", new Object[]{javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, \"true\", e});\n                }\n            }\n            sfactory.setNamespaceAware(true);\n            SAXParser parser = sfactory.newSAXParser();\n            xmlReader = parser.getXMLReader();\n        } catch (Exception ex) {\n            LOG.warn(\"Cannot create the SAXParser XMLReader, due to {}\", ex);\n        }\n        return new SAXSource(xmlReader, inputSource);\n    }\n\n    /**\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public Reader toReaderFromSource(Source src) throws TransformerException {\n        return toReaderFromSource(src, null);\n    }\n\n    @Converter\n    public Reader toReaderFromSource(Source src, Exchange exchange) throws TransformerException {\n        StreamSource stSrc = toStreamSource(src, exchange);\n        Reader r = stSrc.getReader();\n        if (r == null) {\n            r = new InputStreamReader(stSrc.getInputStream());\n        }\n        return r;\n    }\n\n    /**\n    * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n    */\n    @Deprecated\n    public DOMSource toDOMSource(InputStream is) throws ParserConfigurationException, IOException, SAXException {\n        return toDOMSource(is, null);\n    }\n    \n    @Converter\n    public DOMSource toDOMSource(InputStream is, Exchange exchange) throws ParserConfigurationException, IOException, SAXException {\n        InputSource source = new InputSource(is);\n        String systemId = source.getSystemId();\n        DocumentBuilder builder = getDocumentBuilderFactory(exchange).newDocumentBuilder();\n        Document document = builder.parse(source);\n        return new DOMSource(document, systemId);\n    }\n\n    /**\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public DOMSource toDOMSource(File file) throws ParserConfigurationException, IOException, SAXException {\n        return toDOMSource(file, null);\n    }\n    \n    @Converter\n    public DOMSource toDOMSource(File file, Exchange exchange) throws ParserConfigurationException, IOException, SAXException {\n        InputStream is = IOHelper.buffered(new FileInputStream(file));\n        return toDOMSource(is, exchange);\n    }\n\n    /**\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public DOMSource toDOMSourceFromStream(StreamSource source) throws ParserConfigurationException, IOException, SAXException {\n        return toDOMSourceFromStream(source, null);\n    }\n    \n    @Converter\n    public DOMSource toDOMSourceFromStream(StreamSource source, Exchange exchange) throws ParserConfigurationException, IOException, SAXException {\n        Document document;\n        String systemId = source.getSystemId();\n\n        DocumentBuilder builder = getDocumentBuilderFactory(exchange).newDocumentBuilder();\n        Reader reader = source.getReader();\n        if (reader != null) {\n            document = builder.parse(new InputSource(reader));\n        } else {\n            InputStream inputStream = source.getInputStream();\n            if (inputStream != null) {\n                InputSource inputsource = new InputSource(inputStream);\n                inputsource.setSystemId(systemId);\n                document = builder.parse(inputsource);\n            } else {\n                throw new IOException(\"No input stream or reader available on StreamSource: \" + source);\n            }\n        }\n        return new DOMSource(document, systemId);\n    }\n\n    /**\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public SAXSource toSAXSourceFromDOM(DOMSource source) throws TransformerException {\n        return toSAXSourceFromDOM(source, null);\n    }\n\n    @Converter\n    public SAXSource toSAXSourceFromDOM(DOMSource source, Exchange exchange) throws TransformerException {\n        String str = toString(source, exchange);\n        StringReader reader = new StringReader(str);\n        return new SAXSource(new InputSource(reader));\n    }\n\n    @Converter\n    public SAXSource toSAXSourceFromStAX(StAXSource source, Exchange exchange) throws TransformerException {\n        String str = toString(source, exchange);\n        StringReader reader = new StringReader(str);\n        return new SAXSource(new InputSource(reader));\n    }\n\n    @Converter\n    public DOMSource toDOMSourceFromSAX(SAXSource source) throws IOException, SAXException, ParserConfigurationException, TransformerException {\n        return new DOMSource(toDOMNodeFromSAX(source));\n    }\n\n    @Converter\n    public DOMSource toDOMSourceFromStAX(StAXSource source) throws IOException, SAXException, ParserConfigurationException, TransformerException {\n        return new DOMSource(toDOMNodeFromStAX(source));\n    }\n\n    @Converter\n    public Node toDOMNodeFromSAX(SAXSource source) throws ParserConfigurationException, IOException, SAXException, TransformerException {\n        DOMResult result = new DOMResult();\n        toResult(source, result);\n        return result.getNode();\n    }\n\n    @Converter\n    public Node toDOMNodeFromStAX(StAXSource source) throws ParserConfigurationException, IOException, SAXException, TransformerException {\n        DOMResult result = new DOMResult();\n        toResult(source, result);\n        return result.getNode();\n    }\n\n    /**\n     * Convert a NodeList consisting of just 1 node to a DOM Node.\n     * @param nl the NodeList\n     * @return the DOM Node\n     */\n    @Converter(allowNull = true)\n    public Node toDOMNodeFromSingleNodeList(NodeList nl) {\n        return nl.getLength() == 1 ? nl.item(0) : null;\n    }\n\n    /**\n     * Convert a NodeList consisting of just 1 node to a DOM Document.\n     * Cannot convert NodeList with length > 1 because they require a root node.\n     * @param nl the NodeList\n     * @return the DOM Document\n     */\n    @Converter(allowNull = true)\n    public Document toDOMDocumentFromSingleNodeList(NodeList nl) throws ParserConfigurationException, TransformerException {\n        if (nl.getLength() == 1) {\n            return toDOMDocument(nl.item(0));\n        } else if (nl instanceof Node) {\n            // as XML parsers may often have nodes that implement both Node and NodeList then the type converter lookup\n            // may lookup either a type converter from NodeList or Node. So let's fallback and try with Node\n            return toDOMDocument((Node) nl);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Converts the given TRaX Source into a W3C DOM node\n     */\n    @Converter(allowNull = true)\n    public Node toDOMNode(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {\n        DOMSource domSrc = toDOMSource(source);\n        return domSrc != null ? domSrc.getNode() : null;\n    }\n\n    /**\n     * Create a DOM element from the given source.\n     */\n    @Converter\n    public Element toDOMElement(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {\n        Node node = toDOMNode(source);\n        return toDOMElement(node);\n    }\n\n    /**\n     * Create a DOM element from the DOM node.\n     * Simply cast if the node is an Element, or\n     * return the root element if it is a Document.\n     */\n    @Converter\n    public Element toDOMElement(Node node) throws TransformerException {\n        // If the node is an document, return the root element\n        if (node instanceof Document) {\n            return ((Document) node).getDocumentElement();\n            // If the node is an element, just cast it\n        } else if (node instanceof Element) {\n            return (Element) node;\n            // Other node types are not handled\n        } else {\n            throw new TransformerException(\"Unable to convert DOM node to an Element\");\n        }\n    }\n\n    \n    /**\n     * Converts the given data to a DOM document\n     *\n     * @param data is the data to be parsed\n     * @return the parsed document\n     */\n    @Deprecated\n    public Document toDOMDocument(byte[] data) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(data, null);\n    }\n    \n    /**\n     * Converts the given data to a DOM document\n     *\n     * @param data is the data to be parsed\n     * @param exchange is the exchange to be used when calling the converter\n     * @return the parsed document\n     */\n    @Converter\n    public Document toDOMDocument(byte[] data, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {\n        DocumentBuilder documentBuilder = getDocumentBuilderFactory(exchange).newDocumentBuilder();\n        return documentBuilder.parse(new ByteArrayInputStream(data));\n    }\n\n    /**\n     * Converts the given {@link InputStream} to a DOM document\n     *\n     * @param in is the data to be parsed\n     * @return the parsed document\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public Document toDOMDocument(InputStream in) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(in, null);\n    }\n    \n    /**\n     * Converts the given {@link InputStream} to a DOM document\n     *\n     * @param in is the data to be parsed\n     * @param exchange is the exchange to be used when calling the converter\n     * @return the parsed document\n     */\n    @Converter\n    public Document toDOMDocument(InputStream in, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {\n        DocumentBuilder documentBuilder = getDocumentBuilderFactory(exchange).newDocumentBuilder();\n        return documentBuilder.parse(in);\n    }\n\n    /**\n     * Converts the given {@link InputStream} to a DOM document\n     *\n     * @param in is the data to be parsed\n     * @return the parsed document\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public Document toDOMDocument(Reader in) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(new InputSource(in));\n    }\n    \n    /**\n     * Converts the given {@link InputStream} to a DOM document\n     *\n     * @param in is the data to be parsed\n     * @param exchange is the exchange to be used when calling the converter\n     * @return the parsed document\n     */\n    @Converter\n    public Document toDOMDocument(Reader in, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(new InputSource(in), exchange);\n    }\n\n    /**\n     * Converts the given {@link InputSource} to a DOM document\n     *\n     * @param in is the data to be parsed\n     * @return the parsed document\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public Document toDOMDocument(InputSource in) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(in, (Exchange)null);\n    }\n    \n    /**\n     * Converts the given {@link InputSource} to a DOM document\n     *\n     * @param in is the data to be parsed\n     * @param exchange is the exchange to be used when calling the converter\n     * @return the parsed document\n     */\n    @Converter\n    public Document toDOMDocument(InputSource in, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {\n        DocumentBuilder documentBuilder = getDocumentBuilderFactory(exchange).newDocumentBuilder();\n        return documentBuilder.parse(in);\n    }\n\n    /**\n     * Converts the given {@link String} to a DOM document\n     *\n     * @param text is the data to be parsed\n     * @return the parsed document\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public Document toDOMDocument(String text) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(new StringReader(text));\n    }\n    \n    /**\n     * Converts the given {@link String} to a DOM document\n     *\n     * @param text is the data to be parsed\n     * @param exchange is the exchange to be used when calling the converter\n     * @return the parsed document\n     */\n    @Converter\n    public Document toDOMDocument(String text, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(new StringReader(text), exchange);\n    }\n\n    /**\n     * Converts the given {@link File} to a DOM document\n     *\n     * @param file is the data to be parsed\n     * @return the parsed document\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public Document toDOMDocument(File file) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(file, null);\n    }\n    \n    /**\n     * Converts the given {@link File} to a DOM document\n     *\n     * @param file is the data to be parsed\n     * @param exchange is the exchange to be used when calling the converter\n     * @return the parsed document\n     */\n    @Converter\n    public Document toDOMDocument(File file, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {\n        DocumentBuilder documentBuilder = getDocumentBuilderFactory(exchange).newDocumentBuilder();\n        return documentBuilder.parse(file);\n    }\n\n    /**\n     * Create a DOM document from the given source.\n     */\n    @Converter\n    public Document toDOMDocument(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {\n        Node node = toDOMNode(source);\n        return toDOMDocument(node);\n    }\n\n    /**\n     * Create a DOM document from the given Node.\n     *\n     * If the node is an document, just cast it, if the node is an root element, retrieve its\n     * owner element or create a new document and import the node.\n     */\n    @Converter\n    public Document toDOMDocument(final Node node) throws ParserConfigurationException, TransformerException {\n        ObjectHelper.notNull(node, \"node\");\n\n        // If the node is the document, just cast it\n        if (node instanceof Document) {\n            return (Document) node;\n            // If the node is an element\n        } else if (node instanceof Element) {\n            Element elem = (Element) node;\n            // If this is the root element, return its owner document\n            if (elem.getOwnerDocument().getDocumentElement() == elem) {\n                return elem.getOwnerDocument();\n                // else, create a new doc and copy the element inside it\n            } else {\n                Document doc = createDocument();\n                // import node must not occur concurrent on the same node (must be its owner)\n                // so we need to synchronize on it\n                synchronized (node.getOwnerDocument()) {\n                    doc.appendChild(doc.importNode(node, true));\n                }\n                return doc;\n            }\n            // other element types are not handled\n        } else {\n            throw new TransformerException(\"Unable to convert DOM node to a Document: \" + node);\n        }\n    }\n\n    /**\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public InputStream toInputStream(DOMSource source) throws TransformerException, IOException {\n        return toInputStream(source, null);\n    }\n\n    @Converter\n    public InputStream toInputStream(DOMSource source, Exchange exchange) throws TransformerException, IOException {\n        return new ByteArrayInputStream(toByteArray(source, exchange));\n    }\n\n    /**\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public InputStream toInputStream(Document dom) throws TransformerException, IOException {\n        return toInputStream(dom, null);\n    }\n\n    @Converter\n    public InputStream toInputStream(Document dom, Exchange exchange) throws TransformerException, IOException {\n        return toInputStream(new DOMSource(dom), exchange);\n    }\n\n    @Converter\n    public InputSource toInputSource(InputStream is, Exchange exchange) {\n        return new InputSource(is);\n    }\n\n    @Converter\n    public InputSource toInputSource(File file, Exchange exchange) throws FileNotFoundException {\n        InputStream is = IOHelper.buffered(new FileInputStream(file));\n        return new InputSource(is);\n    }\n\n    // Properties\n    //-------------------------------------------------------------------------\n\n    public DocumentBuilderFactory getDocumentBuilderFactory() {\n        if (documentBuilderFactory == null) {\n            documentBuilderFactory = createDocumentBuilderFactory();\n        }\n        return documentBuilderFactory;\n    }\n\n    public void setDocumentBuilderFactory(DocumentBuilderFactory documentBuilderFactory) {\n        this.documentBuilderFactory = documentBuilderFactory;\n    }\n\n    public TransformerFactory getTransformerFactory() {\n        if (transformerFactory == null) {\n            transformerFactory = createTransformerFactory();\n        }\n        return transformerFactory;\n    }\n\n    public void setTransformerFactory(TransformerFactory transformerFactory) {\n        this.transformerFactory = transformerFactory;\n    }\n\n    // Helper methods\n    //-------------------------------------------------------------------------\n\n    protected void setupFeatures(DocumentBuilderFactory factory) {\n        Properties properties = System.getProperties();\n        List<String> features = new ArrayList<String>();\n        for (Map.Entry<Object, Object> prop : properties.entrySet()) {\n            String key = (String) prop.getKey();\n            if (key.startsWith(XmlConverter.DOCUMENT_BUILDER_FACTORY_FEATURE)) {\n                String uri = ObjectHelper.after(key, \":\");\n                Boolean value = Boolean.valueOf((String)prop.getValue());\n                try {\n                    factory.setFeature(uri, value);\n                    features.add(\"feature \" + uri + \" value \" + value);\n                } catch (ParserConfigurationException e) {\n                    LOG.warn(\"DocumentBuilderFactory doesn't support the feature {} with value {}, due to {}.\", new Object[]{uri, value, e});\n                }\n            }\n        }\n        if (features.size() > 0) {\n            StringBuilder featureString = new StringBuilder();\n            // just log the configured feature\n            for (String feature : features) {\n                if (featureString.length() != 0) {\n                    featureString.append(\", \");\n                }\n                featureString.append(feature);\n            }\n            LOG.info(\"DocumentBuilderFactory has been set with features {{}}.\", featureString.toString());\n        }\n\n    }\n    \n    public DocumentBuilderFactory getDocumentBuilderFactory(Exchange exchange) {\n        DocumentBuilderFactory answer = getDocumentBuilderFactory();\n        // Get the DocumentBuilderFactory from the exchange header first\n        if (exchange != null) {\n            DocumentBuilderFactory factory = exchange.getProperty(Exchange.DOCUMENT_BUILDER_FACTORY, DocumentBuilderFactory.class);\n            if (factory != null) {\n                answer = factory;\n            }\n        }\n        return answer;\n    }\n \n    public DocumentBuilderFactory createDocumentBuilderFactory() {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setNamespaceAware(true);\n        factory.setIgnoringElementContentWhitespace(true);\n        factory.setIgnoringComments(true);\n        try {\n            // Disable the external-general-entities by default\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        } catch (ParserConfigurationException e) {\n            LOG.warn(\"DocumentBuilderFactory doesn't support the feature {} with value {}, due to {}.\"\n                     , new Object[]{\"http://xml.org/sax/features/external-general-entities\", false, e});\n        }\n        // setup the SecurityManager by default if it's apache xerces\n        try {\n            Class<?> smClass = ObjectHelper.loadClass(\"org.apache.xerces.util.SecurityManager\");\n            if (smClass != null) {\n                Object sm = smClass.newInstance();\n                // Here we just use the default setting of the SeurityManager\n                factory.setAttribute(\"http://apache.org/xml/properties/security-manager\", sm);\n            }\n        } catch (Exception e) {\n            LOG.warn(\"DocumentBuilderFactory doesn't support the attribute {}, due to {}.\"\n                     , new Object[]{\"http://apache.org/xml/properties/security-manager\", e});\n        }\n        // setup the feature from the system property\n        setupFeatures(factory);\n        return factory;\n    }\n\n    public DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {\n        DocumentBuilderFactory factory = getDocumentBuilderFactory();\n        return factory.newDocumentBuilder();\n    }\n\n    public Document createDocument() throws ParserConfigurationException {\n        DocumentBuilder builder = createDocumentBuilder();\n        return builder.newDocument();\n    }\n\n    /**\n     * @deprecated use {@link #createTransformer}, will be removed in Camel 3.0\n     */\n    @Deprecated\n    public Transformer createTransfomer() throws TransformerConfigurationException {\n        return createTransformer();\n    }\n\n    public Transformer createTransformer() throws TransformerConfigurationException {\n        TransformerFactory factory = getTransformerFactory();\n        return factory.newTransformer();\n    }\n\n    public TransformerFactory createTransformerFactory() {\n        TransformerFactory factory = TransformerFactory.newInstance();\n        // Enable the Security feature by default\n        try {\n            factory.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);\n        } catch (TransformerConfigurationException e) {\n            LOG.warn(\"TransformerFactory doesn't support the feature {} with value {}, due to {}.\", new Object[]{javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, \"true\", e});\n        }\n        factory.setErrorListener(new XmlErrorListener());\n        return factory;\n    }\n\n}\n",
        "human_patch_code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.converter.jaxp;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMResult;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXSource;\nimport javax.xml.transform.stax.StAXSource;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\n\nimport org.apache.camel.BytesSource;\nimport org.apache.camel.Converter;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.StringSource;\nimport org.apache.camel.util.IOHelper;\nimport org.apache.camel.util.ObjectHelper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A helper class to transform to and from various JAXB types such as {@link Source} and {@link Document}\n *\n * @version\n */\n@Converter\npublic class XmlConverter {\n    @Deprecated\n    //It will be removed in Camel 3.0, please use the Exchange.DEFAULT_CHARSET\n    public static final String DEFAULT_CHARSET_PROPERTY = \"org.apache.camel.default.charset\";\n\n    public static final String OUTPUT_PROPERTIES_PREFIX = \"org.apache.camel.xmlconverter.output.\";\n    public static final String DOCUMENT_BUILDER_FACTORY_FEATURE = \"org.apache.camel.xmlconverter.documentBuilderFactory.feature\";\n    public static String defaultCharset = ObjectHelper.getSystemProperty(Exchange.DEFAULT_CHARSET_PROPERTY, \"UTF-8\");\n\n    private static final Logger LOG = LoggerFactory.getLogger(XmlConverter.class);\n\n    private DocumentBuilderFactory documentBuilderFactory;\n    private TransformerFactory transformerFactory;\n\n    public XmlConverter() {\n    }\n\n    public XmlConverter(DocumentBuilderFactory documentBuilderFactory) {\n        this.documentBuilderFactory = documentBuilderFactory;\n    }\n\n    /**\n     * Returns the default set of output properties for conversions.\n     */\n    public Properties defaultOutputProperties() {\n        Properties properties = new Properties();\n        properties.put(OutputKeys.ENCODING, defaultCharset);\n        properties.put(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n        return properties;\n    }\n\n    /**\n     * Converts the given input Source into the required result\n     */\n    public void toResult(Source source, Result result) throws TransformerException {\n        toResult(source, result, defaultOutputProperties());\n    }\n\n    /**\n     * Converts the given input Source into the required result\n     */\n    public void toResult(Source source, Result result, Properties outputProperties) throws TransformerException {\n        if (source == null) {\n            return;\n        }\n\n        Transformer transformer = createTransformer();\n        if (transformer == null) {\n            throw new TransformerException(\"Could not create a transformer - JAXP is misconfigured!\");\n        }\n        transformer.setOutputProperties(outputProperties);\n        transformer.transform(source, result);\n    }\n\n    /**\n     * Converts the given NodeList to a boolean\n     */\n    @Converter\n    public Boolean toBoolean(NodeList list) {\n        return list.getLength() > 0;\n    }\n\n    /**\n     * Converts the given byte[] to a Source\n     */\n    @Converter\n    public BytesSource toBytesSource(byte[] data) {\n        return new BytesSource(data);\n    }\n\n    /**\n     * Converts the given String to a Source\n     */\n    @Converter\n    public StringSource toStringSource(String data) {\n        return new StringSource(data);\n    }\n\n    /**\n     * Converts the given Document to a Source\n     * @deprecated use toDOMSource instead\n     */\n    @Deprecated\n    public DOMSource toSource(Document document) {\n        return new DOMSource(document);\n    }\n\n    /**\n     * Converts the given Node to a Source\n     * @throws TransformerException\n     * @throws ParserConfigurationException\n     * @deprecated  use toDOMSource instead\n     */\n    @Deprecated\n    public Source toSource(Node node) throws ParserConfigurationException, TransformerException {\n        return toDOMSource(node);\n    }\n\n    /**\n     * Converts the given Node to a Source\n     * @throws TransformerException\n     * @throws ParserConfigurationException\n     */\n    @Converter\n    public DOMSource toDOMSource(Node node) throws ParserConfigurationException, TransformerException {\n        Document document = toDOMDocument(node);\n        return new DOMSource(document);\n    }\n\n    /**\n     * Converts the given Document to a DOMSource\n     */\n    @Converter\n    public DOMSource toDOMSource(Document document) {\n        return new DOMSource(document);\n    }\n\n    /**\n     * Converts the given String to a Source\n     */\n    @Converter\n    public Source toSource(String data) {\n        return new StringSource(data);\n    }\n\n    /**\n     * Converts the given input Source into text.\n     *\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public String toString(Source source) throws TransformerException {\n        return toString(source, null);\n    }\n\n    /**\n     * Converts the given input Source into text\n     */\n    @Converter\n    public String toString(Source source, Exchange exchange) throws TransformerException {\n        if (source == null) {\n            return null;\n        } else if (source instanceof StringSource) {\n            return ((StringSource) source).getText();\n        } else if (source instanceof BytesSource) {\n            return new String(((BytesSource) source).getData());\n        } else {\n            StringWriter buffer = new StringWriter();\n            if (exchange != null) {\n                // check the camelContext properties first\n                Properties properties = ObjectHelper.getCamelPropertiesWithPrefix(OUTPUT_PROPERTIES_PREFIX, exchange.getContext());\n                if (properties.size() > 0) {\n                    toResult(source, new StreamResult(buffer), properties);\n                    return buffer.toString();\n                }\n            }\n            // using the old way to deal with it\n            toResult(source, new StreamResult(buffer));\n            return buffer.toString();\n        }\n    }\n\n    /**\n     * Converts the given input Source into bytes\n     */\n    @Converter\n    public byte[] toByteArray(Source source, Exchange exchange) throws TransformerException {\n        if (source instanceof BytesSource) {\n            return ((BytesSource)source).getData();\n        } else {\n            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n            if (exchange != null) {\n                // check the camelContext properties first\n                Properties properties = ObjectHelper.getCamelPropertiesWithPrefix(OUTPUT_PROPERTIES_PREFIX,\n                                                                                  exchange.getContext());\n                if (properties.size() > 0) {\n                    toResult(source, new StreamResult(buffer), properties);\n                    return buffer.toByteArray();\n                }\n            }\n            // using the old way to deal with it\n            toResult(source, new StreamResult(buffer));\n            return buffer.toByteArray();\n        }\n    }\n\n    /**\n     * Converts the given input Node into text\n     *\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public String toString(Node node) throws TransformerException {\n        return toString(node, null);\n    }\n\n    /**\n     * Converts the given input Node into text\n     */\n    @Converter\n    public String toString(Node node, Exchange exchange) throws TransformerException {\n        return toString(new DOMSource(node), exchange);\n    }\n\n    /**\n     * Converts the source instance to a {@link DOMSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public DOMSource toDOMSource(Source source) throws ParserConfigurationException, IOException, SAXException, TransformerException {\n        return toDOMSource(source, (Exchange)null);\n    }\n    \n    /**\n     * Converts the source instance to a {@link DOMSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     */\n    @Converter\n    public DOMSource toDOMSource(Source source, Exchange exchange) throws ParserConfigurationException, IOException, SAXException, TransformerException {\n        if (source instanceof DOMSource) {\n            return (DOMSource) source;\n        } else if (source instanceof SAXSource) {\n            return toDOMSourceFromSAX((SAXSource) source);\n        } else if (source instanceof StreamSource) {\n            return toDOMSourceFromStream((StreamSource) source, exchange);\n        } else if (source instanceof StAXSource) {\n            return toDOMSourceFromStAX((StAXSource)source);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Converts the source instance to a {@link DOMSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     */\n    @Converter\n    public DOMSource toDOMSource(String text) throws ParserConfigurationException, IOException, SAXException, TransformerException {\n        Source source = toSource(text);\n        return toDOMSourceFromStream((StreamSource) source);\n    }\n\n    /**\n     * Converts the source instance to a {@link DOMSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     */\n    @Converter\n    public DOMSource toDOMSource(byte[] bytes) throws IOException, SAXException, ParserConfigurationException {\n        InputStream is = new ByteArrayInputStream(bytes);\n        try {\n            return toDOMSource(is);\n        } finally {\n            IOHelper.close(is);\n        }\n    }\n\n\n    /**\n     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     *\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public SAXSource toSAXSource(String source) throws IOException, SAXException, TransformerException {\n        return toSAXSource(source, null);\n    }\n\n    /**\n     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     */\n    @Converter\n    public SAXSource toSAXSource(String source, Exchange exchange) throws IOException, SAXException, TransformerException {\n        return toSAXSource(toSource(source), exchange);\n    }\n\n    /**\n     * Converts the source instance to a {@link StAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     * @throws XMLStreamException\n     */\n    @Converter\n    public StAXSource toStAXSource(String source, Exchange exchange) throws XMLStreamException {\n        XMLStreamReader r = new StaxConverter().createXMLStreamReader(new StringReader(source));\n        return new StAXSource(r);\n    }\n\n    /**\n     * Converts the source instance to a {@link StAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     * @throws XMLStreamException\n     */\n    @Converter\n    public StAXSource toStAXSource(byte[] in, Exchange exchange) throws XMLStreamException {\n        XMLStreamReader r = new StaxConverter().createXMLStreamReader(new ByteArrayInputStream(in), exchange);\n        return new StAXSource(r);\n    }\n\n    /**\n     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     *\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public SAXSource toSAXSource(InputStream source) throws IOException, SAXException, TransformerException {\n        return toSAXSource(source, null);\n    }\n\n    /**\n     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     */\n    @Converter\n    public SAXSource toSAXSource(InputStream source, Exchange exchange) throws IOException, SAXException, TransformerException {\n        return toSAXSource(toStreamSource(source), exchange);\n    }\n\n    /**\n     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     */\n    @Converter\n    public SAXSource toSAXSource(byte[] in, Exchange exchange) throws IOException, SAXException, TransformerException {\n        return toSAXSource(toStreamSource(in, exchange), exchange);\n    }\n\n    /**\n     * Converts the source instance to a {@link StAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     * @throws XMLStreamException\n     */\n    @Converter\n    public StAXSource toStAXSource(InputStream source, Exchange exchange) throws XMLStreamException {\n        XMLStreamReader r = new StaxConverter().createXMLStreamReader(source, exchange);\n        return new StAXSource(r);\n    }\n\n    /**\n     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     */\n    @Converter\n    public SAXSource toSAXSource(File file, Exchange exchange) throws IOException, SAXException, TransformerException {\n        InputStream is = IOHelper.buffered(new FileInputStream(file));\n        return toSAXSource(is, exchange);\n    }\n\n    /**\n     * Converts the source instance to a {@link StAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     * @throws FileNotFoundException\n     * @throws XMLStreamException\n     */\n    @Converter\n    public StAXSource toStAXSource(File file, Exchange exchange) throws FileNotFoundException, XMLStreamException {\n        InputStream is = IOHelper.buffered(new FileInputStream(file));\n        XMLStreamReader r = new StaxConverter().createXMLStreamReader(is, exchange);\n        return new StAXSource(r);\n    }\n\n    /**\n     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     *\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public SAXSource toSAXSource(Source source) throws IOException, SAXException, TransformerException {\n        return toSAXSource(source, null);\n    }\n\n    /**\n     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not\n     * supported (making it easy to derive from this class to add new kinds of conversion).\n     */\n    @Converter\n    public SAXSource toSAXSource(Source source, Exchange exchange) throws IOException, SAXException, TransformerException {\n        if (source instanceof SAXSource) {\n            return (SAXSource) source;\n        } else if (source instanceof DOMSource) {\n            return toSAXSourceFromDOM((DOMSource) source, exchange);\n        } else if (source instanceof StreamSource) {\n            return toSAXSourceFromStream((StreamSource) source, exchange);\n        } else if (source instanceof StAXSource) {\n            return toSAXSourceFromStAX((StAXSource) source, exchange);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public StreamSource toStreamSource(Source source) throws TransformerException {\n        return toStreamSource(source, null);\n    }\n\n    @Converter\n    public StreamSource toStreamSource(Source source, Exchange exchange) throws TransformerException {\n        if (source instanceof StreamSource) {\n            return (StreamSource) source;\n        } else if (source instanceof DOMSource) {\n            return toStreamSourceFromDOM((DOMSource) source, exchange);\n        } else if (source instanceof SAXSource) {\n            return toStreamSourceFromSAX((SAXSource) source, exchange);\n        } else if (source instanceof StAXSource) {\n            return toStreamSourceFromStAX((StAXSource) source, exchange);\n        } else {\n            return null;\n        }\n    }\n\n    @Converter\n    public StreamSource toStreamSource(InputStream in) throws TransformerException {\n        return new StreamSource(in);\n    }\n\n    @Converter\n    public StreamSource toStreamSource(Reader in) throws TransformerException {\n        return new StreamSource(in);\n    }\n\n    @Converter\n    public StreamSource toStreamSource(File in) throws TransformerException {\n        return new StreamSource(in);\n    }\n\n    @Converter\n    public StreamSource toStreamSource(byte[] in, Exchange exchange) throws TransformerException {\n        InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, in);\n        return new StreamSource(is);\n    }\n\n    @Converter\n    public StreamSource toStreamSource(ByteBuffer in, Exchange exchange) throws TransformerException {\n        InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, in);\n        return new StreamSource(is);\n    }\n\n    /**\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public StreamSource toStreamSourceFromSAX(SAXSource source) throws TransformerException {\n        return toStreamSourceFromSAX(source, null);\n    }\n\n    @Converter\n    public StreamSource toStreamSourceFromSAX(SAXSource source, Exchange exchange) throws TransformerException {\n        InputSource inputSource = source.getInputSource();\n        if (inputSource != null) {\n            if (inputSource.getCharacterStream() != null) {\n                return new StreamSource(inputSource.getCharacterStream());\n            }\n            if (inputSource.getByteStream() != null) {\n                return new StreamSource(inputSource.getByteStream());\n            }\n        }\n        String result = toString(source, exchange);\n        return new StringSource(result);\n    }\n\n    /**\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public StreamSource toStreamSourceFromDOM(DOMSource source) throws TransformerException {\n        return toStreamSourceFromDOM(source, null);\n    }\n\n    @Converter\n    public StreamSource toStreamSourceFromDOM(DOMSource source, Exchange exchange) throws TransformerException {\n        String result = toString(source, exchange);\n        return new StringSource(result);\n    }\n    @Converter\n    public StreamSource toStreamSourceFromStAX(StAXSource source, Exchange exchange) throws TransformerException {\n        String result = toString(source, exchange);\n        return new StringSource(result);\n    }\n\n    /**\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public SAXSource toSAXSourceFromStream(StreamSource source) throws SAXException {\n        return toSAXSourceFromStream(source, null);\n    }\n    \n    @Converter\n    public SAXSource toSAXSourceFromStream(StreamSource source, Exchange exchange) throws SAXException {\n        InputSource inputSource;\n        if (source.getReader() != null) {\n            inputSource = new InputSource(source.getReader());\n        } else {\n            inputSource = new InputSource(source.getInputStream());\n        }\n        inputSource.setSystemId(source.getSystemId());\n        inputSource.setPublicId(source.getPublicId());\n        XMLReader xmlReader = null;\n        SAXParserFactory sfactory = null;\n        //Need to setup XMLReader security feature by default\n        try {\n            // use the SAXPaserFactory which is set from exchange\n            if (exchange != null) {\n                sfactory = exchange.getProperty(Exchange.SAXPARSER_FACTORY, SAXParserFactory.class);\n            }\n            if (sfactory == null) {\n                sfactory = SAXParserFactory.newInstance();\n                try {\n                    sfactory.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);\n                } catch (Exception e) {\n                    LOG.warn(\"SAXParser doesn't support the feature {} with value {}, due to {}.\", new Object[]{javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, \"true\", e});\n                }\n                try {\n                    sfactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n                } catch (SAXException e) {\n                    LOG.warn(\"SAXParser doesn't support the feature {} with value {}, due to {}.\"\n                            , new Object[]{\"http://xml.org/sax/features/external-general-entities\", false, e});                \n                }\n            }\n            sfactory.setNamespaceAware(true);\n            SAXParser parser = sfactory.newSAXParser();\n            xmlReader = parser.getXMLReader();\n        } catch (Exception ex) {\n            LOG.warn(\"Cannot create the SAXParser XMLReader, due to {}\", ex);\n        }\n        return new SAXSource(xmlReader, inputSource);\n    }\n\n    /**\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public Reader toReaderFromSource(Source src) throws TransformerException {\n        return toReaderFromSource(src, null);\n    }\n\n    @Converter\n    public Reader toReaderFromSource(Source src, Exchange exchange) throws TransformerException {\n        StreamSource stSrc = toStreamSource(src, exchange);\n        Reader r = stSrc.getReader();\n        if (r == null) {\n            r = new InputStreamReader(stSrc.getInputStream());\n        }\n        return r;\n    }\n\n    /**\n    * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n    */\n    @Deprecated\n    public DOMSource toDOMSource(InputStream is) throws ParserConfigurationException, IOException, SAXException {\n        return toDOMSource(is, null);\n    }\n    \n    @Converter\n    public DOMSource toDOMSource(InputStream is, Exchange exchange) throws ParserConfigurationException, IOException, SAXException {\n        InputSource source = new InputSource(is);\n        String systemId = source.getSystemId();\n        DocumentBuilder builder = getDocumentBuilderFactory(exchange).newDocumentBuilder();\n        Document document = builder.parse(source);\n        return new DOMSource(document, systemId);\n    }\n\n    /**\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public DOMSource toDOMSource(File file) throws ParserConfigurationException, IOException, SAXException {\n        return toDOMSource(file, null);\n    }\n    \n    @Converter\n    public DOMSource toDOMSource(File file, Exchange exchange) throws ParserConfigurationException, IOException, SAXException {\n        InputStream is = IOHelper.buffered(new FileInputStream(file));\n        return toDOMSource(is, exchange);\n    }\n\n    /**\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public DOMSource toDOMSourceFromStream(StreamSource source) throws ParserConfigurationException, IOException, SAXException {\n        return toDOMSourceFromStream(source, null);\n    }\n    \n    @Converter\n    public DOMSource toDOMSourceFromStream(StreamSource source, Exchange exchange) throws ParserConfigurationException, IOException, SAXException {\n        Document document;\n        String systemId = source.getSystemId();\n\n        DocumentBuilder builder = getDocumentBuilderFactory(exchange).newDocumentBuilder();\n        Reader reader = source.getReader();\n        if (reader != null) {\n            document = builder.parse(new InputSource(reader));\n        } else {\n            InputStream inputStream = source.getInputStream();\n            if (inputStream != null) {\n                InputSource inputsource = new InputSource(inputStream);\n                inputsource.setSystemId(systemId);\n                document = builder.parse(inputsource);\n            } else {\n                throw new IOException(\"No input stream or reader available on StreamSource: \" + source);\n            }\n        }\n        return new DOMSource(document, systemId);\n    }\n\n    /**\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public SAXSource toSAXSourceFromDOM(DOMSource source) throws TransformerException {\n        return toSAXSourceFromDOM(source, null);\n    }\n\n    @Converter\n    public SAXSource toSAXSourceFromDOM(DOMSource source, Exchange exchange) throws TransformerException {\n        String str = toString(source, exchange);\n        StringReader reader = new StringReader(str);\n        return new SAXSource(new InputSource(reader));\n    }\n\n    @Converter\n    public SAXSource toSAXSourceFromStAX(StAXSource source, Exchange exchange) throws TransformerException {\n        String str = toString(source, exchange);\n        StringReader reader = new StringReader(str);\n        return new SAXSource(new InputSource(reader));\n    }\n\n    @Converter\n    public DOMSource toDOMSourceFromSAX(SAXSource source) throws IOException, SAXException, ParserConfigurationException, TransformerException {\n        return new DOMSource(toDOMNodeFromSAX(source));\n    }\n\n    @Converter\n    public DOMSource toDOMSourceFromStAX(StAXSource source) throws IOException, SAXException, ParserConfigurationException, TransformerException {\n        return new DOMSource(toDOMNodeFromStAX(source));\n    }\n\n    @Converter\n    public Node toDOMNodeFromSAX(SAXSource source) throws ParserConfigurationException, IOException, SAXException, TransformerException {\n        DOMResult result = new DOMResult();\n        toResult(source, result);\n        return result.getNode();\n    }\n\n    @Converter\n    public Node toDOMNodeFromStAX(StAXSource source) throws ParserConfigurationException, IOException, SAXException, TransformerException {\n        DOMResult result = new DOMResult();\n        toResult(source, result);\n        return result.getNode();\n    }\n\n    /**\n     * Convert a NodeList consisting of just 1 node to a DOM Node.\n     * @param nl the NodeList\n     * @return the DOM Node\n     */\n    @Converter(allowNull = true)\n    public Node toDOMNodeFromSingleNodeList(NodeList nl) {\n        return nl.getLength() == 1 ? nl.item(0) : null;\n    }\n\n    /**\n     * Convert a NodeList consisting of just 1 node to a DOM Document.\n     * Cannot convert NodeList with length > 1 because they require a root node.\n     * @param nl the NodeList\n     * @return the DOM Document\n     */\n    @Converter(allowNull = true)\n    public Document toDOMDocumentFromSingleNodeList(NodeList nl) throws ParserConfigurationException, TransformerException {\n        if (nl.getLength() == 1) {\n            return toDOMDocument(nl.item(0));\n        } else if (nl instanceof Node) {\n            // as XML parsers may often have nodes that implement both Node and NodeList then the type converter lookup\n            // may lookup either a type converter from NodeList or Node. So let's fallback and try with Node\n            return toDOMDocument((Node) nl);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Converts the given TRaX Source into a W3C DOM node\n     */\n    @Converter(allowNull = true)\n    public Node toDOMNode(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {\n        DOMSource domSrc = toDOMSource(source);\n        return domSrc != null ? domSrc.getNode() : null;\n    }\n\n    /**\n     * Create a DOM element from the given source.\n     */\n    @Converter\n    public Element toDOMElement(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {\n        Node node = toDOMNode(source);\n        return toDOMElement(node);\n    }\n\n    /**\n     * Create a DOM element from the DOM node.\n     * Simply cast if the node is an Element, or\n     * return the root element if it is a Document.\n     */\n    @Converter\n    public Element toDOMElement(Node node) throws TransformerException {\n        // If the node is an document, return the root element\n        if (node instanceof Document) {\n            return ((Document) node).getDocumentElement();\n            // If the node is an element, just cast it\n        } else if (node instanceof Element) {\n            return (Element) node;\n            // Other node types are not handled\n        } else {\n            throw new TransformerException(\"Unable to convert DOM node to an Element\");\n        }\n    }\n\n    \n    /**\n     * Converts the given data to a DOM document\n     *\n     * @param data is the data to be parsed\n     * @return the parsed document\n     */\n    @Deprecated\n    public Document toDOMDocument(byte[] data) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(data, null);\n    }\n    \n    /**\n     * Converts the given data to a DOM document\n     *\n     * @param data is the data to be parsed\n     * @param exchange is the exchange to be used when calling the converter\n     * @return the parsed document\n     */\n    @Converter\n    public Document toDOMDocument(byte[] data, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {\n        DocumentBuilder documentBuilder = getDocumentBuilderFactory(exchange).newDocumentBuilder();\n        return documentBuilder.parse(new ByteArrayInputStream(data));\n    }\n\n    /**\n     * Converts the given {@link InputStream} to a DOM document\n     *\n     * @param in is the data to be parsed\n     * @return the parsed document\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public Document toDOMDocument(InputStream in) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(in, null);\n    }\n    \n    /**\n     * Converts the given {@link InputStream} to a DOM document\n     *\n     * @param in is the data to be parsed\n     * @param exchange is the exchange to be used when calling the converter\n     * @return the parsed document\n     */\n    @Converter\n    public Document toDOMDocument(InputStream in, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {\n        DocumentBuilder documentBuilder = getDocumentBuilderFactory(exchange).newDocumentBuilder();\n        return documentBuilder.parse(in);\n    }\n\n    /**\n     * Converts the given {@link InputStream} to a DOM document\n     *\n     * @param in is the data to be parsed\n     * @return the parsed document\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public Document toDOMDocument(Reader in) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(new InputSource(in));\n    }\n    \n    /**\n     * Converts the given {@link InputStream} to a DOM document\n     *\n     * @param in is the data to be parsed\n     * @param exchange is the exchange to be used when calling the converter\n     * @return the parsed document\n     */\n    @Converter\n    public Document toDOMDocument(Reader in, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(new InputSource(in), exchange);\n    }\n\n    /**\n     * Converts the given {@link InputSource} to a DOM document\n     *\n     * @param in is the data to be parsed\n     * @return the parsed document\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public Document toDOMDocument(InputSource in) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(in, (Exchange)null);\n    }\n    \n    /**\n     * Converts the given {@link InputSource} to a DOM document\n     *\n     * @param in is the data to be parsed\n     * @param exchange is the exchange to be used when calling the converter\n     * @return the parsed document\n     */\n    @Converter\n    public Document toDOMDocument(InputSource in, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {\n        DocumentBuilder documentBuilder = getDocumentBuilderFactory(exchange).newDocumentBuilder();\n        return documentBuilder.parse(in);\n    }\n\n    /**\n     * Converts the given {@link String} to a DOM document\n     *\n     * @param text is the data to be parsed\n     * @return the parsed document\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public Document toDOMDocument(String text) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(new StringReader(text));\n    }\n    \n    /**\n     * Converts the given {@link String} to a DOM document\n     *\n     * @param text is the data to be parsed\n     * @param exchange is the exchange to be used when calling the converter\n     * @return the parsed document\n     */\n    @Converter\n    public Document toDOMDocument(String text, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(new StringReader(text), exchange);\n    }\n\n    /**\n     * Converts the given {@link File} to a DOM document\n     *\n     * @param file is the data to be parsed\n     * @return the parsed document\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public Document toDOMDocument(File file) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(file, null);\n    }\n    \n    /**\n     * Converts the given {@link File} to a DOM document\n     *\n     * @param file is the data to be parsed\n     * @param exchange is the exchange to be used when calling the converter\n     * @return the parsed document\n     */\n    @Converter\n    public Document toDOMDocument(File file, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {\n        DocumentBuilder documentBuilder = getDocumentBuilderFactory(exchange).newDocumentBuilder();\n        return documentBuilder.parse(file);\n    }\n\n    /**\n     * Create a DOM document from the given source.\n     */\n    @Converter\n    public Document toDOMDocument(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {\n        Node node = toDOMNode(source);\n        return toDOMDocument(node);\n    }\n\n    /**\n     * Create a DOM document from the given Node.\n     *\n     * If the node is an document, just cast it, if the node is an root element, retrieve its\n     * owner element or create a new document and import the node.\n     */\n    @Converter\n    public Document toDOMDocument(final Node node) throws ParserConfigurationException, TransformerException {\n        ObjectHelper.notNull(node, \"node\");\n\n        // If the node is the document, just cast it\n        if (node instanceof Document) {\n            return (Document) node;\n            // If the node is an element\n        } else if (node instanceof Element) {\n            Element elem = (Element) node;\n            // If this is the root element, return its owner document\n            if (elem.getOwnerDocument().getDocumentElement() == elem) {\n                return elem.getOwnerDocument();\n                // else, create a new doc and copy the element inside it\n            } else {\n                Document doc = createDocument();\n                // import node must not occur concurrent on the same node (must be its owner)\n                // so we need to synchronize on it\n                synchronized (node.getOwnerDocument()) {\n                    doc.appendChild(doc.importNode(node, true));\n                }\n                return doc;\n            }\n            // other element types are not handled\n        } else {\n            throw new TransformerException(\"Unable to convert DOM node to a Document: \" + node);\n        }\n    }\n\n    /**\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public InputStream toInputStream(DOMSource source) throws TransformerException, IOException {\n        return toInputStream(source, null);\n    }\n\n    @Converter\n    public InputStream toInputStream(DOMSource source, Exchange exchange) throws TransformerException, IOException {\n        return new ByteArrayInputStream(toByteArray(source, exchange));\n    }\n\n    /**\n     * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\n     */\n    @Deprecated\n    public InputStream toInputStream(Document dom) throws TransformerException, IOException {\n        return toInputStream(dom, null);\n    }\n\n    @Converter\n    public InputStream toInputStream(Document dom, Exchange exchange) throws TransformerException, IOException {\n        return toInputStream(new DOMSource(dom), exchange);\n    }\n\n    @Converter\n    public InputSource toInputSource(InputStream is, Exchange exchange) {\n        return new InputSource(is);\n    }\n\n    @Converter\n    public InputSource toInputSource(File file, Exchange exchange) throws FileNotFoundException {\n        InputStream is = IOHelper.buffered(new FileInputStream(file));\n        return new InputSource(is);\n    }\n\n    // Properties\n    //-------------------------------------------------------------------------\n\n    public DocumentBuilderFactory getDocumentBuilderFactory() {\n        if (documentBuilderFactory == null) {\n            documentBuilderFactory = createDocumentBuilderFactory();\n        }\n        return documentBuilderFactory;\n    }\n\n    public void setDocumentBuilderFactory(DocumentBuilderFactory documentBuilderFactory) {\n        this.documentBuilderFactory = documentBuilderFactory;\n    }\n\n    public TransformerFactory getTransformerFactory() {\n        if (transformerFactory == null) {\n            transformerFactory = createTransformerFactory();\n        }\n        return transformerFactory;\n    }\n\n    public void setTransformerFactory(TransformerFactory transformerFactory) {\n        this.transformerFactory = transformerFactory;\n    }\n\n    // Helper methods\n    //-------------------------------------------------------------------------\n\n    protected void setupFeatures(DocumentBuilderFactory factory) {\n        Properties properties = System.getProperties();\n        List<String> features = new ArrayList<String>();\n        for (Map.Entry<Object, Object> prop : properties.entrySet()) {\n            String key = (String) prop.getKey();\n            if (key.startsWith(XmlConverter.DOCUMENT_BUILDER_FACTORY_FEATURE)) {\n                String uri = ObjectHelper.after(key, \":\");\n                Boolean value = Boolean.valueOf((String)prop.getValue());\n                try {\n                    factory.setFeature(uri, value);\n                    features.add(\"feature \" + uri + \" value \" + value);\n                } catch (ParserConfigurationException e) {\n                    LOG.warn(\"DocumentBuilderFactory doesn't support the feature {} with value {}, due to {}.\", new Object[]{uri, value, e});\n                }\n            }\n        }\n        if (features.size() > 0) {\n            StringBuilder featureString = new StringBuilder();\n            // just log the configured feature\n            for (String feature : features) {\n                if (featureString.length() != 0) {\n                    featureString.append(\", \");\n                }\n                featureString.append(feature);\n            }\n            LOG.info(\"DocumentBuilderFactory has been set with features {{}}.\", featureString.toString());\n        }\n\n    }\n    \n    public DocumentBuilderFactory getDocumentBuilderFactory(Exchange exchange) {\n        DocumentBuilderFactory answer = getDocumentBuilderFactory();\n        // Get the DocumentBuilderFactory from the exchange header first\n        if (exchange != null) {\n            DocumentBuilderFactory factory = exchange.getProperty(Exchange.DOCUMENT_BUILDER_FACTORY, DocumentBuilderFactory.class);\n            if (factory != null) {\n                answer = factory;\n            }\n        }\n        return answer;\n    }\n \n    public DocumentBuilderFactory createDocumentBuilderFactory() {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setNamespaceAware(true);\n        factory.setIgnoringElementContentWhitespace(true);\n        factory.setIgnoringComments(true);\n        try {\n            // Disable the external-general-entities by default\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        } catch (ParserConfigurationException e) {\n            LOG.warn(\"DocumentBuilderFactory doesn't support the feature {} with value {}, due to {}.\"\n                     , new Object[]{\"http://xml.org/sax/features/external-general-entities\", false, e});\n        }\n        // setup the SecurityManager by default if it's apache xerces\n        try {\n            Class<?> smClass = ObjectHelper.loadClass(\"org.apache.xerces.util.SecurityManager\");\n            if (smClass != null) {\n                Object sm = smClass.newInstance();\n                // Here we just use the default setting of the SeurityManager\n                factory.setAttribute(\"http://apache.org/xml/properties/security-manager\", sm);\n            }\n        } catch (Exception e) {\n            LOG.warn(\"DocumentBuilderFactory doesn't support the attribute {}, due to {}.\"\n                     , new Object[]{\"http://apache.org/xml/properties/security-manager\", e});\n        }\n        // setup the feature from the system property\n        setupFeatures(factory);\n        return factory;\n    }\n\n    public DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {\n        DocumentBuilderFactory factory = getDocumentBuilderFactory();\n        return factory.newDocumentBuilder();\n    }\n\n    public Document createDocument() throws ParserConfigurationException {\n        DocumentBuilder builder = createDocumentBuilder();\n        return builder.newDocument();\n    }\n\n    /**\n     * @deprecated use {@link #createTransformer}, will be removed in Camel 3.0\n     */\n    @Deprecated\n    public Transformer createTransfomer() throws TransformerConfigurationException {\n        return createTransformer();\n    }\n\n    public Transformer createTransformer() throws TransformerConfigurationException {\n        TransformerFactory factory = getTransformerFactory();\n        return factory.newTransformer();\n    }\n\n    public TransformerFactory createTransformerFactory() {\n        TransformerFactory factory = TransformerFactory.newInstance();\n        // Enable the Security feature by default\n        try {\n            factory.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);\n        } catch (TransformerConfigurationException e) {\n            LOG.warn(\"TransformerFactory doesn't support the feature {} with value {}, due to {}.\", new Object[]{javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, \"true\", e});\n        }\n        factory.setErrorListener(new XmlErrorListener());\n        return factory;\n    }\n\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-4": {
    "vul_id": "VUL4J-4",
    "cve_id": "CVE-2015-0264",
    "project": "apache_camel",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl camel-core -Dtest=org.apache.camel.builder.xml.XPathFeatureTest",
    "test_all_cmd": "mvn test -pl camel-core",
    "human_patch_url": "https://github.com/apache/camel/commit/1df559649a96a1ca0368373387e542f46e4820da",
    "vulnerable_files": [
      {
        "file_path": "camel-core/src/main/java/org/apache/camel/builder/xml/XPathBuilder.java",
        "file_name": "XPathBuilder.java",
        "vulnerable_code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.builder.xml;\n\nimport java.io.File;\nimport java.io.InputStream;\nimport java.io.StringReader;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport javax.xml.namespace.QName;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathFactoryConfigurationException;\nimport javax.xml.xpath.XPathFunction;\nimport javax.xml.xpath.XPathFunctionException;\nimport javax.xml.xpath.XPathFunctionResolver;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport org.apache.camel.CamelContext;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Expression;\nimport org.apache.camel.NoTypeConversionAvailableException;\nimport org.apache.camel.Predicate;\nimport org.apache.camel.RuntimeExpressionException;\nimport org.apache.camel.WrappedFile;\nimport org.apache.camel.component.bean.BeanInvocation;\nimport org.apache.camel.impl.DefaultExchange;\nimport org.apache.camel.spi.Language;\nimport org.apache.camel.spi.NamespaceAware;\nimport org.apache.camel.support.ServiceSupport;\nimport org.apache.camel.util.ExchangeHelper;\nimport org.apache.camel.util.IOHelper;\nimport org.apache.camel.util.MessageHelper;\nimport org.apache.camel.util.ObjectHelper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static org.apache.camel.builder.xml.Namespaces.DEFAULT_NAMESPACE;\nimport static org.apache.camel.builder.xml.Namespaces.FUNCTION_NAMESPACE;\nimport static org.apache.camel.builder.xml.Namespaces.IN_NAMESPACE;\nimport static org.apache.camel.builder.xml.Namespaces.OUT_NAMESPACE;\nimport static org.apache.camel.builder.xml.Namespaces.isMatchingNamespaceOrEmptyNamespace;\n\n/**\n * Creates an XPath expression builder which creates a nodeset result by default.\n * If you want to evaluate a String expression then call {@link #stringResult()}\n * <p/>\n * An XPath object is not thread-safe and not reentrant. In other words, it is the application's responsibility to make\n * sure that one XPath object is not used from more than one thread at any given time, and while the evaluate method\n * is invoked, applications may not recursively call the evaluate method.\n * <p/>\n * This implementation is thread safe by using thread locals and pooling to allow concurrency.\n * <p/>\n * <b>Important:</b> After configuring the {@link XPathBuilder} its advised to invoke {@link #start()}\n * to prepare the builder before using; though the builder will auto-start on first use.\n *\n * @see XPathConstants#NODESET\n */\npublic class XPathBuilder extends ServiceSupport implements Expression, Predicate, NamespaceAware {\n    private static final Logger LOG = LoggerFactory.getLogger(XPathBuilder.class);\n    private static final String SAXON_OBJECT_MODEL_URI = \"http://saxon.sf.net/jaxp/xpath/om\";\n    private static final String OBTAIN_ALL_NS_XPATH = \"//*/namespace::*\";\n\n    private static volatile XPathFactory defaultXPathFactory;\n\n    private final Queue<XPathExpression> pool = new ConcurrentLinkedQueue<XPathExpression>();\n    private final Queue<XPathExpression> poolLogNamespaces = new ConcurrentLinkedQueue<XPathExpression>();\n    private final String text;\n    private final ThreadLocal<Exchange> exchange = new ThreadLocal<Exchange>();\n    private final MessageVariableResolver variableResolver = new MessageVariableResolver(exchange);\n    private final Map<String, String> namespaces = new ConcurrentHashMap<String, String>();\n    private volatile XPathFactory xpathFactory;\n    private volatile Class<?> documentType = Document.class;\n    // For some reason the default expression of \"a/b\" on a document such as\n    // <a><b>1</b><b>2</b></a>\n    // will evaluate as just \"1\" by default which is bizarre. So by default\n    // let's assume XPath expressions result in nodesets.\n    private volatile Class<?> resultType;\n    private volatile QName resultQName = XPathConstants.NODESET;\n    private volatile String objectModelUri;\n    private volatile DefaultNamespaceContext namespaceContext;\n    private volatile boolean logNamespaces;\n    private volatile XPathFunctionResolver functionResolver;\n    private volatile XPathFunction bodyFunction;\n    private volatile XPathFunction headerFunction;\n    private volatile XPathFunction outBodyFunction;\n    private volatile XPathFunction outHeaderFunction;\n    private volatile XPathFunction propertiesFunction;\n    private volatile XPathFunction simpleFunction;\n    /**\n     * The name of the header we want to apply the XPath expression to, which when set will cause\n     * the xpath to be evaluated on the required header, otherwise it will be applied to the body\n     */\n    private volatile String headerName;\n\n    /**\n     * @param text The XPath expression\n     */\n    public XPathBuilder(String text) {\n        this.text = text;\n    }\n\n    /**\n     * @param text The XPath expression\n     * @return A new XPathBuilder object\n     */\n    public static XPathBuilder xpath(String text) {\n        return new XPathBuilder(text);\n    }\n\n    /**\n     * @param text       The XPath expression\n     * @param resultType The result type that the XPath expression will return.\n     * @return A new XPathBuilder object\n     */\n    public static XPathBuilder xpath(String text, Class<?> resultType) {\n        XPathBuilder builder = new XPathBuilder(text);\n        builder.setResultType(resultType);\n        return builder;\n    }\n\n    @Override\n    public String toString() {\n        return \"XPath: \" + text;\n    }\n\n    public boolean matches(Exchange exchange) {\n        try {\n            Object booleanResult = evaluateAs(exchange, XPathConstants.BOOLEAN);\n            return exchange.getContext().getTypeConverter().convertTo(Boolean.class, booleanResult);\n        } finally {\n            // remove the thread local after usage\n            this.exchange.remove();\n        }\n    }\n\n    public <T> T evaluate(Exchange exchange, Class<T> type) {\n        try {\n            Object result = evaluate(exchange);\n            return exchange.getContext().getTypeConverter().convertTo(type, exchange, result);\n        } finally {\n            // remove the thread local after usage\n            this.exchange.remove();\n        }\n    }\n\n    /**\n     * Matches the given xpath using the provided body.\n     *\n     * @param context the camel context\n     * @param body    the body\n     * @return <tt>true</tt> if matches, <tt>false</tt> otherwise\n     */\n    public boolean matches(CamelContext context, Object body) {\n        ObjectHelper.notNull(context, \"CamelContext\");\n\n        // create a dummy Exchange to use during matching\n        Exchange dummy = new DefaultExchange(context);\n        dummy.getIn().setBody(body);\n\n        try {\n            return matches(dummy);\n        } finally {\n            // remove the thread local after usage\n            exchange.remove();\n        }\n    }\n\n    /**\n     * Evaluates the given xpath using the provided body.\n     *\n     * @param context the camel context\n     * @param body    the body\n     * @param type    the type to return\n     * @return result of the evaluation\n     */\n    public <T> T evaluate(CamelContext context, Object body, Class<T> type) {\n        ObjectHelper.notNull(context, \"CamelContext\");\n\n        // create a dummy Exchange to use during evaluation\n        Exchange dummy = new DefaultExchange(context);\n        dummy.getIn().setBody(body);\n\n        try {\n            return evaluate(dummy, type);\n        } finally {\n            // remove the thread local after usage\n            exchange.remove();\n        }\n    }\n\n    /**\n     * Evaluates the given xpath using the provided body as a String return type.\n     *\n     * @param context the camel context\n     * @param body    the body\n     * @return result of the evaluation\n     */\n    public String evaluate(CamelContext context, Object body) {\n        ObjectHelper.notNull(context, \"CamelContext\");\n\n        // create a dummy Exchange to use during evaluation\n        Exchange dummy = new DefaultExchange(context);\n        dummy.getIn().setBody(body);\n\n        setResultQName(XPathConstants.STRING);\n        try {\n            return evaluate(dummy, String.class);\n        } finally {\n            // remove the thread local after usage\n            this.exchange.remove();\n        }\n    }\n\n    // Builder methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Sets the expression result type to {@link XPathConstants#BOOLEAN}\n     *\n     * @return the current builder\n     */\n    public XPathBuilder booleanResult() {\n        resultQName = XPathConstants.BOOLEAN;\n        return this;\n    }\n\n    /**\n     * Sets the expression result type to {@link XPathConstants#NODE}\n     *\n     * @return the current builder\n     */\n    public XPathBuilder nodeResult() {\n        resultQName = XPathConstants.NODE;\n        return this;\n    }\n\n    /**\n     * Sets the expression result type to {@link XPathConstants#NODESET}\n     *\n     * @return the current builder\n     */\n    public XPathBuilder nodeSetResult() {\n        resultQName = XPathConstants.NODESET;\n        return this;\n    }\n\n    /**\n     * Sets the expression result type to {@link XPathConstants#NUMBER}\n     *\n     * @return the current builder\n     */\n    public XPathBuilder numberResult() {\n        resultQName = XPathConstants.NUMBER;\n        return this;\n    }\n\n    /**\n     * Sets the expression result type to {@link XPathConstants#STRING}\n     *\n     * @return the current builder\n     */\n    public XPathBuilder stringResult() {\n        resultQName = XPathConstants.STRING;\n        return this;\n    }\n\n    /**\n     * Sets the expression result type to the given {@code resultType}\n     *\n     * @return the current builder\n     */\n    public XPathBuilder resultType(Class<?> resultType) {\n        setResultType(resultType);\n        return this;\n    }\n\n    /**\n     * Sets the object model URI to use\n     *\n     * @return the current builder\n     */\n    public XPathBuilder objectModel(String uri) {\n        // Careful! Setting the Object Model URI this way will set the *Default* XPath Factory, which since is a static field,\n        // will set the XPath Factory system-wide. Decide what to do, as changing this behaviour can break compatibility. Provided the setObjectModel which changes\n        // this instance's XPath Factory rather than the static field\n        this.objectModelUri = uri;\n        return this;\n    }\n\n    /**\n     * Configures to use Saxon as the XPathFactory which allows you to use XPath 2.0 functions\n     * which may not be part of the build in JDK XPath parser.\n     *\n     * @return the current builder\n     */\n    public XPathBuilder saxon() {\n        this.objectModelUri = SAXON_OBJECT_MODEL_URI;\n        return this;\n    }\n\n    /**\n     * Sets the {@link XPathFunctionResolver} instance to use on these XPath\n     * expressions\n     *\n     * @return the current builder\n     */\n    public XPathBuilder functionResolver(XPathFunctionResolver functionResolver) {\n        this.functionResolver = functionResolver;\n        return this;\n    }\n\n    /**\n     * Registers the namespace prefix and URI with the builder so that the\n     * prefix can be used in XPath expressions\n     *\n     * @param prefix is the namespace prefix that can be used in the XPath\n     *               expressions\n     * @param uri    is the namespace URI to which the prefix refers\n     * @return the current builder\n     */\n    public XPathBuilder namespace(String prefix, String uri) {\n        namespaces.put(prefix, uri);\n        return this;\n    }\n\n    /**\n     * Registers namespaces with the builder so that the registered\n     * prefixes can be used in XPath expressions\n     *\n     * @param namespaces is namespaces object that should be used in the\n     *                   XPath expression\n     * @return the current builder\n     */\n    public XPathBuilder namespaces(Namespaces namespaces) {\n        namespaces.configure(this);\n        return this;\n    }\n\n    /**\n     * Registers a variable (in the global namespace) which can be referred to\n     * from XPath expressions\n     *\n     * @param name  name of variable\n     * @param value value of variable\n     * @return the current builder\n     */\n    public XPathBuilder variable(String name, Object value) {\n        getVariableResolver().addVariable(name, value);\n        return this;\n    }\n\n    /**\n     * Configures the document type to use.\n     * <p/>\n     * The document type controls which kind of Class Camel should convert the payload\n     * to before doing the xpath evaluation.\n     * <p/>\n     * For example you can set it to {@link InputSource} to use SAX streams.\n     * By default Camel uses {@link Document} as the type.\n     *\n     * @param documentType the document type\n     * @return the current builder\n     */\n    public XPathBuilder documentType(Class<?> documentType) {\n        setDocumentType(documentType);\n        return this;\n    }\n\n    /**\n     * Configures to use the provided XPath factory.\n     * <p/>\n     * Can be used to use Saxon instead of the build in factory from the JDK.\n     *\n     * @param xpathFactory the xpath factory to use\n     * @return the current builder.\n     */\n    public XPathBuilder factory(XPathFactory xpathFactory) {\n        setXPathFactory(xpathFactory);\n        return this;\n    }\n\n    /**\n     * Activates trace logging of all discovered namespaces in the message - to simplify debugging namespace-related issues\n     * <p/>\n     * Namespaces are printed in Hashmap style <code>{xmlns:prefix=[namespaceURI], xmlns:prefix=[namespaceURI]}</code>.\n     * <p/>\n     * The implicit XML namespace is omitted (http://www.w3.org/XML/1998/namespace).\n     * XML allows for namespace prefixes to be redefined/overridden due to hierarchical scoping, i.e. prefix abc can be mapped to http://abc.com,\n     * and deeper in the document it can be mapped to http://def.com. When two prefixes are detected which are equal but are mapped to different\n     * namespace URIs, Camel will show all namespaces URIs it is mapped to in an array-style.\n     * <p/>\n     * This feature is disabled by default.\n     *\n     * @return the current builder.\n     */\n    public XPathBuilder logNamespaces() {\n        setLogNamespaces(true);\n        return this;\n    }\n\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets the xpath factory, can be <tt>null</tt> if no custom factory has been assigned.\n     * <p/>\n     * A default factory will be assigned (if no custom assigned) when either starting this builder\n     * or on first evaluation.\n     *\n     * @return the factory, or <tt>null</tt> if this builder has not been started/used before.\n     */\n    public XPathFactory getXPathFactory() {\n        return xpathFactory;\n    }\n\n    public void setXPathFactory(XPathFactory xpathFactory) {\n        this.xpathFactory = xpathFactory;\n    }\n\n    public Class<?> getDocumentType() {\n        return documentType;\n    }\n\n    public void setDocumentType(Class<?> documentType) {\n        this.documentType = documentType;\n    }\n\n    public String getText() {\n        return text;\n    }\n\n    public QName getResultQName() {\n        return resultQName;\n    }\n\n    public void setResultQName(QName resultQName) {\n        this.resultQName = resultQName;\n    }\n\n    public String getHeaderName() {\n        return headerName;\n    }\n\n    public void setHeaderName(String headerName) {\n        this.headerName = headerName;\n    }\n\n    /**\n     * Gets the namespace context, can be <tt>null</tt> if no custom context has been assigned.\n     * <p/>\n     * A default context will be assigned (if no custom assigned) when either starting this builder\n     * or on first evaluation.\n     *\n     * @return the context, or <tt>null</tt> if this builder has not been started/used before.\n     */\n    public DefaultNamespaceContext getNamespaceContext() {\n        return namespaceContext;\n    }\n\n    public void setNamespaceContext(DefaultNamespaceContext namespaceContext) {\n        this.namespaceContext = namespaceContext;\n    }\n\n    public XPathFunctionResolver getFunctionResolver() {\n        return functionResolver;\n    }\n\n    public void setFunctionResolver(XPathFunctionResolver functionResolver) {\n        this.functionResolver = functionResolver;\n    }\n\n    public void setNamespaces(Map<String, String> namespaces) {\n        this.namespaces.clear();\n        this.namespaces.putAll(namespaces);\n    }\n\n    /**\n     * Gets the {@link XPathFunction} for getting the input message body.\n     * <p/>\n     * A default function will be assigned (if no custom assigned) when either starting this builder\n     * or on first evaluation.\n     *\n     * @return the function, or <tt>null</tt> if this builder has not been started/used before.\n     */\n    public XPathFunction getBodyFunction() {\n        return bodyFunction;\n    }\n\n    private XPathFunction createBodyFunction() {\n        return new XPathFunction() {\n            @SuppressWarnings(\"rawtypes\")\n            public Object evaluate(List list) throws XPathFunctionException {\n                return exchange.get().getIn().getBody();\n            }\n        };\n    }\n\n    public void setBodyFunction(XPathFunction bodyFunction) {\n        this.bodyFunction = bodyFunction;\n    }\n\n    /**\n     * Gets the {@link XPathFunction} for getting the input message header.\n     * <p/>\n     * A default function will be assigned (if no custom assigned) when either starting this builder\n     * or on first evaluation.\n     *\n     * @return the function, or <tt>null</tt> if this builder has not been started/used before.\n     */\n    public XPathFunction getHeaderFunction() {\n        return headerFunction;\n    }\n\n    private XPathFunction createHeaderFunction() {\n        return new XPathFunction() {\n            @SuppressWarnings(\"rawtypes\")\n            public Object evaluate(List list) throws XPathFunctionException {\n                if (!list.isEmpty()) {\n                    Object value = list.get(0);\n                    if (value != null) {\n                        String text = exchange.get().getContext().getTypeConverter().convertTo(String.class, value);\n                        return exchange.get().getIn().getHeader(text);\n                    }\n                }\n                return null;\n            }\n        };\n    }\n\n    public void setHeaderFunction(XPathFunction headerFunction) {\n        this.headerFunction = headerFunction;\n    }\n\n    /**\n     * Gets the {@link XPathFunction} for getting the output message body.\n     * <p/>\n     * A default function will be assigned (if no custom assigned) when either starting this builder\n     * or on first evaluation.\n     *\n     * @return the function, or <tt>null</tt> if this builder has not been started/used before.\n     */\n    public XPathFunction getOutBodyFunction() {\n        return outBodyFunction;\n    }\n\n    private XPathFunction createOutBodyFunction() {\n        return new XPathFunction() {\n            @SuppressWarnings(\"rawtypes\")\n            public Object evaluate(List list) throws XPathFunctionException {\n                if (exchange.get() != null && exchange.get().hasOut()) {\n                    return exchange.get().getOut().getBody();\n                }\n                return null;\n            }\n        };\n    }\n\n    public void setOutBodyFunction(XPathFunction outBodyFunction) {\n        this.outBodyFunction = outBodyFunction;\n    }\n\n    /**\n     * Gets the {@link XPathFunction} for getting the output message header.\n     * <p/>\n     * A default function will be assigned (if no custom assigned) when either starting this builder\n     * or on first evaluation.\n     *\n     * @return the function, or <tt>null</tt> if this builder has not been started/used before.\n     */\n    public XPathFunction getOutHeaderFunction() {\n        return outHeaderFunction;\n    }\n\n    private XPathFunction createOutHeaderFunction() {\n        return new XPathFunction() {\n            @SuppressWarnings(\"rawtypes\")\n            public Object evaluate(List list) throws XPathFunctionException {\n                if (exchange.get() != null && !list.isEmpty()) {\n                    Object value = list.get(0);\n                    if (value != null) {\n                        String text = exchange.get().getContext().getTypeConverter().convertTo(String.class, value);\n                        return exchange.get().getOut().getHeader(text);\n                    }\n                }\n                return null;\n            }\n        };\n    }\n\n    public void setOutHeaderFunction(XPathFunction outHeaderFunction) {\n        this.outHeaderFunction = outHeaderFunction;\n    }\n\n    /**\n     * Gets the {@link XPathFunction} for getting the exchange properties.\n     * <p/>\n     * A default function will be assigned (if no custom assigned) when either starting this builder\n     * or on first evaluation.\n     *\n     * @return the function, or <tt>null</tt> if this builder has not been started/used before.\n     */\n    public XPathFunction getPropertiesFunction() {\n        return propertiesFunction;\n    }\n\n    private XPathFunction createPropertiesFunction() {\n        return new XPathFunction() {\n            @SuppressWarnings(\"rawtypes\")\n            public Object evaluate(List list) throws XPathFunctionException {\n                if (!list.isEmpty()) {\n                    Object value = list.get(0);\n                    if (value != null) {\n                        String text = exchange.get().getContext().getTypeConverter().convertTo(String.class, value);\n                        try {\n                            // use the property placeholder resolver to lookup the property for us\n                            Object answer = exchange.get().getContext().resolvePropertyPlaceholders(\"{{\" + text + \"}}\");\n                            return answer;\n                        } catch (Exception e) {\n                            throw new XPathFunctionException(e);\n                        }\n                    }\n                }\n                return null;\n            }\n        };\n    }\n\n    public void setPropertiesFunction(XPathFunction propertiesFunction) {\n        this.propertiesFunction = propertiesFunction;\n    }\n\n    /**\n     * Gets the {@link XPathFunction} for executing <a href=\"http://camel.apache.org/simple\">simple</a>\n     * language as xpath function.\n     * <p/>\n     * A default function will be assigned (if no custom assigned) when either starting this builder\n     * or on first evaluation.\n     *\n     * @return the function, or <tt>null</tt> if this builder has not been started/used before.\n     */\n    public XPathFunction getSimpleFunction() {\n        return simpleFunction;\n    }\n\n    private XPathFunction createSimpleFunction() {\n        return new XPathFunction() {\n            @SuppressWarnings(\"rawtypes\")\n            public Object evaluate(List list) throws XPathFunctionException {\n                if (!list.isEmpty()) {\n                    Object value = list.get(0);\n                    if (value != null) {\n                        String text = exchange.get().getContext().getTypeConverter().convertTo(String.class, value);\n                        Language simple = exchange.get().getContext().resolveLanguage(\"simple\");\n                        Expression exp = simple.createExpression(text);\n                        Object answer = exp.evaluate(exchange.get(), Object.class);\n                        return answer;\n                    }\n                }\n                return null;\n            }\n        };\n    }\n\n    public void setSimpleFunction(XPathFunction simpleFunction) {\n        this.simpleFunction = simpleFunction;\n    }\n\n    public Class<?> getResultType() {\n        return resultType;\n    }\n\n    public void setResultType(Class<?> resultType) {\n        this.resultType = resultType;\n        if (Number.class.isAssignableFrom(resultType)) {\n            numberResult();\n        } else if (String.class.isAssignableFrom(resultType)) {\n            stringResult();\n        } else if (Boolean.class.isAssignableFrom(resultType)) {\n            booleanResult();\n        } else if (Node.class.isAssignableFrom(resultType)) {\n            nodeResult();\n        } else if (NodeList.class.isAssignableFrom(resultType)) {\n            nodeSetResult();\n        }\n    }\n\n    public void setLogNamespaces(boolean logNamespaces) {\n        this.logNamespaces = logNamespaces;\n    }\n\n    public boolean isLogNamespaces() {\n        return logNamespaces;\n    }\n\n    public String getObjectModelUri() {\n        return objectModelUri;\n    }\n\n    /**\n     * Enables Saxon on this particular XPath expression, as {@link #saxon()} sets the default static XPathFactory which may have already been initialised\n     * by previous XPath expressions\n     */\n    public void enableSaxon() {\n        this.setObjectModelUri(SAXON_OBJECT_MODEL_URI);\n    }\n\n    public void setObjectModelUri(String objectModelUri) {\n        this.objectModelUri = objectModelUri;\n    }\n\n    // Implementation methods\n    // -------------------------------------------------------------------------\n\n    protected Object evaluate(Exchange exchange) {\n        Object answer = evaluateAs(exchange, resultQName);\n        if (resultType != null) {\n            return ExchangeHelper.convertToType(exchange, resultType, answer);\n        }\n        return answer;\n    }\n\n    /**\n     * Evaluates the expression as the given result type\n     */\n    protected Object evaluateAs(Exchange exchange, QName resultQName) {\n        // pool a pre compiled expression from pool\n        XPathExpression xpathExpression = pool.poll();\n        if (xpathExpression == null) {\n            LOG.trace(\"Creating new XPathExpression as none was available from pool\");\n            // no avail in pool then create one\n            try {\n                xpathExpression = createXPathExpression();\n            } catch (XPathExpressionException e) {\n                throw new InvalidXPathExpression(getText(), e);\n            } catch (Exception e) {\n                throw new RuntimeExpressionException(\"Cannot create xpath expression\", e);\n            }\n        } else {\n            LOG.trace(\"Acquired XPathExpression from pool\");\n        }\n        try {\n            if (logNamespaces && LOG.isInfoEnabled()) {\n                logNamespaces(exchange);\n            }\n            return doInEvaluateAs(xpathExpression, exchange, resultQName);\n        } finally {\n            // release it back to the pool\n            pool.add(xpathExpression);\n            LOG.trace(\"Released XPathExpression back to pool\");\n        }\n    }\n\n    private void logNamespaces(Exchange exchange) {\n        InputStream is = null;\n        NodeList answer = null;\n        XPathExpression xpathExpression = null;\n\n        try {\n            xpathExpression = poolLogNamespaces.poll();\n            if (xpathExpression == null) {\n                xpathExpression = createTraceNamespaceExpression();\n            }\n\n            // prepare the input\n            Object document;\n            if (isInputStreamNeeded(exchange)) {\n                is = exchange.getIn().getBody(InputStream.class);\n                document = getDocument(exchange, is);\n            } else {\n                Object body = exchange.getIn().getBody();\n                document = getDocument(exchange, body);\n            }\n            // fetch all namespaces\n            if (document instanceof InputSource) {\n                InputSource inputSource = (InputSource) document;\n                answer = (NodeList) xpathExpression.evaluate(inputSource, XPathConstants.NODESET);\n            } else if (document instanceof DOMSource) {\n                DOMSource source = (DOMSource) document;\n                answer = (NodeList) xpathExpression.evaluate(source.getNode(), XPathConstants.NODESET);\n            } else {\n                answer = (NodeList) xpathExpression.evaluate(document, XPathConstants.NODESET);\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Unable to trace discovered namespaces in XPath expression\", e);\n        } finally {\n            // IOHelper can handle if is is null\n            IOHelper.close(is);\n            poolLogNamespaces.add(xpathExpression);\n        }\n\n        if (answer != null) {\n            logDiscoveredNamespaces(answer);\n        }\n    }\n\n    private void logDiscoveredNamespaces(NodeList namespaces) {\n        Map<String, HashSet<String>> map = new LinkedHashMap<String, HashSet<String>>();\n        for (int i = 0; i < namespaces.getLength(); i++) {\n            Node n = namespaces.item(i);\n            if (n.getNodeName().equals(\"xmlns:xml\")) {\n                // skip the implicit XML namespace as it provides no value\n                continue;\n            }\n\n            String prefix = namespaces.item(i).getNodeName();\n            if (prefix.equals(\"xmlns\")) {\n                prefix = \"DEFAULT\";\n            }\n\n            // add to map\n            if (!map.containsKey(prefix)) {\n                map.put(prefix, new HashSet<String>());\n            }\n            map.get(prefix).add(namespaces.item(i).getNodeValue());\n        }\n\n        LOG.info(\"Namespaces discovered in message: {}.\", map);\n    }\n\n    protected Object doInEvaluateAs(XPathExpression xpathExpression, Exchange exchange, QName resultQName) {\n        LOG.trace(\"Evaluating exchange: {} as: {}\", exchange, resultQName);\n\n        Object answer;\n\n        // set exchange and variable resolver as thread locals for concurrency\n        this.exchange.set(exchange);\n\n        // the underlying input stream, which we need to close to avoid locking files or other resources\n        InputStream is = null;\n        try {\n            Object document;\n\n            // Check if we need to apply the XPath expression to a header\n            if (ObjectHelper.isNotEmpty(getHeaderName())) {\n                String headerName = getHeaderName();\n                // only convert to input stream if really needed\n                if (isInputStreamNeeded(exchange, headerName)) {\n                    is = exchange.getIn().getHeader(headerName, InputStream.class);\n                    document = getDocument(exchange, is);\n                } else {\n                    Object headerObject = exchange.getIn().getHeader(getHeaderName());\n                    document = getDocument(exchange, headerObject);\n                }\n            } else {\n                // only convert to input stream if really needed\n                if (isInputStreamNeeded(exchange)) {\n                    is = exchange.getIn().getBody(InputStream.class);\n                    document = getDocument(exchange, is);\n                } else {\n                    Object body = exchange.getIn().getBody();\n                    document = getDocument(exchange, body);\n                }\n            }\n\n            if (resultQName != null) {\n                if (document instanceof InputSource) {\n                    InputSource inputSource = (InputSource) document;\n                    answer = xpathExpression.evaluate(inputSource, resultQName);\n                } else if (document instanceof DOMSource) {\n                    DOMSource source = (DOMSource) document;\n                    answer = xpathExpression.evaluate(source.getNode(), resultQName);\n                } else {\n                    answer = xpathExpression.evaluate(document, resultQName);\n                }\n            } else {\n                if (document instanceof InputSource) {\n                    InputSource inputSource = (InputSource) document;\n                    answer = xpathExpression.evaluate(inputSource);\n                } else if (document instanceof DOMSource) {\n                    DOMSource source = (DOMSource) document;\n                    answer = xpathExpression.evaluate(source.getNode());\n                } else {\n                    answer = xpathExpression.evaluate(document);\n                }\n            }\n        } catch (XPathExpressionException e) {\n            String message = getText();\n            if (ObjectHelper.isNotEmpty(getHeaderName())) {\n                message = message + \" with headerName \" + getHeaderName();\n            }\n            throw new InvalidXPathExpression(message, e);\n        } finally {\n            // IOHelper can handle if is is null\n            IOHelper.close(is);\n        }\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Done evaluating exchange: {} as: {} with result: {}\", new Object[]{exchange, resultQName, answer});\n        }\n        return answer;\n    }\n\n    /**\n     * Creates a new xpath expression as there we no available in the pool.\n     * <p/>\n     * This implementation must be synchronized to ensure thread safety, as this XPathBuilder instance may not have been\n     * started prior to being used.\n     */\n    protected synchronized XPathExpression createXPathExpression() throws XPathExpressionException, XPathFactoryConfigurationException {\n        // ensure we are started\n        try {\n            start();\n        } catch (Exception e) {\n            throw new RuntimeExpressionException(\"Error starting XPathBuilder\", e);\n        }\n\n        // XPathFactory is not thread safe\n        XPath xPath = getXPathFactory().newXPath();\n\n        if (!logNamespaces && LOG.isTraceEnabled()) {\n            LOG.trace(\"Creating new XPath expression in pool. Namespaces on XPath expression: {}\", getNamespaceContext().toString());\n        } else if (logNamespaces && LOG.isInfoEnabled()) {\n            LOG.info(\"Creating new XPath expression in pool. Namespaces on XPath expression: {}\", getNamespaceContext().toString());\n        }\n        xPath.setNamespaceContext(getNamespaceContext());\n        xPath.setXPathVariableResolver(getVariableResolver());\n\n        XPathFunctionResolver parentResolver = getFunctionResolver();\n        if (parentResolver == null) {\n            parentResolver = xPath.getXPathFunctionResolver();\n        }\n        xPath.setXPathFunctionResolver(createDefaultFunctionResolver(parentResolver));\n        return xPath.compile(text);\n    }\n\n    protected synchronized XPathExpression createTraceNamespaceExpression() throws XPathFactoryConfigurationException, XPathExpressionException {\n        // XPathFactory is not thread safe\n        XPath xPath = getXPathFactory().newXPath();\n        return xPath.compile(OBTAIN_ALL_NS_XPATH);\n    }\n\n    protected DefaultNamespaceContext createNamespaceContext(XPathFactory factory) {\n        DefaultNamespaceContext context = new DefaultNamespaceContext(factory);\n        populateDefaultNamespaces(context);\n        return context;\n    }\n\n    /**\n     * Populate a number of standard prefixes if they are not already there\n     */\n    protected void populateDefaultNamespaces(DefaultNamespaceContext context) {\n        setNamespaceIfNotPresent(context, \"in\", IN_NAMESPACE);\n        setNamespaceIfNotPresent(context, \"out\", OUT_NAMESPACE);\n        setNamespaceIfNotPresent(context, \"env\", Namespaces.ENVIRONMENT_VARIABLES);\n        setNamespaceIfNotPresent(context, \"system\", Namespaces.SYSTEM_PROPERTIES_NAMESPACE);\n        setNamespaceIfNotPresent(context, \"function\", Namespaces.FUNCTION_NAMESPACE);\n    }\n\n    protected void setNamespaceIfNotPresent(DefaultNamespaceContext context, String prefix, String uri) {\n        if (context != null) {\n            String current = context.getNamespaceURI(prefix);\n            if (current == null) {\n                context.add(prefix, uri);\n            }\n        }\n    }\n\n    protected XPathFunctionResolver createDefaultFunctionResolver(final XPathFunctionResolver parent) {\n        return new XPathFunctionResolver() {\n            public XPathFunction resolveFunction(QName qName, int argumentCount) {\n                XPathFunction answer = null;\n                if (parent != null) {\n                    answer = parent.resolveFunction(qName, argumentCount);\n                }\n                if (answer == null) {\n                    if (isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), IN_NAMESPACE)\n                            || isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), DEFAULT_NAMESPACE)) {\n                        String localPart = qName.getLocalPart();\n                        if (localPart.equals(\"body\") && argumentCount == 0) {\n                            return getBodyFunction();\n                        }\n                        if (localPart.equals(\"header\") && argumentCount == 1) {\n                            return getHeaderFunction();\n                        }\n                    }\n                    if (isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), OUT_NAMESPACE)) {\n                        String localPart = qName.getLocalPart();\n                        if (localPart.equals(\"body\") && argumentCount == 0) {\n                            return getOutBodyFunction();\n                        }\n                        if (localPart.equals(\"header\") && argumentCount == 1) {\n                            return getOutHeaderFunction();\n                        }\n                    }\n                    if (isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), FUNCTION_NAMESPACE)) {\n                        String localPart = qName.getLocalPart();\n                        if (localPart.equals(\"properties\") && argumentCount == 1) {\n                            return getPropertiesFunction();\n                        }\n                        if (localPart.equals(\"simple\") && argumentCount == 1) {\n                            return getSimpleFunction();\n                        }\n                    }\n                }\n                return answer;\n            }\n        };\n    }\n\n    /**\n     * Checks whether we need an {@link InputStream} to access the message body.\n     * <p/>\n     * Depending on the content in the message body, we may not need to convert\n     * to {@link InputStream}.\n     *\n     * @param exchange the current exchange\n     * @return <tt>true</tt> to convert to {@link InputStream} beforehand converting afterwards.\n     */\n    protected boolean isInputStreamNeeded(Exchange exchange) {\n        Object body = exchange.getIn().getBody();\n        return isInputStreamNeededForObject(exchange, body);\n    }\n\n    /**\n     * Checks whether we need an {@link InputStream} to access the message header.\n     * <p/>\n     * Depending on the content in the message header, we may not need to convert\n     * to {@link InputStream}.\n     *\n     * @param exchange the current exchange\n     * @return <tt>true</tt> to convert to {@link InputStream} beforehand converting afterwards.\n     */\n    protected boolean isInputStreamNeeded(Exchange exchange, String headerName) {\n        Object header = exchange.getIn().getHeader(headerName);\n        return isInputStreamNeededForObject(exchange, header);\n    }\n\n    /**\n     * Checks whether we need an {@link InputStream} to access this object\n     * <p/>\n     * Depending on the content in the object, we may not need to convert\n     * to {@link InputStream}.\n     *\n     * @param exchange the current exchange\n     * @return <tt>true</tt> to convert to {@link InputStream} beforehand converting afterwards.\n     */\n    protected boolean isInputStreamNeededForObject(Exchange exchange, Object obj) {\n        if (obj == null) {\n            return false;\n        }\n\n        if (obj instanceof WrappedFile) {\n            obj = ((WrappedFile<?>) obj).getFile();\n        }\n        if (obj instanceof File) {\n            // input stream is needed for File to avoid locking the file in case of errors etc\n            return true;\n        }\n\n        // input stream is not needed otherwise\n        return false;\n    }\n\n    /**\n     * Strategy method to extract the document from the exchange.\n     */\n    protected Object getDocument(Exchange exchange, Object body) {\n        try {\n            return doGetDocument(exchange, body);\n        } catch (Exception e) {\n            throw ObjectHelper.wrapRuntimeCamelException(e);\n        } finally {\n            // call the reset if the in message body is StreamCache\n            MessageHelper.resetStreamCache(exchange.getIn());\n        }\n    }\n\n    protected Object doGetDocument(Exchange exchange, Object body) throws Exception {\n        if (body == null) {\n            return null;\n        }\n\n        Object answer = null;\n\n        Class<?> type = getDocumentType();\n        Exception cause = null;\n        if (type != null) {\n            // try to get the body as the desired type\n            try {\n                answer = exchange.getContext().getTypeConverter().convertTo(type, exchange, body);\n            } catch (Exception e) {\n                // we want to store the caused exception, if we could not convert\n                cause = e;\n            }\n        }\n\n        // okay we can try to remedy the failed conversion by some special types\n        if (answer == null) {\n            // let's try coercing some common types into something JAXP work with the best for special types\n            if (body instanceof WrappedFile) {\n                // special for files so we can work with them out of the box\n                InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, body);\n                answer = new InputSource(is);\n            } else if (body instanceof BeanInvocation) {\n                // if its a null bean invocation then handle that specially\n                BeanInvocation bi = exchange.getContext().getTypeConverter().convertTo(BeanInvocation.class, exchange, body);\n                if (bi.getArgs() != null && bi.getArgs().length == 1 && bi.getArgs()[0] == null) {\n                    // its a null argument from the bean invocation so use null as answer\n                    answer = null;\n                }\n            } else if (body instanceof String) {\n                answer = new InputSource(new StringReader((String) body));\n            }\n        }\n\n        if (type == null && answer == null) {\n            // fallback to get the body as is\n            answer = body;\n        } else if (answer == null) {\n            // there was a type, and we could not convert to it, then fail\n            if (cause != null) {\n                throw cause;\n            } else {\n                throw new NoTypeConversionAvailableException(body, type);\n            }\n        }\n\n        return answer;\n    }\n\n    private MessageVariableResolver getVariableResolver() {\n        return variableResolver;\n    }\n\n    @Override\n    public void doStart() throws Exception {\n        if (xpathFactory == null) {\n            xpathFactory = createXPathFactory();\n        }\n        if (namespaceContext == null) {\n            namespaceContext = createNamespaceContext(xpathFactory);\n        }\n        for (Map.Entry<String, String> entry : namespaces.entrySet()) {\n            namespaceContext.add(entry.getKey(), entry.getValue());\n        }\n\n        // create default functions if no custom assigned\n        if (bodyFunction == null) {\n            bodyFunction = createBodyFunction();\n        }\n        if (headerFunction == null) {\n            headerFunction = createHeaderFunction();\n        }\n        if (outBodyFunction == null) {\n            outBodyFunction = createOutBodyFunction();\n        }\n        if (outHeaderFunction == null) {\n            outHeaderFunction = createOutHeaderFunction();\n        }\n        if (propertiesFunction == null) {\n            propertiesFunction = createPropertiesFunction();\n        }\n        if (simpleFunction == null) {\n            simpleFunction = createSimpleFunction();\n        }\n    }\n\n    @Override\n    public void doStop() throws Exception {\n        pool.clear();\n        poolLogNamespaces.clear();\n    }\n\n    protected synchronized XPathFactory createXPathFactory() throws XPathFactoryConfigurationException {\n        if (objectModelUri != null) {\n            xpathFactory = XPathFactory.newInstance(objectModelUri);\n            LOG.info(\"Using objectModelUri \" + objectModelUri + \" when created XPathFactory {}\", xpathFactory);\n            return xpathFactory;\n        }\n\n        if (defaultXPathFactory == null) {\n            defaultXPathFactory = createDefaultXPathFactory();\n        }\n        return defaultXPathFactory;\n    }\n\n    protected static XPathFactory createDefaultXPathFactory() throws XPathFactoryConfigurationException {\n        XPathFactory factory = null;\n\n        // read system property and see if there is a factory set\n        Properties properties = System.getProperties();\n        for (Map.Entry<Object, Object> prop : properties.entrySet()) {\n            String key = (String) prop.getKey();\n            if (key.startsWith(XPathFactory.DEFAULT_PROPERTY_NAME)) {\n                String uri = ObjectHelper.after(key, \":\");\n                if (uri != null) {\n                    factory = XPathFactory.newInstance(uri);\n                    LOG.info(\"Using system property {} with value {} when created default XPathFactory {}\", new Object[]{key, uri, factory});\n                }\n            }\n        }\n\n        if (factory == null) {\n            factory = XPathFactory.newInstance();\n            LOG.info(\"Created default XPathFactory {}\", factory);\n        }\n\n        return factory;\n    }\n\n}\n",
        "human_patch_code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.builder.xml;\n\nimport java.io.File;\nimport java.io.InputStream;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport javax.xml.namespace.QName;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathFactoryConfigurationException;\nimport javax.xml.xpath.XPathFunction;\nimport javax.xml.xpath.XPathFunctionException;\nimport javax.xml.xpath.XPathFunctionResolver;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport org.apache.camel.CamelContext;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Expression;\nimport org.apache.camel.NoTypeConversionAvailableException;\nimport org.apache.camel.Predicate;\nimport org.apache.camel.RuntimeExpressionException;\nimport org.apache.camel.WrappedFile;\nimport org.apache.camel.impl.DefaultExchange;\nimport org.apache.camel.spi.Language;\nimport org.apache.camel.spi.NamespaceAware;\nimport org.apache.camel.support.ServiceSupport;\nimport org.apache.camel.util.ExchangeHelper;\nimport org.apache.camel.util.IOHelper;\nimport org.apache.camel.util.MessageHelper;\nimport org.apache.camel.util.ObjectHelper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static org.apache.camel.builder.xml.Namespaces.DEFAULT_NAMESPACE;\nimport static org.apache.camel.builder.xml.Namespaces.FUNCTION_NAMESPACE;\nimport static org.apache.camel.builder.xml.Namespaces.IN_NAMESPACE;\nimport static org.apache.camel.builder.xml.Namespaces.OUT_NAMESPACE;\nimport static org.apache.camel.builder.xml.Namespaces.isMatchingNamespaceOrEmptyNamespace;\n\n/**\n * Creates an XPath expression builder which creates a nodeset result by default.\n * If you want to evaluate a String expression then call {@link #stringResult()}\n * <p/>\n * An XPath object is not thread-safe and not reentrant. In other words, it is the application's responsibility to make\n * sure that one XPath object is not used from more than one thread at any given time, and while the evaluate method\n * is invoked, applications may not recursively call the evaluate method.\n * <p/>\n * This implementation is thread safe by using thread locals and pooling to allow concurrency.\n * <p/>\n * <b>Important:</b> After configuring the {@link XPathBuilder} its advised to invoke {@link #start()}\n * to prepare the builder before using; though the builder will auto-start on first use.\n *\n * @see XPathConstants#NODESET\n */\npublic class XPathBuilder extends ServiceSupport implements Expression, Predicate, NamespaceAware {\n    private static final Logger LOG = LoggerFactory.getLogger(XPathBuilder.class);\n    private static final String SAXON_OBJECT_MODEL_URI = \"http://saxon.sf.net/jaxp/xpath/om\";\n    private static final String OBTAIN_ALL_NS_XPATH = \"//*/namespace::*\";\n\n    private static volatile XPathFactory defaultXPathFactory;\n\n    private final Queue<XPathExpression> pool = new ConcurrentLinkedQueue<XPathExpression>();\n    private final Queue<XPathExpression> poolLogNamespaces = new ConcurrentLinkedQueue<XPathExpression>();\n    private final String text;\n    private final ThreadLocal<Exchange> exchange = new ThreadLocal<Exchange>();\n    private final MessageVariableResolver variableResolver = new MessageVariableResolver(exchange);\n    private final Map<String, String> namespaces = new ConcurrentHashMap<String, String>();\n    private volatile XPathFactory xpathFactory;\n    private volatile Class<?> documentType = Document.class;\n    // For some reason the default expression of \"a/b\" on a document such as\n    // <a><b>1</b><b>2</b></a>\n    // will evaluate as just \"1\" by default which is bizarre. So by default\n    // let's assume XPath expressions result in nodesets.\n    private volatile Class<?> resultType;\n    private volatile QName resultQName = XPathConstants.NODESET;\n    private volatile String objectModelUri;\n    private volatile DefaultNamespaceContext namespaceContext;\n    private volatile boolean logNamespaces;\n    private volatile XPathFunctionResolver functionResolver;\n    private volatile XPathFunction bodyFunction;\n    private volatile XPathFunction headerFunction;\n    private volatile XPathFunction outBodyFunction;\n    private volatile XPathFunction outHeaderFunction;\n    private volatile XPathFunction propertiesFunction;\n    private volatile XPathFunction simpleFunction;\n    /**\n     * The name of the header we want to apply the XPath expression to, which when set will cause\n     * the xpath to be evaluated on the required header, otherwise it will be applied to the body\n     */\n    private volatile String headerName;\n\n    /**\n     * @param text The XPath expression\n     */\n    public XPathBuilder(String text) {\n        this.text = text;\n    }\n\n    /**\n     * @param text The XPath expression\n     * @return A new XPathBuilder object\n     */\n    public static XPathBuilder xpath(String text) {\n        return new XPathBuilder(text);\n    }\n\n    /**\n     * @param text       The XPath expression\n     * @param resultType The result type that the XPath expression will return.\n     * @return A new XPathBuilder object\n     */\n    public static XPathBuilder xpath(String text, Class<?> resultType) {\n        XPathBuilder builder = new XPathBuilder(text);\n        builder.setResultType(resultType);\n        return builder;\n    }\n\n    @Override\n    public String toString() {\n        return \"XPath: \" + text;\n    }\n\n    public boolean matches(Exchange exchange) {\n        try {\n            Object booleanResult = evaluateAs(exchange, XPathConstants.BOOLEAN);\n            return exchange.getContext().getTypeConverter().convertTo(Boolean.class, booleanResult);\n        } finally {\n            // remove the thread local after usage\n            this.exchange.remove();\n        }\n    }\n\n    public <T> T evaluate(Exchange exchange, Class<T> type) {\n        try {\n            Object result = evaluate(exchange);\n            return exchange.getContext().getTypeConverter().convertTo(type, exchange, result);\n        } finally {\n            // remove the thread local after usage\n            this.exchange.remove();\n        }\n    }\n\n    /**\n     * Matches the given xpath using the provided body.\n     *\n     * @param context the camel context\n     * @param body    the body\n     * @return <tt>true</tt> if matches, <tt>false</tt> otherwise\n     */\n    public boolean matches(CamelContext context, Object body) {\n        ObjectHelper.notNull(context, \"CamelContext\");\n\n        // create a dummy Exchange to use during matching\n        Exchange dummy = new DefaultExchange(context);\n        dummy.getIn().setBody(body);\n\n        try {\n            return matches(dummy);\n        } finally {\n            // remove the thread local after usage\n            exchange.remove();\n        }\n    }\n\n    /**\n     * Evaluates the given xpath using the provided body.\n     *\n     * @param context the camel context\n     * @param body    the body\n     * @param type    the type to return\n     * @return result of the evaluation\n     */\n    public <T> T evaluate(CamelContext context, Object body, Class<T> type) {\n        ObjectHelper.notNull(context, \"CamelContext\");\n\n        // create a dummy Exchange to use during evaluation\n        Exchange dummy = new DefaultExchange(context);\n        dummy.getIn().setBody(body);\n\n        try {\n            return evaluate(dummy, type);\n        } finally {\n            // remove the thread local after usage\n            exchange.remove();\n        }\n    }\n\n    /**\n     * Evaluates the given xpath using the provided body as a String return type.\n     *\n     * @param context the camel context\n     * @param body    the body\n     * @return result of the evaluation\n     */\n    public String evaluate(CamelContext context, Object body) {\n        ObjectHelper.notNull(context, \"CamelContext\");\n\n        // create a dummy Exchange to use during evaluation\n        Exchange dummy = new DefaultExchange(context);\n        dummy.getIn().setBody(body);\n\n        setResultQName(XPathConstants.STRING);\n        try {\n            return evaluate(dummy, String.class);\n        } finally {\n            // remove the thread local after usage\n            this.exchange.remove();\n        }\n    }\n\n    // Builder methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Sets the expression result type to {@link XPathConstants#BOOLEAN}\n     *\n     * @return the current builder\n     */\n    public XPathBuilder booleanResult() {\n        resultQName = XPathConstants.BOOLEAN;\n        return this;\n    }\n\n    /**\n     * Sets the expression result type to {@link XPathConstants#NODE}\n     *\n     * @return the current builder\n     */\n    public XPathBuilder nodeResult() {\n        resultQName = XPathConstants.NODE;\n        return this;\n    }\n\n    /**\n     * Sets the expression result type to {@link XPathConstants#NODESET}\n     *\n     * @return the current builder\n     */\n    public XPathBuilder nodeSetResult() {\n        resultQName = XPathConstants.NODESET;\n        return this;\n    }\n\n    /**\n     * Sets the expression result type to {@link XPathConstants#NUMBER}\n     *\n     * @return the current builder\n     */\n    public XPathBuilder numberResult() {\n        resultQName = XPathConstants.NUMBER;\n        return this;\n    }\n\n    /**\n     * Sets the expression result type to {@link XPathConstants#STRING}\n     *\n     * @return the current builder\n     */\n    public XPathBuilder stringResult() {\n        resultQName = XPathConstants.STRING;\n        return this;\n    }\n\n    /**\n     * Sets the expression result type to the given {@code resultType}\n     *\n     * @return the current builder\n     */\n    public XPathBuilder resultType(Class<?> resultType) {\n        setResultType(resultType);\n        return this;\n    }\n\n    /**\n     * Sets the object model URI to use\n     *\n     * @return the current builder\n     */\n    public XPathBuilder objectModel(String uri) {\n        // Careful! Setting the Object Model URI this way will set the *Default* XPath Factory, which since is a static field,\n        // will set the XPath Factory system-wide. Decide what to do, as changing this behaviour can break compatibility. Provided the setObjectModel which changes\n        // this instance's XPath Factory rather than the static field\n        this.objectModelUri = uri;\n        return this;\n    }\n\n    /**\n     * Configures to use Saxon as the XPathFactory which allows you to use XPath 2.0 functions\n     * which may not be part of the build in JDK XPath parser.\n     *\n     * @return the current builder\n     */\n    public XPathBuilder saxon() {\n        this.objectModelUri = SAXON_OBJECT_MODEL_URI;\n        return this;\n    }\n\n    /**\n     * Sets the {@link XPathFunctionResolver} instance to use on these XPath\n     * expressions\n     *\n     * @return the current builder\n     */\n    public XPathBuilder functionResolver(XPathFunctionResolver functionResolver) {\n        this.functionResolver = functionResolver;\n        return this;\n    }\n\n    /**\n     * Registers the namespace prefix and URI with the builder so that the\n     * prefix can be used in XPath expressions\n     *\n     * @param prefix is the namespace prefix that can be used in the XPath\n     *               expressions\n     * @param uri    is the namespace URI to which the prefix refers\n     * @return the current builder\n     */\n    public XPathBuilder namespace(String prefix, String uri) {\n        namespaces.put(prefix, uri);\n        return this;\n    }\n\n    /**\n     * Registers namespaces with the builder so that the registered\n     * prefixes can be used in XPath expressions\n     *\n     * @param namespaces is namespaces object that should be used in the\n     *                   XPath expression\n     * @return the current builder\n     */\n    public XPathBuilder namespaces(Namespaces namespaces) {\n        namespaces.configure(this);\n        return this;\n    }\n\n    /**\n     * Registers a variable (in the global namespace) which can be referred to\n     * from XPath expressions\n     *\n     * @param name  name of variable\n     * @param value value of variable\n     * @return the current builder\n     */\n    public XPathBuilder variable(String name, Object value) {\n        getVariableResolver().addVariable(name, value);\n        return this;\n    }\n\n    /**\n     * Configures the document type to use.\n     * <p/>\n     * The document type controls which kind of Class Camel should convert the payload\n     * to before doing the xpath evaluation.\n     * <p/>\n     * For example you can set it to {@link InputSource} to use SAX streams.\n     * By default Camel uses {@link Document} as the type.\n     *\n     * @param documentType the document type\n     * @return the current builder\n     */\n    public XPathBuilder documentType(Class<?> documentType) {\n        setDocumentType(documentType);\n        return this;\n    }\n\n    /**\n     * Configures to use the provided XPath factory.\n     * <p/>\n     * Can be used to use Saxon instead of the build in factory from the JDK.\n     *\n     * @param xpathFactory the xpath factory to use\n     * @return the current builder.\n     */\n    public XPathBuilder factory(XPathFactory xpathFactory) {\n        setXPathFactory(xpathFactory);\n        return this;\n    }\n\n    /**\n     * Activates trace logging of all discovered namespaces in the message - to simplify debugging namespace-related issues\n     * <p/>\n     * Namespaces are printed in Hashmap style <code>{xmlns:prefix=[namespaceURI], xmlns:prefix=[namespaceURI]}</code>.\n     * <p/>\n     * The implicit XML namespace is omitted (http://www.w3.org/XML/1998/namespace).\n     * XML allows for namespace prefixes to be redefined/overridden due to hierarchical scoping, i.e. prefix abc can be mapped to http://abc.com,\n     * and deeper in the document it can be mapped to http://def.com. When two prefixes are detected which are equal but are mapped to different\n     * namespace URIs, Camel will show all namespaces URIs it is mapped to in an array-style.\n     * <p/>\n     * This feature is disabled by default.\n     *\n     * @return the current builder.\n     */\n    public XPathBuilder logNamespaces() {\n        setLogNamespaces(true);\n        return this;\n    }\n\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets the xpath factory, can be <tt>null</tt> if no custom factory has been assigned.\n     * <p/>\n     * A default factory will be assigned (if no custom assigned) when either starting this builder\n     * or on first evaluation.\n     *\n     * @return the factory, or <tt>null</tt> if this builder has not been started/used before.\n     */\n    public XPathFactory getXPathFactory() {\n        return xpathFactory;\n    }\n\n    public void setXPathFactory(XPathFactory xpathFactory) {\n        this.xpathFactory = xpathFactory;\n    }\n\n    public Class<?> getDocumentType() {\n        return documentType;\n    }\n\n    public void setDocumentType(Class<?> documentType) {\n        this.documentType = documentType;\n    }\n\n    public String getText() {\n        return text;\n    }\n\n    public QName getResultQName() {\n        return resultQName;\n    }\n\n    public void setResultQName(QName resultQName) {\n        this.resultQName = resultQName;\n    }\n\n    public String getHeaderName() {\n        return headerName;\n    }\n\n    public void setHeaderName(String headerName) {\n        this.headerName = headerName;\n    }\n\n    /**\n     * Gets the namespace context, can be <tt>null</tt> if no custom context has been assigned.\n     * <p/>\n     * A default context will be assigned (if no custom assigned) when either starting this builder\n     * or on first evaluation.\n     *\n     * @return the context, or <tt>null</tt> if this builder has not been started/used before.\n     */\n    public DefaultNamespaceContext getNamespaceContext() {\n        return namespaceContext;\n    }\n\n    public void setNamespaceContext(DefaultNamespaceContext namespaceContext) {\n        this.namespaceContext = namespaceContext;\n    }\n\n    public XPathFunctionResolver getFunctionResolver() {\n        return functionResolver;\n    }\n\n    public void setFunctionResolver(XPathFunctionResolver functionResolver) {\n        this.functionResolver = functionResolver;\n    }\n\n    public void setNamespaces(Map<String, String> namespaces) {\n        this.namespaces.clear();\n        this.namespaces.putAll(namespaces);\n    }\n\n    /**\n     * Gets the {@link XPathFunction} for getting the input message body.\n     * <p/>\n     * A default function will be assigned (if no custom assigned) when either starting this builder\n     * or on first evaluation.\n     *\n     * @return the function, or <tt>null</tt> if this builder has not been started/used before.\n     */\n    public XPathFunction getBodyFunction() {\n        return bodyFunction;\n    }\n\n    private XPathFunction createBodyFunction() {\n        return new XPathFunction() {\n            @SuppressWarnings(\"rawtypes\")\n            public Object evaluate(List list) throws XPathFunctionException {\n                return exchange.get().getIn().getBody();\n            }\n        };\n    }\n\n    public void setBodyFunction(XPathFunction bodyFunction) {\n        this.bodyFunction = bodyFunction;\n    }\n\n    /**\n     * Gets the {@link XPathFunction} for getting the input message header.\n     * <p/>\n     * A default function will be assigned (if no custom assigned) when either starting this builder\n     * or on first evaluation.\n     *\n     * @return the function, or <tt>null</tt> if this builder has not been started/used before.\n     */\n    public XPathFunction getHeaderFunction() {\n        return headerFunction;\n    }\n\n    private XPathFunction createHeaderFunction() {\n        return new XPathFunction() {\n            @SuppressWarnings(\"rawtypes\")\n            public Object evaluate(List list) throws XPathFunctionException {\n                if (!list.isEmpty()) {\n                    Object value = list.get(0);\n                    if (value != null) {\n                        String text = exchange.get().getContext().getTypeConverter().convertTo(String.class, value);\n                        return exchange.get().getIn().getHeader(text);\n                    }\n                }\n                return null;\n            }\n        };\n    }\n\n    public void setHeaderFunction(XPathFunction headerFunction) {\n        this.headerFunction = headerFunction;\n    }\n\n    /**\n     * Gets the {@link XPathFunction} for getting the output message body.\n     * <p/>\n     * A default function will be assigned (if no custom assigned) when either starting this builder\n     * or on first evaluation.\n     *\n     * @return the function, or <tt>null</tt> if this builder has not been started/used before.\n     */\n    public XPathFunction getOutBodyFunction() {\n        return outBodyFunction;\n    }\n\n    private XPathFunction createOutBodyFunction() {\n        return new XPathFunction() {\n            @SuppressWarnings(\"rawtypes\")\n            public Object evaluate(List list) throws XPathFunctionException {\n                if (exchange.get() != null && exchange.get().hasOut()) {\n                    return exchange.get().getOut().getBody();\n                }\n                return null;\n            }\n        };\n    }\n\n    public void setOutBodyFunction(XPathFunction outBodyFunction) {\n        this.outBodyFunction = outBodyFunction;\n    }\n\n    /**\n     * Gets the {@link XPathFunction} for getting the output message header.\n     * <p/>\n     * A default function will be assigned (if no custom assigned) when either starting this builder\n     * or on first evaluation.\n     *\n     * @return the function, or <tt>null</tt> if this builder has not been started/used before.\n     */\n    public XPathFunction getOutHeaderFunction() {\n        return outHeaderFunction;\n    }\n\n    private XPathFunction createOutHeaderFunction() {\n        return new XPathFunction() {\n            @SuppressWarnings(\"rawtypes\")\n            public Object evaluate(List list) throws XPathFunctionException {\n                if (exchange.get() != null && !list.isEmpty()) {\n                    Object value = list.get(0);\n                    if (value != null) {\n                        String text = exchange.get().getContext().getTypeConverter().convertTo(String.class, value);\n                        return exchange.get().getOut().getHeader(text);\n                    }\n                }\n                return null;\n            }\n        };\n    }\n\n    public void setOutHeaderFunction(XPathFunction outHeaderFunction) {\n        this.outHeaderFunction = outHeaderFunction;\n    }\n\n    /**\n     * Gets the {@link XPathFunction} for getting the exchange properties.\n     * <p/>\n     * A default function will be assigned (if no custom assigned) when either starting this builder\n     * or on first evaluation.\n     *\n     * @return the function, or <tt>null</tt> if this builder has not been started/used before.\n     */\n    public XPathFunction getPropertiesFunction() {\n        return propertiesFunction;\n    }\n\n    private XPathFunction createPropertiesFunction() {\n        return new XPathFunction() {\n            @SuppressWarnings(\"rawtypes\")\n            public Object evaluate(List list) throws XPathFunctionException {\n                if (!list.isEmpty()) {\n                    Object value = list.get(0);\n                    if (value != null) {\n                        String text = exchange.get().getContext().getTypeConverter().convertTo(String.class, value);\n                        try {\n                            // use the property placeholder resolver to lookup the property for us\n                            Object answer = exchange.get().getContext().resolvePropertyPlaceholders(\"{{\" + text + \"}}\");\n                            return answer;\n                        } catch (Exception e) {\n                            throw new XPathFunctionException(e);\n                        }\n                    }\n                }\n                return null;\n            }\n        };\n    }\n\n    public void setPropertiesFunction(XPathFunction propertiesFunction) {\n        this.propertiesFunction = propertiesFunction;\n    }\n\n    /**\n     * Gets the {@link XPathFunction} for executing <a href=\"http://camel.apache.org/simple\">simple</a>\n     * language as xpath function.\n     * <p/>\n     * A default function will be assigned (if no custom assigned) when either starting this builder\n     * or on first evaluation.\n     *\n     * @return the function, or <tt>null</tt> if this builder has not been started/used before.\n     */\n    public XPathFunction getSimpleFunction() {\n        return simpleFunction;\n    }\n\n    private XPathFunction createSimpleFunction() {\n        return new XPathFunction() {\n            @SuppressWarnings(\"rawtypes\")\n            public Object evaluate(List list) throws XPathFunctionException {\n                if (!list.isEmpty()) {\n                    Object value = list.get(0);\n                    if (value != null) {\n                        String text = exchange.get().getContext().getTypeConverter().convertTo(String.class, value);\n                        Language simple = exchange.get().getContext().resolveLanguage(\"simple\");\n                        Expression exp = simple.createExpression(text);\n                        Object answer = exp.evaluate(exchange.get(), Object.class);\n                        return answer;\n                    }\n                }\n                return null;\n            }\n        };\n    }\n\n    public void setSimpleFunction(XPathFunction simpleFunction) {\n        this.simpleFunction = simpleFunction;\n    }\n\n    public Class<?> getResultType() {\n        return resultType;\n    }\n\n    public void setResultType(Class<?> resultType) {\n        this.resultType = resultType;\n        if (Number.class.isAssignableFrom(resultType)) {\n            numberResult();\n        } else if (String.class.isAssignableFrom(resultType)) {\n            stringResult();\n        } else if (Boolean.class.isAssignableFrom(resultType)) {\n            booleanResult();\n        } else if (Node.class.isAssignableFrom(resultType)) {\n            nodeResult();\n        } else if (NodeList.class.isAssignableFrom(resultType)) {\n            nodeSetResult();\n        }\n    }\n\n    public void setLogNamespaces(boolean logNamespaces) {\n        this.logNamespaces = logNamespaces;\n    }\n\n    public boolean isLogNamespaces() {\n        return logNamespaces;\n    }\n\n    public String getObjectModelUri() {\n        return objectModelUri;\n    }\n\n    /**\n     * Enables Saxon on this particular XPath expression, as {@link #saxon()} sets the default static XPathFactory which may have already been initialised\n     * by previous XPath expressions\n     */\n    public void enableSaxon() {\n        this.setObjectModelUri(SAXON_OBJECT_MODEL_URI);\n    }\n\n    public void setObjectModelUri(String objectModelUri) {\n        this.objectModelUri = objectModelUri;\n    }\n\n    // Implementation methods\n    // -------------------------------------------------------------------------\n\n    protected Object evaluate(Exchange exchange) {\n        Object answer = evaluateAs(exchange, resultQName);\n        if (resultType != null) {\n            return ExchangeHelper.convertToType(exchange, resultType, answer);\n        }\n        return answer;\n    }\n\n    /**\n     * Evaluates the expression as the given result type\n     */\n    protected Object evaluateAs(Exchange exchange, QName resultQName) {\n        // pool a pre compiled expression from pool\n        XPathExpression xpathExpression = pool.poll();\n        if (xpathExpression == null) {\n            LOG.trace(\"Creating new XPathExpression as none was available from pool\");\n            // no avail in pool then create one\n            try {\n                xpathExpression = createXPathExpression();\n            } catch (XPathExpressionException e) {\n                throw new InvalidXPathExpression(getText(), e);\n            } catch (Exception e) {\n                throw new RuntimeExpressionException(\"Cannot create xpath expression\", e);\n            }\n        } else {\n            LOG.trace(\"Acquired XPathExpression from pool\");\n        }\n        try {\n            if (logNamespaces && LOG.isInfoEnabled()) {\n                logNamespaces(exchange);\n            }\n            return doInEvaluateAs(xpathExpression, exchange, resultQName);\n        } finally {\n            // release it back to the pool\n            pool.add(xpathExpression);\n            LOG.trace(\"Released XPathExpression back to pool\");\n        }\n    }\n\n    private void logNamespaces(Exchange exchange) {\n        InputStream is = null;\n        NodeList answer = null;\n        XPathExpression xpathExpression = null;\n\n        try {\n            xpathExpression = poolLogNamespaces.poll();\n            if (xpathExpression == null) {\n                xpathExpression = createTraceNamespaceExpression();\n            }\n\n            // prepare the input\n            Object document;\n            if (isInputStreamNeeded(exchange)) {\n                is = exchange.getIn().getBody(InputStream.class);\n                document = getDocument(exchange, is);\n            } else {\n                Object body = exchange.getIn().getBody();\n                document = getDocument(exchange, body);\n            }\n            // fetch all namespaces\n            if (document instanceof InputSource) {\n                InputSource inputSource = (InputSource) document;\n                answer = (NodeList) xpathExpression.evaluate(inputSource, XPathConstants.NODESET);\n            } else if (document instanceof DOMSource) {\n                DOMSource source = (DOMSource) document;\n                answer = (NodeList) xpathExpression.evaluate(source.getNode(), XPathConstants.NODESET);\n            } else {\n                answer = (NodeList) xpathExpression.evaluate(document, XPathConstants.NODESET);\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Unable to trace discovered namespaces in XPath expression\", e);\n        } finally {\n            // IOHelper can handle if is is null\n            IOHelper.close(is);\n            poolLogNamespaces.add(xpathExpression);\n        }\n\n        if (answer != null) {\n            logDiscoveredNamespaces(answer);\n        }\n    }\n\n    private void logDiscoveredNamespaces(NodeList namespaces) {\n        Map<String, HashSet<String>> map = new LinkedHashMap<String, HashSet<String>>();\n        for (int i = 0; i < namespaces.getLength(); i++) {\n            Node n = namespaces.item(i);\n            if (n.getNodeName().equals(\"xmlns:xml\")) {\n                // skip the implicit XML namespace as it provides no value\n                continue;\n            }\n\n            String prefix = namespaces.item(i).getNodeName();\n            if (prefix.equals(\"xmlns\")) {\n                prefix = \"DEFAULT\";\n            }\n\n            // add to map\n            if (!map.containsKey(prefix)) {\n                map.put(prefix, new HashSet<String>());\n            }\n            map.get(prefix).add(namespaces.item(i).getNodeValue());\n        }\n\n        LOG.info(\"Namespaces discovered in message: {}.\", map);\n    }\n\n    protected Object doInEvaluateAs(XPathExpression xpathExpression, Exchange exchange, QName resultQName) {\n        LOG.trace(\"Evaluating exchange: {} as: {}\", exchange, resultQName);\n\n        Object answer;\n\n        // set exchange and variable resolver as thread locals for concurrency\n        this.exchange.set(exchange);\n\n        // the underlying input stream, which we need to close to avoid locking files or other resources\n        InputStream is = null;\n        try {\n            Object document;\n\n            // Check if we need to apply the XPath expression to a header\n            if (ObjectHelper.isNotEmpty(getHeaderName())) {\n                String headerName = getHeaderName();\n                // only convert to input stream if really needed\n                if (isInputStreamNeeded(exchange, headerName)) {\n                    is = exchange.getIn().getHeader(headerName, InputStream.class);\n                    document = getDocument(exchange, is);\n                } else {\n                    Object headerObject = exchange.getIn().getHeader(getHeaderName());\n                    document = getDocument(exchange, headerObject);\n                }\n            } else {\n                // only convert to input stream if really needed\n                if (isInputStreamNeeded(exchange)) {\n                    is = exchange.getIn().getBody(InputStream.class);\n                    document = getDocument(exchange, is);\n                } else {\n                    Object body = exchange.getIn().getBody();\n                    document = getDocument(exchange, body);\n                }\n            }\n\n            if (resultQName != null) {\n                if (document instanceof InputSource) {\n                    InputSource inputSource = (InputSource) document;\n                    answer = xpathExpression.evaluate(inputSource, resultQName);\n                } else if (document instanceof DOMSource) {\n                    DOMSource source = (DOMSource) document;\n                    answer = xpathExpression.evaluate(source.getNode(), resultQName);\n                } else {\n                    answer = xpathExpression.evaluate(document, resultQName);\n                }\n            } else {\n                if (document instanceof InputSource) {\n                    InputSource inputSource = (InputSource) document;\n                    answer = xpathExpression.evaluate(inputSource);\n                } else if (document instanceof DOMSource) {\n                    DOMSource source = (DOMSource) document;\n                    answer = xpathExpression.evaluate(source.getNode());\n                } else {\n                    answer = xpathExpression.evaluate(document);\n                }\n            }\n        } catch (XPathExpressionException e) {\n            String message = getText();\n            if (ObjectHelper.isNotEmpty(getHeaderName())) {\n                message = message + \" with headerName \" + getHeaderName();\n            }\n            throw new InvalidXPathExpression(message, e);\n        } finally {\n            // IOHelper can handle if is is null\n            IOHelper.close(is);\n        }\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Done evaluating exchange: {} as: {} with result: {}\", new Object[]{exchange, resultQName, answer});\n        }\n        return answer;\n    }\n\n    /**\n     * Creates a new xpath expression as there we no available in the pool.\n     * <p/>\n     * This implementation must be synchronized to ensure thread safety, as this XPathBuilder instance may not have been\n     * started prior to being used.\n     */\n    protected synchronized XPathExpression createXPathExpression() throws XPathExpressionException, XPathFactoryConfigurationException {\n        // ensure we are started\n        try {\n            start();\n        } catch (Exception e) {\n            throw new RuntimeExpressionException(\"Error starting XPathBuilder\", e);\n        }\n\n        // XPathFactory is not thread safe\n        XPath xPath = getXPathFactory().newXPath();\n\n        if (!logNamespaces && LOG.isTraceEnabled()) {\n            LOG.trace(\"Creating new XPath expression in pool. Namespaces on XPath expression: {}\", getNamespaceContext().toString());\n        } else if (logNamespaces && LOG.isInfoEnabled()) {\n            LOG.info(\"Creating new XPath expression in pool. Namespaces on XPath expression: {}\", getNamespaceContext().toString());\n        }\n        xPath.setNamespaceContext(getNamespaceContext());\n        xPath.setXPathVariableResolver(getVariableResolver());\n\n        XPathFunctionResolver parentResolver = getFunctionResolver();\n        if (parentResolver == null) {\n            parentResolver = xPath.getXPathFunctionResolver();\n        }\n        xPath.setXPathFunctionResolver(createDefaultFunctionResolver(parentResolver));\n        return xPath.compile(text);\n    }\n\n    protected synchronized XPathExpression createTraceNamespaceExpression() throws XPathFactoryConfigurationException, XPathExpressionException {\n        // XPathFactory is not thread safe\n        XPath xPath = getXPathFactory().newXPath();\n        return xPath.compile(OBTAIN_ALL_NS_XPATH);\n    }\n\n    protected DefaultNamespaceContext createNamespaceContext(XPathFactory factory) {\n        DefaultNamespaceContext context = new DefaultNamespaceContext(factory);\n        populateDefaultNamespaces(context);\n        return context;\n    }\n\n    /**\n     * Populate a number of standard prefixes if they are not already there\n     */\n    protected void populateDefaultNamespaces(DefaultNamespaceContext context) {\n        setNamespaceIfNotPresent(context, \"in\", IN_NAMESPACE);\n        setNamespaceIfNotPresent(context, \"out\", OUT_NAMESPACE);\n        setNamespaceIfNotPresent(context, \"env\", Namespaces.ENVIRONMENT_VARIABLES);\n        setNamespaceIfNotPresent(context, \"system\", Namespaces.SYSTEM_PROPERTIES_NAMESPACE);\n        setNamespaceIfNotPresent(context, \"function\", Namespaces.FUNCTION_NAMESPACE);\n    }\n\n    protected void setNamespaceIfNotPresent(DefaultNamespaceContext context, String prefix, String uri) {\n        if (context != null) {\n            String current = context.getNamespaceURI(prefix);\n            if (current == null) {\n                context.add(prefix, uri);\n            }\n        }\n    }\n\n    protected XPathFunctionResolver createDefaultFunctionResolver(final XPathFunctionResolver parent) {\n        return new XPathFunctionResolver() {\n            public XPathFunction resolveFunction(QName qName, int argumentCount) {\n                XPathFunction answer = null;\n                if (parent != null) {\n                    answer = parent.resolveFunction(qName, argumentCount);\n                }\n                if (answer == null) {\n                    if (isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), IN_NAMESPACE)\n                            || isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), DEFAULT_NAMESPACE)) {\n                        String localPart = qName.getLocalPart();\n                        if (localPart.equals(\"body\") && argumentCount == 0) {\n                            return getBodyFunction();\n                        }\n                        if (localPart.equals(\"header\") && argumentCount == 1) {\n                            return getHeaderFunction();\n                        }\n                    }\n                    if (isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), OUT_NAMESPACE)) {\n                        String localPart = qName.getLocalPart();\n                        if (localPart.equals(\"body\") && argumentCount == 0) {\n                            return getOutBodyFunction();\n                        }\n                        if (localPart.equals(\"header\") && argumentCount == 1) {\n                            return getOutHeaderFunction();\n                        }\n                    }\n                    if (isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), FUNCTION_NAMESPACE)) {\n                        String localPart = qName.getLocalPart();\n                        if (localPart.equals(\"properties\") && argumentCount == 1) {\n                            return getPropertiesFunction();\n                        }\n                        if (localPart.equals(\"simple\") && argumentCount == 1) {\n                            return getSimpleFunction();\n                        }\n                    }\n                }\n                return answer;\n            }\n        };\n    }\n\n    /**\n     * Checks whether we need an {@link InputStream} to access the message body.\n     * <p/>\n     * Depending on the content in the message body, we may not need to convert\n     * to {@link InputStream}.\n     *\n     * @param exchange the current exchange\n     * @return <tt>true</tt> to convert to {@link InputStream} beforehand converting afterwards.\n     */\n    protected boolean isInputStreamNeeded(Exchange exchange) {\n        Object body = exchange.getIn().getBody();\n        return isInputStreamNeededForObject(exchange, body);\n    }\n\n    /**\n     * Checks whether we need an {@link InputStream} to access the message header.\n     * <p/>\n     * Depending on the content in the message header, we may not need to convert\n     * to {@link InputStream}.\n     *\n     * @param exchange the current exchange\n     * @return <tt>true</tt> to convert to {@link InputStream} beforehand converting afterwards.\n     */\n    protected boolean isInputStreamNeeded(Exchange exchange, String headerName) {\n        Object header = exchange.getIn().getHeader(headerName);\n        return isInputStreamNeededForObject(exchange, header);\n    }\n\n    /**\n     * Checks whether we need an {@link InputStream} to access this object\n     * <p/>\n     * Depending on the content in the object, we may not need to convert\n     * to {@link InputStream}.\n     *\n     * @param exchange the current exchange\n     * @return <tt>true</tt> to convert to {@link InputStream} beforehand converting afterwards.\n     */\n    protected boolean isInputStreamNeededForObject(Exchange exchange, Object obj) {\n        if (obj == null) {\n            return false;\n        }\n\n        if (obj instanceof WrappedFile) {\n            obj = ((WrappedFile<?>) obj).getFile();\n        }\n        if (obj instanceof File) {\n            // input stream is needed for File to avoid locking the file in case of errors etc\n            return true;\n        }\n\n        // input stream is not needed otherwise\n        return false;\n    }\n\n    /**\n     * Strategy method to extract the document from the exchange.\n     */\n    protected Object getDocument(Exchange exchange, Object body) {\n        try {\n            return doGetDocument(exchange, body);\n        } catch (Exception e) {\n            throw ObjectHelper.wrapRuntimeCamelException(e);\n        } finally {\n            // call the reset if the in message body is StreamCache\n            MessageHelper.resetStreamCache(exchange.getIn());\n        }\n    }\n\n    protected Object doGetDocument(Exchange exchange, Object body) throws Exception {\n        if (body == null) {\n            return null;\n        }\n\n        Object answer = null;\n\n        Class<?> type = getDocumentType();\n        Exception cause = null;\n        if (type != null) {\n            // try to get the body as the desired type\n            try {\n                answer = exchange.getContext().getTypeConverter().convertTo(type, exchange, body);\n            } catch (Exception e) {\n                // we want to store the caused exception, if we could not convert\n                cause = e;\n            }\n        }\n\n        if (type == null && answer == null) {\n            // fallback to get the body as is\n            answer = body;\n        } else if (answer == null) {\n            // there was a type, and we could not convert to it, then fail\n            if (cause != null) {\n                throw cause;\n            } else {\n                throw new NoTypeConversionAvailableException(body, type);\n            }\n        }\n\n        return answer;\n    }\n\n    private MessageVariableResolver getVariableResolver() {\n        return variableResolver;\n    }\n\n    @Override\n    public void doStart() throws Exception {\n        if (xpathFactory == null) {\n            xpathFactory = createXPathFactory();\n        }\n        if (namespaceContext == null) {\n            namespaceContext = createNamespaceContext(xpathFactory);\n        }\n        for (Map.Entry<String, String> entry : namespaces.entrySet()) {\n            namespaceContext.add(entry.getKey(), entry.getValue());\n        }\n\n        // create default functions if no custom assigned\n        if (bodyFunction == null) {\n            bodyFunction = createBodyFunction();\n        }\n        if (headerFunction == null) {\n            headerFunction = createHeaderFunction();\n        }\n        if (outBodyFunction == null) {\n            outBodyFunction = createOutBodyFunction();\n        }\n        if (outHeaderFunction == null) {\n            outHeaderFunction = createOutHeaderFunction();\n        }\n        if (propertiesFunction == null) {\n            propertiesFunction = createPropertiesFunction();\n        }\n        if (simpleFunction == null) {\n            simpleFunction = createSimpleFunction();\n        }\n    }\n\n    @Override\n    public void doStop() throws Exception {\n        pool.clear();\n        poolLogNamespaces.clear();\n    }\n\n    protected synchronized XPathFactory createXPathFactory() throws XPathFactoryConfigurationException {\n        if (objectModelUri != null) {\n            xpathFactory = XPathFactory.newInstance(objectModelUri);\n            LOG.info(\"Using objectModelUri \" + objectModelUri + \" when created XPathFactory {}\", xpathFactory);\n            return xpathFactory;\n        }\n\n        if (defaultXPathFactory == null) {\n            defaultXPathFactory = createDefaultXPathFactory();\n        }\n        return defaultXPathFactory;\n    }\n\n    protected static XPathFactory createDefaultXPathFactory() throws XPathFactoryConfigurationException {\n        XPathFactory factory = null;\n\n        // read system property and see if there is a factory set\n        Properties properties = System.getProperties();\n        for (Map.Entry<Object, Object> prop : properties.entrySet()) {\n            String key = (String) prop.getKey();\n            if (key.startsWith(XPathFactory.DEFAULT_PROPERTY_NAME)) {\n                String uri = ObjectHelper.after(key, \":\");\n                if (uri != null) {\n                    factory = XPathFactory.newInstance(uri);\n                    LOG.info(\"Using system property {} with value {} when created default XPathFactory {}\", new Object[]{key, uri, factory});\n                }\n            }\n        }\n\n        if (factory == null) {\n            factory = XPathFactory.newInstance();\n            LOG.info(\"Created default XPathFactory {}\", factory);\n        }\n\n        return factory;\n    }\n\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-5": {
    "vul_id": "VUL4J-5",
    "cve_id": "APACHE-COMMONS-001",
    "project": "apache_commons-compress",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=org.apache.commons.compress.archivers.examples.ExpanderTest#fileCantEscapeDoubleDotPathWithSimilarSibling",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/apache/commons-compress/commit/a080293da69f3fe3d11d5214432e1469ee195870",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/org/apache/commons/compress/archivers/examples/Expander.java",
        "file_name": "Expander.java",
        "vulnerable_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.commons.compress.archivers.examples;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.channels.Channels;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Enumeration;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveException;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.ArchiveStreamFactory;\nimport org.apache.commons.compress.archivers.sevenz.SevenZFile;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipFile;\nimport org.apache.commons.compress.utils.IOUtils;\n\n/**\n * Provides a high level API for expanding archives.\n * @since 1.17\n */\npublic class Expander {\n\n    private interface ArchiveEntrySupplier {\n        ArchiveEntry getNextReadableEntry() throws IOException;\n    }\n\n    private interface EntryWriter {\n        void writeEntryDataTo(ArchiveEntry entry, OutputStream out) throws IOException;\n    }\n\n    /**\n     * Expands {@code archive} into {@code targetDirectory}.\n     *\n     * <p>Tries to auto-detect the archive's format.</p>\n     *\n     * @param archive the file to expand\n     * @param targetDirectory the directory to write to\n     * @throws IOException if an I/O error occurs\n     * @throws ArchiveException if the archive cannot be read for other reasons\n     */\n    public void expand(File archive, File targetDirectory) throws IOException, ArchiveException {\n        String format = null;\n        try (InputStream i = new BufferedInputStream(Files.newInputStream(archive.toPath()))) {\n            format = new ArchiveStreamFactory().detect(i);\n        }\n        expand(format, archive, targetDirectory);\n    }\n\n    /**\n     * Expands {@code archive} into {@code targetDirectory}.\n     *\n     * @param archive the file to expand\n     * @param targetDirectory the directory to write to\n     * @param format the archive format. This uses the same format as\n     * accepted by {@link ArchiveStreamFactory}.\n     * @throws IOException if an I/O error occurs\n     * @throws ArchiveException if the archive cannot be read for other reasons\n     */\n    public void expand(String format, File archive, File targetDirectory) throws IOException, ArchiveException {\n        if (prefersSeekableByteChannel(format)) {\n            try (SeekableByteChannel c = FileChannel.open(archive.toPath(), StandardOpenOption.READ)) {\n                expand(format, c, targetDirectory);\n            }\n            return;\n        }\n        try (InputStream i = new BufferedInputStream(Files.newInputStream(archive.toPath()))) {\n            expand(format, i, targetDirectory);\n        }\n    }\n\n    /**\n     * Expands {@code archive} into {@code targetDirectory}.\n     *\n     * <p>Tries to auto-detect the archive's format.</p>\n     *\n     * @param archive the file to expand\n     * @param targetDirectory the directory to write to\n     * @throws IOException if an I/O error occurs\n     * @throws ArchiveException if the archive cannot be read for other reasons\n     */\n    public void expand(InputStream archive, File targetDirectory) throws IOException, ArchiveException {\n        expand(new ArchiveStreamFactory().createArchiveInputStream(archive), targetDirectory);\n    }\n\n    /**\n     * Expands {@code archive} into {@code targetDirectory}.\n     *\n     * @param archive the file to expand\n     * @param targetDirectory the directory to write to\n     * @param format the archive format. This uses the same format as\n     * accepted by {@link ArchiveStreamFactory}.\n     * @throws IOException if an I/O error occurs\n     * @throws ArchiveException if the archive cannot be read for other reasons\n     */\n    public void expand(String format, InputStream archive, File targetDirectory)\n        throws IOException, ArchiveException {\n        expand(new ArchiveStreamFactory().createArchiveInputStream(format, archive), targetDirectory);\n    }\n\n    /**\n     * Expands {@code archive} into {@code targetDirectory}.\n     *\n     * @param archive the file to expand\n     * @param targetDirectory the directory to write to\n     * @param format the archive format. This uses the same format as\n     * accepted by {@link ArchiveStreamFactory}.\n     * @throws IOException if an I/O error occurs\n     * @throws ArchiveException if the archive cannot be read for other reasons\n     */\n    public void expand(String format, SeekableByteChannel archive, File targetDirectory)\n        throws IOException, ArchiveException {\n        if (!prefersSeekableByteChannel(format)) {\n            expand(format, Channels.newInputStream(archive), targetDirectory);\n        } else if (ArchiveStreamFactory.ZIP.equalsIgnoreCase(format)) {\n            expand(new ZipFile(archive), targetDirectory);\n        } else if (ArchiveStreamFactory.SEVEN_Z.equalsIgnoreCase(format)) {\n            expand(new SevenZFile(archive), targetDirectory);\n        } else {\n            // never reached as prefersSeekableByteChannel only returns true for ZIP and 7z\n            throw new ArchiveException(\"don't know how to handle format \" + format);\n        }\n    }\n\n    /**\n     * Expands {@code archive} into {@code targetDirectory}.\n     *\n     * @param archive the file to expand\n     * @param targetDirectory the directory to write to\n     * @throws IOException if an I/O error occurs\n     * @throws ArchiveException if the archive cannot be read for other reasons\n     */\n    public void expand(final ArchiveInputStream archive, File targetDirectory)\n        throws IOException, ArchiveException {\n        expand(new ArchiveEntrySupplier() {\n            @Override\n            public ArchiveEntry getNextReadableEntry() throws IOException {\n                ArchiveEntry next = archive.getNextEntry();\n                while (next != null && !archive.canReadEntryData(next)) {\n                    next = archive.getNextEntry();\n                }\n                return next;\n            }\n        }, new EntryWriter() {\n            @Override\n            public void writeEntryDataTo(ArchiveEntry entry, OutputStream out) throws IOException {\n                IOUtils.copy(archive, out);\n            }\n        }, targetDirectory);\n    }\n\n    /**\n     * Expands {@code archive} into {@code targetDirectory}.\n     *\n     * @param archive the file to expand\n     * @param targetDirectory the directory to write to\n     * @throws IOException if an I/O error occurs\n     * @throws ArchiveException if the archive cannot be read for other reasons\n     */\n    public void expand(final ZipFile archive, File targetDirectory)\n        throws IOException, ArchiveException {\n        final Enumeration<ZipArchiveEntry> entries = archive.getEntries();\n        expand(new ArchiveEntrySupplier() {\n            @Override\n            public ArchiveEntry getNextReadableEntry() throws IOException {\n                ZipArchiveEntry next = entries.hasMoreElements() ? entries.nextElement() : null;\n                while (next != null && !archive.canReadEntryData(next)) {\n                    next = entries.hasMoreElements() ? entries.nextElement() : null;\n                }\n                return next;\n            }\n        }, new EntryWriter() {\n            @Override\n            public void writeEntryDataTo(ArchiveEntry entry, OutputStream out) throws IOException {\n                try (InputStream in = archive.getInputStream((ZipArchiveEntry) entry)) {\n                    IOUtils.copy(in, out);\n                }\n            }\n        }, targetDirectory);\n    }\n\n    /**\n     * Expands {@code archive} into {@code targetDirectory}.\n     *\n     * @param archive the file to expand\n     * @param targetDirectory the directory to write to\n     * @throws IOException if an I/O error occurs\n     * @throws ArchiveException if the archive cannot be read for other reasons\n     */\n    public void expand(final SevenZFile archive, File targetDirectory)\n        throws IOException, ArchiveException {\n        expand(new ArchiveEntrySupplier() {\n            @Override\n            public ArchiveEntry getNextReadableEntry() throws IOException {\n                return archive.getNextEntry();\n            }\n        }, new EntryWriter() {\n            @Override\n            public void writeEntryDataTo(ArchiveEntry entry, OutputStream out) throws IOException {\n                final byte[] buffer = new byte[8024];\n                int n = 0;\n                long count = 0;\n                while (-1 != (n = archive.read(buffer))) {\n                    out.write(buffer, 0, n);\n                    count += n;\n                }\n            }\n        }, targetDirectory);\n    }\n\n    private boolean prefersSeekableByteChannel(String format) {\n        return ArchiveStreamFactory.ZIP.equalsIgnoreCase(format) || ArchiveStreamFactory.SEVEN_Z.equalsIgnoreCase(format);\n    }\n\n    private void expand(ArchiveEntrySupplier supplier, EntryWriter writer, File targetDirectory)\n        throws IOException {\n        String targetDirPath = targetDirectory.getCanonicalPath();\n        ArchiveEntry nextEntry = supplier.getNextReadableEntry();\n        while (nextEntry != null) {\n            File f = new File(targetDirectory, nextEntry.getName());\n            if (!f.getCanonicalPath().startsWith(targetDirPath)) {\n                throw new IOException(\"expanding \" + nextEntry.getName()\n                    + \" would create file outside of \" + targetDirectory);\n            }\n            if (nextEntry.isDirectory()) {\n                if (!f.isDirectory() && !f.mkdirs()) {\n                    throw new IOException(\"failed to create directory \" + f);\n                }\n            } else {\n                File parent = f.getParentFile();\n                if (!parent.isDirectory() && !parent.mkdirs()) {\n                    throw new IOException(\"failed to create directory \" + parent);\n                }\n                try (OutputStream o = Files.newOutputStream(f.toPath())) {\n                    writer.writeEntryDataTo(nextEntry, o);\n                }\n            }\n            nextEntry = supplier.getNextReadableEntry();\n        }\n    }\n\n}\n",
        "human_patch_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.commons.compress.archivers.examples;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.channels.Channels;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Enumeration;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveException;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.ArchiveStreamFactory;\nimport org.apache.commons.compress.archivers.sevenz.SevenZFile;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipFile;\nimport org.apache.commons.compress.utils.IOUtils;\n\n/**\n * Provides a high level API for expanding archives.\n * @since 1.17\n */\npublic class Expander {\n\n    private interface ArchiveEntrySupplier {\n        ArchiveEntry getNextReadableEntry() throws IOException;\n    }\n\n    private interface EntryWriter {\n        void writeEntryDataTo(ArchiveEntry entry, OutputStream out) throws IOException;\n    }\n\n    /**\n     * Expands {@code archive} into {@code targetDirectory}.\n     *\n     * <p>Tries to auto-detect the archive's format.</p>\n     *\n     * @param archive the file to expand\n     * @param targetDirectory the directory to write to\n     * @throws IOException if an I/O error occurs\n     * @throws ArchiveException if the archive cannot be read for other reasons\n     */\n    public void expand(File archive, File targetDirectory) throws IOException, ArchiveException {\n        String format = null;\n        try (InputStream i = new BufferedInputStream(Files.newInputStream(archive.toPath()))) {\n            format = new ArchiveStreamFactory().detect(i);\n        }\n        expand(format, archive, targetDirectory);\n    }\n\n    /**\n     * Expands {@code archive} into {@code targetDirectory}.\n     *\n     * @param archive the file to expand\n     * @param targetDirectory the directory to write to\n     * @param format the archive format. This uses the same format as\n     * accepted by {@link ArchiveStreamFactory}.\n     * @throws IOException if an I/O error occurs\n     * @throws ArchiveException if the archive cannot be read for other reasons\n     */\n    public void expand(String format, File archive, File targetDirectory) throws IOException, ArchiveException {\n        if (prefersSeekableByteChannel(format)) {\n            try (SeekableByteChannel c = FileChannel.open(archive.toPath(), StandardOpenOption.READ)) {\n                expand(format, c, targetDirectory);\n            }\n            return;\n        }\n        try (InputStream i = new BufferedInputStream(Files.newInputStream(archive.toPath()))) {\n            expand(format, i, targetDirectory);\n        }\n    }\n\n    /**\n     * Expands {@code archive} into {@code targetDirectory}.\n     *\n     * <p>Tries to auto-detect the archive's format.</p>\n     *\n     * @param archive the file to expand\n     * @param targetDirectory the directory to write to\n     * @throws IOException if an I/O error occurs\n     * @throws ArchiveException if the archive cannot be read for other reasons\n     */\n    public void expand(InputStream archive, File targetDirectory) throws IOException, ArchiveException {\n        expand(new ArchiveStreamFactory().createArchiveInputStream(archive), targetDirectory);\n    }\n\n    /**\n     * Expands {@code archive} into {@code targetDirectory}.\n     *\n     * @param archive the file to expand\n     * @param targetDirectory the directory to write to\n     * @param format the archive format. This uses the same format as\n     * accepted by {@link ArchiveStreamFactory}.\n     * @throws IOException if an I/O error occurs\n     * @throws ArchiveException if the archive cannot be read for other reasons\n     */\n    public void expand(String format, InputStream archive, File targetDirectory)\n        throws IOException, ArchiveException {\n        expand(new ArchiveStreamFactory().createArchiveInputStream(format, archive), targetDirectory);\n    }\n\n    /**\n     * Expands {@code archive} into {@code targetDirectory}.\n     *\n     * @param archive the file to expand\n     * @param targetDirectory the directory to write to\n     * @param format the archive format. This uses the same format as\n     * accepted by {@link ArchiveStreamFactory}.\n     * @throws IOException if an I/O error occurs\n     * @throws ArchiveException if the archive cannot be read for other reasons\n     */\n    public void expand(String format, SeekableByteChannel archive, File targetDirectory)\n        throws IOException, ArchiveException {\n        if (!prefersSeekableByteChannel(format)) {\n            expand(format, Channels.newInputStream(archive), targetDirectory);\n        } else if (ArchiveStreamFactory.ZIP.equalsIgnoreCase(format)) {\n            expand(new ZipFile(archive), targetDirectory);\n        } else if (ArchiveStreamFactory.SEVEN_Z.equalsIgnoreCase(format)) {\n            expand(new SevenZFile(archive), targetDirectory);\n        } else {\n            // never reached as prefersSeekableByteChannel only returns true for ZIP and 7z\n            throw new ArchiveException(\"don't know how to handle format \" + format);\n        }\n    }\n\n    /**\n     * Expands {@code archive} into {@code targetDirectory}.\n     *\n     * @param archive the file to expand\n     * @param targetDirectory the directory to write to\n     * @throws IOException if an I/O error occurs\n     * @throws ArchiveException if the archive cannot be read for other reasons\n     */\n    public void expand(final ArchiveInputStream archive, File targetDirectory)\n        throws IOException, ArchiveException {\n        expand(new ArchiveEntrySupplier() {\n            @Override\n            public ArchiveEntry getNextReadableEntry() throws IOException {\n                ArchiveEntry next = archive.getNextEntry();\n                while (next != null && !archive.canReadEntryData(next)) {\n                    next = archive.getNextEntry();\n                }\n                return next;\n            }\n        }, new EntryWriter() {\n            @Override\n            public void writeEntryDataTo(ArchiveEntry entry, OutputStream out) throws IOException {\n                IOUtils.copy(archive, out);\n            }\n        }, targetDirectory);\n    }\n\n    /**\n     * Expands {@code archive} into {@code targetDirectory}.\n     *\n     * @param archive the file to expand\n     * @param targetDirectory the directory to write to\n     * @throws IOException if an I/O error occurs\n     * @throws ArchiveException if the archive cannot be read for other reasons\n     */\n    public void expand(final ZipFile archive, File targetDirectory)\n        throws IOException, ArchiveException {\n        final Enumeration<ZipArchiveEntry> entries = archive.getEntries();\n        expand(new ArchiveEntrySupplier() {\n            @Override\n            public ArchiveEntry getNextReadableEntry() throws IOException {\n                ZipArchiveEntry next = entries.hasMoreElements() ? entries.nextElement() : null;\n                while (next != null && !archive.canReadEntryData(next)) {\n                    next = entries.hasMoreElements() ? entries.nextElement() : null;\n                }\n                return next;\n            }\n        }, new EntryWriter() {\n            @Override\n            public void writeEntryDataTo(ArchiveEntry entry, OutputStream out) throws IOException {\n                try (InputStream in = archive.getInputStream((ZipArchiveEntry) entry)) {\n                    IOUtils.copy(in, out);\n                }\n            }\n        }, targetDirectory);\n    }\n\n    /**\n     * Expands {@code archive} into {@code targetDirectory}.\n     *\n     * @param archive the file to expand\n     * @param targetDirectory the directory to write to\n     * @throws IOException if an I/O error occurs\n     * @throws ArchiveException if the archive cannot be read for other reasons\n     */\n    public void expand(final SevenZFile archive, File targetDirectory)\n        throws IOException, ArchiveException {\n        expand(new ArchiveEntrySupplier() {\n            @Override\n            public ArchiveEntry getNextReadableEntry() throws IOException {\n                return archive.getNextEntry();\n            }\n        }, new EntryWriter() {\n            @Override\n            public void writeEntryDataTo(ArchiveEntry entry, OutputStream out) throws IOException {\n                final byte[] buffer = new byte[8024];\n                int n = 0;\n                long count = 0;\n                while (-1 != (n = archive.read(buffer))) {\n                    out.write(buffer, 0, n);\n                    count += n;\n                }\n            }\n        }, targetDirectory);\n    }\n\n    private boolean prefersSeekableByteChannel(String format) {\n        return ArchiveStreamFactory.ZIP.equalsIgnoreCase(format) || ArchiveStreamFactory.SEVEN_Z.equalsIgnoreCase(format);\n    }\n\n    private void expand(ArchiveEntrySupplier supplier, EntryWriter writer, File targetDirectory)\n        throws IOException {\n        String targetDirPath = targetDirectory.getCanonicalPath() + File.separatorChar;\n        ArchiveEntry nextEntry = supplier.getNextReadableEntry();\n        while (nextEntry != null) {\n            File f = new File(targetDirectory, nextEntry.getName());\n            if (!f.getCanonicalPath().startsWith(targetDirPath)) {\n                throw new IOException(\"expanding \" + nextEntry.getName()\n                    + \" would create file outside of \" + targetDirectory);\n            }\n            if (nextEntry.isDirectory()) {\n                if (!f.isDirectory() && !f.mkdirs()) {\n                    throw new IOException(\"failed to create directory \" + f);\n                }\n            } else {\n                File parent = f.getParentFile();\n                if (!parent.isDirectory() && !parent.mkdirs()) {\n                    throw new IOException(\"failed to create directory \" + parent);\n                }\n                try (OutputStream o = Files.newOutputStream(f.toPath())) {\n                    writer.writeEntryDataTo(nextEntry, o);\n                }\n            }\n            nextEntry = supplier.getNextReadableEntry();\n        }\n    }\n\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-6": {
    "vul_id": "VUL4J-6",
    "cve_id": "CVE-2018-1324",
    "project": "apache_commons-compress",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=org.apache.commons.compress.Test_CVE_2018_1324",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/apache/commons-compress/commit/2a2f1dc48e22a34ddb72321a4db211da91aa933b",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/org/apache/commons/compress/archivers/zip/X0017_StrongEncryptionHeader.java",
        "file_name": "X0017_StrongEncryptionHeader.java",
        "vulnerable_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.commons.compress.archivers.zip;\n\n/**\n * Strong Encryption Header (0x0017).\n *\n * <p>Certificate-based encryption:</p>\n *\n * <pre>\n * Value     Size     Description\n * -----     ----     -----------\n * 0x0017    2 bytes  Tag for this \"extra\" block type\n * TSize     2 bytes  Size of data that follows\n * Format    2 bytes  Format definition for this record\n * AlgID     2 bytes  Encryption algorithm identifier\n * Bitlen    2 bytes  Bit length of encryption key (32-448 bits)\n * Flags     2 bytes  Processing flags\n * RCount    4 bytes  Number of recipients.\n * HashAlg   2 bytes  Hash algorithm identifier\n * HSize     2 bytes  Hash size\n * SRList    (var)    Simple list of recipients hashed public keys\n *\n * Flags -   This defines the processing flags.\n * </pre>\n *\n *           <ul>\n *           <li>0x0007 - reserved for future use\n *           <li>0x000F - reserved for future use\n *           <li>0x0100 - Indicates non-OAEP key wrapping was used.  If this\n *                        this field is set, the version needed to extract must\n *                        be at least 61.  This means OAEP key wrapping is not\n *                        used when generating a Master Session Key using\n *                        ErdData.\n *           <li>0x4000 - ErdData must be decrypted using 3DES-168, otherwise use the\n *                        same algorithm used for encrypting the file contents.\n *           <li>0x8000 - reserved for future use\n *           </ul>\n *\n * <pre>\n * RCount - This defines the number intended recipients whose\n *          public keys were used for encryption.  This identifies\n *          the number of elements in the SRList.\n *\n *          see also: reserved1\n *\n * HashAlg - This defines the hash algorithm used to calculate\n *           the public key hash of each public key used\n *           for encryption. This field currently supports\n *           only the following value for SHA-1\n *\n *           0x8004 - SHA1\n *\n * HSize -   This defines the size of a hashed public key.\n *\n * SRList -  This is a variable length list of the hashed\n *           public keys for each intended recipient.  Each\n *           element in this list is HSize.  The total size of\n *           SRList is determined using RCount * HSize.\n * </pre>\n *\n * <p>Password-based Extra Field 0x0017 in central header only.</p>\n *\n * <pre>\n * Value     Size     Description\n * -----     ----     -----------\n * 0x0017    2 bytes  Tag for this \"extra\" block type\n * TSize     2 bytes  Size of data that follows\n * Format    2 bytes  Format definition for this record\n * AlgID     2 bytes  Encryption algorithm identifier\n * Bitlen    2 bytes  Bit length of encryption key (32-448 bits)\n * Flags     2 bytes  Processing flags\n * (more?)\n * </pre>\n *\n * <p><b>Format</b> - the data format identifier for this record. The only value\n * allowed at this time is the integer value 2.</p>\n *\n * <p>Password-based Extra Field 0x0017 preceding compressed file data.</p>\n *\n * <pre>\n * Value     Size     Description\n * -----     ----     -----------\n * 0x0017    2 bytes  Tag for this \"extra\" block type\n * IVSize    2 bytes  Size of initialization vector (IV)\n * IVData    IVSize   Initialization vector for this file\n * Size      4 bytes  Size of remaining decryption header data\n * Format    2 bytes  Format definition for this record\n * AlgID     2 bytes  Encryption algorithm identifier\n * Bitlen    2 bytes  Bit length of encryption key (32-448 bits)\n * Flags     2 bytes  Processing flags\n * ErdSize   2 bytes  Size of Encrypted Random Data\n * ErdData   ErdSize  Encrypted Random Data\n * Reserved1 4 bytes  Reserved certificate processing data\n * Reserved2 (var)    Reserved for certificate processing data\n * VSize     2 bytes  Size of password validation data\n * VData     VSize-4  Password validation data\n * VCRC32    4 bytes  Standard ZIP CRC32 of password validation data\n *\n * IVData - The size of the IV should match the algorithm block size.\n *          The IVData can be completely random data.  If the size of\n *          the randomly generated data does not match the block size\n *          it should be complemented with zero's or truncated as\n *          necessary.  If IVSize is 0,then IV = CRC32 + Uncompressed\n *          File Size (as a 64 bit little-endian, unsigned integer value).\n *\n * Format -  the data format identifier for this record.  The only\n *           value allowed at this time is the integer value 2.\n *\n * ErdData - Encrypted random data is used to store random data that\n *           is used to generate a file session key for encrypting\n *           each file.  SHA1 is used to calculate hash data used to\n *           derive keys.  File session keys are derived from a master\n *           session key generated from the user-supplied password.\n *           If the Flags field in the decryption header contains\n *           the value 0x4000, then the ErdData field must be\n *           decrypted using 3DES. If the value 0x4000 is not set,\n *           then the ErdData field must be decrypted using AlgId.\n *\n * Reserved1 - Reserved for certificate processing, if value is\n *           zero, then Reserved2 data is absent.  See the explanation\n *           under the Certificate Processing Method for details on\n *           this data structure.\n *\n * Reserved2 - If present, the size of the Reserved2 data structure\n *           is located by skipping the first 4 bytes of this field\n *           and using the next 2 bytes as the remaining size.  See\n *           the explanation under the Certificate Processing Method\n *           for details on this data structure.\n *\n * VSize - This size value will always include the 4 bytes of the\n *         VCRC32 data and will be greater than 4 bytes.\n *\n * VData - Random data for password validation.  This data is VSize\n *         in length and VSize must be a multiple of the encryption\n *         block size.  VCRC32 is a checksum value of VData.\n *         VData and VCRC32 are stored encrypted and start the\n *         stream of encrypted data for a file.\n * </pre>\n *\n * <p>Reserved1 - Certificate Decryption Header Reserved1 Data:</p>\n *\n * <pre>\n * Value     Size     Description\n * -----     ----     -----------\n * RCount    4 bytes  Number of recipients.\n * </pre>\n *\n * <p>RCount - This defines the number intended recipients whose public keys were\n * used for encryption. This defines the number of elements in the REList field\n * defined below.</p>\n *\n * <p>Reserved2 - Certificate Decryption Header Reserved2 Data Structures:</p>\n *\n * <pre>\n * Value     Size     Description\n * -----     ----     -----------\n * HashAlg   2 bytes  Hash algorithm identifier\n * HSize     2 bytes  Hash size\n * REList    (var)    List of recipient data elements\n *\n * HashAlg - This defines the hash algorithm used to calculate\n *           the public key hash of each public key used\n *           for encryption. This field currently supports\n *           only the following value for SHA-1\n *\n *               0x8004 - SHA1\n *\n * HSize -   This defines the size of a hashed public key\n *           defined in REHData.\n *\n * REList -  This is a variable length of list of recipient data.\n *           Each element in this list consists of a Recipient\n *           Element data structure as follows:\n * </pre>\n *\n * <p>Recipient Element (REList) Data Structure:</p>\n *\n * <pre>\n * Value     Size     Description\n * -----     ----     -----------\n * RESize    2 bytes  Size of REHData + REKData\n * REHData   HSize    Hash of recipients public key\n * REKData   (var)    Simple key blob\n *\n *\n * RESize -  This defines the size of an individual REList\n *           element.  This value is the combined size of the\n *           REHData field + REKData field.  REHData is defined by\n *           HSize.  REKData is variable and can be calculated\n *           for each REList element using RESize and HSize.\n *\n * REHData - Hashed public key for this recipient.\n *\n * REKData - Simple Key Blob.  The format of this data structure\n *           is identical to that defined in the Microsoft\n *           CryptoAPI and generated using the CryptExportKey()\n *           function.  The version of the Simple Key Blob\n *           supported at this time is 0x02 as defined by\n *           Microsoft.\n *\n *           For more details see https://msdn.microsoft.com/en-us/library/aa920051.aspx\n * </pre>\n *\n * <p><b>Flags</b> - Processing flags needed for decryption</p>\n *\n * <ul>\n * <li>0x0001 - Password is required to decrypt</li>\n * <li>0x0002 - Certificates only</li>\n * <li>0x0003 - Password or certificate required to decrypt</li>\n * <li>0x0007 - reserved for future use\n * <li>0x000F - reserved for future use\n * <li>0x0100 - indicates non-OAEP key wrapping was used. If this field is set\n * the version needed to extract must be at least 61. This means OAEP key\n * wrapping is not used when generating a Master Session Key using ErdData.\n * <li>0x4000 - ErdData must be decrypted using 3DES-168, otherwise use the same\n * algorithm used for encrypting the file contents.\n * <li>0x8000 - reserved for future use.\n * </ul>\n *\n * <p><b>See the section describing the Strong Encryption Specification for\n * details. Refer to the section in this document entitled\n * \"Incorporating PKWARE Proprietary Technology into Your Product\" for more\n * information.</b></p>\n *\n * @NotThreadSafe\n * @since 1.11\n */\npublic class X0017_StrongEncryptionHeader extends PKWareExtraHeader {\n\n    public X0017_StrongEncryptionHeader() {\n        super(new ZipShort(0x0017));\n    }\n\n    private int format; // TODO written but not read\n    private EncryptionAlgorithm algId;\n    private int bitlen; // TODO written but not read\n    private int flags; // TODO written but not read\n    private long rcount;\n    private HashAlgorithm hashAlg;\n    private int hashSize;\n\n    // encryption data\n    private byte ivData[];\n    private byte erdData[];\n\n    // encryption key\n    private byte recipientKeyHash[];\n    private byte keyBlob[];\n\n    // password verification data\n    private byte vData[];\n    private byte vCRC32[];\n\n    /**\n     * Get record count.\n     * @return the record count\n     */\n    public long getRecordCount() {\n        return rcount;\n    }\n\n    /**\n     * Get hash algorithm.\n     * @return the hash algorithm\n     */\n    public HashAlgorithm getHashAlgorithm() {\n        return hashAlg;\n    }\n\n    /**\n     * Get encryption algorithm.\n     * @return the encryption algorithm\n     */\n    public EncryptionAlgorithm getEncryptionAlgorithm() {\n        return algId;\n    }\n\n    /**\n     * Parse central directory format.\n     *\n     * @param data the buffer to read data from\n     * @param offset offset into buffer to read data\n     * @param length the length of data\n     */\n    public void parseCentralDirectoryFormat(final byte[] data, final int offset, final int length) {\n        this.format = ZipShort.getValue(data, offset);\n        this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\n        this.bitlen = ZipShort.getValue(data, offset + 4);\n        this.flags = ZipShort.getValue(data, offset + 6);\n        this.rcount = ZipLong.getValue(data, offset + 8);\n\n        if (rcount > 0) {\n            this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12));\n            this.hashSize = ZipShort.getValue(data, offset + 14);\n            // srlist... hashed public keys\n            for (int i = 0; i < this.rcount; i++) {\n                for (int j = 0; j < this.hashSize; j++) {\n                    //  ZipUtil.signedByteToUnsignedInt(data[offset + 16 + (i * this.hashSize) + j]));\n                }\n            }\n        }\n    }\n\n    /**\n     * Parse file header format.\n     *\n     * <p>(Password only?)</p>\n     *\n     * @param data the buffer to read data from\n     * @param offset offset into buffer to read data\n     * @param length the length of data\n     */\n    public void parseFileFormat(final byte[] data, final int offset, final int length) {\n        final int ivSize = ZipShort.getValue(data, offset);\n        this.ivData = new byte[ivSize];\n        System.arraycopy(data, offset + 4, this.ivData, 0, ivSize);\n\n        this.format = ZipShort.getValue(data, offset + ivSize + 6);\n        this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + ivSize + 8));\n        this.bitlen = ZipShort.getValue(data, offset + ivSize + 10);\n        this.flags = ZipShort.getValue(data, offset + ivSize + 12);\n\n        final int erdSize = ZipShort.getValue(data, offset + ivSize + 14);\n        this.erdData = new byte[erdSize];\n        System.arraycopy(data, offset + ivSize + 16, this.erdData, 0, erdSize);\n\n        this.rcount = ZipLong.getValue(data, offset + ivSize + 16 + erdSize);\n        System.out.println(\"rcount: \" + rcount);\n        if (rcount == 0) {\n            final int vSize = ZipShort.getValue(data, offset + ivSize + 20 + erdSize);\n            this.vData = new byte[vSize - 4];\n            this.vCRC32 = new byte[4];\n            System.arraycopy(data, offset + ivSize + 22 + erdSize , this.vData, 0, vSize - 4);\n            System.arraycopy(data, offset + ivSize + 22 + erdSize + vSize - 4, vCRC32, 0, 4);\n        } else {\n            this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + ivSize + 20 + erdSize));\n            this.hashSize = ZipShort.getValue(data, offset + ivSize + 22 + erdSize);\n            final int resize = ZipShort.getValue(data, offset + ivSize + 24 + erdSize);\n            this.recipientKeyHash = new byte[this.hashSize];\n            this.keyBlob = new byte[resize - this.hashSize];\n            System.arraycopy(data, offset + ivSize + 24 + erdSize, this.recipientKeyHash, 0, this.hashSize);\n            System.arraycopy(data, offset + ivSize + 24 + erdSize + this.hashSize, this.keyBlob, 0, resize - this.hashSize);\n\n            final int vSize = ZipShort.getValue(data, offset + ivSize + 26 + erdSize + resize);\n            this.vData = new byte[vSize - 4];\n            this.vCRC32 = new byte[4];\n            System.arraycopy(data, offset + ivSize + 22 + erdSize + resize, this.vData, 0, vSize - 4);\n            System.arraycopy(data, offset + ivSize + 22 + erdSize + resize + vSize - 4, vCRC32, 0, 4);\n        }\n\n        // validate values?\n    }\n\n    @Override\n    public void parseFromLocalFileData(final byte[] data, final int offset, final int length) {\n        super.parseFromLocalFileData(data, offset, length);\n        parseFileFormat(data, offset, length);\n    }\n\n    @Override\n    public void parseFromCentralDirectoryData(final byte[] data, final int offset, final int length) {\n        super.parseFromCentralDirectoryData(data, offset, length);\n        parseCentralDirectoryFormat(data, offset, length);\n    }\n}\n",
        "human_patch_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.commons.compress.archivers.zip;\n\n/**\n * Strong Encryption Header (0x0017).\n *\n * <p>Certificate-based encryption:</p>\n *\n * <pre>\n * Value     Size     Description\n * -----     ----     -----------\n * 0x0017    2 bytes  Tag for this \"extra\" block type\n * TSize     2 bytes  Size of data that follows\n * Format    2 bytes  Format definition for this record\n * AlgID     2 bytes  Encryption algorithm identifier\n * Bitlen    2 bytes  Bit length of encryption key (32-448 bits)\n * Flags     2 bytes  Processing flags\n * RCount    4 bytes  Number of recipients.\n * HashAlg   2 bytes  Hash algorithm identifier\n * HSize     2 bytes  Hash size\n * SRList    (var)    Simple list of recipients hashed public keys\n *\n * Flags -   This defines the processing flags.\n * </pre>\n *\n *           <ul>\n *           <li>0x0007 - reserved for future use\n *           <li>0x000F - reserved for future use\n *           <li>0x0100 - Indicates non-OAEP key wrapping was used.  If this\n *                        this field is set, the version needed to extract must\n *                        be at least 61.  This means OAEP key wrapping is not\n *                        used when generating a Master Session Key using\n *                        ErdData.\n *           <li>0x4000 - ErdData must be decrypted using 3DES-168, otherwise use the\n *                        same algorithm used for encrypting the file contents.\n *           <li>0x8000 - reserved for future use\n *           </ul>\n *\n * <pre>\n * RCount - This defines the number intended recipients whose\n *          public keys were used for encryption.  This identifies\n *          the number of elements in the SRList.\n *\n *          see also: reserved1\n *\n * HashAlg - This defines the hash algorithm used to calculate\n *           the public key hash of each public key used\n *           for encryption. This field currently supports\n *           only the following value for SHA-1\n *\n *           0x8004 - SHA1\n *\n * HSize -   This defines the size of a hashed public key.\n *\n * SRList -  This is a variable length list of the hashed\n *           public keys for each intended recipient.  Each\n *           element in this list is HSize.  The total size of\n *           SRList is determined using RCount * HSize.\n * </pre>\n *\n * <p>Password-based Extra Field 0x0017 in central header only.</p>\n *\n * <pre>\n * Value     Size     Description\n * -----     ----     -----------\n * 0x0017    2 bytes  Tag for this \"extra\" block type\n * TSize     2 bytes  Size of data that follows\n * Format    2 bytes  Format definition for this record\n * AlgID     2 bytes  Encryption algorithm identifier\n * Bitlen    2 bytes  Bit length of encryption key (32-448 bits)\n * Flags     2 bytes  Processing flags\n * (more?)\n * </pre>\n *\n * <p><b>Format</b> - the data format identifier for this record. The only value\n * allowed at this time is the integer value 2.</p>\n *\n * <p>Password-based Extra Field 0x0017 preceding compressed file data.</p>\n *\n * <pre>\n * Value     Size     Description\n * -----     ----     -----------\n * 0x0017    2 bytes  Tag for this \"extra\" block type\n * IVSize    2 bytes  Size of initialization vector (IV)\n * IVData    IVSize   Initialization vector for this file\n * Size      4 bytes  Size of remaining decryption header data\n * Format    2 bytes  Format definition for this record\n * AlgID     2 bytes  Encryption algorithm identifier\n * Bitlen    2 bytes  Bit length of encryption key (32-448 bits)\n * Flags     2 bytes  Processing flags\n * ErdSize   2 bytes  Size of Encrypted Random Data\n * ErdData   ErdSize  Encrypted Random Data\n * Reserved1 4 bytes  Reserved certificate processing data\n * Reserved2 (var)    Reserved for certificate processing data\n * VSize     2 bytes  Size of password validation data\n * VData     VSize-4  Password validation data\n * VCRC32    4 bytes  Standard ZIP CRC32 of password validation data\n *\n * IVData - The size of the IV should match the algorithm block size.\n *          The IVData can be completely random data.  If the size of\n *          the randomly generated data does not match the block size\n *          it should be complemented with zero's or truncated as\n *          necessary.  If IVSize is 0,then IV = CRC32 + Uncompressed\n *          File Size (as a 64 bit little-endian, unsigned integer value).\n *\n * Format -  the data format identifier for this record.  The only\n *           value allowed at this time is the integer value 2.\n *\n * ErdData - Encrypted random data is used to store random data that\n *           is used to generate a file session key for encrypting\n *           each file.  SHA1 is used to calculate hash data used to\n *           derive keys.  File session keys are derived from a master\n *           session key generated from the user-supplied password.\n *           If the Flags field in the decryption header contains\n *           the value 0x4000, then the ErdData field must be\n *           decrypted using 3DES. If the value 0x4000 is not set,\n *           then the ErdData field must be decrypted using AlgId.\n *\n * Reserved1 - Reserved for certificate processing, if value is\n *           zero, then Reserved2 data is absent.  See the explanation\n *           under the Certificate Processing Method for details on\n *           this data structure.\n *\n * Reserved2 - If present, the size of the Reserved2 data structure\n *           is located by skipping the first 4 bytes of this field\n *           and using the next 2 bytes as the remaining size.  See\n *           the explanation under the Certificate Processing Method\n *           for details on this data structure.\n *\n * VSize - This size value will always include the 4 bytes of the\n *         VCRC32 data and will be greater than 4 bytes.\n *\n * VData - Random data for password validation.  This data is VSize\n *         in length and VSize must be a multiple of the encryption\n *         block size.  VCRC32 is a checksum value of VData.\n *         VData and VCRC32 are stored encrypted and start the\n *         stream of encrypted data for a file.\n * </pre>\n *\n * <p>Reserved1 - Certificate Decryption Header Reserved1 Data:</p>\n *\n * <pre>\n * Value     Size     Description\n * -----     ----     -----------\n * RCount    4 bytes  Number of recipients.\n * </pre>\n *\n * <p>RCount - This defines the number intended recipients whose public keys were\n * used for encryption. This defines the number of elements in the REList field\n * defined below.</p>\n *\n * <p>Reserved2 - Certificate Decryption Header Reserved2 Data Structures:</p>\n *\n * <pre>\n * Value     Size     Description\n * -----     ----     -----------\n * HashAlg   2 bytes  Hash algorithm identifier\n * HSize     2 bytes  Hash size\n * REList    (var)    List of recipient data elements\n *\n * HashAlg - This defines the hash algorithm used to calculate\n *           the public key hash of each public key used\n *           for encryption. This field currently supports\n *           only the following value for SHA-1\n *\n *               0x8004 - SHA1\n *\n * HSize -   This defines the size of a hashed public key\n *           defined in REHData.\n *\n * REList -  This is a variable length of list of recipient data.\n *           Each element in this list consists of a Recipient\n *           Element data structure as follows:\n * </pre>\n *\n * <p>Recipient Element (REList) Data Structure:</p>\n *\n * <pre>\n * Value     Size     Description\n * -----     ----     -----------\n * RESize    2 bytes  Size of REHData + REKData\n * REHData   HSize    Hash of recipients public key\n * REKData   (var)    Simple key blob\n *\n *\n * RESize -  This defines the size of an individual REList\n *           element.  This value is the combined size of the\n *           REHData field + REKData field.  REHData is defined by\n *           HSize.  REKData is variable and can be calculated\n *           for each REList element using RESize and HSize.\n *\n * REHData - Hashed public key for this recipient.\n *\n * REKData - Simple Key Blob.  The format of this data structure\n *           is identical to that defined in the Microsoft\n *           CryptoAPI and generated using the CryptExportKey()\n *           function.  The version of the Simple Key Blob\n *           supported at this time is 0x02 as defined by\n *           Microsoft.\n *\n *           For more details see https://msdn.microsoft.com/en-us/library/aa920051.aspx\n * </pre>\n *\n * <p><b>Flags</b> - Processing flags needed for decryption</p>\n *\n * <ul>\n * <li>0x0001 - Password is required to decrypt</li>\n * <li>0x0002 - Certificates only</li>\n * <li>0x0003 - Password or certificate required to decrypt</li>\n * <li>0x0007 - reserved for future use\n * <li>0x000F - reserved for future use\n * <li>0x0100 - indicates non-OAEP key wrapping was used. If this field is set\n * the version needed to extract must be at least 61. This means OAEP key\n * wrapping is not used when generating a Master Session Key using ErdData.\n * <li>0x4000 - ErdData must be decrypted using 3DES-168, otherwise use the same\n * algorithm used for encrypting the file contents.\n * <li>0x8000 - reserved for future use.\n * </ul>\n *\n * <p><b>See the section describing the Strong Encryption Specification for\n * details. Refer to the section in this document entitled\n * \"Incorporating PKWARE Proprietary Technology into Your Product\" for more\n * information.</b></p>\n *\n * @NotThreadSafe\n * @since 1.11\n */\npublic class X0017_StrongEncryptionHeader extends PKWareExtraHeader {\n\n    public X0017_StrongEncryptionHeader() {\n        super(new ZipShort(0x0017));\n    }\n\n    private int format; // TODO written but not read\n    private EncryptionAlgorithm algId;\n    private int bitlen; // TODO written but not read\n    private int flags; // TODO written but not read\n    private long rcount;\n    private HashAlgorithm hashAlg;\n    private int hashSize;\n\n    // encryption data\n    private byte ivData[];\n    private byte erdData[];\n\n    // encryption key\n    private byte recipientKeyHash[];\n    private byte keyBlob[];\n\n    // password verification data\n    private byte vData[];\n    private byte vCRC32[];\n\n    /**\n     * Get record count.\n     * @return the record count\n     */\n    public long getRecordCount() {\n        return rcount;\n    }\n\n    /**\n     * Get hash algorithm.\n     * @return the hash algorithm\n     */\n    public HashAlgorithm getHashAlgorithm() {\n        return hashAlg;\n    }\n\n    /**\n     * Get encryption algorithm.\n     * @return the encryption algorithm\n     */\n    public EncryptionAlgorithm getEncryptionAlgorithm() {\n        return algId;\n    }\n\n    /**\n     * Parse central directory format.\n     *\n     * @param data the buffer to read data from\n     * @param offset offset into buffer to read data\n     * @param length the length of data\n     */\n    public void parseCentralDirectoryFormat(final byte[] data, final int offset, final int length) {\n        this.format = ZipShort.getValue(data, offset);\n        this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\n        this.bitlen = ZipShort.getValue(data, offset + 4);\n        this.flags = ZipShort.getValue(data, offset + 6);\n        this.rcount = ZipLong.getValue(data, offset + 8);\n\n        if (rcount > 0) {\n            this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12));\n            this.hashSize = ZipShort.getValue(data, offset + 14);\n            // srlist... hashed public keys\n            for (long i = 0; i < this.rcount; i++) {\n                for (int j = 0; j < this.hashSize; j++) {\n                    //  ZipUtil.signedByteToUnsignedInt(data[offset + 16 + (i * this.hashSize) + j]));\n                }\n            }\n        }\n    }\n\n    /**\n     * Parse file header format.\n     *\n     * <p>(Password only?)</p>\n     *\n     * @param data the buffer to read data from\n     * @param offset offset into buffer to read data\n     * @param length the length of data\n     */\n    public void parseFileFormat(final byte[] data, final int offset, final int length) {\n        final int ivSize = ZipShort.getValue(data, offset);\n        this.ivData = new byte[ivSize];\n        System.arraycopy(data, offset + 4, this.ivData, 0, ivSize);\n\n        this.format = ZipShort.getValue(data, offset + ivSize + 6);\n        this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + ivSize + 8));\n        this.bitlen = ZipShort.getValue(data, offset + ivSize + 10);\n        this.flags = ZipShort.getValue(data, offset + ivSize + 12);\n\n        final int erdSize = ZipShort.getValue(data, offset + ivSize + 14);\n        this.erdData = new byte[erdSize];\n        System.arraycopy(data, offset + ivSize + 16, this.erdData, 0, erdSize);\n\n        this.rcount = ZipLong.getValue(data, offset + ivSize + 16 + erdSize);\n        System.out.println(\"rcount: \" + rcount);\n        if (rcount == 0) {\n            final int vSize = ZipShort.getValue(data, offset + ivSize + 20 + erdSize);\n            this.vData = new byte[vSize - 4];\n            this.vCRC32 = new byte[4];\n            System.arraycopy(data, offset + ivSize + 22 + erdSize , this.vData, 0, vSize - 4);\n            System.arraycopy(data, offset + ivSize + 22 + erdSize + vSize - 4, vCRC32, 0, 4);\n        } else {\n            this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + ivSize + 20 + erdSize));\n            this.hashSize = ZipShort.getValue(data, offset + ivSize + 22 + erdSize);\n            final int resize = ZipShort.getValue(data, offset + ivSize + 24 + erdSize);\n            this.recipientKeyHash = new byte[this.hashSize];\n            this.keyBlob = new byte[resize - this.hashSize];\n            System.arraycopy(data, offset + ivSize + 24 + erdSize, this.recipientKeyHash, 0, this.hashSize);\n            System.arraycopy(data, offset + ivSize + 24 + erdSize + this.hashSize, this.keyBlob, 0, resize - this.hashSize);\n\n            final int vSize = ZipShort.getValue(data, offset + ivSize + 26 + erdSize + resize);\n            this.vData = new byte[vSize - 4];\n            this.vCRC32 = new byte[4];\n            System.arraycopy(data, offset + ivSize + 22 + erdSize + resize, this.vData, 0, vSize - 4);\n            System.arraycopy(data, offset + ivSize + 22 + erdSize + resize + vSize - 4, vCRC32, 0, 4);\n        }\n\n        // validate values?\n    }\n\n    @Override\n    public void parseFromLocalFileData(final byte[] data, final int offset, final int length) {\n        super.parseFromLocalFileData(data, offset, length);\n        parseFileFormat(data, offset, length);\n    }\n\n    @Override\n    public void parseFromCentralDirectoryData(final byte[] data, final int offset, final int length) {\n        super.parseFromCentralDirectoryData(data, offset, length);\n        parseCentralDirectoryFormat(data, offset, length);\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-7": {
    "vul_id": "VUL4J-7",
    "cve_id": "CVE-2018-11771",
    "project": "apache_commons-compress",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest#singleByteReadThrowsAtEofForCorruptedStoredEntry,org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest#multiByteReadThrowsAtEofForCorruptedStoredEntry",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/apache/commons-compress/commit/a41ce6892cb0590b2e658704434ac0dbcb6834c8",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java",
        "file_name": "ZipArchiveInputStream.java",
        "vulnerable_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PushbackInputStream;\nimport java.math.BigInteger;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.zip.CRC32;\nimport java.util.zip.DataFormatException;\nimport java.util.zip.Inflater;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipException;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\nimport org.apache.commons.compress.compressors.deflate64.Deflate64CompressorInputStream;\nimport org.apache.commons.compress.utils.ArchiveUtils;\nimport org.apache.commons.compress.utils.IOUtils;\nimport org.apache.commons.compress.utils.InputStreamStatistics;\n\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD;\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC;\n\n/**\n * Implements an input stream that can read Zip archives.\n *\n * <p>As of Apache Commons Compress it transparently supports Zip64\n * extensions and thus individual entries and archives larger than 4\n * GB or with more than 65536 entries.</p>\n *\n * <p>The {@link ZipFile} class is preferred when reading from files\n * as {@link ZipArchiveInputStream} is limited by not being able to\n * read the central directory header before returning entries.  In\n * particular {@link ZipArchiveInputStream}</p>\n *\n * <ul>\n *\n *  <li>may return entries that are not part of the central directory\n *  at all and shouldn't be considered part of the archive.</li>\n *\n *  <li>may return several entries with the same name.</li>\n *\n *  <li>will not return internal or external attributes.</li>\n *\n *  <li>may return incomplete extra field data.</li>\n *\n *  <li>may return unknown sizes and CRC values for entries until the\n *  next entry has been reached if the archive uses the data\n *  descriptor feature.</li>\n *\n * </ul>\n *\n * @see ZipFile\n * @NotThreadSafe\n */\npublic class ZipArchiveInputStream extends ArchiveInputStream implements InputStreamStatistics {\n\n    /** The zip encoding to use for filenames and the file comment. */\n    private final ZipEncoding zipEncoding;\n\n    // the provided encoding (for unit tests)\n    final String encoding;\n\n    /** Whether to look for and use Unicode extra fields. */\n    private final boolean useUnicodeExtraFields;\n\n    /** Wrapped stream, will always be a PushbackInputStream. */\n    private final InputStream in;\n\n    /** Inflater used for all deflated entries. */\n    private final Inflater inf = new Inflater(true);\n\n    /** Buffer used to read from the wrapped stream. */\n    private final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE);\n\n    /** The entry that is currently being read. */\n    private CurrentEntry current = null;\n\n    /** Whether the stream has been closed. */\n    private boolean closed = false;\n\n    /** Whether the stream has reached the central directory - and thus found all entries. */\n    private boolean hitCentralDirectory = false;\n\n    /**\n     * When reading a stored entry that uses the data descriptor this\n     * stream has to read the full entry and caches it.  This is the\n     * cache.\n     */\n    private ByteArrayInputStream lastStoredEntry = null;\n\n    /** Whether the stream will try to read STORED entries that use a data descriptor. */\n    private boolean allowStoredEntriesWithDataDescriptor = false;\n\n    /** Count decompressed bytes for current entry */\n    private long uncompressedCount = 0;\n\n    private static final int LFH_LEN = 30;\n    /*\n      local file header signature     WORD\n      version needed to extract       SHORT\n      general purpose bit flag        SHORT\n      compression method              SHORT\n      last mod file time              SHORT\n      last mod file date              SHORT\n      crc-32                          WORD\n      compressed size                 WORD\n      uncompressed size               WORD\n      file name length                SHORT\n      extra field length              SHORT\n    */\n\n    private static final int CFH_LEN = 46;\n    /*\n        central file header signature   WORD\n        version made by                 SHORT\n        version needed to extract       SHORT\n        general purpose bit flag        SHORT\n        compression method              SHORT\n        last mod file time              SHORT\n        last mod file date              SHORT\n        crc-32                          WORD\n        compressed size                 WORD\n        uncompressed size               WORD\n        file name length                SHORT\n        extra field length              SHORT\n        file comment length             SHORT\n        disk number start               SHORT\n        internal file attributes        SHORT\n        external file attributes        WORD\n        relative offset of local header WORD\n    */\n\n    private static final long TWO_EXP_32 = ZIP64_MAGIC + 1;\n\n    // cached buffers - must only be used locally in the class (COMPRESS-172 - reduce garbage collection)\n    private final byte[] lfhBuf = new byte[LFH_LEN];\n    private final byte[] skipBuf = new byte[1024];\n    private final byte[] shortBuf = new byte[SHORT];\n    private final byte[] wordBuf = new byte[WORD];\n    private final byte[] twoDwordBuf = new byte[2 * DWORD];\n\n    private int entriesRead = 0;\n\n    /**\n     * Create an instance using UTF-8 encoding\n     * @param inputStream the stream to wrap\n     */\n    public ZipArchiveInputStream(final InputStream inputStream) {\n        this(inputStream, ZipEncodingHelper.UTF8);\n    }\n\n    /**\n     * Create an instance using the specified encoding\n     * @param inputStream the stream to wrap\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @since 1.5\n     */\n    public ZipArchiveInputStream(final InputStream inputStream, final String encoding) {\n        this(inputStream, encoding, true);\n    }\n\n    /**\n     * Create an instance using the specified encoding\n     * @param inputStream the stream to wrap\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     */\n    public ZipArchiveInputStream(final InputStream inputStream, final String encoding, final boolean useUnicodeExtraFields) {\n        this(inputStream, encoding, useUnicodeExtraFields, false);\n    }\n\n    /**\n     * Create an instance using the specified encoding\n     * @param inputStream the stream to wrap\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     * @param allowStoredEntriesWithDataDescriptor whether the stream\n     * will try to read STORED entries that use a data descriptor\n     * @since 1.1\n     */\n    public ZipArchiveInputStream(final InputStream inputStream,\n                                 final String encoding,\n                                 final boolean useUnicodeExtraFields,\n                                 final boolean allowStoredEntriesWithDataDescriptor) {\n        this.encoding = encoding;\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n        // haven't read anything so far\n        buf.limit(0);\n    }\n\n    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        uncompressedCount = 0;\n\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n\n        long currentHeaderOffset = getBytesRead();\n        try {\n            if (firstEntry) {\n                // split archives have a special signature before the\n                // first local file header - look for it and fail with\n                // the appropriate error message if this is a split\n                // archive.\n                readFirstLocalFileHeader(lfhBuf);\n            } else {\n                readFully(lfhBuf);\n            }\n        } catch (final EOFException e) {\n            return null;\n        }\n\n        final ZipLong sig = new ZipLong(lfhBuf);\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG) || isApkSigningBlock(lfhBuf)) {\n                hitCentralDirectory = true;\n                skipRemainderOfArchive();\n                return null;\n            }\n            throw new ZipException(String.format(\"Unexpected record signature: 0X%X\", sig.getValue()));\n        }\n\n        int off = WORD;\n        current = new CurrentEntry();\n\n        final int versionMadeBy = ZipShort.getValue(lfhBuf, off);\n        off += SHORT;\n        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(lfhBuf, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n        current.entry.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        current.entry.setMethod(ZipShort.getValue(lfhBuf, off));\n        off += SHORT;\n\n        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfhBuf, off));\n        current.entry.setTime(time);\n        off += WORD;\n\n        ZipLong size = null, cSize = null;\n        if (!current.hasDataDescriptor) {\n            current.entry.setCrc(ZipLong.getValue(lfhBuf, off));\n            off += WORD;\n\n            cSize = new ZipLong(lfhBuf, off);\n            off += WORD;\n\n            size = new ZipLong(lfhBuf, off);\n            off += WORD;\n        } else {\n            off += 3 * WORD;\n        }\n\n        final int fileNameLen = ZipShort.getValue(lfhBuf, off);\n\n        off += SHORT;\n\n        final int extraLen = ZipShort.getValue(lfhBuf, off);\n        off += SHORT; // NOSONAR - assignment as documentation\n\n        final byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        current.entry.setName(entryEncoding.decode(fileName), fileName);\n        if (hasUTF8Flag) {\n            current.entry.setNameSource(ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG);\n        }\n\n        final byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.entry.setExtra(extraData);\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n        }\n\n        processZip64Extra(size, cSize);\n\n        current.entry.setLocalHeaderOffset(currentHeaderOffset);\n        current.entry.setDataOffset(getBytesRead());\n        current.entry.setStreamContiguous(true);\n\n        ZipMethod m = ZipMethod.getMethodByCode(current.entry.getMethod());\n        if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\n            if (ZipUtil.canHandleEntryData(current.entry) && m != ZipMethod.STORED && m != ZipMethod.DEFLATED) {\n                InputStream bis = new BoundedInputStream(in, current.entry.getCompressedSize());\n                switch (m) {\n                case UNSHRINKING:\n                    current.in = new UnshrinkingInputStream(bis);\n                    break;\n                case IMPLODING:\n                    current.in = new ExplodingInputStream(\n                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                        bis);\n                    break;\n                case BZIP2:\n                    current.in = new BZip2CompressorInputStream(bis);\n                    break;\n                case ENHANCED_DEFLATED:\n                    current.in = new Deflate64CompressorInputStream(bis);\n                    break;\n                default:\n                    // we should never get here as all supported methods have been covered\n                    // will cause an error when read is invoked, don't throw an exception here so people can\n                    // skip unsupported entries\n                    break;\n                }\n            }\n        } else if (m == ZipMethod.ENHANCED_DEFLATED) {\n            current.in = new Deflate64CompressorInputStream(in);\n        }\n\n        entriesRead++;\n        return current.entry;\n    }\n\n    /**\n     * Fills the given array with the first local file header and\n     * deals with splitting/spanning markers that may prefix the first\n     * LFH.\n     */\n    private void readFirstLocalFileHeader(final byte[] lfh) throws IOException {\n        readFully(lfh);\n        final ZipLong sig = new ZipLong(lfh);\n        if (sig.equals(ZipLong.DD_SIG)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING);\n        }\n\n        if (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER)) {\n            // The archive is not really split as only one segment was\n            // needed in the end.  Just skip over the marker.\n            final byte[] missedLfhBytes = new byte[4];\n            readFully(missedLfhBytes);\n            System.arraycopy(lfh, 4, lfh, 0, LFH_LEN - 4);\n            System.arraycopy(missedLfhBytes, 0, lfh, LFH_LEN - 4, 4);\n        }\n    }\n\n    /**\n     * Records whether a Zip64 extra is present and sets the size\n     * information from it if sizes are 0xFFFFFFFF and the entry\n     * doesn't use a data descriptor.\n     */\n    private void processZip64Extra(final ZipLong size, final ZipLong cSize) {\n        final Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            current.entry.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        current.usesZip64 = z64 != null;\n        if (!current.hasDataDescriptor) {\n            if (z64 != null // same as current.usesZip64 but avoids NPE warning\n                    && (cSize.equals(ZipLong.ZIP64_MAGIC) || size.equals(ZipLong.ZIP64_MAGIC)) ) {\n                current.entry.setCompressedSize(z64.getCompressedSize().getLongValue());\n                current.entry.setSize(z64.getSize().getLongValue());\n            } else {\n                current.entry.setCompressedSize(cSize.getValue());\n                current.entry.setSize(size.getValue());\n            }\n        }\n    }\n\n    @Override\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextZipEntry();\n    }\n\n    /**\n     * Whether this class is able to read the given entry.\n     *\n     * <p>May return false if it is set up to use encryption or a\n     * compression method that hasn't been implemented yet.</p>\n     * @since 1.1\n     */\n    @Override\n    public boolean canReadEntryData(final ArchiveEntry ae) {\n        if (ae instanceof ZipArchiveEntry) {\n            final ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n            return ZipUtil.canHandleEntryData(ze)\n                && supportsDataDescriptorFor(ze)\n                && supportsCompressedSizeFor(ze);\n        }\n        return false;\n    }\n\n    @Override\n    public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n\n        if (current == null) {\n            return -1;\n        }\n\n        // avoid int overflow, check null buffer\n        if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n\n        ZipUtil.checkRequestedFeatures(current.entry);\n        if (!supportsDataDescriptorFor(current.entry)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR,\n                    current.entry);\n        }\n        if (!supportsCompressedSizeFor(current.entry)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE,\n                    current.entry);\n        }\n\n        int read;\n        if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n            read = readStored(buffer, offset, length);\n        } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n            read = readDeflated(buffer, offset, length);\n        } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()\n                || current.entry.getMethod() == ZipMethod.IMPLODING.getCode()\n                || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode()\n                || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n            read = current.in.read(buffer, offset, length);\n        } else {\n            throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()),\n                    current.entry);\n        }\n\n        if (read >= 0) {\n            current.crc.update(buffer, offset, read);\n            uncompressedCount += read;\n        }\n\n        return read;\n    }\n\n    /**\n     * @since 1.17\n     */\n    @Override\n    public long getCompressedCount() {\n        if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n            return current.bytesRead;\n        } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n            return getBytesInflated();\n        } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n            return ((UnshrinkingInputStream) current.in).getCompressedCount();\n        } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n            return ((ExplodingInputStream) current.in).getCompressedCount();\n        } else if (current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode()) {\n            return ((Deflate64CompressorInputStream) current.in).getCompressedCount();\n        } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n            return ((BZip2CompressorInputStream) current.in).getCompressedCount();\n        } else {\n            return -1;\n        }\n    }\n\n    /**\n     * @since 1.17\n     */\n    @Override\n    public long getUncompressedCount() {\n        return uncompressedCount;\n    }\n\n    /**\n     * Implementation of read for STORED entries.\n     */\n    private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n\n        if (current.hasDataDescriptor) {\n            if (lastStoredEntry == null) {\n                readStoredEntry();\n            }\n            return lastStoredEntry.read(buffer, offset, length);\n        }\n\n        final long csize = current.entry.getSize();\n        if (current.bytesRead >= csize) {\n            return -1;\n        }\n\n        if (buf.position() >= buf.limit()) {\n            buf.position(0);\n            final int l = in.read(buf.array());\n            if (l == -1) {\n                return -1;\n            }\n            buf.limit(l);\n\n            count(l);\n            current.bytesReadFromStream += l;\n        }\n\n        int toRead = Math.min(buf.remaining(), length);\n        if ((csize - current.bytesRead) < toRead) {\n            // if it is smaller than toRead then it fits into an int\n            toRead = (int) (csize - current.bytesRead);\n        }\n        buf.get(buffer, offset, toRead);\n        current.bytesRead += toRead;\n        return toRead;\n    }\n\n    /**\n     * Implementation of read for DEFLATED entries.\n     */\n    private int readDeflated(final byte[] buffer, final int offset, final int length) throws IOException {\n        final int read = readFromInflater(buffer, offset, length);\n        if (read <= 0) {\n            if (inf.finished()) {\n                return -1;\n            } else if (inf.needsDictionary()) {\n                throw new ZipException(\"This archive needs a preset dictionary\"\n                                       + \" which is not supported by Commons\"\n                                       + \" Compress.\");\n            } else if (read == -1) {\n                throw new IOException(\"Truncated ZIP file\");\n            }\n        }\n        return read;\n    }\n\n    /**\n     * Potentially reads more bytes to fill the inflater's buffer and\n     * reads from it.\n     */\n    private int readFromInflater(final byte[] buffer, final int offset, final int length) throws IOException {\n        int read = 0;\n        do {\n            if (inf.needsInput()) {\n                final int l = fill();\n                if (l > 0) {\n                    current.bytesReadFromStream += buf.limit();\n                } else if (l == -1) {\n                    return -1;\n                } else {\n                    break;\n                }\n            }\n            try {\n                read = inf.inflate(buffer, offset, length);\n            } catch (final DataFormatException e) {\n                throw (IOException) new ZipException(e.getMessage()).initCause(e);\n            }\n        } while (read == 0 && inf.needsInput());\n        return read;\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (!closed) {\n            closed = true;\n            try {\n                in.close();\n            } finally {\n                inf.end();\n            }\n        }\n    }\n\n    /**\n     * Skips over and discards value bytes of data from this input\n     * stream.\n     *\n     * <p>This implementation may end up skipping over some smaller\n     * number of bytes, possibly 0, if and only if it reaches the end\n     * of the underlying stream.</p>\n     *\n     * <p>The actual number of bytes skipped is returned.</p>\n     *\n     * @param value the number of bytes to be skipped.\n     * @return the actual number of bytes skipped.\n     * @throws IOException - if an I/O error occurs.\n     * @throws IllegalArgumentException - if value is negative.\n     */\n    @Override\n    public long skip(final long value) throws IOException {\n        if (value >= 0) {\n            long skipped = 0;\n            while (skipped < value) {\n                final long rem = value - skipped;\n                final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n                if (x == -1) {\n                    return skipped;\n                }\n                skipped += x;\n            }\n            return skipped;\n        }\n        throw new IllegalArgumentException();\n    }\n\n    /**\n     * Checks if the signature matches what is expected for a zip file.\n     * Does not currently handle self-extracting zips which may have arbitrary\n     * leading content.\n     *\n     * @param signature the bytes to check\n     * @param length    the number of bytes to check\n     * @return true, if this stream is a zip archive stream, false otherwise\n     */\n    public static boolean matches(final byte[] signature, final int length) {\n        if (length < ZipArchiveOutputStream.LFH_SIG.length) {\n            return false;\n        }\n\n        return checksig(signature, ZipArchiveOutputStream.LFH_SIG) // normal file\n            || checksig(signature, ZipArchiveOutputStream.EOCD_SIG) // empty zip\n            || checksig(signature, ZipArchiveOutputStream.DD_SIG) // split zip\n            || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());\n    }\n\n    private static boolean checksig(final byte[] signature, final byte[] expected) {\n        for (int i = 0; i < expected.length; i++) {\n            if (signature[i] != expected[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Closes the current ZIP archive entry and positions the underlying\n     * stream to the beginning of the next entry. All per-entry variables\n     * and data structures are cleared.\n     * <p>\n     * If the compressed size of this entry is included in the entry header,\n     * then any outstanding bytes are simply skipped from the underlying\n     * stream without uncompressing them. This allows an entry to be safely\n     * closed even if the compression method is unsupported.\n     * <p>\n     * In case we don't know the compressed size of this entry or have\n     * already buffered too much data from the underlying stream to support\n     * uncompression, then the uncompression process is completed and the\n     * end position of the stream is adjusted based on the result of that\n     * process.\n     *\n     * @throws IOException if an error occurs\n     */\n    private void closeEntry() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if (current == null) {\n            return;\n        }\n\n        // Ensure all entry bytes are read\n        if (currentEntryHasOutstandingBytes()) {\n            drainCurrentEntryData();\n        } else {\n            // this is guaranteed to exhaust the stream\n            skip(Long.MAX_VALUE); //NOSONAR\n\n            final long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n                       ? getBytesInflated() : current.bytesRead;\n\n            // this is at most a single read() operation and can't\n            // exceed the range of int\n            final int diff = (int) (current.bytesReadFromStream - inB);\n\n            // Pushback any required bytes\n            if (diff > 0) {\n                pushback(buf.array(), buf.limit() - diff, diff);\n                current.bytesReadFromStream -= diff;\n            }\n\n            // Drain remainder of entry if not all data bytes were required\n            if (currentEntryHasOutstandingBytes()) {\n                drainCurrentEntryData();\n            }\n        }\n\n        if (lastStoredEntry == null && current.hasDataDescriptor) {\n            readDataDescriptor();\n        }\n\n        inf.reset();\n        buf.clear().flip();\n        current = null;\n        lastStoredEntry = null;\n    }\n\n    /**\n     * If the compressed size of the current entry is included in the entry header\n     * and there are any outstanding bytes in the underlying stream, then\n     * this returns true.\n     *\n     * @return true, if current entry is determined to have outstanding bytes, false otherwise\n     */\n    private boolean currentEntryHasOutstandingBytes() {\n        return current.bytesReadFromStream <= current.entry.getCompressedSize()\n                && !current.hasDataDescriptor;\n    }\n\n    /**\n     * Read all data of the current entry from the underlying stream\n     * that hasn't been read, yet.\n     */\n    private void drainCurrentEntryData() throws IOException {\n        long remaining = current.entry.getCompressedSize() - current.bytesReadFromStream;\n        while (remaining > 0) {\n            final long n = in.read(buf.array(), 0, (int) Math.min(buf.capacity(), remaining));\n            if (n < 0) {\n                throw new EOFException(\"Truncated ZIP entry: \"\n                                       + ArchiveUtils.sanitize(current.entry.getName()));\n            }\n            count(n);\n            remaining -= n;\n        }\n    }\n\n    /**\n     * Get the number of bytes Inflater has actually processed.\n     *\n     * <p>for Java &lt; Java7 the getBytes* methods in\n     * Inflater/Deflater seem to return unsigned ints rather than\n     * longs that start over with 0 at 2^32.</p>\n     *\n     * <p>The stream knows how many bytes it has read, but not how\n     * many the Inflater actually consumed - it should be between the\n     * total number of bytes read for the entry and the total number\n     * minus the last read operation.  Here we just try to make the\n     * value close enough to the bytes we've read by assuming the\n     * number of bytes consumed must be smaller than (or equal to) the\n     * number of bytes read but not smaller by more than 2^32.</p>\n     */\n    private long getBytesInflated() {\n        long inB = inf.getBytesRead();\n        if (current.bytesReadFromStream >= TWO_EXP_32) {\n            while (inB + TWO_EXP_32 <= current.bytesReadFromStream) {\n                inB += TWO_EXP_32;\n            }\n        }\n        return inB;\n    }\n\n    private int fill() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        final int length = in.read(buf.array());\n        if (length > 0) {\n            buf.limit(length);\n            count(buf.limit());\n            inf.setInput(buf.array(), 0, buf.limit());\n        }\n        return length;\n    }\n\n    private void readFully(final byte[] b) throws IOException {\n        readFully(b, 0);\n    }\n\n    private void readFully(final byte[] b, final int off) throws IOException {\n        final int len = b.length - off;\n        final int count = IOUtils.readFully(in, b, off, len);\n        count(count);\n        if (count < len) {\n            throw new EOFException();\n        }\n    }\n\n    private void readDataDescriptor() throws IOException {\n        readFully(wordBuf);\n        ZipLong val = new ZipLong(wordBuf);\n        if (ZipLong.DD_SIG.equals(val)) {\n            // data descriptor with signature, skip sig\n            readFully(wordBuf);\n            val = new ZipLong(wordBuf);\n        }\n        current.entry.setCrc(val.getValue());\n\n        // if there is a ZIP64 extra field, sizes are eight bytes\n        // each, otherwise four bytes each.  Unfortunately some\n        // implementations - namely Java7 - use eight bytes without\n        // using a ZIP64 extra field -\n        // https://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7073588\n\n        // just read 16 bytes and check whether bytes nine to twelve\n        // look like one of the signatures of what could follow a data\n        // descriptor (ignoring archive decryption headers for now).\n        // If so, push back eight bytes and assume sizes are four\n        // bytes, otherwise sizes are eight bytes each.\n        readFully(twoDwordBuf);\n        final ZipLong potentialSig = new ZipLong(twoDwordBuf, DWORD);\n        if (potentialSig.equals(ZipLong.CFH_SIG) || potentialSig.equals(ZipLong.LFH_SIG)) {\n            pushback(twoDwordBuf, DWORD, DWORD);\n            current.entry.setCompressedSize(ZipLong.getValue(twoDwordBuf));\n            current.entry.setSize(ZipLong.getValue(twoDwordBuf, WORD));\n        } else {\n            current.entry.setCompressedSize(ZipEightByteInteger.getLongValue(twoDwordBuf));\n            current.entry.setSize(ZipEightByteInteger.getLongValue(twoDwordBuf, DWORD));\n        }\n    }\n\n    /**\n     * Whether this entry requires a data descriptor this library can work with.\n     *\n     * @return true if allowStoredEntriesWithDataDescriptor is true,\n     * the entry doesn't require any data descriptor or the method is\n     * DEFLATED or ENHANCED_DEFLATED.\n     */\n    private boolean supportsDataDescriptorFor(final ZipArchiveEntry entry) {\n        return !entry.getGeneralPurposeBit().usesDataDescriptor()\n\n                || (allowStoredEntriesWithDataDescriptor && entry.getMethod() == ZipEntry.STORED)\n                || entry.getMethod() == ZipEntry.DEFLATED\n                || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode();\n    }\n\n    /**\n     * Whether the compressed size for the entry is either known or\n     * not required by the compression method being used.\n     */\n    private boolean supportsCompressedSizeFor(final ZipArchiveEntry entry) {\n        return entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN\n            || entry.getMethod() == ZipEntry.DEFLATED\n            || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode()\n            || (entry.getGeneralPurposeBit().usesDataDescriptor()\n                && allowStoredEntriesWithDataDescriptor\n                && entry.getMethod() == ZipEntry.STORED);\n    }\n\n    /**\n     * Caches a stored entry that uses the data descriptor.\n     *\n     * <ul>\n     *   <li>Reads a stored entry until the signature of a local file\n     *     header, central directory header or data descriptor has been\n     *     found.</li>\n     *   <li>Stores all entry data in lastStoredEntry.</p>\n     *   <li>Rewinds the stream to position at the data\n     *     descriptor.</li>\n     *   <li>reads the data descriptor</li>\n     * </ul>\n     *\n     * <p>After calling this method the entry should know its size,\n     * the entry's data is cached and the stream is positioned at the\n     * next local file or central directory header.</p>\n     */\n    private void readStoredEntry() throws IOException {\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        int off = 0;\n        boolean done = false;\n\n        // length of DD without signature\n        final int ddLen = current.usesZip64 ? WORD + 2 * DWORD : 3 * WORD;\n\n        while (!done) {\n            final int r = in.read(buf.array(), off, ZipArchiveOutputStream.BUFFER_SIZE - off);\n            if (r <= 0) {\n                // read the whole archive without ever finding a\n                // central directory\n                throw new IOException(\"Truncated ZIP file\");\n            }\n            if (r + off < 4) {\n                // buffer too small to check for a signature, loop\n                off += r;\n                continue;\n            }\n\n            done = bufferContainsSignature(bos, off, r, ddLen);\n            if (!done) {\n                off = cacheBytesRead(bos, off, r, ddLen);\n            }\n        }\n\n        final byte[] b = bos.toByteArray();\n        lastStoredEntry = new ByteArrayInputStream(b);\n    }\n\n    private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\n    private static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\n    private static final byte[] DD = ZipLong.DD_SIG.getBytes();\n\n    /**\n     * Checks whether the current buffer contains the signature of a\n     * &quot;data descriptor&quot;, &quot;local file header&quot; or\n     * &quot;central directory entry&quot;.\n     *\n     * <p>If it contains such a signature, reads the data descriptor\n     * and positions the stream right after the data descriptor.</p>\n     */\n    private boolean bufferContainsSignature(final ByteArrayOutputStream bos, final int offset, final int lastRead, final int expectedDDLen)\n            throws IOException {\n\n        boolean done = false;\n        int readTooMuch = 0;\n        for (int i = 0; !done && i < offset + lastRead - 4; i++) {\n            if (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {\n                if ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3])\n                    || (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {\n                    // found a LFH or CFH:\n                    readTooMuch = offset + lastRead - i - expectedDDLen;\n                    done = true;\n                }\n                else if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {\n                    // found DD:\n                    readTooMuch = offset + lastRead - i;\n                    done = true;\n                }\n                if (done) {\n                    // * push back bytes read in excess as well as the data\n                    //   descriptor\n                    // * copy the remaining bytes to cache\n                    // * read data descriptor\n                    pushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);\n                    bos.write(buf.array(), 0, i);\n                    readDataDescriptor();\n                }\n            }\n        }\n        return done;\n    }\n\n    /**\n     * If the last read bytes could hold a data descriptor and an\n     * incomplete signature then save the last bytes to the front of\n     * the buffer and cache everything in front of the potential data\n     * descriptor into the given ByteArrayOutputStream.\n     *\n     * <p>Data descriptor plus incomplete signature (3 bytes in the\n     * worst case) can be 20 bytes max.</p>\n     */\n    private int cacheBytesRead(final ByteArrayOutputStream bos, int offset, final int lastRead, final int expecteDDLen) {\n        final int cacheable = offset + lastRead - expecteDDLen - 3;\n        if (cacheable > 0) {\n            bos.write(buf.array(), 0, cacheable);\n            System.arraycopy(buf.array(), cacheable, buf.array(), 0, expecteDDLen + 3);\n            offset = expecteDDLen + 3;\n        } else {\n            offset += lastRead;\n        }\n        return offset;\n    }\n\n    private void pushback(final byte[] buf, final int offset, final int length) throws IOException {\n        ((PushbackInputStream) in).unread(buf, offset, length);\n        pushedBackBytes(length);\n    }\n\n    // End of Central Directory Record\n    //   end of central dir signature    WORD\n    //   number of this disk             SHORT\n    //   number of the disk with the\n    //   start of the central directory  SHORT\n    //   total number of entries in the\n    //   central directory on this disk  SHORT\n    //   total number of entries in\n    //   the central directory           SHORT\n    //   size of the central directory   WORD\n    //   offset of start of central\n    //   directory with respect to\n    //   the starting disk number        WORD\n    //   .ZIP file comment length        SHORT\n    //   .ZIP file comment               up to 64KB\n    //\n\n    /**\n     * Reads the stream until it find the \"End of central directory\n     * record\" and consumes it as well.\n     */\n    private void skipRemainderOfArchive() throws IOException {\n        // skip over central directory. One LFH has been read too much\n        // already.  The calculation discounts file names and extra\n        // data so it will be too short.\n        realSkip((long) entriesRead * CFH_LEN - LFH_LEN);\n        findEocdRecord();\n        realSkip((long) ZipFile.MIN_EOCD_SIZE - WORD /* signature */ - SHORT /* comment len */);\n        readFully(shortBuf);\n        // file comment\n        realSkip(ZipShort.getValue(shortBuf));\n    }\n\n    /**\n     * Reads forward until the signature of the &quot;End of central\n     * directory&quot; record is found.\n     */\n    private void findEocdRecord() throws IOException {\n        int currentByte = -1;\n        boolean skipReadCall = false;\n        while (skipReadCall || (currentByte = readOneByte()) > -1) {\n            skipReadCall = false;\n            if (!isFirstByteOfEocdSig(currentByte)) {\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[1]) {\n                if (currentByte == -1) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[2]) {\n                if (currentByte == -1) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte == -1\n                || currentByte == ZipArchiveOutputStream.EOCD_SIG[3]) {\n                break;\n            }\n            skipReadCall = isFirstByteOfEocdSig(currentByte);\n        }\n    }\n\n    /**\n     * Skips bytes by reading from the underlying stream rather than\n     * the (potentially inflating) archive stream - which {@link\n     * #skip} would do.\n     *\n     * Also updates bytes-read counter.\n     */\n    private void realSkip(final long value) throws IOException {\n        if (value >= 0) {\n            long skipped = 0;\n            while (skipped < value) {\n                final long rem = value - skipped;\n                final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n                if (x == -1) {\n                    return;\n                }\n                count(x);\n                skipped += x;\n            }\n            return;\n        }\n        throw new IllegalArgumentException();\n    }\n\n    /**\n     * Reads bytes by reading from the underlying stream rather than\n     * the (potentially inflating) archive stream - which {@link #read} would do.\n     *\n     * Also updates bytes-read counter.\n     */\n    private int readOneByte() throws IOException {\n        final int b = in.read();\n        if (b != -1) {\n            count(1);\n        }\n        return b;\n    }\n\n    private boolean isFirstByteOfEocdSig(final int b) {\n        return b == ZipArchiveOutputStream.EOCD_SIG[0];\n    }\n\n    private static final byte[] APK_SIGNING_BLOCK_MAGIC = new byte[] {\n        'A', 'P', 'K', ' ', 'S', 'i', 'g', ' ', 'B', 'l', 'o', 'c', 'k', ' ', '4', '2',\n    };\n    private static final BigInteger LONG_MAX = BigInteger.valueOf(Long.MAX_VALUE);\n\n    /**\n     * Checks whether this might be an APK Signing Block.\n     *\n     * <p>Unfortunately the APK signing block does not start with some kind of signature, it rather ends with one. It\n     * starts with a length, so what we do is parse the suspect length, skip ahead far enough, look for the signature\n     * and if we've found it, return true.</p>\n     *\n     * @param suspectLocalFileHeader the bytes read from the underlying stream in the expectation that they would hold\n     * the local file header of the next entry.\n     *\n     * @return true if this looks like a APK signing block\n     *\n     * @see <a href=\"https://source.android.com/security/apksigning/v2\">https://source.android.com/security/apksigning/v2</a>\n     */\n    private boolean isApkSigningBlock(byte[] suspectLocalFileHeader) throws IOException {\n        // length of block excluding the size field itself\n        BigInteger len = ZipEightByteInteger.getValue(suspectLocalFileHeader);\n        // LFH has already been read and all but the first eight bytes contain (part of) the APK signing block,\n        // also subtract 16 bytes in order to position us at the magic string\n        BigInteger toSkip = len.add(BigInteger.valueOf(DWORD - suspectLocalFileHeader.length\n            - APK_SIGNING_BLOCK_MAGIC.length));\n        byte[] magic = new byte[APK_SIGNING_BLOCK_MAGIC.length];\n\n        try {\n            if (toSkip.signum() < 0) {\n                // suspectLocalFileHeader contains the start of suspect magic string\n                int off = suspectLocalFileHeader.length + toSkip.intValue();\n                // length was shorter than magic length\n                if (off < DWORD) {\n                    return false;\n                }\n                int bytesInBuffer = Math.abs(toSkip.intValue());\n                System.arraycopy(suspectLocalFileHeader, off, magic, 0, Math.min(bytesInBuffer, magic.length));\n                if (bytesInBuffer < magic.length) {\n                    readFully(magic, bytesInBuffer);\n                }\n            } else {\n                while (toSkip.compareTo(LONG_MAX) > 0) {\n                    realSkip(Long.MAX_VALUE);\n                    toSkip = toSkip.add(LONG_MAX.negate());\n                }\n                realSkip(toSkip.longValue());\n                readFully(magic);\n            }\n        } catch (EOFException ex) {\n            // length was invalid\n            return false;\n        }\n        return Arrays.equals(magic, APK_SIGNING_BLOCK_MAGIC);\n    }\n\n    /**\n     * Structure collecting information for the entry that is\n     * currently being read.\n     */\n    private static final class CurrentEntry {\n\n        /**\n         * Current ZIP entry.\n         */\n        private final ZipArchiveEntry entry = new ZipArchiveEntry();\n\n        /**\n         * Does the entry use a data descriptor?\n         */\n        private boolean hasDataDescriptor;\n\n        /**\n         * Does the entry have a ZIP64 extended information extra field.\n         */\n        private boolean usesZip64;\n\n        /**\n         * Number of bytes of entry content read by the client if the\n         * entry is STORED.\n         */\n        private long bytesRead;\n\n        /**\n         * Number of bytes of entry content read from the stream.\n         *\n         * <p>This may be more than the actual entry's length as some\n         * stuff gets buffered up and needs to be pushed back when the\n         * end of the entry has been reached.</p>\n         */\n        private long bytesReadFromStream;\n\n        /**\n         * The checksum calculated as the current entry is read.\n         */\n        private final CRC32 crc = new CRC32();\n\n        /**\n         * The input stream decompressing the data for shrunk and imploded entries.\n         */\n        private InputStream in;\n    }\n\n    /**\n     * Bounded input stream adapted from commons-io\n     */\n    private class BoundedInputStream extends InputStream {\n\n        /** the wrapped input stream */\n        private final InputStream in;\n\n        /** the max length to provide */\n        private final long max;\n\n        /** the number of bytes already returned */\n        private long pos = 0;\n\n        /**\n         * Creates a new <code>BoundedInputStream</code> that wraps the given input\n         * stream and limits it to a certain size.\n         *\n         * @param in The wrapped input stream\n         * @param size The maximum number of bytes to return\n         */\n        public BoundedInputStream(final InputStream in, final long size) {\n            this.max = size;\n            this.in = in;\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (max >= 0 && pos >= max) {\n                return -1;\n            }\n            final int result = in.read();\n            pos++;\n            count(1);\n            current.bytesReadFromStream++;\n            return result;\n        }\n\n        @Override\n        public int read(final byte[] b) throws IOException {\n            return this.read(b, 0, b.length);\n        }\n\n        @Override\n        public int read(final byte[] b, final int off, final int len) throws IOException {\n            if (max >= 0 && pos >= max) {\n                return -1;\n            }\n            final long maxRead = max >= 0 ? Math.min(len, max - pos) : len;\n            final int bytesRead = in.read(b, off, (int) maxRead);\n\n            if (bytesRead == -1) {\n                return -1;\n            }\n\n            pos += bytesRead;\n            count(bytesRead);\n            current.bytesReadFromStream += bytesRead;\n            return bytesRead;\n        }\n\n        @Override\n        public long skip(final long n) throws IOException {\n            final long toSkip = max >= 0 ? Math.min(n, max - pos) : n;\n            final long skippedBytes = IOUtils.skip(in, toSkip);\n            pos += skippedBytes;\n            return skippedBytes;\n        }\n\n        @Override\n        public int available() throws IOException {\n            if (max >= 0 && pos >= max) {\n                return 0;\n            }\n            return in.available();\n        }\n    }\n}\n",
        "human_patch_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PushbackInputStream;\nimport java.math.BigInteger;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.zip.CRC32;\nimport java.util.zip.DataFormatException;\nimport java.util.zip.Inflater;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipException;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\nimport org.apache.commons.compress.compressors.deflate64.Deflate64CompressorInputStream;\nimport org.apache.commons.compress.utils.ArchiveUtils;\nimport org.apache.commons.compress.utils.IOUtils;\nimport org.apache.commons.compress.utils.InputStreamStatistics;\n\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD;\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC;\n\n/**\n * Implements an input stream that can read Zip archives.\n *\n * <p>As of Apache Commons Compress it transparently supports Zip64\n * extensions and thus individual entries and archives larger than 4\n * GB or with more than 65536 entries.</p>\n *\n * <p>The {@link ZipFile} class is preferred when reading from files\n * as {@link ZipArchiveInputStream} is limited by not being able to\n * read the central directory header before returning entries.  In\n * particular {@link ZipArchiveInputStream}</p>\n *\n * <ul>\n *\n *  <li>may return entries that are not part of the central directory\n *  at all and shouldn't be considered part of the archive.</li>\n *\n *  <li>may return several entries with the same name.</li>\n *\n *  <li>will not return internal or external attributes.</li>\n *\n *  <li>may return incomplete extra field data.</li>\n *\n *  <li>may return unknown sizes and CRC values for entries until the\n *  next entry has been reached if the archive uses the data\n *  descriptor feature.</li>\n *\n * </ul>\n *\n * @see ZipFile\n * @NotThreadSafe\n */\npublic class ZipArchiveInputStream extends ArchiveInputStream implements InputStreamStatistics {\n\n    /** The zip encoding to use for filenames and the file comment. */\n    private final ZipEncoding zipEncoding;\n\n    // the provided encoding (for unit tests)\n    final String encoding;\n\n    /** Whether to look for and use Unicode extra fields. */\n    private final boolean useUnicodeExtraFields;\n\n    /** Wrapped stream, will always be a PushbackInputStream. */\n    private final InputStream in;\n\n    /** Inflater used for all deflated entries. */\n    private final Inflater inf = new Inflater(true);\n\n    /** Buffer used to read from the wrapped stream. */\n    private final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE);\n\n    /** The entry that is currently being read. */\n    private CurrentEntry current = null;\n\n    /** Whether the stream has been closed. */\n    private boolean closed = false;\n\n    /** Whether the stream has reached the central directory - and thus found all entries. */\n    private boolean hitCentralDirectory = false;\n\n    /**\n     * When reading a stored entry that uses the data descriptor this\n     * stream has to read the full entry and caches it.  This is the\n     * cache.\n     */\n    private ByteArrayInputStream lastStoredEntry = null;\n\n    /** Whether the stream will try to read STORED entries that use a data descriptor. */\n    private boolean allowStoredEntriesWithDataDescriptor = false;\n\n    /** Count decompressed bytes for current entry */\n    private long uncompressedCount = 0;\n\n    private static final int LFH_LEN = 30;\n    /*\n      local file header signature     WORD\n      version needed to extract       SHORT\n      general purpose bit flag        SHORT\n      compression method              SHORT\n      last mod file time              SHORT\n      last mod file date              SHORT\n      crc-32                          WORD\n      compressed size                 WORD\n      uncompressed size               WORD\n      file name length                SHORT\n      extra field length              SHORT\n    */\n\n    private static final int CFH_LEN = 46;\n    /*\n        central file header signature   WORD\n        version made by                 SHORT\n        version needed to extract       SHORT\n        general purpose bit flag        SHORT\n        compression method              SHORT\n        last mod file time              SHORT\n        last mod file date              SHORT\n        crc-32                          WORD\n        compressed size                 WORD\n        uncompressed size               WORD\n        file name length                SHORT\n        extra field length              SHORT\n        file comment length             SHORT\n        disk number start               SHORT\n        internal file attributes        SHORT\n        external file attributes        WORD\n        relative offset of local header WORD\n    */\n\n    private static final long TWO_EXP_32 = ZIP64_MAGIC + 1;\n\n    // cached buffers - must only be used locally in the class (COMPRESS-172 - reduce garbage collection)\n    private final byte[] lfhBuf = new byte[LFH_LEN];\n    private final byte[] skipBuf = new byte[1024];\n    private final byte[] shortBuf = new byte[SHORT];\n    private final byte[] wordBuf = new byte[WORD];\n    private final byte[] twoDwordBuf = new byte[2 * DWORD];\n\n    private int entriesRead = 0;\n\n    /**\n     * Create an instance using UTF-8 encoding\n     * @param inputStream the stream to wrap\n     */\n    public ZipArchiveInputStream(final InputStream inputStream) {\n        this(inputStream, ZipEncodingHelper.UTF8);\n    }\n\n    /**\n     * Create an instance using the specified encoding\n     * @param inputStream the stream to wrap\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @since 1.5\n     */\n    public ZipArchiveInputStream(final InputStream inputStream, final String encoding) {\n        this(inputStream, encoding, true);\n    }\n\n    /**\n     * Create an instance using the specified encoding\n     * @param inputStream the stream to wrap\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     */\n    public ZipArchiveInputStream(final InputStream inputStream, final String encoding, final boolean useUnicodeExtraFields) {\n        this(inputStream, encoding, useUnicodeExtraFields, false);\n    }\n\n    /**\n     * Create an instance using the specified encoding\n     * @param inputStream the stream to wrap\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     * @param allowStoredEntriesWithDataDescriptor whether the stream\n     * will try to read STORED entries that use a data descriptor\n     * @since 1.1\n     */\n    public ZipArchiveInputStream(final InputStream inputStream,\n                                 final String encoding,\n                                 final boolean useUnicodeExtraFields,\n                                 final boolean allowStoredEntriesWithDataDescriptor) {\n        this.encoding = encoding;\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n        // haven't read anything so far\n        buf.limit(0);\n    }\n\n    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        uncompressedCount = 0;\n\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n\n        long currentHeaderOffset = getBytesRead();\n        try {\n            if (firstEntry) {\n                // split archives have a special signature before the\n                // first local file header - look for it and fail with\n                // the appropriate error message if this is a split\n                // archive.\n                readFirstLocalFileHeader(lfhBuf);\n            } else {\n                readFully(lfhBuf);\n            }\n        } catch (final EOFException e) {\n            return null;\n        }\n\n        final ZipLong sig = new ZipLong(lfhBuf);\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG) || isApkSigningBlock(lfhBuf)) {\n                hitCentralDirectory = true;\n                skipRemainderOfArchive();\n                return null;\n            }\n            throw new ZipException(String.format(\"Unexpected record signature: 0X%X\", sig.getValue()));\n        }\n\n        int off = WORD;\n        current = new CurrentEntry();\n\n        final int versionMadeBy = ZipShort.getValue(lfhBuf, off);\n        off += SHORT;\n        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(lfhBuf, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n        current.entry.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        current.entry.setMethod(ZipShort.getValue(lfhBuf, off));\n        off += SHORT;\n\n        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfhBuf, off));\n        current.entry.setTime(time);\n        off += WORD;\n\n        ZipLong size = null, cSize = null;\n        if (!current.hasDataDescriptor) {\n            current.entry.setCrc(ZipLong.getValue(lfhBuf, off));\n            off += WORD;\n\n            cSize = new ZipLong(lfhBuf, off);\n            off += WORD;\n\n            size = new ZipLong(lfhBuf, off);\n            off += WORD;\n        } else {\n            off += 3 * WORD;\n        }\n\n        final int fileNameLen = ZipShort.getValue(lfhBuf, off);\n\n        off += SHORT;\n\n        final int extraLen = ZipShort.getValue(lfhBuf, off);\n        off += SHORT; // NOSONAR - assignment as documentation\n\n        final byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        current.entry.setName(entryEncoding.decode(fileName), fileName);\n        if (hasUTF8Flag) {\n            current.entry.setNameSource(ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG);\n        }\n\n        final byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.entry.setExtra(extraData);\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n        }\n\n        processZip64Extra(size, cSize);\n\n        current.entry.setLocalHeaderOffset(currentHeaderOffset);\n        current.entry.setDataOffset(getBytesRead());\n        current.entry.setStreamContiguous(true);\n\n        ZipMethod m = ZipMethod.getMethodByCode(current.entry.getMethod());\n        if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\n            if (ZipUtil.canHandleEntryData(current.entry) && m != ZipMethod.STORED && m != ZipMethod.DEFLATED) {\n                InputStream bis = new BoundedInputStream(in, current.entry.getCompressedSize());\n                switch (m) {\n                case UNSHRINKING:\n                    current.in = new UnshrinkingInputStream(bis);\n                    break;\n                case IMPLODING:\n                    current.in = new ExplodingInputStream(\n                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                        bis);\n                    break;\n                case BZIP2:\n                    current.in = new BZip2CompressorInputStream(bis);\n                    break;\n                case ENHANCED_DEFLATED:\n                    current.in = new Deflate64CompressorInputStream(bis);\n                    break;\n                default:\n                    // we should never get here as all supported methods have been covered\n                    // will cause an error when read is invoked, don't throw an exception here so people can\n                    // skip unsupported entries\n                    break;\n                }\n            }\n        } else if (m == ZipMethod.ENHANCED_DEFLATED) {\n            current.in = new Deflate64CompressorInputStream(in);\n        }\n\n        entriesRead++;\n        return current.entry;\n    }\n\n    /**\n     * Fills the given array with the first local file header and\n     * deals with splitting/spanning markers that may prefix the first\n     * LFH.\n     */\n    private void readFirstLocalFileHeader(final byte[] lfh) throws IOException {\n        readFully(lfh);\n        final ZipLong sig = new ZipLong(lfh);\n        if (sig.equals(ZipLong.DD_SIG)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING);\n        }\n\n        if (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER)) {\n            // The archive is not really split as only one segment was\n            // needed in the end.  Just skip over the marker.\n            final byte[] missedLfhBytes = new byte[4];\n            readFully(missedLfhBytes);\n            System.arraycopy(lfh, 4, lfh, 0, LFH_LEN - 4);\n            System.arraycopy(missedLfhBytes, 0, lfh, LFH_LEN - 4, 4);\n        }\n    }\n\n    /**\n     * Records whether a Zip64 extra is present and sets the size\n     * information from it if sizes are 0xFFFFFFFF and the entry\n     * doesn't use a data descriptor.\n     */\n    private void processZip64Extra(final ZipLong size, final ZipLong cSize) {\n        final Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            current.entry.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        current.usesZip64 = z64 != null;\n        if (!current.hasDataDescriptor) {\n            if (z64 != null // same as current.usesZip64 but avoids NPE warning\n                    && (cSize.equals(ZipLong.ZIP64_MAGIC) || size.equals(ZipLong.ZIP64_MAGIC)) ) {\n                current.entry.setCompressedSize(z64.getCompressedSize().getLongValue());\n                current.entry.setSize(z64.getSize().getLongValue());\n            } else {\n                current.entry.setCompressedSize(cSize.getValue());\n                current.entry.setSize(size.getValue());\n            }\n        }\n    }\n\n    @Override\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextZipEntry();\n    }\n\n    /**\n     * Whether this class is able to read the given entry.\n     *\n     * <p>May return false if it is set up to use encryption or a\n     * compression method that hasn't been implemented yet.</p>\n     * @since 1.1\n     */\n    @Override\n    public boolean canReadEntryData(final ArchiveEntry ae) {\n        if (ae instanceof ZipArchiveEntry) {\n            final ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n            return ZipUtil.canHandleEntryData(ze)\n                && supportsDataDescriptorFor(ze)\n                && supportsCompressedSizeFor(ze);\n        }\n        return false;\n    }\n\n    @Override\n    public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n\n        if (current == null) {\n            return -1;\n        }\n\n        // avoid int overflow, check null buffer\n        if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n\n        ZipUtil.checkRequestedFeatures(current.entry);\n        if (!supportsDataDescriptorFor(current.entry)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR,\n                    current.entry);\n        }\n        if (!supportsCompressedSizeFor(current.entry)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE,\n                    current.entry);\n        }\n\n        int read;\n        if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n            read = readStored(buffer, offset, length);\n        } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n            read = readDeflated(buffer, offset, length);\n        } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()\n                || current.entry.getMethod() == ZipMethod.IMPLODING.getCode()\n                || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode()\n                || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n            read = current.in.read(buffer, offset, length);\n        } else {\n            throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()),\n                    current.entry);\n        }\n\n        if (read >= 0) {\n            current.crc.update(buffer, offset, read);\n            uncompressedCount += read;\n        }\n\n        return read;\n    }\n\n    /**\n     * @since 1.17\n     */\n    @Override\n    public long getCompressedCount() {\n        if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n            return current.bytesRead;\n        } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n            return getBytesInflated();\n        } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n            return ((UnshrinkingInputStream) current.in).getCompressedCount();\n        } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n            return ((ExplodingInputStream) current.in).getCompressedCount();\n        } else if (current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode()) {\n            return ((Deflate64CompressorInputStream) current.in).getCompressedCount();\n        } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n            return ((BZip2CompressorInputStream) current.in).getCompressedCount();\n        } else {\n            return -1;\n        }\n    }\n\n    /**\n     * @since 1.17\n     */\n    @Override\n    public long getUncompressedCount() {\n        return uncompressedCount;\n    }\n\n    /**\n     * Implementation of read for STORED entries.\n     */\n    private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n\n        if (current.hasDataDescriptor) {\n            if (lastStoredEntry == null) {\n                readStoredEntry();\n            }\n            return lastStoredEntry.read(buffer, offset, length);\n        }\n\n        final long csize = current.entry.getSize();\n        if (current.bytesRead >= csize) {\n            return -1;\n        }\n\n        if (buf.position() >= buf.limit()) {\n            buf.position(0);\n            final int l = in.read(buf.array());\n            if (l == -1) {\n                buf.limit(0);\n                throw new IOException(\"Truncated ZIP file\");\n            }\n            buf.limit(l);\n\n            count(l);\n            current.bytesReadFromStream += l;\n        }\n\n        int toRead = Math.min(buf.remaining(), length);\n        if ((csize - current.bytesRead) < toRead) {\n            // if it is smaller than toRead then it fits into an int\n            toRead = (int) (csize - current.bytesRead);\n        }\n        buf.get(buffer, offset, toRead);\n        current.bytesRead += toRead;\n        return toRead;\n    }\n\n    /**\n     * Implementation of read for DEFLATED entries.\n     */\n    private int readDeflated(final byte[] buffer, final int offset, final int length) throws IOException {\n        final int read = readFromInflater(buffer, offset, length);\n        if (read <= 0) {\n            if (inf.finished()) {\n                return -1;\n            } else if (inf.needsDictionary()) {\n                throw new ZipException(\"This archive needs a preset dictionary\"\n                                       + \" which is not supported by Commons\"\n                                       + \" Compress.\");\n            } else if (read == -1) {\n                throw new IOException(\"Truncated ZIP file\");\n            }\n        }\n        return read;\n    }\n\n    /**\n     * Potentially reads more bytes to fill the inflater's buffer and\n     * reads from it.\n     */\n    private int readFromInflater(final byte[] buffer, final int offset, final int length) throws IOException {\n        int read = 0;\n        do {\n            if (inf.needsInput()) {\n                final int l = fill();\n                if (l > 0) {\n                    current.bytesReadFromStream += buf.limit();\n                } else if (l == -1) {\n                    return -1;\n                } else {\n                    break;\n                }\n            }\n            try {\n                read = inf.inflate(buffer, offset, length);\n            } catch (final DataFormatException e) {\n                throw (IOException) new ZipException(e.getMessage()).initCause(e);\n            }\n        } while (read == 0 && inf.needsInput());\n        return read;\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (!closed) {\n            closed = true;\n            try {\n                in.close();\n            } finally {\n                inf.end();\n            }\n        }\n    }\n\n    /**\n     * Skips over and discards value bytes of data from this input\n     * stream.\n     *\n     * <p>This implementation may end up skipping over some smaller\n     * number of bytes, possibly 0, if and only if it reaches the end\n     * of the underlying stream.</p>\n     *\n     * <p>The actual number of bytes skipped is returned.</p>\n     *\n     * @param value the number of bytes to be skipped.\n     * @return the actual number of bytes skipped.\n     * @throws IOException - if an I/O error occurs.\n     * @throws IllegalArgumentException - if value is negative.\n     */\n    @Override\n    public long skip(final long value) throws IOException {\n        if (value >= 0) {\n            long skipped = 0;\n            while (skipped < value) {\n                final long rem = value - skipped;\n                final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n                if (x == -1) {\n                    return skipped;\n                }\n                skipped += x;\n            }\n            return skipped;\n        }\n        throw new IllegalArgumentException();\n    }\n\n    /**\n     * Checks if the signature matches what is expected for a zip file.\n     * Does not currently handle self-extracting zips which may have arbitrary\n     * leading content.\n     *\n     * @param signature the bytes to check\n     * @param length    the number of bytes to check\n     * @return true, if this stream is a zip archive stream, false otherwise\n     */\n    public static boolean matches(final byte[] signature, final int length) {\n        if (length < ZipArchiveOutputStream.LFH_SIG.length) {\n            return false;\n        }\n\n        return checksig(signature, ZipArchiveOutputStream.LFH_SIG) // normal file\n            || checksig(signature, ZipArchiveOutputStream.EOCD_SIG) // empty zip\n            || checksig(signature, ZipArchiveOutputStream.DD_SIG) // split zip\n            || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());\n    }\n\n    private static boolean checksig(final byte[] signature, final byte[] expected) {\n        for (int i = 0; i < expected.length; i++) {\n            if (signature[i] != expected[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Closes the current ZIP archive entry and positions the underlying\n     * stream to the beginning of the next entry. All per-entry variables\n     * and data structures are cleared.\n     * <p>\n     * If the compressed size of this entry is included in the entry header,\n     * then any outstanding bytes are simply skipped from the underlying\n     * stream without uncompressing them. This allows an entry to be safely\n     * closed even if the compression method is unsupported.\n     * <p>\n     * In case we don't know the compressed size of this entry or have\n     * already buffered too much data from the underlying stream to support\n     * uncompression, then the uncompression process is completed and the\n     * end position of the stream is adjusted based on the result of that\n     * process.\n     *\n     * @throws IOException if an error occurs\n     */\n    private void closeEntry() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if (current == null) {\n            return;\n        }\n\n        // Ensure all entry bytes are read\n        if (currentEntryHasOutstandingBytes()) {\n            drainCurrentEntryData();\n        } else {\n            // this is guaranteed to exhaust the stream\n            skip(Long.MAX_VALUE); //NOSONAR\n\n            final long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n                       ? getBytesInflated() : current.bytesRead;\n\n            // this is at most a single read() operation and can't\n            // exceed the range of int\n            final int diff = (int) (current.bytesReadFromStream - inB);\n\n            // Pushback any required bytes\n            if (diff > 0) {\n                pushback(buf.array(), buf.limit() - diff, diff);\n                current.bytesReadFromStream -= diff;\n            }\n\n            // Drain remainder of entry if not all data bytes were required\n            if (currentEntryHasOutstandingBytes()) {\n                drainCurrentEntryData();\n            }\n        }\n\n        if (lastStoredEntry == null && current.hasDataDescriptor) {\n            readDataDescriptor();\n        }\n\n        inf.reset();\n        buf.clear().flip();\n        current = null;\n        lastStoredEntry = null;\n    }\n\n    /**\n     * If the compressed size of the current entry is included in the entry header\n     * and there are any outstanding bytes in the underlying stream, then\n     * this returns true.\n     *\n     * @return true, if current entry is determined to have outstanding bytes, false otherwise\n     */\n    private boolean currentEntryHasOutstandingBytes() {\n        return current.bytesReadFromStream <= current.entry.getCompressedSize()\n                && !current.hasDataDescriptor;\n    }\n\n    /**\n     * Read all data of the current entry from the underlying stream\n     * that hasn't been read, yet.\n     */\n    private void drainCurrentEntryData() throws IOException {\n        long remaining = current.entry.getCompressedSize() - current.bytesReadFromStream;\n        while (remaining > 0) {\n            final long n = in.read(buf.array(), 0, (int) Math.min(buf.capacity(), remaining));\n            if (n < 0) {\n                throw new EOFException(\"Truncated ZIP entry: \"\n                                       + ArchiveUtils.sanitize(current.entry.getName()));\n            }\n            count(n);\n            remaining -= n;\n        }\n    }\n\n    /**\n     * Get the number of bytes Inflater has actually processed.\n     *\n     * <p>for Java &lt; Java7 the getBytes* methods in\n     * Inflater/Deflater seem to return unsigned ints rather than\n     * longs that start over with 0 at 2^32.</p>\n     *\n     * <p>The stream knows how many bytes it has read, but not how\n     * many the Inflater actually consumed - it should be between the\n     * total number of bytes read for the entry and the total number\n     * minus the last read operation.  Here we just try to make the\n     * value close enough to the bytes we've read by assuming the\n     * number of bytes consumed must be smaller than (or equal to) the\n     * number of bytes read but not smaller by more than 2^32.</p>\n     */\n    private long getBytesInflated() {\n        long inB = inf.getBytesRead();\n        if (current.bytesReadFromStream >= TWO_EXP_32) {\n            while (inB + TWO_EXP_32 <= current.bytesReadFromStream) {\n                inB += TWO_EXP_32;\n            }\n        }\n        return inB;\n    }\n\n    private int fill() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        final int length = in.read(buf.array());\n        if (length > 0) {\n            buf.limit(length);\n            count(buf.limit());\n            inf.setInput(buf.array(), 0, buf.limit());\n        }\n        return length;\n    }\n\n    private void readFully(final byte[] b) throws IOException {\n        readFully(b, 0);\n    }\n\n    private void readFully(final byte[] b, final int off) throws IOException {\n        final int len = b.length - off;\n        final int count = IOUtils.readFully(in, b, off, len);\n        count(count);\n        if (count < len) {\n            throw new EOFException();\n        }\n    }\n\n    private void readDataDescriptor() throws IOException {\n        readFully(wordBuf);\n        ZipLong val = new ZipLong(wordBuf);\n        if (ZipLong.DD_SIG.equals(val)) {\n            // data descriptor with signature, skip sig\n            readFully(wordBuf);\n            val = new ZipLong(wordBuf);\n        }\n        current.entry.setCrc(val.getValue());\n\n        // if there is a ZIP64 extra field, sizes are eight bytes\n        // each, otherwise four bytes each.  Unfortunately some\n        // implementations - namely Java7 - use eight bytes without\n        // using a ZIP64 extra field -\n        // https://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7073588\n\n        // just read 16 bytes and check whether bytes nine to twelve\n        // look like one of the signatures of what could follow a data\n        // descriptor (ignoring archive decryption headers for now).\n        // If so, push back eight bytes and assume sizes are four\n        // bytes, otherwise sizes are eight bytes each.\n        readFully(twoDwordBuf);\n        final ZipLong potentialSig = new ZipLong(twoDwordBuf, DWORD);\n        if (potentialSig.equals(ZipLong.CFH_SIG) || potentialSig.equals(ZipLong.LFH_SIG)) {\n            pushback(twoDwordBuf, DWORD, DWORD);\n            current.entry.setCompressedSize(ZipLong.getValue(twoDwordBuf));\n            current.entry.setSize(ZipLong.getValue(twoDwordBuf, WORD));\n        } else {\n            current.entry.setCompressedSize(ZipEightByteInteger.getLongValue(twoDwordBuf));\n            current.entry.setSize(ZipEightByteInteger.getLongValue(twoDwordBuf, DWORD));\n        }\n    }\n\n    /**\n     * Whether this entry requires a data descriptor this library can work with.\n     *\n     * @return true if allowStoredEntriesWithDataDescriptor is true,\n     * the entry doesn't require any data descriptor or the method is\n     * DEFLATED or ENHANCED_DEFLATED.\n     */\n    private boolean supportsDataDescriptorFor(final ZipArchiveEntry entry) {\n        return !entry.getGeneralPurposeBit().usesDataDescriptor()\n\n                || (allowStoredEntriesWithDataDescriptor && entry.getMethod() == ZipEntry.STORED)\n                || entry.getMethod() == ZipEntry.DEFLATED\n                || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode();\n    }\n\n    /**\n     * Whether the compressed size for the entry is either known or\n     * not required by the compression method being used.\n     */\n    private boolean supportsCompressedSizeFor(final ZipArchiveEntry entry) {\n        return entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN\n            || entry.getMethod() == ZipEntry.DEFLATED\n            || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode()\n            || (entry.getGeneralPurposeBit().usesDataDescriptor()\n                && allowStoredEntriesWithDataDescriptor\n                && entry.getMethod() == ZipEntry.STORED);\n    }\n\n    /**\n     * Caches a stored entry that uses the data descriptor.\n     *\n     * <ul>\n     *   <li>Reads a stored entry until the signature of a local file\n     *     header, central directory header or data descriptor has been\n     *     found.</li>\n     *   <li>Stores all entry data in lastStoredEntry.</p>\n     *   <li>Rewinds the stream to position at the data\n     *     descriptor.</li>\n     *   <li>reads the data descriptor</li>\n     * </ul>\n     *\n     * <p>After calling this method the entry should know its size,\n     * the entry's data is cached and the stream is positioned at the\n     * next local file or central directory header.</p>\n     */\n    private void readStoredEntry() throws IOException {\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        int off = 0;\n        boolean done = false;\n\n        // length of DD without signature\n        final int ddLen = current.usesZip64 ? WORD + 2 * DWORD : 3 * WORD;\n\n        while (!done) {\n            final int r = in.read(buf.array(), off, ZipArchiveOutputStream.BUFFER_SIZE - off);\n            if (r <= 0) {\n                // read the whole archive without ever finding a\n                // central directory\n                throw new IOException(\"Truncated ZIP file\");\n            }\n            if (r + off < 4) {\n                // buffer too small to check for a signature, loop\n                off += r;\n                continue;\n            }\n\n            done = bufferContainsSignature(bos, off, r, ddLen);\n            if (!done) {\n                off = cacheBytesRead(bos, off, r, ddLen);\n            }\n        }\n\n        final byte[] b = bos.toByteArray();\n        lastStoredEntry = new ByteArrayInputStream(b);\n    }\n\n    private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\n    private static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\n    private static final byte[] DD = ZipLong.DD_SIG.getBytes();\n\n    /**\n     * Checks whether the current buffer contains the signature of a\n     * &quot;data descriptor&quot;, &quot;local file header&quot; or\n     * &quot;central directory entry&quot;.\n     *\n     * <p>If it contains such a signature, reads the data descriptor\n     * and positions the stream right after the data descriptor.</p>\n     */\n    private boolean bufferContainsSignature(final ByteArrayOutputStream bos, final int offset, final int lastRead, final int expectedDDLen)\n            throws IOException {\n\n        boolean done = false;\n        int readTooMuch = 0;\n        for (int i = 0; !done && i < offset + lastRead - 4; i++) {\n            if (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {\n                if ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3])\n                    || (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {\n                    // found a LFH or CFH:\n                    readTooMuch = offset + lastRead - i - expectedDDLen;\n                    done = true;\n                }\n                else if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {\n                    // found DD:\n                    readTooMuch = offset + lastRead - i;\n                    done = true;\n                }\n                if (done) {\n                    // * push back bytes read in excess as well as the data\n                    //   descriptor\n                    // * copy the remaining bytes to cache\n                    // * read data descriptor\n                    pushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);\n                    bos.write(buf.array(), 0, i);\n                    readDataDescriptor();\n                }\n            }\n        }\n        return done;\n    }\n\n    /**\n     * If the last read bytes could hold a data descriptor and an\n     * incomplete signature then save the last bytes to the front of\n     * the buffer and cache everything in front of the potential data\n     * descriptor into the given ByteArrayOutputStream.\n     *\n     * <p>Data descriptor plus incomplete signature (3 bytes in the\n     * worst case) can be 20 bytes max.</p>\n     */\n    private int cacheBytesRead(final ByteArrayOutputStream bos, int offset, final int lastRead, final int expecteDDLen) {\n        final int cacheable = offset + lastRead - expecteDDLen - 3;\n        if (cacheable > 0) {\n            bos.write(buf.array(), 0, cacheable);\n            System.arraycopy(buf.array(), cacheable, buf.array(), 0, expecteDDLen + 3);\n            offset = expecteDDLen + 3;\n        } else {\n            offset += lastRead;\n        }\n        return offset;\n    }\n\n    private void pushback(final byte[] buf, final int offset, final int length) throws IOException {\n        ((PushbackInputStream) in).unread(buf, offset, length);\n        pushedBackBytes(length);\n    }\n\n    // End of Central Directory Record\n    //   end of central dir signature    WORD\n    //   number of this disk             SHORT\n    //   number of the disk with the\n    //   start of the central directory  SHORT\n    //   total number of entries in the\n    //   central directory on this disk  SHORT\n    //   total number of entries in\n    //   the central directory           SHORT\n    //   size of the central directory   WORD\n    //   offset of start of central\n    //   directory with respect to\n    //   the starting disk number        WORD\n    //   .ZIP file comment length        SHORT\n    //   .ZIP file comment               up to 64KB\n    //\n\n    /**\n     * Reads the stream until it find the \"End of central directory\n     * record\" and consumes it as well.\n     */\n    private void skipRemainderOfArchive() throws IOException {\n        // skip over central directory. One LFH has been read too much\n        // already.  The calculation discounts file names and extra\n        // data so it will be too short.\n        realSkip((long) entriesRead * CFH_LEN - LFH_LEN);\n        findEocdRecord();\n        realSkip((long) ZipFile.MIN_EOCD_SIZE - WORD /* signature */ - SHORT /* comment len */);\n        readFully(shortBuf);\n        // file comment\n        realSkip(ZipShort.getValue(shortBuf));\n    }\n\n    /**\n     * Reads forward until the signature of the &quot;End of central\n     * directory&quot; record is found.\n     */\n    private void findEocdRecord() throws IOException {\n        int currentByte = -1;\n        boolean skipReadCall = false;\n        while (skipReadCall || (currentByte = readOneByte()) > -1) {\n            skipReadCall = false;\n            if (!isFirstByteOfEocdSig(currentByte)) {\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[1]) {\n                if (currentByte == -1) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[2]) {\n                if (currentByte == -1) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte == -1\n                || currentByte == ZipArchiveOutputStream.EOCD_SIG[3]) {\n                break;\n            }\n            skipReadCall = isFirstByteOfEocdSig(currentByte);\n        }\n    }\n\n    /**\n     * Skips bytes by reading from the underlying stream rather than\n     * the (potentially inflating) archive stream - which {@link\n     * #skip} would do.\n     *\n     * Also updates bytes-read counter.\n     */\n    private void realSkip(final long value) throws IOException {\n        if (value >= 0) {\n            long skipped = 0;\n            while (skipped < value) {\n                final long rem = value - skipped;\n                final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n                if (x == -1) {\n                    return;\n                }\n                count(x);\n                skipped += x;\n            }\n            return;\n        }\n        throw new IllegalArgumentException();\n    }\n\n    /**\n     * Reads bytes by reading from the underlying stream rather than\n     * the (potentially inflating) archive stream - which {@link #read} would do.\n     *\n     * Also updates bytes-read counter.\n     */\n    private int readOneByte() throws IOException {\n        final int b = in.read();\n        if (b != -1) {\n            count(1);\n        }\n        return b;\n    }\n\n    private boolean isFirstByteOfEocdSig(final int b) {\n        return b == ZipArchiveOutputStream.EOCD_SIG[0];\n    }\n\n    private static final byte[] APK_SIGNING_BLOCK_MAGIC = new byte[] {\n        'A', 'P', 'K', ' ', 'S', 'i', 'g', ' ', 'B', 'l', 'o', 'c', 'k', ' ', '4', '2',\n    };\n    private static final BigInteger LONG_MAX = BigInteger.valueOf(Long.MAX_VALUE);\n\n    /**\n     * Checks whether this might be an APK Signing Block.\n     *\n     * <p>Unfortunately the APK signing block does not start with some kind of signature, it rather ends with one. It\n     * starts with a length, so what we do is parse the suspect length, skip ahead far enough, look for the signature\n     * and if we've found it, return true.</p>\n     *\n     * @param suspectLocalFileHeader the bytes read from the underlying stream in the expectation that they would hold\n     * the local file header of the next entry.\n     *\n     * @return true if this looks like a APK signing block\n     *\n     * @see <a href=\"https://source.android.com/security/apksigning/v2\">https://source.android.com/security/apksigning/v2</a>\n     */\n    private boolean isApkSigningBlock(byte[] suspectLocalFileHeader) throws IOException {\n        // length of block excluding the size field itself\n        BigInteger len = ZipEightByteInteger.getValue(suspectLocalFileHeader);\n        // LFH has already been read and all but the first eight bytes contain (part of) the APK signing block,\n        // also subtract 16 bytes in order to position us at the magic string\n        BigInteger toSkip = len.add(BigInteger.valueOf(DWORD - suspectLocalFileHeader.length\n            - APK_SIGNING_BLOCK_MAGIC.length));\n        byte[] magic = new byte[APK_SIGNING_BLOCK_MAGIC.length];\n\n        try {\n            if (toSkip.signum() < 0) {\n                // suspectLocalFileHeader contains the start of suspect magic string\n                int off = suspectLocalFileHeader.length + toSkip.intValue();\n                // length was shorter than magic length\n                if (off < DWORD) {\n                    return false;\n                }\n                int bytesInBuffer = Math.abs(toSkip.intValue());\n                System.arraycopy(suspectLocalFileHeader, off, magic, 0, Math.min(bytesInBuffer, magic.length));\n                if (bytesInBuffer < magic.length) {\n                    readFully(magic, bytesInBuffer);\n                }\n            } else {\n                while (toSkip.compareTo(LONG_MAX) > 0) {\n                    realSkip(Long.MAX_VALUE);\n                    toSkip = toSkip.add(LONG_MAX.negate());\n                }\n                realSkip(toSkip.longValue());\n                readFully(magic);\n            }\n        } catch (EOFException ex) {\n            // length was invalid\n            return false;\n        }\n        return Arrays.equals(magic, APK_SIGNING_BLOCK_MAGIC);\n    }\n\n    /**\n     * Structure collecting information for the entry that is\n     * currently being read.\n     */\n    private static final class CurrentEntry {\n\n        /**\n         * Current ZIP entry.\n         */\n        private final ZipArchiveEntry entry = new ZipArchiveEntry();\n\n        /**\n         * Does the entry use a data descriptor?\n         */\n        private boolean hasDataDescriptor;\n\n        /**\n         * Does the entry have a ZIP64 extended information extra field.\n         */\n        private boolean usesZip64;\n\n        /**\n         * Number of bytes of entry content read by the client if the\n         * entry is STORED.\n         */\n        private long bytesRead;\n\n        /**\n         * Number of bytes of entry content read from the stream.\n         *\n         * <p>This may be more than the actual entry's length as some\n         * stuff gets buffered up and needs to be pushed back when the\n         * end of the entry has been reached.</p>\n         */\n        private long bytesReadFromStream;\n\n        /**\n         * The checksum calculated as the current entry is read.\n         */\n        private final CRC32 crc = new CRC32();\n\n        /**\n         * The input stream decompressing the data for shrunk and imploded entries.\n         */\n        private InputStream in;\n    }\n\n    /**\n     * Bounded input stream adapted from commons-io\n     */\n    private class BoundedInputStream extends InputStream {\n\n        /** the wrapped input stream */\n        private final InputStream in;\n\n        /** the max length to provide */\n        private final long max;\n\n        /** the number of bytes already returned */\n        private long pos = 0;\n\n        /**\n         * Creates a new <code>BoundedInputStream</code> that wraps the given input\n         * stream and limits it to a certain size.\n         *\n         * @param in The wrapped input stream\n         * @param size The maximum number of bytes to return\n         */\n        public BoundedInputStream(final InputStream in, final long size) {\n            this.max = size;\n            this.in = in;\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (max >= 0 && pos >= max) {\n                return -1;\n            }\n            final int result = in.read();\n            pos++;\n            count(1);\n            current.bytesReadFromStream++;\n            return result;\n        }\n\n        @Override\n        public int read(final byte[] b) throws IOException {\n            return this.read(b, 0, b.length);\n        }\n\n        @Override\n        public int read(final byte[] b, final int off, final int len) throws IOException {\n            if (max >= 0 && pos >= max) {\n                return -1;\n            }\n            final long maxRead = max >= 0 ? Math.min(len, max - pos) : len;\n            final int bytesRead = in.read(b, off, (int) maxRead);\n\n            if (bytesRead == -1) {\n                return -1;\n            }\n\n            pos += bytesRead;\n            count(bytesRead);\n            current.bytesReadFromStream += bytesRead;\n            return bytesRead;\n        }\n\n        @Override\n        public long skip(final long n) throws IOException {\n            final long toSkip = max >= 0 ? Math.min(n, max - pos) : n;\n            final long skippedBytes = IOUtils.skip(in, toSkip);\n            pos += skippedBytes;\n            return skippedBytes;\n        }\n\n        @Override\n        public int available() throws IOException {\n            if (max >= 0 && pos >= max) {\n                return 0;\n            }\n            return in.available();\n        }\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-8": {
    "vul_id": "VUL4J-8",
    "cve_id": "CVE-2019-12402",
    "project": "apache_commons-compress",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=org.apache.commons.compress.archivers.zip.NioZipEncodingTest#partialSurrogatePair",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/apache/commons-compress/commit/4ad5d80a6272e007f64a6ac66829ca189a8093b9",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/org/apache/commons/compress/archivers/zip/NioZipEncoding.java",
        "file_name": "NioZipEncoding.java",
        "vulnerable_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.CoderResult;\nimport java.nio.charset.CodingErrorAction;\n\n/**\n * A ZipEncoding, which uses a java.nio {@link\n * java.nio.charset.Charset Charset} to encode names.\n * <p>The methods of this class are reentrant.</p>\n * @Immutable\n */\nclass NioZipEncoding implements ZipEncoding, CharsetAccessor {\n\n    private final Charset charset;\n    private final boolean useReplacement;\n    private static final char REPLACEMENT = '?';\n    private static final byte[] REPLACEMENT_BYTES = { (byte) REPLACEMENT };\n    private static final String REPLACEMENT_STRING = String.valueOf(REPLACEMENT);\n    private static final char[] HEX_CHARS = new char[] {\n        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n    };\n\n\n    /**\n     * Construct an NioZipEncoding using the given charset.\n     * @param charset  The character set to use.\n     * @param useReplacement should invalid characters be replaced, or reported.\n     */\n    NioZipEncoding(final Charset charset, boolean useReplacement) {\n        this.charset = charset;\n        this.useReplacement = useReplacement;\n    }\n\n    @Override\n    public Charset getCharset() {\n        return charset;\n    }\n\n    /**\n     * @see  ZipEncoding#canEncode(java.lang.String)\n     */\n    @Override\n    public boolean canEncode(final String name) {\n        final CharsetEncoder enc = newEncoder();\n\n        return enc.canEncode(name);\n    }\n\n    /**\n     * @see ZipEncoding#encode(java.lang.String)\n     */\n    @Override\n    public ByteBuffer encode(final String name) {\n        final CharsetEncoder enc = newEncoder();\n\n        final CharBuffer cb = CharBuffer.wrap(name);\n        CharBuffer tmp = null;\n        ByteBuffer out = ByteBuffer.allocate(estimateInitialBufferSize(enc, cb.remaining()));\n\n        while (cb.remaining() > 0) {\n            final CoderResult res = enc.encode(cb, out, false);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n\n                int spaceForSurrogate = estimateIncrementalEncodingSize(enc, 6 * res.length());\n                if (spaceForSurrogate > out.remaining()) {\n                    // if the destination buffer isn't over sized, assume that the presence of one\n                    // unmappable character makes it likely that there will be more. Find all the\n                    // un-encoded characters and allocate space based on those estimates.\n                    int charCount = 0;\n                    for (int i = cb.position() ; i < cb.limit(); i++) {\n                        charCount += !enc.canEncode(cb.get(i)) ? 6 : 1;\n                    }\n                    int totalExtraSpace = estimateIncrementalEncodingSize(enc, charCount);\n                    out = ZipEncodingHelper.growBufferBy(out, totalExtraSpace - out.remaining());\n                }\n                if (tmp == null) {\n                    tmp = CharBuffer.allocate(6);\n                }\n                for (int i = 0; i < res.length(); ++i) {\n                    out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out);\n                }\n\n            } else if (res.isOverflow()) {\n                int increment = estimateIncrementalEncodingSize(enc, cb.remaining());\n                out = ZipEncodingHelper.growBufferBy(out, increment);\n            }\n        }\n        // tell the encoder we are done\n        enc.encode(cb, out, true);\n        // may have caused underflow, but that's been ignored traditionally\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n\n    /**\n     * @see\n     * ZipEncoding#decode(byte[])\n     */\n    @Override\n    public String decode(final byte[] data) throws IOException {\n        return newDecoder()\n            .decode(ByteBuffer.wrap(data)).toString();\n    }\n\n    private static ByteBuffer encodeFully(CharsetEncoder enc, CharBuffer cb, ByteBuffer out) {\n        ByteBuffer o = out;\n        while (cb.hasRemaining()) {\n            CoderResult result = enc.encode(cb, o, false);\n            if (result.isOverflow()) {\n                int increment = estimateIncrementalEncodingSize(enc, cb.remaining());\n                o = ZipEncodingHelper.growBufferBy(o, increment);\n            }\n        }\n        return o;\n    }\n\n    private static CharBuffer encodeSurrogate(CharBuffer cb, char c) {\n        cb.position(0).limit(6);\n        cb.put('%');\n        cb.put('U');\n\n        cb.put(HEX_CHARS[(c >> 12) & 0x0f]);\n        cb.put(HEX_CHARS[(c >> 8) & 0x0f]);\n        cb.put(HEX_CHARS[(c >> 4) & 0x0f]);\n        cb.put(HEX_CHARS[c & 0x0f]);\n        cb.flip();\n        return cb;\n    }\n\n    private CharsetEncoder newEncoder() {\n        if (useReplacement) {\n            return charset.newEncoder()\n                .onMalformedInput(CodingErrorAction.REPLACE)\n                .onUnmappableCharacter(CodingErrorAction.REPLACE)\n                .replaceWith(REPLACEMENT_BYTES);\n        } else {\n            return charset.newEncoder()\n                .onMalformedInput(CodingErrorAction.REPORT)\n                .onUnmappableCharacter(CodingErrorAction.REPORT);\n        }\n    }\n\n    private CharsetDecoder newDecoder() {\n        if (!useReplacement) {\n            return this.charset.newDecoder()\n                .onMalformedInput(CodingErrorAction.REPORT)\n                .onUnmappableCharacter(CodingErrorAction.REPORT);\n        } else {\n            return  charset.newDecoder()\n                .onMalformedInput(CodingErrorAction.REPLACE)\n                .onUnmappableCharacter(CodingErrorAction.REPLACE)\n                .replaceWith(REPLACEMENT_STRING);\n        }\n    }\n\n    /**\n     * Estimate the initial encoded size (in bytes) for a character buffer.\n     * <p>\n     * The estimate assumes that one character consumes uses the maximum length encoding,\n     * whilst the rest use an average size encoding. This accounts for any BOM for UTF-16, at\n     * the expense of a couple of extra bytes for UTF-8 encoded ASCII.\n     * </p>\n     *\n     * @param enc        encoder to use for estimates\n     * @param charChount number of characters in string\n     * @return estimated size in bytes.\n     */\n    private static int estimateInitialBufferSize(CharsetEncoder enc, int charChount) {\n        float first = enc.maxBytesPerChar();\n        float rest = (charChount - 1) * enc.averageBytesPerChar();\n        return (int) Math.ceil(first + rest);\n    }\n\n    /**\n     * Estimate the size needed for remaining characters\n     *\n     * @param enc       encoder to use for estimates\n     * @param charCount number of characters remaining\n     * @return estimated size in bytes.\n     */\n    private static int estimateIncrementalEncodingSize(CharsetEncoder enc, int charCount) {\n        return (int) Math.ceil(charCount * enc.averageBytesPerChar());\n    }\n\n}\n",
        "human_patch_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.CoderResult;\nimport java.nio.charset.CodingErrorAction;\n\n/**\n * A ZipEncoding, which uses a java.nio {@link\n * java.nio.charset.Charset Charset} to encode names.\n * <p>The methods of this class are reentrant.</p>\n * @Immutable\n */\nclass NioZipEncoding implements ZipEncoding, CharsetAccessor {\n\n    private final Charset charset;\n    private final boolean useReplacement;\n    private static final char REPLACEMENT = '?';\n    private static final byte[] REPLACEMENT_BYTES = { (byte) REPLACEMENT };\n    private static final String REPLACEMENT_STRING = String.valueOf(REPLACEMENT);\n    private static final char[] HEX_CHARS = new char[] {\n        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n    };\n\n\n    /**\n     * Construct an NioZipEncoding using the given charset.\n     * @param charset  The character set to use.\n     * @param useReplacement should invalid characters be replaced, or reported.\n     */\n    NioZipEncoding(final Charset charset, boolean useReplacement) {\n        this.charset = charset;\n        this.useReplacement = useReplacement;\n    }\n\n    @Override\n    public Charset getCharset() {\n        return charset;\n    }\n\n    /**\n     * @see  ZipEncoding#canEncode(java.lang.String)\n     */\n    @Override\n    public boolean canEncode(final String name) {\n        final CharsetEncoder enc = newEncoder();\n\n        return enc.canEncode(name);\n    }\n\n    /**\n     * @see ZipEncoding#encode(java.lang.String)\n     */\n    @Override\n    public ByteBuffer encode(final String name) {\n        final CharsetEncoder enc = newEncoder();\n\n        final CharBuffer cb = CharBuffer.wrap(name);\n        CharBuffer tmp = null;\n        ByteBuffer out = ByteBuffer.allocate(estimateInitialBufferSize(enc, cb.remaining()));\n\n        while (cb.remaining() > 0) {\n            final CoderResult res = enc.encode(cb, out, false);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n\n                int spaceForSurrogate = estimateIncrementalEncodingSize(enc, 6 * res.length());\n                if (spaceForSurrogate > out.remaining()) {\n                    // if the destination buffer isn't over sized, assume that the presence of one\n                    // unmappable character makes it likely that there will be more. Find all the\n                    // un-encoded characters and allocate space based on those estimates.\n                    int charCount = 0;\n                    for (int i = cb.position() ; i < cb.limit(); i++) {\n                        charCount += !enc.canEncode(cb.get(i)) ? 6 : 1;\n                    }\n                    int totalExtraSpace = estimateIncrementalEncodingSize(enc, charCount);\n                    out = ZipEncodingHelper.growBufferBy(out, totalExtraSpace - out.remaining());\n                }\n                if (tmp == null) {\n                    tmp = CharBuffer.allocate(6);\n                }\n                for (int i = 0; i < res.length(); ++i) {\n                    out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out);\n                }\n\n            } else if (res.isOverflow()) {\n                int increment = estimateIncrementalEncodingSize(enc, cb.remaining());\n                out = ZipEncodingHelper.growBufferBy(out, increment);\n\n            } else if (res.isUnderflow() || res.isError()) {\n                break;\n            }\n        }\n        // tell the encoder we are done\n        enc.encode(cb, out, true);\n        // may have caused underflow, but that's been ignored traditionally\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n\n    /**\n     * @see\n     * ZipEncoding#decode(byte[])\n     */\n    @Override\n    public String decode(final byte[] data) throws IOException {\n        return newDecoder()\n            .decode(ByteBuffer.wrap(data)).toString();\n    }\n\n    private static ByteBuffer encodeFully(CharsetEncoder enc, CharBuffer cb, ByteBuffer out) {\n        ByteBuffer o = out;\n        while (cb.hasRemaining()) {\n            CoderResult result = enc.encode(cb, o, false);\n            if (result.isOverflow()) {\n                int increment = estimateIncrementalEncodingSize(enc, cb.remaining());\n                o = ZipEncodingHelper.growBufferBy(o, increment);\n            }\n        }\n        return o;\n    }\n\n    private static CharBuffer encodeSurrogate(CharBuffer cb, char c) {\n        cb.position(0).limit(6);\n        cb.put('%');\n        cb.put('U');\n\n        cb.put(HEX_CHARS[(c >> 12) & 0x0f]);\n        cb.put(HEX_CHARS[(c >> 8) & 0x0f]);\n        cb.put(HEX_CHARS[(c >> 4) & 0x0f]);\n        cb.put(HEX_CHARS[c & 0x0f]);\n        cb.flip();\n        return cb;\n    }\n\n    private CharsetEncoder newEncoder() {\n        if (useReplacement) {\n            return charset.newEncoder()\n                .onMalformedInput(CodingErrorAction.REPLACE)\n                .onUnmappableCharacter(CodingErrorAction.REPLACE)\n                .replaceWith(REPLACEMENT_BYTES);\n        } else {\n            return charset.newEncoder()\n                .onMalformedInput(CodingErrorAction.REPORT)\n                .onUnmappableCharacter(CodingErrorAction.REPORT);\n        }\n    }\n\n    private CharsetDecoder newDecoder() {\n        if (!useReplacement) {\n            return this.charset.newDecoder()\n                .onMalformedInput(CodingErrorAction.REPORT)\n                .onUnmappableCharacter(CodingErrorAction.REPORT);\n        } else {\n            return  charset.newDecoder()\n                .onMalformedInput(CodingErrorAction.REPLACE)\n                .onUnmappableCharacter(CodingErrorAction.REPLACE)\n                .replaceWith(REPLACEMENT_STRING);\n        }\n    }\n\n    /**\n     * Estimate the initial encoded size (in bytes) for a character buffer.\n     * <p>\n     * The estimate assumes that one character consumes uses the maximum length encoding,\n     * whilst the rest use an average size encoding. This accounts for any BOM for UTF-16, at\n     * the expense of a couple of extra bytes for UTF-8 encoded ASCII.\n     * </p>\n     *\n     * @param enc        encoder to use for estimates\n     * @param charChount number of characters in string\n     * @return estimated size in bytes.\n     */\n    private static int estimateInitialBufferSize(CharsetEncoder enc, int charChount) {\n        float first = enc.maxBytesPerChar();\n        float rest = (charChount - 1) * enc.averageBytesPerChar();\n        return (int) Math.ceil(first + rest);\n    }\n\n    /**\n     * Estimate the size needed for remaining characters\n     *\n     * @param enc       encoder to use for estimates\n     * @param charCount number of characters remaining\n     * @return estimated size in bytes.\n     */\n    private static int estimateIncrementalEncodingSize(CharsetEncoder enc, int charCount) {\n        return (int) Math.ceil(charCount * enc.averageBytesPerChar());\n    }\n\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-9": {
    "vul_id": "VUL4J-9",
    "cve_id": "CVE-2020-1953",
    "project": "apache_commons-configuration",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=org.apache.commons.configuration2.TestYAMLConfiguration#testObjectCreationFromStream,org.apache.commons.configuration2.TestYAMLConfiguration#testObjectCreationFromReader",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/apache/commons-configuration/commit/add7375cf37fd316d4838c6c56b054fc293b4641",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/org/apache/commons/configuration2/YAMLConfiguration.java",
        "file_name": "YAMLConfiguration.java",
        "vulnerable_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.configuration2;\n\nimport org.apache.commons.configuration2.ex.ConfigurationException;\nimport org.apache.commons.configuration2.io.InputStreamSupport;\nimport org.apache.commons.configuration2.tree.ImmutableNode;\nimport org.yaml.snakeyaml.DumperOptions;\nimport org.yaml.snakeyaml.LoaderOptions;\nimport org.yaml.snakeyaml.Yaml;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.util.Map;\n\n/**\n * <p>\n * A specialized hierarchical configuration class that is able to parse YAML\n * documents.\n * </p>\n *\n * @since 2.2\n */\npublic class YAMLConfiguration extends AbstractYAMLBasedConfiguration\n        implements FileBasedConfiguration, InputStreamSupport\n{\n    /**\n     * Creates a new instance of {@code YAMLConfiguration}.\n     */\n    public YAMLConfiguration()\n    {\n        super();\n    }\n\n    /**\n     * Creates a new instance of {@code YAMLConfiguration} as a copy of the\n     * specified configuration.\n     *\n     * @param c the configuration to be copied\n     */\n    public YAMLConfiguration(final HierarchicalConfiguration<ImmutableNode> c)\n    {\n        super(c);\n    }\n\n    @Override\n    public void read(final Reader in) throws ConfigurationException\n    {\n        try\n        {\n            final Yaml yaml = new Yaml();\n            final Map<String, Object> map = (Map) yaml.load(in);\n            load(map);\n        }\n        catch (final Exception e)\n        {\n            rethrowException(e);\n        }\n    }\n\n    public void read(final Reader in, final LoaderOptions options)\n            throws ConfigurationException\n    {\n        try\n        {\n            final Yaml yaml = new Yaml(options);\n            final Map<String, Object> map = (Map) yaml.load(in);\n            load(map);\n        }\n        catch (final Exception e)\n        {\n            rethrowException(e);\n        }\n    }\n\n    @Override\n    public void write(final Writer out) throws ConfigurationException, IOException\n    {\n        final DumperOptions options = new DumperOptions();\n        options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);\n        dump(out, options);\n    }\n\n    public void dump(final Writer out, final DumperOptions options)\n            throws ConfigurationException, IOException\n    {\n        final Yaml yaml = new Yaml(options);\n        yaml.dump(constructMap(getNodeModel().getNodeHandler().getRootNode()),\n                out);\n    }\n\n    /**\n     * Loads the configuration from the given input stream.\n     *\n     * @param in the input stream\n     * @throws ConfigurationException if an error occurs\n     */\n    @Override\n    public void read(final InputStream in) throws ConfigurationException\n    {\n        try\n        {\n            final Yaml yaml = new Yaml();\n            final Map<String, Object> map = (Map) yaml.load(in);\n            load(map);\n        }\n        catch (final Exception e)\n        {\n            rethrowException(e);\n        }\n    }\n\n    public void read(final InputStream in, final LoaderOptions options)\n            throws ConfigurationException\n    {\n        try\n        {\n            final Yaml yaml = new Yaml(options);\n            final Map<String, Object> map = (Map) yaml.load(in);\n            load(map);\n        }\n        catch (final Exception e)\n        {\n            rethrowException(e);\n        }\n    }\n\n}\n",
        "human_patch_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.configuration2;\n\nimport org.apache.commons.configuration2.ex.ConfigurationException;\nimport org.apache.commons.configuration2.ex.ConfigurationRuntimeException;\nimport org.apache.commons.configuration2.io.InputStreamSupport;\nimport org.apache.commons.configuration2.tree.ImmutableNode;\nimport org.yaml.snakeyaml.DumperOptions;\nimport org.yaml.snakeyaml.LoaderOptions;\nimport org.yaml.snakeyaml.Yaml;\nimport org.yaml.snakeyaml.constructor.Constructor;\nimport org.yaml.snakeyaml.representer.Representer;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.util.Map;\n\n/**\n * <p>\n * A specialized hierarchical configuration class that is able to parse YAML\n * documents.\n * </p>\n *\n * @since 2.2\n */\npublic class YAMLConfiguration extends AbstractYAMLBasedConfiguration\n        implements FileBasedConfiguration, InputStreamSupport\n{\n    /**\n     * Creates a new instance of {@code YAMLConfiguration}.\n     */\n    public YAMLConfiguration()\n    {\n        super();\n    }\n\n    /**\n     * Creates a new instance of {@code YAMLConfiguration} as a copy of the\n     * specified configuration.\n     *\n     * @param c the configuration to be copied\n     */\n    public YAMLConfiguration(final HierarchicalConfiguration<ImmutableNode> c)\n    {\n        super(c);\n    }\n\n    @Override\n    public void read(final Reader in) throws ConfigurationException\n    {\n        try\n        {\n            final Yaml yaml = createYamlForReading(new LoaderOptions());\n            final Map<String, Object> map = (Map) yaml.load(in);\n            load(map);\n        }\n        catch (final Exception e)\n        {\n            rethrowException(e);\n        }\n    }\n\n    public void read(final Reader in, final LoaderOptions options)\n            throws ConfigurationException\n    {\n        try\n        {\n            final Yaml yaml = createYamlForReading(options);\n            final Map<String, Object> map = (Map) yaml.load(in);\n            load(map);\n        }\n        catch (final Exception e)\n        {\n            rethrowException(e);\n        }\n    }\n\n    @Override\n    public void write(final Writer out) throws ConfigurationException, IOException\n    {\n        final DumperOptions options = new DumperOptions();\n        options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);\n        dump(out, options);\n    }\n\n    public void dump(final Writer out, final DumperOptions options)\n            throws ConfigurationException, IOException\n    {\n        final Yaml yaml = new Yaml(options);\n        yaml.dump(constructMap(getNodeModel().getNodeHandler().getRootNode()),\n                out);\n    }\n\n    /**\n     * Loads the configuration from the given input stream.\n     *\n     * @param in the input stream\n     * @throws ConfigurationException if an error occurs\n     */\n    @Override\n    public void read(final InputStream in) throws ConfigurationException\n    {\n        try\n        {\n            final Yaml yaml = createYamlForReading(new LoaderOptions());\n            final Map<String, Object> map = (Map) yaml.load(in);\n            load(map);\n        }\n        catch (final Exception e)\n        {\n            rethrowException(e);\n        }\n    }\n\n    public void read(final InputStream in, final LoaderOptions options)\n            throws ConfigurationException\n    {\n        try\n        {\n            final Yaml yaml = createYamlForReading(options);\n            final Map<String, Object> map = (Map) yaml.load(in);\n            load(map);\n        }\n        catch (final Exception e)\n        {\n            rethrowException(e);\n        }\n    }\n\n    /**\n     * Creates a {@code Yaml} object for reading a Yaml file. The object is\n     * configured with some default settings.\n     *\n     * @param options options for loading the file\n     * @return the {@code Yaml} instance for loading a file\n     */\n    private static Yaml createYamlForReading(LoaderOptions options)\n    {\n        return new Yaml(createClassLoadingDisablingConstructor(), new Representer(), new DumperOptions(), options);\n    }\n\n    /**\n     * Returns a {@code Constructor} object for the YAML parser that prevents\n     * all classes from being loaded. This effectively disables the dynamic\n     * creation of Java objects that are declared in YAML files to be loaded.\n     *\n     * @return the {@code Constructor} preventing object creation\n     */\n    private static Constructor createClassLoadingDisablingConstructor()\n    {\n        return new Constructor()\n        {\n            @Override\n            protected Class<?> getClassForName(String name)\n            {\n                throw new ConfigurationRuntimeException(\"Class loading is disabled.\");\n            }\n        };\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-10": {
    "vul_id": "VUL4J-10",
    "cve_id": "CVE-2013-2186",
    "project": "apache_commons-fileupload",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=org.apache.commons.fileupload.DiskFileItemSerializeTest#testInvalidRepositoryWithNullChar,org.apache.commons.fileupload.DiskFileItemSerializeTest#testInvalidRepository",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/apache/commons-fileupload/commit/163a6061fbc077d4b6e4787d26857c2baba495d1",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/org/apache/commons/fileupload/disk/DiskFileItem.java",
        "file_name": "DiskFileItem.java",
        "vulnerable_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.fileupload.disk;\n\nimport static java.lang.String.format;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileItemHeaders;\nimport org.apache.commons.fileupload.FileUploadException;\nimport org.apache.commons.fileupload.ParameterParser;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.output.DeferredFileOutputStream;\n\n/**\n * <p> The default implementation of the\n * {@link org.apache.commons.fileupload.FileItem FileItem} interface.\n *\n * <p> After retrieving an instance of this class from a {@link\n * org.apache.commons.fileupload.DiskFileUpload DiskFileUpload} instance (see\n * {@link org.apache.commons.fileupload.servlet.ServletFileUpload\n * #parseRequest(javax.servlet.http.HttpServletRequest)}), you may\n * either request all contents of file at once using {@link #get()} or\n * request an {@link java.io.InputStream InputStream} with\n * {@link #getInputStream()} and process the file without attempting to load\n * it into memory, which may come handy with large files.\n *\n * <p>Temporary files, which are created for file items, should be\n * deleted later on. The best way to do this is using a\n * {@link org.apache.commons.io.FileCleaningTracker}, which you can set on the\n * {@link DiskFileItemFactory}. However, if you do use such a tracker,\n * then you must consider the following: Temporary files are automatically\n * deleted as soon as they are no longer needed. (More precisely, when the\n * corresponding instance of {@link java.io.File} is garbage collected.)\n * This is done by the so-called reaper thread, which is started\n * automatically when the class {@link org.apache.commons.io.FileCleaner}\n * is loaded.\n * It might make sense to terminate that thread, for example, if\n * your web application ends. See the section on \"Resource cleanup\"\n * in the users guide of commons-fileupload.</p>\n *\n * @since FileUpload 1.1\n *\n * @version $Id$\n */\npublic class DiskFileItem\n    implements FileItem {\n\n    // ----------------------------------------------------- Manifest constants\n\n    /**\n     * The UID to use when serializing this instance.\n     */\n    private static final long serialVersionUID = 2237570099615271025L;\n\n    /**\n     * Default content charset to be used when no explicit charset\n     * parameter is provided by the sender. Media subtypes of the\n     * \"text\" type are defined to have a default charset value of\n     * \"ISO-8859-1\" when received via HTTP.\n     */\n    public static final String DEFAULT_CHARSET = \"ISO-8859-1\";\n\n    // ----------------------------------------------------------- Data members\n\n    /**\n     * UID used in unique file name generation.\n     */\n    private static final String UID =\n            UUID.randomUUID().toString().replace('-', '_');\n\n    /**\n     * Counter used in unique identifier generation.\n     */\n    private static final AtomicInteger COUNTER = new AtomicInteger(0);\n\n    /**\n     * The name of the form field as provided by the browser.\n     */\n    private String fieldName;\n\n    /**\n     * The content type passed by the browser, or <code>null</code> if\n     * not defined.\n     */\n    private final String contentType;\n\n    /**\n     * Whether or not this item is a simple form field.\n     */\n    private boolean isFormField;\n\n    /**\n     * The original filename in the user's filesystem.\n     */\n    private final String fileName;\n\n    /**\n     * The size of the item, in bytes. This is used to cache the size when a\n     * file item is moved from its original location.\n     */\n    private long size = -1;\n\n\n    /**\n     * The threshold above which uploads will be stored on disk.\n     */\n    private final int sizeThreshold;\n\n    /**\n     * The directory in which uploaded files will be stored, if stored on disk.\n     */\n    private final File repository;\n\n    /**\n     * Cached contents of the file.\n     */\n    private byte[] cachedContent;\n\n    /**\n     * Output stream for this item.\n     */\n    private transient DeferredFileOutputStream dfos;\n\n    /**\n     * The temporary file to use.\n     */\n    private transient File tempFile;\n\n    /**\n     * File to allow for serialization of the content of this item.\n     */\n    private File dfosFile;\n\n    /**\n     * The file items headers.\n     */\n    private FileItemHeaders headers;\n\n    // ----------------------------------------------------------- Constructors\n\n    /**\n     * Constructs a new <code>DiskFileItem</code> instance.\n     *\n     * @param fieldName     The name of the form field.\n     * @param contentType   The content type passed by the browser or\n     *                      <code>null</code> if not specified.\n     * @param isFormField   Whether or not this item is a plain form field, as\n     *                      opposed to a file upload.\n     * @param fileName      The original filename in the user's filesystem, or\n     *                      <code>null</code> if not specified.\n     * @param sizeThreshold The threshold, in bytes, below which items will be\n     *                      retained in memory and above which they will be\n     *                      stored as a file.\n     * @param repository    The data repository, which is the directory in\n     *                      which files will be created, should the item size\n     *                      exceed the threshold.\n     */\n    public DiskFileItem(String fieldName,\n            String contentType, boolean isFormField, String fileName,\n            int sizeThreshold, File repository) {\n        this.fieldName = fieldName;\n        this.contentType = contentType;\n        this.isFormField = isFormField;\n        this.fileName = fileName;\n        this.sizeThreshold = sizeThreshold;\n        this.repository = repository;\n    }\n\n    // ------------------------------- Methods from javax.activation.DataSource\n\n    /**\n     * Returns an {@link java.io.InputStream InputStream} that can be\n     * used to retrieve the contents of the file.\n     *\n     * @return An {@link java.io.InputStream InputStream} that can be\n     *         used to retrieve the contents of the file.\n     *\n     * @throws IOException if an error occurs.\n     */\n    public InputStream getInputStream()\n        throws IOException {\n        if (!isInMemory()) {\n            return new FileInputStream(dfos.getFile());\n        }\n\n        if (cachedContent == null) {\n            cachedContent = dfos.getData();\n        }\n        return new ByteArrayInputStream(cachedContent);\n    }\n\n    /**\n     * Returns the content type passed by the agent or <code>null</code> if\n     * not defined.\n     *\n     * @return The content type passed by the agent or <code>null</code> if\n     *         not defined.\n     */\n    public String getContentType() {\n        return contentType;\n    }\n\n    /**\n     * Returns the content charset passed by the agent or <code>null</code> if\n     * not defined.\n     *\n     * @return The content charset passed by the agent or <code>null</code> if\n     *         not defined.\n     */\n    public String getCharSet() {\n        ParameterParser parser = new ParameterParser();\n        parser.setLowerCaseNames(true);\n        // Parameter parser can handle null input\n        Map<String, String> params = parser.parse(getContentType(), ';');\n        return params.get(\"charset\");\n    }\n\n    /**\n     * Returns the original filename in the client's filesystem.\n     *\n     * @return The original filename in the client's filesystem.\n     * @throws org.apache.commons.fileupload.InvalidFileNameException The file name contains a NUL character,\n     *   which might be an indicator of a security attack. If you intend to\n     *   use the file name anyways, catch the exception and use\n     *   {@link org.apache.commons.fileupload.InvalidFileNameException#getName()}.\n     */\n    public String getName() {\n        return Streams.checkFileName(fileName);\n    }\n\n    // ------------------------------------------------------- FileItem methods\n\n    /**\n     * Provides a hint as to whether or not the file contents will be read\n     * from memory.\n     *\n     * @return <code>true</code> if the file contents will be read\n     *         from memory; <code>false</code> otherwise.\n     */\n    public boolean isInMemory() {\n        if (cachedContent != null) {\n            return true;\n        }\n        return dfos.isInMemory();\n    }\n\n    /**\n     * Returns the size of the file.\n     *\n     * @return The size of the file, in bytes.\n     */\n    public long getSize() {\n        if (size >= 0) {\n            return size;\n        } else if (cachedContent != null) {\n            return cachedContent.length;\n        } else if (dfos.isInMemory()) {\n            return dfos.getData().length;\n        } else {\n            return dfos.getFile().length();\n        }\n    }\n\n    /**\n     * Returns the contents of the file as an array of bytes.  If the\n     * contents of the file were not yet cached in memory, they will be\n     * loaded from the disk storage and cached.\n     *\n     * @return The contents of the file as an array of bytes.\n     */\n    public byte[] get() {\n        if (isInMemory()) {\n            if (cachedContent == null) {\n                cachedContent = dfos.getData();\n            }\n            return cachedContent;\n        }\n\n        byte[] fileData = new byte[(int) getSize()];\n        InputStream fis = null;\n\n        try {\n            fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));\n            fis.read(fileData);\n        } catch (IOException e) {\n            fileData = null;\n        } finally {\n            if (fis != null) {\n                try {\n                    fis.close();\n                } catch (IOException e) {\n                    // ignore\n                }\n            }\n        }\n\n        return fileData;\n    }\n\n    /**\n     * Returns the contents of the file as a String, using the specified\n     * encoding.  This method uses {@link #get()} to retrieve the\n     * contents of the file.\n     *\n     * @param charset The charset to use.\n     *\n     * @return The contents of the file, as a string.\n     *\n     * @throws UnsupportedEncodingException if the requested character\n     *                                      encoding is not available.\n     */\n    public String getString(final String charset)\n        throws UnsupportedEncodingException {\n        return new String(get(), charset);\n    }\n\n    /**\n     * Returns the contents of the file as a String, using the default\n     * character encoding.  This method uses {@link #get()} to retrieve the\n     * contents of the file.\n     *\n     * <b>TODO</b> Consider making this method throw UnsupportedEncodingException.\n     *\n     * @return The contents of the file, as a string.\n     */\n    public String getString() {\n        byte[] rawdata = get();\n        String charset = getCharSet();\n        if (charset == null) {\n            charset = DEFAULT_CHARSET;\n        }\n        try {\n            return new String(rawdata, charset);\n        } catch (UnsupportedEncodingException e) {\n            return new String(rawdata);\n        }\n    }\n\n    /**\n     * A convenience method to write an uploaded item to disk. The client code\n     * is not concerned with whether or not the item is stored in memory, or on\n     * disk in a temporary location. They just want to write the uploaded item\n     * to a file.\n     * <p>\n     * This implementation first attempts to rename the uploaded item to the\n     * specified destination file, if the item was originally written to disk.\n     * Otherwise, the data will be copied to the specified file.\n     * <p>\n     * This method is only guaranteed to work <em>once</em>, the first time it\n     * is invoked for a particular item. This is because, in the event that the\n     * method renames a temporary file, that file will no longer be available\n     * to copy or rename again at a later time.\n     *\n     * @param file The <code>File</code> into which the uploaded item should\n     *             be stored.\n     *\n     * @throws Exception if an error occurs.\n     */\n    public void write(File file) throws Exception {\n        if (isInMemory()) {\n            FileOutputStream fout = null;\n            try {\n                fout = new FileOutputStream(file);\n                fout.write(get());\n            } finally {\n                if (fout != null) {\n                    fout.close();\n                }\n            }\n        } else {\n            File outputFile = getStoreLocation();\n            if (outputFile != null) {\n                // Save the length of the file\n                size = outputFile.length();\n                /*\n                 * The uploaded file is being stored on disk\n                 * in a temporary location so move it to the\n                 * desired file.\n                 */\n                if (!outputFile.renameTo(file)) {\n                    BufferedInputStream in = null;\n                    BufferedOutputStream out = null;\n                    try {\n                        in = new BufferedInputStream(\n                            new FileInputStream(outputFile));\n                        out = new BufferedOutputStream(\n                                new FileOutputStream(file));\n                        IOUtils.copy(in, out);\n                    } finally {\n                        if (in != null) {\n                            try {\n                                in.close();\n                            } catch (IOException e) {\n                                // ignore\n                            }\n                        }\n                        if (out != null) {\n                            try {\n                                out.close();\n                            } catch (IOException e) {\n                                // ignore\n                            }\n                        }\n                    }\n                }\n            } else {\n                /*\n                 * For whatever reason we cannot write the\n                 * file to disk.\n                 */\n                throw new FileUploadException(\n                    \"Cannot write uploaded file to disk!\");\n            }\n        }\n    }\n\n    /**\n     * Deletes the underlying storage for a file item, including deleting any\n     * associated temporary disk file. Although this storage will be deleted\n     * automatically when the <code>FileItem</code> instance is garbage\n     * collected, this method can be used to ensure that this is done at an\n     * earlier time, thus preserving system resources.\n     */\n    public void delete() {\n        cachedContent = null;\n        File outputFile = getStoreLocation();\n        if (outputFile != null && outputFile.exists()) {\n            outputFile.delete();\n        }\n    }\n\n    /**\n     * Returns the name of the field in the multipart form corresponding to\n     * this file item.\n     *\n     * @return The name of the form field.\n     *\n     * @see #setFieldName(java.lang.String)\n     *\n     */\n    public String getFieldName() {\n        return fieldName;\n    }\n\n    /**\n     * Sets the field name used to reference this file item.\n     *\n     * @param fieldName The name of the form field.\n     *\n     * @see #getFieldName()\n     *\n     */\n    public void setFieldName(String fieldName) {\n        this.fieldName = fieldName;\n    }\n\n    /**\n     * Determines whether or not a <code>FileItem</code> instance represents\n     * a simple form field.\n     *\n     * @return <code>true</code> if the instance represents a simple form\n     *         field; <code>false</code> if it represents an uploaded file.\n     *\n     * @see #setFormField(boolean)\n     *\n     */\n    public boolean isFormField() {\n        return isFormField;\n    }\n\n    /**\n     * Specifies whether or not a <code>FileItem</code> instance represents\n     * a simple form field.\n     *\n     * @param state <code>true</code> if the instance represents a simple form\n     *              field; <code>false</code> if it represents an uploaded file.\n     *\n     * @see #isFormField()\n     *\n     */\n    public void setFormField(boolean state) {\n        isFormField = state;\n    }\n\n    /**\n     * Returns an {@link java.io.OutputStream OutputStream} that can\n     * be used for storing the contents of the file.\n     *\n     * @return An {@link java.io.OutputStream OutputStream} that can be used\n     *         for storing the contensts of the file.\n     *\n     * @throws IOException if an error occurs.\n     */\n    public OutputStream getOutputStream()\n        throws IOException {\n        if (dfos == null) {\n            File outputFile = getTempFile();\n            dfos = new DeferredFileOutputStream(sizeThreshold, outputFile);\n        }\n        return dfos;\n    }\n\n    // --------------------------------------------------------- Public methods\n\n    /**\n     * Returns the {@link java.io.File} object for the <code>FileItem</code>'s\n     * data's temporary location on the disk. Note that for\n     * <code>FileItem</code>s that have their data stored in memory,\n     * this method will return <code>null</code>. When handling large\n     * files, you can use {@link java.io.File#renameTo(java.io.File)} to\n     * move the file to new location without copying the data, if the\n     * source and destination locations reside within the same logical\n     * volume.\n     *\n     * @return The data file, or <code>null</code> if the data is stored in\n     *         memory.\n     */\n    public File getStoreLocation() {\n        if (dfos == null) {\n            return null;\n        }\n        return dfos.getFile();\n    }\n\n    // ------------------------------------------------------ Protected methods\n\n    /**\n     * Removes the file contents from the temporary storage.\n     */\n    @Override\n    protected void finalize() {\n        File outputFile = dfos.getFile();\n\n        if (outputFile != null && outputFile.exists()) {\n            outputFile.delete();\n        }\n    }\n\n    /**\n     * Creates and returns a {@link java.io.File File} representing a uniquely\n     * named temporary file in the configured repository path. The lifetime of\n     * the file is tied to the lifetime of the <code>FileItem</code> instance;\n     * the file will be deleted when the instance is garbage collected.\n     *\n     * @return The {@link java.io.File File} to be used for temporary storage.\n     */\n    protected File getTempFile() {\n        if (tempFile == null) {\n            File tempDir = repository;\n            if (tempDir == null) {\n                tempDir = new File(System.getProperty(\"java.io.tmpdir\"));\n            }\n\n            String tempFileName = format(\"upload_%s_%s.tmp\", UID, getUniqueId());\n\n            tempFile = new File(tempDir, tempFileName);\n        }\n        return tempFile;\n    }\n\n    // -------------------------------------------------------- Private methods\n\n    /**\n     * Returns an identifier that is unique within the class loader used to\n     * load this class, but does not have random-like apearance.\n     *\n     * @return A String with the non-random looking instance identifier.\n     */\n    private static String getUniqueId() {\n        final int limit = 100000000;\n        int current = COUNTER.getAndIncrement();\n        String id = Integer.toString(current);\n\n        // If you manage to get more than 100 million of ids, you'll\n        // start getting ids longer than 8 characters.\n        if (current < limit) {\n            id = (\"00000000\" + id).substring(id.length());\n        }\n        return id;\n    }\n\n    /**\n     * Returns a string representation of this object.\n     *\n     * @return a string representation of this object.\n     */\n    @Override\n    public String toString() {\n        return format(\"name=%s, StoreLocation=%s, size=%s bytes, isFormField=%s, FieldName=%s\",\n                      getName(), getStoreLocation(), getSize(), isFormField(), getFieldName());\n    }\n\n    // -------------------------------------------------- Serialization methods\n\n    /**\n     * Writes the state of this object during serialization.\n     *\n     * @param out The stream to which the state should be written.\n     *\n     * @throws IOException if an error occurs.\n     */\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        // Read the data\n        if (dfos.isInMemory()) {\n            cachedContent = get();\n        } else {\n            cachedContent = null;\n            dfosFile = dfos.getFile();\n        }\n\n        // write out values\n        out.defaultWriteObject();\n    }\n\n    /**\n     * Reads the state of this object during deserialization.\n     *\n     * @param in The stream from which the state should be read.\n     *\n     * @throws IOException if an error occurs.\n     * @throws ClassNotFoundException if class cannot be found.\n     */\n    private void readObject(ObjectInputStream in)\n            throws IOException, ClassNotFoundException {\n        // read values\n        in.defaultReadObject();\n\n        OutputStream output = getOutputStream();\n        if (cachedContent != null) {\n            output.write(cachedContent);\n        } else {\n            FileInputStream input = new FileInputStream(dfosFile);\n            IOUtils.copy(input, output);\n            dfosFile.delete();\n            dfosFile = null;\n        }\n        output.close();\n\n        cachedContent = null;\n    }\n\n    /**\n     * Returns the file item headers.\n     * @return The file items headers.\n     */\n    public FileItemHeaders getHeaders() {\n        return headers;\n    }\n\n    /**\n     * Sets the file item headers.\n     * @param pHeaders The file items headers.\n     */\n    public void setHeaders(FileItemHeaders pHeaders) {\n        headers = pHeaders;\n    }\n\n}\n",
        "human_patch_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.fileupload.disk;\n\nimport static java.lang.String.format;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileItemHeaders;\nimport org.apache.commons.fileupload.FileUploadException;\nimport org.apache.commons.fileupload.ParameterParser;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.output.DeferredFileOutputStream;\n\n/**\n * <p> The default implementation of the\n * {@link org.apache.commons.fileupload.FileItem FileItem} interface.\n *\n * <p> After retrieving an instance of this class from a {@link\n * org.apache.commons.fileupload.DiskFileUpload DiskFileUpload} instance (see\n * {@link org.apache.commons.fileupload.servlet.ServletFileUpload\n * #parseRequest(javax.servlet.http.HttpServletRequest)}), you may\n * either request all contents of file at once using {@link #get()} or\n * request an {@link java.io.InputStream InputStream} with\n * {@link #getInputStream()} and process the file without attempting to load\n * it into memory, which may come handy with large files.\n *\n * <p>Temporary files, which are created for file items, should be\n * deleted later on. The best way to do this is using a\n * {@link org.apache.commons.io.FileCleaningTracker}, which you can set on the\n * {@link DiskFileItemFactory}. However, if you do use such a tracker,\n * then you must consider the following: Temporary files are automatically\n * deleted as soon as they are no longer needed. (More precisely, when the\n * corresponding instance of {@link java.io.File} is garbage collected.)\n * This is done by the so-called reaper thread, which is started\n * automatically when the class {@link org.apache.commons.io.FileCleaner}\n * is loaded.\n * It might make sense to terminate that thread, for example, if\n * your web application ends. See the section on \"Resource cleanup\"\n * in the users guide of commons-fileupload.</p>\n *\n * @since FileUpload 1.1\n *\n * @version $Id$\n */\npublic class DiskFileItem\n    implements FileItem {\n\n    // ----------------------------------------------------- Manifest constants\n\n    /**\n     * The UID to use when serializing this instance.\n     */\n    private static final long serialVersionUID = 2237570099615271025L;\n\n    /**\n     * Default content charset to be used when no explicit charset\n     * parameter is provided by the sender. Media subtypes of the\n     * \"text\" type are defined to have a default charset value of\n     * \"ISO-8859-1\" when received via HTTP.\n     */\n    public static final String DEFAULT_CHARSET = \"ISO-8859-1\";\n\n    // ----------------------------------------------------------- Data members\n\n    /**\n     * UID used in unique file name generation.\n     */\n    private static final String UID =\n            UUID.randomUUID().toString().replace('-', '_');\n\n    /**\n     * Counter used in unique identifier generation.\n     */\n    private static final AtomicInteger COUNTER = new AtomicInteger(0);\n\n    /**\n     * The name of the form field as provided by the browser.\n     */\n    private String fieldName;\n\n    /**\n     * The content type passed by the browser, or <code>null</code> if\n     * not defined.\n     */\n    private final String contentType;\n\n    /**\n     * Whether or not this item is a simple form field.\n     */\n    private boolean isFormField;\n\n    /**\n     * The original filename in the user's filesystem.\n     */\n    private final String fileName;\n\n    /**\n     * The size of the item, in bytes. This is used to cache the size when a\n     * file item is moved from its original location.\n     */\n    private long size = -1;\n\n\n    /**\n     * The threshold above which uploads will be stored on disk.\n     */\n    private final int sizeThreshold;\n\n    /**\n     * The directory in which uploaded files will be stored, if stored on disk.\n     */\n    private final File repository;\n\n    /**\n     * Cached contents of the file.\n     */\n    private byte[] cachedContent;\n\n    /**\n     * Output stream for this item.\n     */\n    private transient DeferredFileOutputStream dfos;\n\n    /**\n     * The temporary file to use.\n     */\n    private transient File tempFile;\n\n    /**\n     * File to allow for serialization of the content of this item.\n     */\n    private File dfosFile;\n\n    /**\n     * The file items headers.\n     */\n    private FileItemHeaders headers;\n\n    // ----------------------------------------------------------- Constructors\n\n    /**\n     * Constructs a new <code>DiskFileItem</code> instance.\n     *\n     * @param fieldName     The name of the form field.\n     * @param contentType   The content type passed by the browser or\n     *                      <code>null</code> if not specified.\n     * @param isFormField   Whether or not this item is a plain form field, as\n     *                      opposed to a file upload.\n     * @param fileName      The original filename in the user's filesystem, or\n     *                      <code>null</code> if not specified.\n     * @param sizeThreshold The threshold, in bytes, below which items will be\n     *                      retained in memory and above which they will be\n     *                      stored as a file.\n     * @param repository    The data repository, which is the directory in\n     *                      which files will be created, should the item size\n     *                      exceed the threshold.\n     */\n    public DiskFileItem(String fieldName,\n            String contentType, boolean isFormField, String fileName,\n            int sizeThreshold, File repository) {\n        this.fieldName = fieldName;\n        this.contentType = contentType;\n        this.isFormField = isFormField;\n        this.fileName = fileName;\n        this.sizeThreshold = sizeThreshold;\n        this.repository = repository;\n    }\n\n    // ------------------------------- Methods from javax.activation.DataSource\n\n    /**\n     * Returns an {@link java.io.InputStream InputStream} that can be\n     * used to retrieve the contents of the file.\n     *\n     * @return An {@link java.io.InputStream InputStream} that can be\n     *         used to retrieve the contents of the file.\n     *\n     * @throws IOException if an error occurs.\n     */\n    public InputStream getInputStream()\n        throws IOException {\n        if (!isInMemory()) {\n            return new FileInputStream(dfos.getFile());\n        }\n\n        if (cachedContent == null) {\n            cachedContent = dfos.getData();\n        }\n        return new ByteArrayInputStream(cachedContent);\n    }\n\n    /**\n     * Returns the content type passed by the agent or <code>null</code> if\n     * not defined.\n     *\n     * @return The content type passed by the agent or <code>null</code> if\n     *         not defined.\n     */\n    public String getContentType() {\n        return contentType;\n    }\n\n    /**\n     * Returns the content charset passed by the agent or <code>null</code> if\n     * not defined.\n     *\n     * @return The content charset passed by the agent or <code>null</code> if\n     *         not defined.\n     */\n    public String getCharSet() {\n        ParameterParser parser = new ParameterParser();\n        parser.setLowerCaseNames(true);\n        // Parameter parser can handle null input\n        Map<String, String> params = parser.parse(getContentType(), ';');\n        return params.get(\"charset\");\n    }\n\n    /**\n     * Returns the original filename in the client's filesystem.\n     *\n     * @return The original filename in the client's filesystem.\n     * @throws org.apache.commons.fileupload.InvalidFileNameException The file name contains a NUL character,\n     *   which might be an indicator of a security attack. If you intend to\n     *   use the file name anyways, catch the exception and use\n     *   {@link org.apache.commons.fileupload.InvalidFileNameException#getName()}.\n     */\n    public String getName() {\n        return Streams.checkFileName(fileName);\n    }\n\n    // ------------------------------------------------------- FileItem methods\n\n    /**\n     * Provides a hint as to whether or not the file contents will be read\n     * from memory.\n     *\n     * @return <code>true</code> if the file contents will be read\n     *         from memory; <code>false</code> otherwise.\n     */\n    public boolean isInMemory() {\n        if (cachedContent != null) {\n            return true;\n        }\n        return dfos.isInMemory();\n    }\n\n    /**\n     * Returns the size of the file.\n     *\n     * @return The size of the file, in bytes.\n     */\n    public long getSize() {\n        if (size >= 0) {\n            return size;\n        } else if (cachedContent != null) {\n            return cachedContent.length;\n        } else if (dfos.isInMemory()) {\n            return dfos.getData().length;\n        } else {\n            return dfos.getFile().length();\n        }\n    }\n\n    /**\n     * Returns the contents of the file as an array of bytes.  If the\n     * contents of the file were not yet cached in memory, they will be\n     * loaded from the disk storage and cached.\n     *\n     * @return The contents of the file as an array of bytes.\n     */\n    public byte[] get() {\n        if (isInMemory()) {\n            if (cachedContent == null) {\n                cachedContent = dfos.getData();\n            }\n            return cachedContent;\n        }\n\n        byte[] fileData = new byte[(int) getSize()];\n        InputStream fis = null;\n\n        try {\n            fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));\n            fis.read(fileData);\n        } catch (IOException e) {\n            fileData = null;\n        } finally {\n            if (fis != null) {\n                try {\n                    fis.close();\n                } catch (IOException e) {\n                    // ignore\n                }\n            }\n        }\n\n        return fileData;\n    }\n\n    /**\n     * Returns the contents of the file as a String, using the specified\n     * encoding.  This method uses {@link #get()} to retrieve the\n     * contents of the file.\n     *\n     * @param charset The charset to use.\n     *\n     * @return The contents of the file, as a string.\n     *\n     * @throws UnsupportedEncodingException if the requested character\n     *                                      encoding is not available.\n     */\n    public String getString(final String charset)\n        throws UnsupportedEncodingException {\n        return new String(get(), charset);\n    }\n\n    /**\n     * Returns the contents of the file as a String, using the default\n     * character encoding.  This method uses {@link #get()} to retrieve the\n     * contents of the file.\n     *\n     * <b>TODO</b> Consider making this method throw UnsupportedEncodingException.\n     *\n     * @return The contents of the file, as a string.\n     */\n    public String getString() {\n        byte[] rawdata = get();\n        String charset = getCharSet();\n        if (charset == null) {\n            charset = DEFAULT_CHARSET;\n        }\n        try {\n            return new String(rawdata, charset);\n        } catch (UnsupportedEncodingException e) {\n            return new String(rawdata);\n        }\n    }\n\n    /**\n     * A convenience method to write an uploaded item to disk. The client code\n     * is not concerned with whether or not the item is stored in memory, or on\n     * disk in a temporary location. They just want to write the uploaded item\n     * to a file.\n     * <p>\n     * This implementation first attempts to rename the uploaded item to the\n     * specified destination file, if the item was originally written to disk.\n     * Otherwise, the data will be copied to the specified file.\n     * <p>\n     * This method is only guaranteed to work <em>once</em>, the first time it\n     * is invoked for a particular item. This is because, in the event that the\n     * method renames a temporary file, that file will no longer be available\n     * to copy or rename again at a later time.\n     *\n     * @param file The <code>File</code> into which the uploaded item should\n     *             be stored.\n     *\n     * @throws Exception if an error occurs.\n     */\n    public void write(File file) throws Exception {\n        if (isInMemory()) {\n            FileOutputStream fout = null;\n            try {\n                fout = new FileOutputStream(file);\n                fout.write(get());\n            } finally {\n                if (fout != null) {\n                    fout.close();\n                }\n            }\n        } else {\n            File outputFile = getStoreLocation();\n            if (outputFile != null) {\n                // Save the length of the file\n                size = outputFile.length();\n                /*\n                 * The uploaded file is being stored on disk\n                 * in a temporary location so move it to the\n                 * desired file.\n                 */\n                if (!outputFile.renameTo(file)) {\n                    BufferedInputStream in = null;\n                    BufferedOutputStream out = null;\n                    try {\n                        in = new BufferedInputStream(\n                            new FileInputStream(outputFile));\n                        out = new BufferedOutputStream(\n                                new FileOutputStream(file));\n                        IOUtils.copy(in, out);\n                    } finally {\n                        if (in != null) {\n                            try {\n                                in.close();\n                            } catch (IOException e) {\n                                // ignore\n                            }\n                        }\n                        if (out != null) {\n                            try {\n                                out.close();\n                            } catch (IOException e) {\n                                // ignore\n                            }\n                        }\n                    }\n                }\n            } else {\n                /*\n                 * For whatever reason we cannot write the\n                 * file to disk.\n                 */\n                throw new FileUploadException(\n                    \"Cannot write uploaded file to disk!\");\n            }\n        }\n    }\n\n    /**\n     * Deletes the underlying storage for a file item, including deleting any\n     * associated temporary disk file. Although this storage will be deleted\n     * automatically when the <code>FileItem</code> instance is garbage\n     * collected, this method can be used to ensure that this is done at an\n     * earlier time, thus preserving system resources.\n     */\n    public void delete() {\n        cachedContent = null;\n        File outputFile = getStoreLocation();\n        if (outputFile != null && outputFile.exists()) {\n            outputFile.delete();\n        }\n    }\n\n    /**\n     * Returns the name of the field in the multipart form corresponding to\n     * this file item.\n     *\n     * @return The name of the form field.\n     *\n     * @see #setFieldName(java.lang.String)\n     *\n     */\n    public String getFieldName() {\n        return fieldName;\n    }\n\n    /**\n     * Sets the field name used to reference this file item.\n     *\n     * @param fieldName The name of the form field.\n     *\n     * @see #getFieldName()\n     *\n     */\n    public void setFieldName(String fieldName) {\n        this.fieldName = fieldName;\n    }\n\n    /**\n     * Determines whether or not a <code>FileItem</code> instance represents\n     * a simple form field.\n     *\n     * @return <code>true</code> if the instance represents a simple form\n     *         field; <code>false</code> if it represents an uploaded file.\n     *\n     * @see #setFormField(boolean)\n     *\n     */\n    public boolean isFormField() {\n        return isFormField;\n    }\n\n    /**\n     * Specifies whether or not a <code>FileItem</code> instance represents\n     * a simple form field.\n     *\n     * @param state <code>true</code> if the instance represents a simple form\n     *              field; <code>false</code> if it represents an uploaded file.\n     *\n     * @see #isFormField()\n     *\n     */\n    public void setFormField(boolean state) {\n        isFormField = state;\n    }\n\n    /**\n     * Returns an {@link java.io.OutputStream OutputStream} that can\n     * be used for storing the contents of the file.\n     *\n     * @return An {@link java.io.OutputStream OutputStream} that can be used\n     *         for storing the contensts of the file.\n     *\n     * @throws IOException if an error occurs.\n     */\n    public OutputStream getOutputStream()\n        throws IOException {\n        if (dfos == null) {\n            File outputFile = getTempFile();\n            dfos = new DeferredFileOutputStream(sizeThreshold, outputFile);\n        }\n        return dfos;\n    }\n\n    // --------------------------------------------------------- Public methods\n\n    /**\n     * Returns the {@link java.io.File} object for the <code>FileItem</code>'s\n     * data's temporary location on the disk. Note that for\n     * <code>FileItem</code>s that have their data stored in memory,\n     * this method will return <code>null</code>. When handling large\n     * files, you can use {@link java.io.File#renameTo(java.io.File)} to\n     * move the file to new location without copying the data, if the\n     * source and destination locations reside within the same logical\n     * volume.\n     *\n     * @return The data file, or <code>null</code> if the data is stored in\n     *         memory.\n     */\n    public File getStoreLocation() {\n        if (dfos == null) {\n            return null;\n        }\n        return dfos.getFile();\n    }\n\n    // ------------------------------------------------------ Protected methods\n\n    /**\n     * Removes the file contents from the temporary storage.\n     */\n    @Override\n    protected void finalize() {\n        File outputFile = dfos.getFile();\n\n        if (outputFile != null && outputFile.exists()) {\n            outputFile.delete();\n        }\n    }\n\n    /**\n     * Creates and returns a {@link java.io.File File} representing a uniquely\n     * named temporary file in the configured repository path. The lifetime of\n     * the file is tied to the lifetime of the <code>FileItem</code> instance;\n     * the file will be deleted when the instance is garbage collected.\n     *\n     * @return The {@link java.io.File File} to be used for temporary storage.\n     */\n    protected File getTempFile() {\n        if (tempFile == null) {\n            File tempDir = repository;\n            if (tempDir == null) {\n                tempDir = new File(System.getProperty(\"java.io.tmpdir\"));\n            }\n\n            String tempFileName = format(\"upload_%s_%s.tmp\", UID, getUniqueId());\n\n            tempFile = new File(tempDir, tempFileName);\n        }\n        return tempFile;\n    }\n\n    // -------------------------------------------------------- Private methods\n\n    /**\n     * Returns an identifier that is unique within the class loader used to\n     * load this class, but does not have random-like apearance.\n     *\n     * @return A String with the non-random looking instance identifier.\n     */\n    private static String getUniqueId() {\n        final int limit = 100000000;\n        int current = COUNTER.getAndIncrement();\n        String id = Integer.toString(current);\n\n        // If you manage to get more than 100 million of ids, you'll\n        // start getting ids longer than 8 characters.\n        if (current < limit) {\n            id = (\"00000000\" + id).substring(id.length());\n        }\n        return id;\n    }\n\n    /**\n     * Returns a string representation of this object.\n     *\n     * @return a string representation of this object.\n     */\n    @Override\n    public String toString() {\n        return format(\"name=%s, StoreLocation=%s, size=%s bytes, isFormField=%s, FieldName=%s\",\n                      getName(), getStoreLocation(), getSize(), isFormField(), getFieldName());\n    }\n\n    // -------------------------------------------------- Serialization methods\n\n    /**\n     * Writes the state of this object during serialization.\n     *\n     * @param out The stream to which the state should be written.\n     *\n     * @throws IOException if an error occurs.\n     */\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        // Read the data\n        if (dfos.isInMemory()) {\n            cachedContent = get();\n        } else {\n            cachedContent = null;\n            dfosFile = dfos.getFile();\n        }\n\n        // write out values\n        out.defaultWriteObject();\n    }\n\n    /**\n     * Reads the state of this object during deserialization.\n     *\n     * @param in The stream from which the state should be read.\n     *\n     * @throws IOException if an error occurs.\n     * @throws ClassNotFoundException if class cannot be found.\n     */\n    private void readObject(ObjectInputStream in)\n            throws IOException, ClassNotFoundException {\n        // read values\n        in.defaultReadObject();\n\n        /* One expected use of serialization is to migrate HTTP sessions\n         * containing a DiskFileItem between JVMs. Particularly if the JVMs are\n         * on different machines It is possible that the repository location is\n         * not valid so validate it.\n         */\n        if (repository != null) {\n            if (repository.isDirectory()) {\n                // Check path for nulls\n                if (repository.getPath().contains(\"\\0\")) {\n                    throw new IOException(format(\n                            \"The repository [%s] contains a null character\",\n                            repository.getPath()));\n                }\n            } else {\n                throw new IOException(format(\n                        \"The repository [%s] is not a directory\",\n                        repository.getAbsolutePath()));\n            }\n        }\n\n        OutputStream output = getOutputStream();\n        if (cachedContent != null) {\n            output.write(cachedContent);\n        } else {\n            FileInputStream input = new FileInputStream(dfosFile);\n            IOUtils.copy(input, output);\n            dfosFile.delete();\n            dfosFile = null;\n        }\n        output.close();\n\n        cachedContent = null;\n    }\n\n    /**\n     * Returns the file item headers.\n     * @return The file items headers.\n     */\n    public FileItemHeaders getHeaders() {\n        return headers;\n    }\n\n    /**\n     * Sets the file item headers.\n     * @param pHeaders The file items headers.\n     */\n    public void setHeaders(FileItemHeaders pHeaders) {\n        headers = pHeaders;\n    }\n\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-11": {
    "vul_id": "VUL4J-11",
    "cve_id": "CVE-2014-0050",
    "project": "apache_commons-fileupload",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=org.apache.commons.fileupload.MultipartStreamTest#testSmallBuffer",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/apache/commons-fileupload/commit/c61ff05b3241cb14d989b67209e57aa71540417a",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/org/apache/commons/fileupload/FileUploadBase.java",
        "file_name": "FileUploadBase.java",
        "vulnerable_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.fileupload;\n\nimport static java.lang.String.format;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.apache.commons.fileupload.MultipartStream.ItemInputStream;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.apache.commons.fileupload.servlet.ServletRequestContext;\nimport org.apache.commons.fileupload.util.Closeable;\nimport org.apache.commons.fileupload.util.FileItemHeadersImpl;\nimport org.apache.commons.fileupload.util.LimitedInputStream;\nimport org.apache.commons.fileupload.util.Streams;\n\n/**\n * <p>High level API for processing file uploads.</p>\n *\n * <p>This class handles multiple files per single HTML widget, sent using\n * <code>multipart/mixed</code> encoding type, as specified by\n * <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a>.  Use {@link\n * #parseRequest(RequestContext)} to acquire a list of {@link\n * org.apache.commons.fileupload.FileItem}s associated with a given HTML\n * widget.</p>\n *\n * <p>How the data for individual parts is stored is determined by the factory\n * used to create them; a given part may be in memory, on disk, or somewhere\n * else.</p>\n *\n * @version $Id$\n */\npublic abstract class FileUploadBase {\n\n    // ---------------------------------------------------------- Class methods\n\n    /**\n     * <p>Utility method that determines whether the request contains multipart\n     * content.</p>\n     *\n     * <p><strong>NOTE:</strong>This method will be moved to the\n     * <code>ServletFileUpload</code> class after the FileUpload 1.1 release.\n     * Unfortunately, since this method is static, it is not possible to\n     * provide its replacement until this method is removed.</p>\n     *\n     * @param ctx The request context to be evaluated. Must be non-null.\n     *\n     * @return <code>true</code> if the request is multipart;\n     *         <code>false</code> otherwise.\n     */\n    public static final boolean isMultipartContent(RequestContext ctx) {\n        String contentType = ctx.getContentType();\n        if (contentType == null) {\n            return false;\n        }\n        if (contentType.toLowerCase(Locale.ENGLISH).startsWith(MULTIPART)) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Utility method that determines whether the request contains multipart\n     * content.\n     *\n     * @param req The servlet request to be evaluated. Must be non-null.\n     *\n     * @return <code>true</code> if the request is multipart;\n     *         <code>false</code> otherwise.\n     *\n     * @deprecated 1.1 Use the method on <code>ServletFileUpload</code> instead.\n     */\n    @Deprecated\n    public static boolean isMultipartContent(HttpServletRequest req) {\n        return ServletFileUpload.isMultipartContent(req);\n    }\n\n    // ----------------------------------------------------- Manifest constants\n\n    /**\n     * HTTP content type header name.\n     */\n    public static final String CONTENT_TYPE = \"Content-type\";\n\n    /**\n     * HTTP content disposition header name.\n     */\n    public static final String CONTENT_DISPOSITION = \"Content-disposition\";\n\n    /**\n     * HTTP content length header name.\n     */\n    public static final String CONTENT_LENGTH = \"Content-length\";\n\n    /**\n     * Content-disposition value for form data.\n     */\n    public static final String FORM_DATA = \"form-data\";\n\n    /**\n     * Content-disposition value for file attachment.\n     */\n    public static final String ATTACHMENT = \"attachment\";\n\n    /**\n     * Part of HTTP content type header.\n     */\n    public static final String MULTIPART = \"multipart/\";\n\n    /**\n     * HTTP content type header for multipart forms.\n     */\n    public static final String MULTIPART_FORM_DATA = \"multipart/form-data\";\n\n    /**\n     * HTTP content type header for multiple uploads.\n     */\n    public static final String MULTIPART_MIXED = \"multipart/mixed\";\n\n    /**\n     * The maximum length of a single header line that will be parsed\n     * (1024 bytes).\n     * @deprecated This constant is no longer used. As of commons-fileupload\n     *   1.2, the only applicable limit is the total size of a parts headers,\n     *   {@link MultipartStream#HEADER_PART_SIZE_MAX}.\n     */\n    @Deprecated\n    public static final int MAX_HEADER_SIZE = 1024;\n\n    // ----------------------------------------------------------- Data members\n\n    /**\n     * The maximum size permitted for the complete request, as opposed to\n     * {@link #fileSizeMax}. A value of -1 indicates no maximum.\n     */\n    private long sizeMax = -1;\n\n    /**\n     * The maximum size permitted for a single uploaded file, as opposed\n     * to {@link #sizeMax}. A value of -1 indicates no maximum.\n     */\n    private long fileSizeMax = -1;\n\n    /**\n     * The content encoding to use when reading part headers.\n     */\n    private String headerEncoding;\n\n    /**\n     * The progress listener.\n     */\n    private ProgressListener listener;\n\n    // ----------------------------------------------------- Property accessors\n\n    /**\n     * Returns the factory class used when creating file items.\n     *\n     * @return The factory class for new file items.\n     */\n    public abstract FileItemFactory getFileItemFactory();\n\n    /**\n     * Sets the factory class to use when creating file items.\n     *\n     * @param factory The factory class for new file items.\n     */\n    public abstract void setFileItemFactory(FileItemFactory factory);\n\n    /**\n     * Returns the maximum allowed size of a complete request, as opposed\n     * to {@link #getFileSizeMax()}.\n     *\n     * @return The maximum allowed size, in bytes. The default value of\n     *   -1 indicates, that there is no limit.\n     *\n     * @see #setSizeMax(long)\n     *\n     */\n    public long getSizeMax() {\n        return sizeMax;\n    }\n\n    /**\n     * Sets the maximum allowed size of a complete request, as opposed\n     * to {@link #setFileSizeMax(long)}.\n     *\n     * @param sizeMax The maximum allowed size, in bytes. The default value of\n     *   -1 indicates, that there is no limit.\n     *\n     * @see #getSizeMax()\n     *\n     */\n    public void setSizeMax(long sizeMax) {\n        this.sizeMax = sizeMax;\n    }\n\n    /**\n     * Returns the maximum allowed size of a single uploaded file,\n     * as opposed to {@link #getSizeMax()}.\n     *\n     * @see #setFileSizeMax(long)\n     * @return Maximum size of a single uploaded file.\n     */\n    public long getFileSizeMax() {\n        return fileSizeMax;\n    }\n\n    /**\n     * Sets the maximum allowed size of a single uploaded file,\n     * as opposed to {@link #getSizeMax()}.\n     *\n     * @see #getFileSizeMax()\n     * @param fileSizeMax Maximum size of a single uploaded file.\n     */\n    public void setFileSizeMax(long fileSizeMax) {\n        this.fileSizeMax = fileSizeMax;\n    }\n\n    /**\n     * Retrieves the character encoding used when reading the headers of an\n     * individual part. When not specified, or <code>null</code>, the request\n     * encoding is used. If that is also not specified, or <code>null</code>,\n     * the platform default encoding is used.\n     *\n     * @return The encoding used to read part headers.\n     */\n    public String getHeaderEncoding() {\n        return headerEncoding;\n    }\n\n    /**\n     * Specifies the character encoding to be used when reading the headers of\n     * individual part. When not specified, or <code>null</code>, the request\n     * encoding is used. If that is also not specified, or <code>null</code>,\n     * the platform default encoding is used.\n     *\n     * @param encoding The encoding used to read part headers.\n     */\n    public void setHeaderEncoding(String encoding) {\n        headerEncoding = encoding;\n    }\n\n    // --------------------------------------------------------- Public methods\n\n    /**\n     * Processes an <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a>\n     * compliant <code>multipart/form-data</code> stream.\n     *\n     * @param req The servlet request to be parsed.\n     *\n     * @return A list of <code>FileItem</code> instances parsed from the\n     *         request, in the order that they were transmitted.\n     *\n     * @throws FileUploadException if there are problems reading/parsing\n     *                             the request or storing files.\n     *\n     * @deprecated 1.1 Use {@link ServletFileUpload#parseRequest(HttpServletRequest)} instead.\n     */\n    @Deprecated\n    public List<FileItem> parseRequest(HttpServletRequest req)\n    throws FileUploadException {\n        return parseRequest(new ServletRequestContext(req));\n    }\n\n    /**\n     * Processes an <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a>\n     * compliant <code>multipart/form-data</code> stream.\n     *\n     * @param ctx The context for the request to be parsed.\n     *\n     * @return An iterator to instances of <code>FileItemStream</code>\n     *         parsed from the request, in the order that they were\n     *         transmitted.\n     *\n     * @throws FileUploadException if there are problems reading/parsing\n     *                             the request or storing files.\n     * @throws IOException An I/O error occurred. This may be a network\n     *   error while communicating with the client or a problem while\n     *   storing the uploaded content.\n     */\n    public FileItemIterator getItemIterator(RequestContext ctx)\n    throws FileUploadException, IOException {\n        try {\n            return new FileItemIteratorImpl(ctx);\n        } catch (FileUploadIOException e) {\n            // unwrap encapsulated SizeException\n            throw (FileUploadException) e.getCause();\n        }\n    }\n\n    /**\n     * Processes an <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a>\n     * compliant <code>multipart/form-data</code> stream.\n     *\n     * @param ctx The context for the request to be parsed.\n     *\n     * @return A list of <code>FileItem</code> instances parsed from the\n     *         request, in the order that they were transmitted.\n     *\n     * @throws FileUploadException if there are problems reading/parsing\n     *                             the request or storing files.\n     */\n    public List<FileItem> parseRequest(RequestContext ctx)\n            throws FileUploadException {\n        List<FileItem> items = new ArrayList<FileItem>();\n        boolean successful = false;\n        try {\n            FileItemIterator iter = getItemIterator(ctx);\n            FileItemFactory fac = getFileItemFactory();\n            if (fac == null) {\n                throw new NullPointerException(\"No FileItemFactory has been set.\");\n            }\n            while (iter.hasNext()) {\n                final FileItemStream item = iter.next();\n                // Don't use getName() here to prevent an InvalidFileNameException.\n                final String fileName = ((FileItemIteratorImpl.FileItemStreamImpl) item).name;\n                FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(),\n                                                   item.isFormField(), fileName);\n                items.add(fileItem);\n                try {\n                    Streams.copy(item.openStream(), fileItem.getOutputStream(), true);\n                } catch (FileUploadIOException e) {\n                    throw (FileUploadException) e.getCause();\n                } catch (IOException e) {\n                    throw new IOFileUploadException(format(\"Processing of %s request failed. %s\",\n                                                           MULTIPART_FORM_DATA, e.getMessage()), e);\n                }\n                final FileItemHeaders fih = item.getHeaders();\n                fileItem.setHeaders(fih);\n            }\n            successful = true;\n            return items;\n        } catch (FileUploadIOException e) {\n            throw (FileUploadException) e.getCause();\n        } catch (IOException e) {\n            throw new FileUploadException(e.getMessage(), e);\n        } finally {\n            if (!successful) {\n                for (FileItem fileItem : items) {\n                    try {\n                        fileItem.delete();\n                    } catch (Throwable e) {\n                        // ignore it\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Processes an <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a>\n     * compliant <code>multipart/form-data</code> stream.\n     *\n     * @param ctx The context for the request to be parsed.\n     *\n     * @return A map of <code>FileItem</code> instances parsed from the request.\n     *\n     * @throws FileUploadException if there are problems reading/parsing\n     *                             the request or storing files.\n     *\n     * @since 1.3\n     */\n    public Map<String, List<FileItem>> parseParameterMap(RequestContext ctx)\n            throws FileUploadException {\n        final List<FileItem> items = parseRequest(ctx);\n        final Map<String, List<FileItem>> itemsMap = new HashMap<String, List<FileItem>>(items.size());\n\n        for (FileItem fileItem : items) {\n            String fieldName = fileItem.getFieldName();\n            List<FileItem> mappedItems = itemsMap.get(fieldName);\n\n            if (mappedItems == null) {\n                mappedItems = new ArrayList<FileItem>();\n                itemsMap.put(fieldName, mappedItems);\n            }\n\n            mappedItems.add(fileItem);\n        }\n\n        return itemsMap;\n    }\n\n    // ------------------------------------------------------ Protected methods\n\n    /**\n     * Retrieves the boundary from the <code>Content-type</code> header.\n     *\n     * @param contentType The value of the content type header from which to\n     *                    extract the boundary value.\n     *\n     * @return The boundary, as a byte array.\n     */\n    protected byte[] getBoundary(String contentType) {\n        ParameterParser parser = new ParameterParser();\n        parser.setLowerCaseNames(true);\n        // Parameter parser can handle null input\n        Map<String, String> params = parser.parse(contentType, new char[] {';', ','});\n        String boundaryStr = params.get(\"boundary\");\n\n        if (boundaryStr == null) {\n            return null;\n        }\n        byte[] boundary;\n        try {\n            boundary = boundaryStr.getBytes(\"ISO-8859-1\");\n        } catch (UnsupportedEncodingException e) {\n            boundary = boundaryStr.getBytes(); // Intentionally falls back to default charset\n        }\n        return boundary;\n    }\n\n    /**\n     * Retrieves the file name from the <code>Content-disposition</code>\n     * header.\n     *\n     * @param headers A <code>Map</code> containing the HTTP request headers.\n     *\n     * @return The file name for the current <code>encapsulation</code>.\n     * @deprecated 1.2.1 Use {@link #getFileName(FileItemHeaders)}.\n     */\n    @Deprecated\n    protected String getFileName(Map<String, String> headers) {\n        return getFileName(getHeader(headers, CONTENT_DISPOSITION));\n    }\n\n    /**\n     * Retrieves the file name from the <code>Content-disposition</code>\n     * header.\n     *\n     * @param headers The HTTP headers object.\n     *\n     * @return The file name for the current <code>encapsulation</code>.\n     */\n    protected String getFileName(FileItemHeaders headers) {\n        return getFileName(headers.getHeader(CONTENT_DISPOSITION));\n    }\n\n    /**\n     * Returns the given content-disposition headers file name.\n     * @param pContentDisposition The content-disposition headers value.\n     * @return The file name\n     */\n    private String getFileName(String pContentDisposition) {\n        String fileName = null;\n        if (pContentDisposition != null) {\n            String cdl = pContentDisposition.toLowerCase(Locale.ENGLISH);\n            if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {\n                ParameterParser parser = new ParameterParser();\n                parser.setLowerCaseNames(true);\n                // Parameter parser can handle null input\n                Map<String, String> params = parser.parse(pContentDisposition, ';');\n                if (params.containsKey(\"filename\")) {\n                    fileName = params.get(\"filename\");\n                    if (fileName != null) {\n                        fileName = fileName.trim();\n                    } else {\n                        // Even if there is no value, the parameter is present,\n                        // so we return an empty file name rather than no file\n                        // name.\n                        fileName = \"\";\n                    }\n                }\n            }\n        }\n        return fileName;\n    }\n\n    /**\n     * Retrieves the field name from the <code>Content-disposition</code>\n     * header.\n     *\n     * @param headers A <code>Map</code> containing the HTTP request headers.\n     *\n     * @return The field name for the current <code>encapsulation</code>.\n     */\n    protected String getFieldName(FileItemHeaders headers) {\n        return getFieldName(headers.getHeader(CONTENT_DISPOSITION));\n    }\n\n    /**\n     * Returns the field name, which is given by the content-disposition\n     * header.\n     * @param pContentDisposition The content-dispositions header value.\n     * @return The field jake\n     */\n    private String getFieldName(String pContentDisposition) {\n        String fieldName = null;\n        if (pContentDisposition != null\n                && pContentDisposition.toLowerCase(Locale.ENGLISH).startsWith(FORM_DATA)) {\n            ParameterParser parser = new ParameterParser();\n            parser.setLowerCaseNames(true);\n            // Parameter parser can handle null input\n            Map<String, String> params = parser.parse(pContentDisposition, ';');\n            fieldName = params.get(\"name\");\n            if (fieldName != null) {\n                fieldName = fieldName.trim();\n            }\n        }\n        return fieldName;\n    }\n\n    /**\n     * Retrieves the field name from the <code>Content-disposition</code>\n     * header.\n     *\n     * @param headers A <code>Map</code> containing the HTTP request headers.\n     *\n     * @return The field name for the current <code>encapsulation</code>.\n     * @deprecated 1.2.1 Use {@link #getFieldName(FileItemHeaders)}.\n     */\n    @Deprecated\n    protected String getFieldName(Map<String, String> headers) {\n        return getFieldName(getHeader(headers, CONTENT_DISPOSITION));\n    }\n\n    /**\n     * Creates a new {@link FileItem} instance.\n     *\n     * @param headers       A <code>Map</code> containing the HTTP request\n     *                      headers.\n     * @param isFormField   Whether or not this item is a form field, as\n     *                      opposed to a file.\n     *\n     * @return A newly created <code>FileItem</code> instance.\n     *\n     * @throws FileUploadException if an error occurs.\n     * @deprecated 1.2 This method is no longer used in favour of\n     *   internally created instances of {@link FileItem}.\n     */\n    @Deprecated\n    protected FileItem createItem(Map<String, String> headers,\n                                  boolean isFormField)\n        throws FileUploadException {\n        return getFileItemFactory().createItem(getFieldName(headers),\n                getHeader(headers, CONTENT_TYPE),\n                isFormField,\n                getFileName(headers));\n    }\n\n    /**\n     * <p> Parses the <code>header-part</code> and returns as key/value\n     * pairs.\n     *\n     * <p> If there are multiple headers of the same names, the name\n     * will map to a comma-separated list containing the values.\n     *\n     * @param headerPart The <code>header-part</code> of the current\n     *                   <code>encapsulation</code>.\n     *\n     * @return A <code>Map</code> containing the parsed HTTP request headers.\n     */\n    protected FileItemHeaders getParsedHeaders(String headerPart) {\n        final int len = headerPart.length();\n        FileItemHeadersImpl headers = newFileItemHeaders();\n        int start = 0;\n        for (;;) {\n            int end = parseEndOfLine(headerPart, start);\n            if (start == end) {\n                break;\n            }\n            StringBuilder header = new StringBuilder(headerPart.substring(start, end));\n            start = end + 2;\n            while (start < len) {\n                int nonWs = start;\n                while (nonWs < len) {\n                    char c = headerPart.charAt(nonWs);\n                    if (c != ' '  &&  c != '\\t') {\n                        break;\n                    }\n                    ++nonWs;\n                }\n                if (nonWs == start) {\n                    break;\n                }\n                // Continuation line found\n                end = parseEndOfLine(headerPart, nonWs);\n                header.append(\" \").append(headerPart.substring(nonWs, end));\n                start = end + 2;\n            }\n            parseHeaderLine(headers, header.toString());\n        }\n        return headers;\n    }\n\n    /**\n     * Creates a new instance of {@link FileItemHeaders}.\n     * @return The new instance.\n     */\n    protected FileItemHeadersImpl newFileItemHeaders() {\n        return new FileItemHeadersImpl();\n    }\n\n    /**\n     * <p> Parses the <code>header-part</code> and returns as key/value\n     * pairs.\n     *\n     * <p> If there are multiple headers of the same names, the name\n     * will map to a comma-separated list containing the values.\n     *\n     * @param headerPart The <code>header-part</code> of the current\n     *                   <code>encapsulation</code>.\n     *\n     * @return A <code>Map</code> containing the parsed HTTP request headers.\n     * @deprecated 1.2.1 Use {@link #getParsedHeaders(String)}\n     */\n    @Deprecated\n    protected Map<String, String> parseHeaders(String headerPart) {\n        FileItemHeaders headers = getParsedHeaders(headerPart);\n        Map<String, String> result = new HashMap<String, String>();\n        for (Iterator<String> iter = headers.getHeaderNames();  iter.hasNext();) {\n            String headerName = iter.next();\n            Iterator<String> iter2 = headers.getHeaders(headerName);\n            StringBuilder headerValue = new StringBuilder(iter2.next());\n            while (iter2.hasNext()) {\n                headerValue.append(\",\").append(iter2.next());\n            }\n            result.put(headerName, headerValue.toString());\n        }\n        return result;\n    }\n\n    /**\n     * Skips bytes until the end of the current line.\n     * @param headerPart The headers, which are being parsed.\n     * @param end Index of the last byte, which has yet been\n     *   processed.\n     * @return Index of the \\r\\n sequence, which indicates\n     *   end of line.\n     */\n    private int parseEndOfLine(String headerPart, int end) {\n        int index = end;\n        for (;;) {\n            int offset = headerPart.indexOf('\\r', index);\n            if (offset == -1  ||  offset + 1 >= headerPart.length()) {\n                throw new IllegalStateException(\n                    \"Expected headers to be terminated by an empty line.\");\n            }\n            if (headerPart.charAt(offset + 1) == '\\n') {\n                return offset;\n            }\n            index = offset + 1;\n        }\n    }\n\n    /**\n     * Reads the next header line.\n     * @param headers String with all headers.\n     * @param header Map where to store the current header.\n     */\n    private void parseHeaderLine(FileItemHeadersImpl headers, String header) {\n        final int colonOffset = header.indexOf(':');\n        if (colonOffset == -1) {\n            // This header line is malformed, skip it.\n            return;\n        }\n        String headerName = header.substring(0, colonOffset).trim();\n        String headerValue =\n            header.substring(header.indexOf(':') + 1).trim();\n        headers.addHeader(headerName, headerValue);\n    }\n\n    /**\n     * Returns the header with the specified name from the supplied map. The\n     * header lookup is case-insensitive.\n     *\n     * @param headers A <code>Map</code> containing the HTTP request headers.\n     * @param name    The name of the header to return.\n     *\n     * @return The value of specified header, or a comma-separated list if\n     *         there were multiple headers of that name.\n     * @deprecated 1.2.1 Use {@link FileItemHeaders#getHeader(String)}.\n     */\n    @Deprecated\n    protected final String getHeader(Map<String, String> headers,\n            String name) {\n        return headers.get(name.toLowerCase(Locale.ENGLISH));\n    }\n\n    /**\n     * The iterator, which is returned by\n     * {@link FileUploadBase#getItemIterator(RequestContext)}.\n     */\n    private class FileItemIteratorImpl implements FileItemIterator {\n\n        /**\n         * Default implementation of {@link FileItemStream}.\n         */\n        class FileItemStreamImpl implements FileItemStream {\n\n            /**\n             * The file items content type.\n             */\n            private final String contentType;\n\n            /**\n             * The file items field name.\n             */\n            private final String fieldName;\n\n            /**\n             * The file items file name.\n             */\n            private final String name;\n\n            /**\n             * Whether the file item is a form field.\n             */\n            private final boolean formField;\n\n            /**\n             * The file items input stream.\n             */\n            private final InputStream stream;\n\n            /**\n             * Whether the file item was already opened.\n             */\n            private boolean opened;\n\n            /**\n             * The headers, if any.\n             */\n            private FileItemHeaders headers;\n\n            /**\n             * Creates a new instance.\n             *\n             * @param pName The items file name, or null.\n             * @param pFieldName The items field name.\n             * @param pContentType The items content type, or null.\n             * @param pFormField Whether the item is a form field.\n             * @param pContentLength The items content length, if known, or -1\n             * @throws IOException Creating the file item failed.\n             */\n            FileItemStreamImpl(String pName, String pFieldName,\n                    String pContentType, boolean pFormField,\n                    long pContentLength) throws IOException {\n                name = pName;\n                fieldName = pFieldName;\n                contentType = pContentType;\n                formField = pFormField;\n                final ItemInputStream itemStream = multi.newInputStream();\n                InputStream istream = itemStream;\n                if (fileSizeMax != -1) {\n                    if (pContentLength != -1\n                            &&  pContentLength > fileSizeMax) {\n                        FileSizeLimitExceededException e =\n                            new FileSizeLimitExceededException(\n                                format(\"The field %s exceeds its maximum permitted size of %s bytes.\",\n                                       fieldName, Long.valueOf(fileSizeMax)),\n                                pContentLength, fileSizeMax);\n                        e.setFileName(pName);\n                        e.setFieldName(pFieldName);\n                        throw new FileUploadIOException(e);\n                    }\n                    istream = new LimitedInputStream(istream, fileSizeMax) {\n                        @Override\n                        protected void raiseError(long pSizeMax, long pCount)\n                                throws IOException {\n                            itemStream.close(true);\n                            FileSizeLimitExceededException e =\n                                new FileSizeLimitExceededException(\n                                    format(\"The field %s exceeds its maximum permitted size of %s bytes.\",\n                                           fieldName, Long.valueOf(pSizeMax)),\n                                    pCount, pSizeMax);\n                            e.setFieldName(fieldName);\n                            e.setFileName(name);\n                            throw new FileUploadIOException(e);\n                        }\n                    };\n                }\n                stream = istream;\n            }\n\n            /**\n             * Returns the items content type, or null.\n             *\n             * @return Content type, if known, or null.\n             */\n            public String getContentType() {\n                return contentType;\n            }\n\n            /**\n             * Returns the items field name.\n             *\n             * @return Field name.\n             */\n            public String getFieldName() {\n                return fieldName;\n            }\n\n            /**\n             * Returns the items file name.\n             *\n             * @return File name, if known, or null.\n             * @throws InvalidFileNameException The file name contains a NUL character,\n             *   which might be an indicator of a security attack. If you intend to\n             *   use the file name anyways, catch the exception and use\n             *   InvalidFileNameException#getName().\n             */\n            public String getName() {\n                return Streams.checkFileName(name);\n            }\n\n            /**\n             * Returns, whether this is a form field.\n             *\n             * @return True, if the item is a form field,\n             *   otherwise false.\n             */\n            public boolean isFormField() {\n                return formField;\n            }\n\n            /**\n             * Returns an input stream, which may be used to\n             * read the items contents.\n             *\n             * @return Opened input stream.\n             * @throws IOException An I/O error occurred.\n             */\n            public InputStream openStream() throws IOException {\n                if (opened) {\n                    throw new IllegalStateException(\n                            \"The stream was already opened.\");\n                }\n                if (((Closeable) stream).isClosed()) {\n                    throw new FileItemStream.ItemSkippedException();\n                }\n                return stream;\n            }\n\n            /**\n             * Closes the file item.\n             *\n             * @throws IOException An I/O error occurred.\n             */\n            void close() throws IOException {\n                stream.close();\n            }\n\n            /**\n             * Returns the file item headers.\n             *\n             * @return The items header object\n             */\n            public FileItemHeaders getHeaders() {\n                return headers;\n            }\n\n            /**\n             * Sets the file item headers.\n             *\n             * @param pHeaders The items header object\n             */\n            public void setHeaders(FileItemHeaders pHeaders) {\n                headers = pHeaders;\n            }\n\n        }\n\n        /**\n         * The multi part stream to process.\n         */\n        private final MultipartStream multi;\n\n        /**\n         * The notifier, which used for triggering the\n         * {@link ProgressListener}.\n         */\n        private final MultipartStream.ProgressNotifier notifier;\n\n        /**\n         * The boundary, which separates the various parts.\n         */\n        private final byte[] boundary;\n\n        /**\n         * The item, which we currently process.\n         */\n        private FileItemStreamImpl currentItem;\n\n        /**\n         * The current items field name.\n         */\n        private String currentFieldName;\n\n        /**\n         * Whether we are currently skipping the preamble.\n         */\n        private boolean skipPreamble;\n\n        /**\n         * Whether the current item may still be read.\n         */\n        private boolean itemValid;\n\n        /**\n         * Whether we have seen the end of the file.\n         */\n        private boolean eof;\n\n        /**\n         * Creates a new instance.\n         *\n         * @param ctx The request context.\n         * @throws FileUploadException An error occurred while\n         *   parsing the request.\n         * @throws IOException An I/O error occurred.\n         */\n        FileItemIteratorImpl(RequestContext ctx)\n                throws FileUploadException, IOException {\n            if (ctx == null) {\n                throw new NullPointerException(\"ctx parameter\");\n            }\n\n            String contentType = ctx.getContentType();\n            if ((null == contentType)\n                    || (!contentType.toLowerCase(Locale.ENGLISH).startsWith(MULTIPART))) {\n                throw new InvalidContentTypeException(\n                        format(\"the request doesn't contain a %s or %s stream, content type header is %s\",\n                               MULTIPART_FORM_DATA, MULTIPART_FORM_DATA, contentType));\n            }\n\n            InputStream input = ctx.getInputStream();\n\n            @SuppressWarnings(\"deprecation\") // still has to be backward compatible\n            final int contentLengthInt = ctx.getContentLength();\n\n            final long requestSize = UploadContext.class.isAssignableFrom(ctx.getClass())\n                                     // Inline conditional is OK here CHECKSTYLE:OFF\n                                     ? ((UploadContext) ctx).contentLength()\n                                     : contentLengthInt;\n                                     // CHECKSTYLE:ON\n\n            if (sizeMax >= 0) {\n                if (requestSize != -1 && requestSize > sizeMax) {\n                    throw new SizeLimitExceededException(\n                        format(\"the request was rejected because its size (%s) exceeds the configured maximum (%s)\",\n                                Long.valueOf(requestSize), Long.valueOf(sizeMax)),\n                               requestSize, sizeMax);\n                }\n                input = new LimitedInputStream(input, sizeMax) {\n                    @Override\n                    protected void raiseError(long pSizeMax, long pCount)\n                            throws IOException {\n                        FileUploadException ex = new SizeLimitExceededException(\n                        format(\"the request was rejected because its size (%s) exceeds the configured maximum (%s)\",\n                                Long.valueOf(pCount), Long.valueOf(pSizeMax)),\n                               pCount, pSizeMax);\n                        throw new FileUploadIOException(ex);\n                    }\n                };\n            }\n\n            String charEncoding = headerEncoding;\n            if (charEncoding == null) {\n                charEncoding = ctx.getCharacterEncoding();\n            }\n\n            boundary = getBoundary(contentType);\n            if (boundary == null) {\n                throw new FileUploadException(\"the request was rejected because no multipart boundary was found\");\n            }\n\n            notifier = new MultipartStream.ProgressNotifier(listener, requestSize);\n            multi = new MultipartStream(input, boundary, notifier);\n            multi.setHeaderEncoding(charEncoding);\n\n            skipPreamble = true;\n            findNextItem();\n        }\n\n        /**\n         * Called for finding the next item, if any.\n         *\n         * @return True, if an next item was found, otherwise false.\n         * @throws IOException An I/O error occurred.\n         */\n        private boolean findNextItem() throws IOException {\n            if (eof) {\n                return false;\n            }\n            if (currentItem != null) {\n                currentItem.close();\n                currentItem = null;\n            }\n            for (;;) {\n                boolean nextPart;\n                if (skipPreamble) {\n                    nextPart = multi.skipPreamble();\n                } else {\n                    nextPart = multi.readBoundary();\n                }\n                if (!nextPart) {\n                    if (currentFieldName == null) {\n                        // Outer multipart terminated -> No more data\n                        eof = true;\n                        return false;\n                    }\n                    // Inner multipart terminated -> Return to parsing the outer\n                    multi.setBoundary(boundary);\n                    currentFieldName = null;\n                    continue;\n                }\n                FileItemHeaders headers = getParsedHeaders(multi.readHeaders());\n                if (currentFieldName == null) {\n                    // We're parsing the outer multipart\n                    String fieldName = getFieldName(headers);\n                    if (fieldName != null) {\n                        String subContentType = headers.getHeader(CONTENT_TYPE);\n                        if (subContentType != null\n                                &&  subContentType.toLowerCase(Locale.ENGLISH)\n                                        .startsWith(MULTIPART_MIXED)) {\n                            currentFieldName = fieldName;\n                            // Multiple files associated with this field name\n                            byte[] subBoundary = getBoundary(subContentType);\n                            multi.setBoundary(subBoundary);\n                            skipPreamble = true;\n                            continue;\n                        }\n                        String fileName = getFileName(headers);\n                        currentItem = new FileItemStreamImpl(fileName,\n                                fieldName, headers.getHeader(CONTENT_TYPE),\n                                fileName == null, getContentLength(headers));\n                        currentItem.setHeaders(headers);\n                        notifier.noteItem();\n                        itemValid = true;\n                        return true;\n                    }\n                } else {\n                    String fileName = getFileName(headers);\n                    if (fileName != null) {\n                        currentItem = new FileItemStreamImpl(fileName,\n                                currentFieldName,\n                                headers.getHeader(CONTENT_TYPE),\n                                false, getContentLength(headers));\n                        currentItem.setHeaders(headers);\n                        notifier.noteItem();\n                        itemValid = true;\n                        return true;\n                    }\n                }\n                multi.discardBodyData();\n            }\n        }\n\n        private long getContentLength(FileItemHeaders pHeaders) {\n            try {\n                return Long.parseLong(pHeaders.getHeader(CONTENT_LENGTH));\n            } catch (Exception e) {\n                return -1;\n            }\n        }\n\n        /**\n         * Returns, whether another instance of {@link FileItemStream}\n         * is available.\n         *\n         * @throws FileUploadException Parsing or processing the\n         *   file item failed.\n         * @throws IOException Reading the file item failed.\n         * @return True, if one or more additional file items\n         *   are available, otherwise false.\n         */\n        public boolean hasNext() throws FileUploadException, IOException {\n            if (eof) {\n                return false;\n            }\n            if (itemValid) {\n                return true;\n            }\n            try {\n                return findNextItem();\n            } catch (FileUploadIOException e) {\n                // unwrap encapsulated SizeException\n                throw (FileUploadException) e.getCause();\n            }\n        }\n\n        /**\n         * Returns the next available {@link FileItemStream}.\n         *\n         * @throws java.util.NoSuchElementException No more items are\n         *   available. Use {@link #hasNext()} to prevent this exception.\n         * @throws FileUploadException Parsing or processing the\n         *   file item failed.\n         * @throws IOException Reading the file item failed.\n         * @return FileItemStream instance, which provides\n         *   access to the next file item.\n         */\n        public FileItemStream next() throws FileUploadException, IOException {\n            if (eof  ||  (!itemValid && !hasNext())) {\n                throw new NoSuchElementException();\n            }\n            itemValid = false;\n            return currentItem;\n        }\n\n    }\n\n    /**\n     * This exception is thrown for hiding an inner\n     * {@link FileUploadException} in an {@link IOException}.\n     */\n    public static class FileUploadIOException extends IOException {\n\n        /**\n         * The exceptions UID, for serializing an instance.\n         */\n        private static final long serialVersionUID = -7047616958165584154L;\n\n        /**\n         * The exceptions cause; we overwrite the parent\n         * classes field, which is available since Java\n         * 1.4 only.\n         */\n        private final FileUploadException cause;\n\n        /**\n         * Creates a <code>FileUploadIOException</code> with the\n         * given cause.\n         *\n         * @param pCause The exceptions cause, if any, or null.\n         */\n        public FileUploadIOException(FileUploadException pCause) {\n            // We're not doing super(pCause) cause of 1.3 compatibility.\n            cause = pCause;\n        }\n\n        /**\n         * Returns the exceptions cause.\n         *\n         * @return The exceptions cause, if any, or null.\n         */\n        @Override\n        public Throwable getCause() {\n            return cause;\n        }\n\n    }\n\n    /**\n     * Thrown to indicate that the request is not a multipart request.\n     */\n    public static class InvalidContentTypeException\n            extends FileUploadException {\n\n        /**\n         * The exceptions UID, for serializing an instance.\n         */\n        private static final long serialVersionUID = -9073026332015646668L;\n\n        /**\n         * Constructs a <code>InvalidContentTypeException</code> with no\n         * detail message.\n         */\n        public InvalidContentTypeException() {\n            // Nothing to do.\n        }\n\n        /**\n         * Constructs an <code>InvalidContentTypeException</code> with\n         * the specified detail message.\n         *\n         * @param message The detail message.\n         */\n        public InvalidContentTypeException(String message) {\n            super(message);\n        }\n\n    }\n\n    /**\n     * Thrown to indicate an IOException.\n     */\n    public static class IOFileUploadException extends FileUploadException {\n\n        /**\n         * The exceptions UID, for serializing an instance.\n         */\n        private static final long serialVersionUID = 1749796615868477269L;\n\n        /**\n         * The exceptions cause; we overwrite the parent\n         * classes field, which is available since Java\n         * 1.4 only.\n         */\n        private final IOException cause;\n\n        /**\n         * Creates a new instance with the given cause.\n         *\n         * @param pMsg The detail message.\n         * @param pException The exceptions cause.\n         */\n        public IOFileUploadException(String pMsg, IOException pException) {\n            super(pMsg);\n            cause = pException;\n        }\n\n        /**\n         * Returns the exceptions cause.\n         *\n         * @return The exceptions cause, if any, or null.\n         */\n        @Override\n        public Throwable getCause() {\n            return cause;\n        }\n\n    }\n\n    /**\n     * This exception is thrown, if a requests permitted size\n     * is exceeded.\n     */\n    protected abstract static class SizeException extends FileUploadException {\n\n        /**\n         * Serial version UID, being used, if serialized.\n         */\n        private static final long serialVersionUID = -8776225574705254126L;\n\n        /**\n         * The actual size of the request.\n         */\n        private final long actual;\n\n        /**\n         * The maximum permitted size of the request.\n         */\n        private final long permitted;\n\n        /**\n         * Creates a new instance.\n         *\n         * @param message The detail message.\n         * @param actual The actual number of bytes in the request.\n         * @param permitted The requests size limit, in bytes.\n         */\n        protected SizeException(String message, long actual, long permitted) {\n            super(message);\n            this.actual = actual;\n            this.permitted = permitted;\n        }\n\n        /**\n         * Retrieves the actual size of the request.\n         *\n         * @return The actual size of the request.\n         * @since 1.3\n         */\n        public long getActualSize() {\n            return actual;\n        }\n\n        /**\n         * Retrieves the permitted size of the request.\n         *\n         * @return The permitted size of the request.\n         * @since 1.3\n         */\n        public long getPermittedSize() {\n            return permitted;\n        }\n\n    }\n\n    /**\n     * Thrown to indicate that the request size is not specified. In other\n     * words, it is thrown, if the content-length header is missing or\n     * contains the value -1.\n     *\n     * @deprecated 1.2 As of commons-fileupload 1.2, the presence of a\n     *   content-length header is no longer required.\n     */\n    @Deprecated\n    public static class UnknownSizeException\n        extends FileUploadException {\n\n        /**\n         * The exceptions UID, for serializing an instance.\n         */\n        private static final long serialVersionUID = 7062279004812015273L;\n\n        /**\n         * Constructs a <code>UnknownSizeException</code> with no\n         * detail message.\n         */\n        public UnknownSizeException() {\n            super();\n        }\n\n        /**\n         * Constructs an <code>UnknownSizeException</code> with\n         * the specified detail message.\n         *\n         * @param message The detail message.\n         */\n        public UnknownSizeException(String message) {\n            super(message);\n        }\n\n    }\n\n    /**\n     * Thrown to indicate that the request size exceeds the configured maximum.\n     */\n    public static class SizeLimitExceededException\n            extends SizeException {\n\n        /**\n         * The exceptions UID, for serializing an instance.\n         */\n        private static final long serialVersionUID = -2474893167098052828L;\n\n        /**\n         * @deprecated 1.2 Replaced by\n         * {@link #SizeLimitExceededException(String, long, long)}\n         */\n        @Deprecated\n        public SizeLimitExceededException() {\n            this(null, 0, 0);\n        }\n\n        /**\n         * @deprecated 1.2 Replaced by\n         * {@link #SizeLimitExceededException(String, long, long)}\n         * @param message The exceptions detail message.\n         */\n        @Deprecated\n        public SizeLimitExceededException(String message) {\n            this(message, 0, 0);\n        }\n\n        /**\n         * Constructs a <code>SizeExceededException</code> with\n         * the specified detail message, and actual and permitted sizes.\n         *\n         * @param message   The detail message.\n         * @param actual    The actual request size.\n         * @param permitted The maximum permitted request size.\n         */\n        public SizeLimitExceededException(String message, long actual,\n                long permitted) {\n            super(message, actual, permitted);\n        }\n\n    }\n\n    /**\n     * Thrown to indicate that A files size exceeds the configured maximum.\n     */\n    public static class FileSizeLimitExceededException\n            extends SizeException {\n\n        /**\n         * The exceptions UID, for serializing an instance.\n         */\n        private static final long serialVersionUID = 8150776562029630058L;\n\n        /**\n         * File name of the item, which caused the exception.\n         */\n        private String fileName;\n\n        /**\n         * Field name of the item, which caused the exception.\n         */\n        private String fieldName;\n\n        /**\n         * Constructs a <code>SizeExceededException</code> with\n         * the specified detail message, and actual and permitted sizes.\n         *\n         * @param message   The detail message.\n         * @param actual    The actual request size.\n         * @param permitted The maximum permitted request size.\n         */\n        public FileSizeLimitExceededException(String message, long actual,\n                long permitted) {\n            super(message, actual, permitted);\n        }\n\n        /**\n         * Returns the file name of the item, which caused the\n         * exception.\n         *\n         * @return File name, if known, or null.\n         */\n        public String getFileName() {\n            return fileName;\n        }\n\n        /**\n         * Sets the file name of the item, which caused the\n         * exception.\n         *\n         * @param pFileName the file name of the item, which caused the exception.\n         */\n        public void setFileName(String pFileName) {\n            fileName = pFileName;\n        }\n\n        /**\n         * Returns the field name of the item, which caused the\n         * exception.\n         *\n         * @return Field name, if known, or null.\n         */\n        public String getFieldName() {\n            return fieldName;\n        }\n\n        /**\n         * Sets the field name of the item, which caused the\n         * exception.\n         *\n         * @param pFieldName the field name of the item,\n         *        which caused the exception.\n         */\n        public void setFieldName(String pFieldName) {\n            fieldName = pFieldName;\n        }\n\n    }\n\n    /**\n     * Returns the progress listener.\n     *\n     * @return The progress listener, if any, or null.\n     */\n    public ProgressListener getProgressListener() {\n        return listener;\n    }\n\n    /**\n     * Sets the progress listener.\n     *\n     * @param pListener The progress listener, if any. Defaults to null.\n     */\n    public void setProgressListener(ProgressListener pListener) {\n        listener = pListener;\n    }\n\n}\n",
        "human_patch_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.fileupload;\n\nimport static java.lang.String.format;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.apache.commons.fileupload.MultipartStream.ItemInputStream;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.apache.commons.fileupload.servlet.ServletRequestContext;\nimport org.apache.commons.fileupload.util.Closeable;\nimport org.apache.commons.fileupload.util.FileItemHeadersImpl;\nimport org.apache.commons.fileupload.util.LimitedInputStream;\nimport org.apache.commons.fileupload.util.Streams;\n\n/**\n * <p>High level API for processing file uploads.</p>\n *\n * <p>This class handles multiple files per single HTML widget, sent using\n * <code>multipart/mixed</code> encoding type, as specified by\n * <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a>.  Use {@link\n * #parseRequest(RequestContext)} to acquire a list of {@link\n * org.apache.commons.fileupload.FileItem}s associated with a given HTML\n * widget.</p>\n *\n * <p>How the data for individual parts is stored is determined by the factory\n * used to create them; a given part may be in memory, on disk, or somewhere\n * else.</p>\n *\n * @version $Id$\n */\npublic abstract class FileUploadBase {\n\n    // ---------------------------------------------------------- Class methods\n\n    /**\n     * <p>Utility method that determines whether the request contains multipart\n     * content.</p>\n     *\n     * <p><strong>NOTE:</strong>This method will be moved to the\n     * <code>ServletFileUpload</code> class after the FileUpload 1.1 release.\n     * Unfortunately, since this method is static, it is not possible to\n     * provide its replacement until this method is removed.</p>\n     *\n     * @param ctx The request context to be evaluated. Must be non-null.\n     *\n     * @return <code>true</code> if the request is multipart;\n     *         <code>false</code> otherwise.\n     */\n    public static final boolean isMultipartContent(RequestContext ctx) {\n        String contentType = ctx.getContentType();\n        if (contentType == null) {\n            return false;\n        }\n        if (contentType.toLowerCase(Locale.ENGLISH).startsWith(MULTIPART)) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Utility method that determines whether the request contains multipart\n     * content.\n     *\n     * @param req The servlet request to be evaluated. Must be non-null.\n     *\n     * @return <code>true</code> if the request is multipart;\n     *         <code>false</code> otherwise.\n     *\n     * @deprecated 1.1 Use the method on <code>ServletFileUpload</code> instead.\n     */\n    @Deprecated\n    public static boolean isMultipartContent(HttpServletRequest req) {\n        return ServletFileUpload.isMultipartContent(req);\n    }\n\n    // ----------------------------------------------------- Manifest constants\n\n    /**\n     * HTTP content type header name.\n     */\n    public static final String CONTENT_TYPE = \"Content-type\";\n\n    /**\n     * HTTP content disposition header name.\n     */\n    public static final String CONTENT_DISPOSITION = \"Content-disposition\";\n\n    /**\n     * HTTP content length header name.\n     */\n    public static final String CONTENT_LENGTH = \"Content-length\";\n\n    /**\n     * Content-disposition value for form data.\n     */\n    public static final String FORM_DATA = \"form-data\";\n\n    /**\n     * Content-disposition value for file attachment.\n     */\n    public static final String ATTACHMENT = \"attachment\";\n\n    /**\n     * Part of HTTP content type header.\n     */\n    public static final String MULTIPART = \"multipart/\";\n\n    /**\n     * HTTP content type header for multipart forms.\n     */\n    public static final String MULTIPART_FORM_DATA = \"multipart/form-data\";\n\n    /**\n     * HTTP content type header for multiple uploads.\n     */\n    public static final String MULTIPART_MIXED = \"multipart/mixed\";\n\n    /**\n     * The maximum length of a single header line that will be parsed\n     * (1024 bytes).\n     * @deprecated This constant is no longer used. As of commons-fileupload\n     *   1.2, the only applicable limit is the total size of a parts headers,\n     *   {@link MultipartStream#HEADER_PART_SIZE_MAX}.\n     */\n    @Deprecated\n    public static final int MAX_HEADER_SIZE = 1024;\n\n    // ----------------------------------------------------------- Data members\n\n    /**\n     * The maximum size permitted for the complete request, as opposed to\n     * {@link #fileSizeMax}. A value of -1 indicates no maximum.\n     */\n    private long sizeMax = -1;\n\n    /**\n     * The maximum size permitted for a single uploaded file, as opposed\n     * to {@link #sizeMax}. A value of -1 indicates no maximum.\n     */\n    private long fileSizeMax = -1;\n\n    /**\n     * The content encoding to use when reading part headers.\n     */\n    private String headerEncoding;\n\n    /**\n     * The progress listener.\n     */\n    private ProgressListener listener;\n\n    // ----------------------------------------------------- Property accessors\n\n    /**\n     * Returns the factory class used when creating file items.\n     *\n     * @return The factory class for new file items.\n     */\n    public abstract FileItemFactory getFileItemFactory();\n\n    /**\n     * Sets the factory class to use when creating file items.\n     *\n     * @param factory The factory class for new file items.\n     */\n    public abstract void setFileItemFactory(FileItemFactory factory);\n\n    /**\n     * Returns the maximum allowed size of a complete request, as opposed\n     * to {@link #getFileSizeMax()}.\n     *\n     * @return The maximum allowed size, in bytes. The default value of\n     *   -1 indicates, that there is no limit.\n     *\n     * @see #setSizeMax(long)\n     *\n     */\n    public long getSizeMax() {\n        return sizeMax;\n    }\n\n    /**\n     * Sets the maximum allowed size of a complete request, as opposed\n     * to {@link #setFileSizeMax(long)}.\n     *\n     * @param sizeMax The maximum allowed size, in bytes. The default value of\n     *   -1 indicates, that there is no limit.\n     *\n     * @see #getSizeMax()\n     *\n     */\n    public void setSizeMax(long sizeMax) {\n        this.sizeMax = sizeMax;\n    }\n\n    /**\n     * Returns the maximum allowed size of a single uploaded file,\n     * as opposed to {@link #getSizeMax()}.\n     *\n     * @see #setFileSizeMax(long)\n     * @return Maximum size of a single uploaded file.\n     */\n    public long getFileSizeMax() {\n        return fileSizeMax;\n    }\n\n    /**\n     * Sets the maximum allowed size of a single uploaded file,\n     * as opposed to {@link #getSizeMax()}.\n     *\n     * @see #getFileSizeMax()\n     * @param fileSizeMax Maximum size of a single uploaded file.\n     */\n    public void setFileSizeMax(long fileSizeMax) {\n        this.fileSizeMax = fileSizeMax;\n    }\n\n    /**\n     * Retrieves the character encoding used when reading the headers of an\n     * individual part. When not specified, or <code>null</code>, the request\n     * encoding is used. If that is also not specified, or <code>null</code>,\n     * the platform default encoding is used.\n     *\n     * @return The encoding used to read part headers.\n     */\n    public String getHeaderEncoding() {\n        return headerEncoding;\n    }\n\n    /**\n     * Specifies the character encoding to be used when reading the headers of\n     * individual part. When not specified, or <code>null</code>, the request\n     * encoding is used. If that is also not specified, or <code>null</code>,\n     * the platform default encoding is used.\n     *\n     * @param encoding The encoding used to read part headers.\n     */\n    public void setHeaderEncoding(String encoding) {\n        headerEncoding = encoding;\n    }\n\n    // --------------------------------------------------------- Public methods\n\n    /**\n     * Processes an <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a>\n     * compliant <code>multipart/form-data</code> stream.\n     *\n     * @param req The servlet request to be parsed.\n     *\n     * @return A list of <code>FileItem</code> instances parsed from the\n     *         request, in the order that they were transmitted.\n     *\n     * @throws FileUploadException if there are problems reading/parsing\n     *                             the request or storing files.\n     *\n     * @deprecated 1.1 Use {@link ServletFileUpload#parseRequest(HttpServletRequest)} instead.\n     */\n    @Deprecated\n    public List<FileItem> parseRequest(HttpServletRequest req)\n    throws FileUploadException {\n        return parseRequest(new ServletRequestContext(req));\n    }\n\n    /**\n     * Processes an <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a>\n     * compliant <code>multipart/form-data</code> stream.\n     *\n     * @param ctx The context for the request to be parsed.\n     *\n     * @return An iterator to instances of <code>FileItemStream</code>\n     *         parsed from the request, in the order that they were\n     *         transmitted.\n     *\n     * @throws FileUploadException if there are problems reading/parsing\n     *                             the request or storing files.\n     * @throws IOException An I/O error occurred. This may be a network\n     *   error while communicating with the client or a problem while\n     *   storing the uploaded content.\n     */\n    public FileItemIterator getItemIterator(RequestContext ctx)\n    throws FileUploadException, IOException {\n        try {\n            return new FileItemIteratorImpl(ctx);\n        } catch (FileUploadIOException e) {\n            // unwrap encapsulated SizeException\n            throw (FileUploadException) e.getCause();\n        }\n    }\n\n    /**\n     * Processes an <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a>\n     * compliant <code>multipart/form-data</code> stream.\n     *\n     * @param ctx The context for the request to be parsed.\n     *\n     * @return A list of <code>FileItem</code> instances parsed from the\n     *         request, in the order that they were transmitted.\n     *\n     * @throws FileUploadException if there are problems reading/parsing\n     *                             the request or storing files.\n     */\n    public List<FileItem> parseRequest(RequestContext ctx)\n            throws FileUploadException {\n        List<FileItem> items = new ArrayList<FileItem>();\n        boolean successful = false;\n        try {\n            FileItemIterator iter = getItemIterator(ctx);\n            FileItemFactory fac = getFileItemFactory();\n            if (fac == null) {\n                throw new NullPointerException(\"No FileItemFactory has been set.\");\n            }\n            while (iter.hasNext()) {\n                final FileItemStream item = iter.next();\n                // Don't use getName() here to prevent an InvalidFileNameException.\n                final String fileName = ((FileItemIteratorImpl.FileItemStreamImpl) item).name;\n                FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(),\n                                                   item.isFormField(), fileName);\n                items.add(fileItem);\n                try {\n                    Streams.copy(item.openStream(), fileItem.getOutputStream(), true);\n                } catch (FileUploadIOException e) {\n                    throw (FileUploadException) e.getCause();\n                } catch (IOException e) {\n                    throw new IOFileUploadException(format(\"Processing of %s request failed. %s\",\n                                                           MULTIPART_FORM_DATA, e.getMessage()), e);\n                }\n                final FileItemHeaders fih = item.getHeaders();\n                fileItem.setHeaders(fih);\n            }\n            successful = true;\n            return items;\n        } catch (FileUploadIOException e) {\n            throw (FileUploadException) e.getCause();\n        } catch (IOException e) {\n            throw new FileUploadException(e.getMessage(), e);\n        } finally {\n            if (!successful) {\n                for (FileItem fileItem : items) {\n                    try {\n                        fileItem.delete();\n                    } catch (Throwable e) {\n                        // ignore it\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Processes an <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a>\n     * compliant <code>multipart/form-data</code> stream.\n     *\n     * @param ctx The context for the request to be parsed.\n     *\n     * @return A map of <code>FileItem</code> instances parsed from the request.\n     *\n     * @throws FileUploadException if there are problems reading/parsing\n     *                             the request or storing files.\n     *\n     * @since 1.3\n     */\n    public Map<String, List<FileItem>> parseParameterMap(RequestContext ctx)\n            throws FileUploadException {\n        final List<FileItem> items = parseRequest(ctx);\n        final Map<String, List<FileItem>> itemsMap = new HashMap<String, List<FileItem>>(items.size());\n\n        for (FileItem fileItem : items) {\n            String fieldName = fileItem.getFieldName();\n            List<FileItem> mappedItems = itemsMap.get(fieldName);\n\n            if (mappedItems == null) {\n                mappedItems = new ArrayList<FileItem>();\n                itemsMap.put(fieldName, mappedItems);\n            }\n\n            mappedItems.add(fileItem);\n        }\n\n        return itemsMap;\n    }\n\n    // ------------------------------------------------------ Protected methods\n\n    /**\n     * Retrieves the boundary from the <code>Content-type</code> header.\n     *\n     * @param contentType The value of the content type header from which to\n     *                    extract the boundary value.\n     *\n     * @return The boundary, as a byte array.\n     */\n    protected byte[] getBoundary(String contentType) {\n        ParameterParser parser = new ParameterParser();\n        parser.setLowerCaseNames(true);\n        // Parameter parser can handle null input\n        Map<String, String> params = parser.parse(contentType, new char[] {';', ','});\n        String boundaryStr = params.get(\"boundary\");\n\n        if (boundaryStr == null) {\n            return null;\n        }\n        byte[] boundary;\n        try {\n            boundary = boundaryStr.getBytes(\"ISO-8859-1\");\n        } catch (UnsupportedEncodingException e) {\n            boundary = boundaryStr.getBytes(); // Intentionally falls back to default charset\n        }\n        return boundary;\n    }\n\n    /**\n     * Retrieves the file name from the <code>Content-disposition</code>\n     * header.\n     *\n     * @param headers A <code>Map</code> containing the HTTP request headers.\n     *\n     * @return The file name for the current <code>encapsulation</code>.\n     * @deprecated 1.2.1 Use {@link #getFileName(FileItemHeaders)}.\n     */\n    @Deprecated\n    protected String getFileName(Map<String, String> headers) {\n        return getFileName(getHeader(headers, CONTENT_DISPOSITION));\n    }\n\n    /**\n     * Retrieves the file name from the <code>Content-disposition</code>\n     * header.\n     *\n     * @param headers The HTTP headers object.\n     *\n     * @return The file name for the current <code>encapsulation</code>.\n     */\n    protected String getFileName(FileItemHeaders headers) {\n        return getFileName(headers.getHeader(CONTENT_DISPOSITION));\n    }\n\n    /**\n     * Returns the given content-disposition headers file name.\n     * @param pContentDisposition The content-disposition headers value.\n     * @return The file name\n     */\n    private String getFileName(String pContentDisposition) {\n        String fileName = null;\n        if (pContentDisposition != null) {\n            String cdl = pContentDisposition.toLowerCase(Locale.ENGLISH);\n            if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {\n                ParameterParser parser = new ParameterParser();\n                parser.setLowerCaseNames(true);\n                // Parameter parser can handle null input\n                Map<String, String> params = parser.parse(pContentDisposition, ';');\n                if (params.containsKey(\"filename\")) {\n                    fileName = params.get(\"filename\");\n                    if (fileName != null) {\n                        fileName = fileName.trim();\n                    } else {\n                        // Even if there is no value, the parameter is present,\n                        // so we return an empty file name rather than no file\n                        // name.\n                        fileName = \"\";\n                    }\n                }\n            }\n        }\n        return fileName;\n    }\n\n    /**\n     * Retrieves the field name from the <code>Content-disposition</code>\n     * header.\n     *\n     * @param headers A <code>Map</code> containing the HTTP request headers.\n     *\n     * @return The field name for the current <code>encapsulation</code>.\n     */\n    protected String getFieldName(FileItemHeaders headers) {\n        return getFieldName(headers.getHeader(CONTENT_DISPOSITION));\n    }\n\n    /**\n     * Returns the field name, which is given by the content-disposition\n     * header.\n     * @param pContentDisposition The content-dispositions header value.\n     * @return The field jake\n     */\n    private String getFieldName(String pContentDisposition) {\n        String fieldName = null;\n        if (pContentDisposition != null\n                && pContentDisposition.toLowerCase(Locale.ENGLISH).startsWith(FORM_DATA)) {\n            ParameterParser parser = new ParameterParser();\n            parser.setLowerCaseNames(true);\n            // Parameter parser can handle null input\n            Map<String, String> params = parser.parse(pContentDisposition, ';');\n            fieldName = params.get(\"name\");\n            if (fieldName != null) {\n                fieldName = fieldName.trim();\n            }\n        }\n        return fieldName;\n    }\n\n    /**\n     * Retrieves the field name from the <code>Content-disposition</code>\n     * header.\n     *\n     * @param headers A <code>Map</code> containing the HTTP request headers.\n     *\n     * @return The field name for the current <code>encapsulation</code>.\n     * @deprecated 1.2.1 Use {@link #getFieldName(FileItemHeaders)}.\n     */\n    @Deprecated\n    protected String getFieldName(Map<String, String> headers) {\n        return getFieldName(getHeader(headers, CONTENT_DISPOSITION));\n    }\n\n    /**\n     * Creates a new {@link FileItem} instance.\n     *\n     * @param headers       A <code>Map</code> containing the HTTP request\n     *                      headers.\n     * @param isFormField   Whether or not this item is a form field, as\n     *                      opposed to a file.\n     *\n     * @return A newly created <code>FileItem</code> instance.\n     *\n     * @throws FileUploadException if an error occurs.\n     * @deprecated 1.2 This method is no longer used in favour of\n     *   internally created instances of {@link FileItem}.\n     */\n    @Deprecated\n    protected FileItem createItem(Map<String, String> headers,\n                                  boolean isFormField)\n        throws FileUploadException {\n        return getFileItemFactory().createItem(getFieldName(headers),\n                getHeader(headers, CONTENT_TYPE),\n                isFormField,\n                getFileName(headers));\n    }\n\n    /**\n     * <p> Parses the <code>header-part</code> and returns as key/value\n     * pairs.\n     *\n     * <p> If there are multiple headers of the same names, the name\n     * will map to a comma-separated list containing the values.\n     *\n     * @param headerPart The <code>header-part</code> of the current\n     *                   <code>encapsulation</code>.\n     *\n     * @return A <code>Map</code> containing the parsed HTTP request headers.\n     */\n    protected FileItemHeaders getParsedHeaders(String headerPart) {\n        final int len = headerPart.length();\n        FileItemHeadersImpl headers = newFileItemHeaders();\n        int start = 0;\n        for (;;) {\n            int end = parseEndOfLine(headerPart, start);\n            if (start == end) {\n                break;\n            }\n            StringBuilder header = new StringBuilder(headerPart.substring(start, end));\n            start = end + 2;\n            while (start < len) {\n                int nonWs = start;\n                while (nonWs < len) {\n                    char c = headerPart.charAt(nonWs);\n                    if (c != ' '  &&  c != '\\t') {\n                        break;\n                    }\n                    ++nonWs;\n                }\n                if (nonWs == start) {\n                    break;\n                }\n                // Continuation line found\n                end = parseEndOfLine(headerPart, nonWs);\n                header.append(\" \").append(headerPart.substring(nonWs, end));\n                start = end + 2;\n            }\n            parseHeaderLine(headers, header.toString());\n        }\n        return headers;\n    }\n\n    /**\n     * Creates a new instance of {@link FileItemHeaders}.\n     * @return The new instance.\n     */\n    protected FileItemHeadersImpl newFileItemHeaders() {\n        return new FileItemHeadersImpl();\n    }\n\n    /**\n     * <p> Parses the <code>header-part</code> and returns as key/value\n     * pairs.\n     *\n     * <p> If there are multiple headers of the same names, the name\n     * will map to a comma-separated list containing the values.\n     *\n     * @param headerPart The <code>header-part</code> of the current\n     *                   <code>encapsulation</code>.\n     *\n     * @return A <code>Map</code> containing the parsed HTTP request headers.\n     * @deprecated 1.2.1 Use {@link #getParsedHeaders(String)}\n     */\n    @Deprecated\n    protected Map<String, String> parseHeaders(String headerPart) {\n        FileItemHeaders headers = getParsedHeaders(headerPart);\n        Map<String, String> result = new HashMap<String, String>();\n        for (Iterator<String> iter = headers.getHeaderNames();  iter.hasNext();) {\n            String headerName = iter.next();\n            Iterator<String> iter2 = headers.getHeaders(headerName);\n            StringBuilder headerValue = new StringBuilder(iter2.next());\n            while (iter2.hasNext()) {\n                headerValue.append(\",\").append(iter2.next());\n            }\n            result.put(headerName, headerValue.toString());\n        }\n        return result;\n    }\n\n    /**\n     * Skips bytes until the end of the current line.\n     * @param headerPart The headers, which are being parsed.\n     * @param end Index of the last byte, which has yet been\n     *   processed.\n     * @return Index of the \\r\\n sequence, which indicates\n     *   end of line.\n     */\n    private int parseEndOfLine(String headerPart, int end) {\n        int index = end;\n        for (;;) {\n            int offset = headerPart.indexOf('\\r', index);\n            if (offset == -1  ||  offset + 1 >= headerPart.length()) {\n                throw new IllegalStateException(\n                    \"Expected headers to be terminated by an empty line.\");\n            }\n            if (headerPart.charAt(offset + 1) == '\\n') {\n                return offset;\n            }\n            index = offset + 1;\n        }\n    }\n\n    /**\n     * Reads the next header line.\n     * @param headers String with all headers.\n     * @param header Map where to store the current header.\n     */\n    private void parseHeaderLine(FileItemHeadersImpl headers, String header) {\n        final int colonOffset = header.indexOf(':');\n        if (colonOffset == -1) {\n            // This header line is malformed, skip it.\n            return;\n        }\n        String headerName = header.substring(0, colonOffset).trim();\n        String headerValue =\n            header.substring(header.indexOf(':') + 1).trim();\n        headers.addHeader(headerName, headerValue);\n    }\n\n    /**\n     * Returns the header with the specified name from the supplied map. The\n     * header lookup is case-insensitive.\n     *\n     * @param headers A <code>Map</code> containing the HTTP request headers.\n     * @param name    The name of the header to return.\n     *\n     * @return The value of specified header, or a comma-separated list if\n     *         there were multiple headers of that name.\n     * @deprecated 1.2.1 Use {@link FileItemHeaders#getHeader(String)}.\n     */\n    @Deprecated\n    protected final String getHeader(Map<String, String> headers,\n            String name) {\n        return headers.get(name.toLowerCase(Locale.ENGLISH));\n    }\n\n    /**\n     * The iterator, which is returned by\n     * {@link FileUploadBase#getItemIterator(RequestContext)}.\n     */\n    private class FileItemIteratorImpl implements FileItemIterator {\n\n        /**\n         * Default implementation of {@link FileItemStream}.\n         */\n        class FileItemStreamImpl implements FileItemStream {\n\n            /**\n             * The file items content type.\n             */\n            private final String contentType;\n\n            /**\n             * The file items field name.\n             */\n            private final String fieldName;\n\n            /**\n             * The file items file name.\n             */\n            private final String name;\n\n            /**\n             * Whether the file item is a form field.\n             */\n            private final boolean formField;\n\n            /**\n             * The file items input stream.\n             */\n            private final InputStream stream;\n\n            /**\n             * Whether the file item was already opened.\n             */\n            private boolean opened;\n\n            /**\n             * The headers, if any.\n             */\n            private FileItemHeaders headers;\n\n            /**\n             * Creates a new instance.\n             *\n             * @param pName The items file name, or null.\n             * @param pFieldName The items field name.\n             * @param pContentType The items content type, or null.\n             * @param pFormField Whether the item is a form field.\n             * @param pContentLength The items content length, if known, or -1\n             * @throws IOException Creating the file item failed.\n             */\n            FileItemStreamImpl(String pName, String pFieldName,\n                    String pContentType, boolean pFormField,\n                    long pContentLength) throws IOException {\n                name = pName;\n                fieldName = pFieldName;\n                contentType = pContentType;\n                formField = pFormField;\n                final ItemInputStream itemStream = multi.newInputStream();\n                InputStream istream = itemStream;\n                if (fileSizeMax != -1) {\n                    if (pContentLength != -1\n                            &&  pContentLength > fileSizeMax) {\n                        FileSizeLimitExceededException e =\n                            new FileSizeLimitExceededException(\n                                format(\"The field %s exceeds its maximum permitted size of %s bytes.\",\n                                       fieldName, Long.valueOf(fileSizeMax)),\n                                pContentLength, fileSizeMax);\n                        e.setFileName(pName);\n                        e.setFieldName(pFieldName);\n                        throw new FileUploadIOException(e);\n                    }\n                    istream = new LimitedInputStream(istream, fileSizeMax) {\n                        @Override\n                        protected void raiseError(long pSizeMax, long pCount)\n                                throws IOException {\n                            itemStream.close(true);\n                            FileSizeLimitExceededException e =\n                                new FileSizeLimitExceededException(\n                                    format(\"The field %s exceeds its maximum permitted size of %s bytes.\",\n                                           fieldName, Long.valueOf(pSizeMax)),\n                                    pCount, pSizeMax);\n                            e.setFieldName(fieldName);\n                            e.setFileName(name);\n                            throw new FileUploadIOException(e);\n                        }\n                    };\n                }\n                stream = istream;\n            }\n\n            /**\n             * Returns the items content type, or null.\n             *\n             * @return Content type, if known, or null.\n             */\n            public String getContentType() {\n                return contentType;\n            }\n\n            /**\n             * Returns the items field name.\n             *\n             * @return Field name.\n             */\n            public String getFieldName() {\n                return fieldName;\n            }\n\n            /**\n             * Returns the items file name.\n             *\n             * @return File name, if known, or null.\n             * @throws InvalidFileNameException The file name contains a NUL character,\n             *   which might be an indicator of a security attack. If you intend to\n             *   use the file name anyways, catch the exception and use\n             *   InvalidFileNameException#getName().\n             */\n            public String getName() {\n                return Streams.checkFileName(name);\n            }\n\n            /**\n             * Returns, whether this is a form field.\n             *\n             * @return True, if the item is a form field,\n             *   otherwise false.\n             */\n            public boolean isFormField() {\n                return formField;\n            }\n\n            /**\n             * Returns an input stream, which may be used to\n             * read the items contents.\n             *\n             * @return Opened input stream.\n             * @throws IOException An I/O error occurred.\n             */\n            public InputStream openStream() throws IOException {\n                if (opened) {\n                    throw new IllegalStateException(\n                            \"The stream was already opened.\");\n                }\n                if (((Closeable) stream).isClosed()) {\n                    throw new FileItemStream.ItemSkippedException();\n                }\n                return stream;\n            }\n\n            /**\n             * Closes the file item.\n             *\n             * @throws IOException An I/O error occurred.\n             */\n            void close() throws IOException {\n                stream.close();\n            }\n\n            /**\n             * Returns the file item headers.\n             *\n             * @return The items header object\n             */\n            public FileItemHeaders getHeaders() {\n                return headers;\n            }\n\n            /**\n             * Sets the file item headers.\n             *\n             * @param pHeaders The items header object\n             */\n            public void setHeaders(FileItemHeaders pHeaders) {\n                headers = pHeaders;\n            }\n\n        }\n\n        /**\n         * The multi part stream to process.\n         */\n        private final MultipartStream multi;\n\n        /**\n         * The notifier, which used for triggering the\n         * {@link ProgressListener}.\n         */\n        private final MultipartStream.ProgressNotifier notifier;\n\n        /**\n         * The boundary, which separates the various parts.\n         */\n        private final byte[] boundary;\n\n        /**\n         * The item, which we currently process.\n         */\n        private FileItemStreamImpl currentItem;\n\n        /**\n         * The current items field name.\n         */\n        private String currentFieldName;\n\n        /**\n         * Whether we are currently skipping the preamble.\n         */\n        private boolean skipPreamble;\n\n        /**\n         * Whether the current item may still be read.\n         */\n        private boolean itemValid;\n\n        /**\n         * Whether we have seen the end of the file.\n         */\n        private boolean eof;\n\n        /**\n         * Creates a new instance.\n         *\n         * @param ctx The request context.\n         * @throws FileUploadException An error occurred while\n         *   parsing the request.\n         * @throws IOException An I/O error occurred.\n         */\n        FileItemIteratorImpl(RequestContext ctx)\n                throws FileUploadException, IOException {\n            if (ctx == null) {\n                throw new NullPointerException(\"ctx parameter\");\n            }\n\n            String contentType = ctx.getContentType();\n            if ((null == contentType)\n                    || (!contentType.toLowerCase(Locale.ENGLISH).startsWith(MULTIPART))) {\n                throw new InvalidContentTypeException(\n                        format(\"the request doesn't contain a %s or %s stream, content type header is %s\",\n                               MULTIPART_FORM_DATA, MULTIPART_FORM_DATA, contentType));\n            }\n\n            InputStream input = ctx.getInputStream();\n\n            @SuppressWarnings(\"deprecation\") // still has to be backward compatible\n            final int contentLengthInt = ctx.getContentLength();\n\n            final long requestSize = UploadContext.class.isAssignableFrom(ctx.getClass())\n                                     // Inline conditional is OK here CHECKSTYLE:OFF\n                                     ? ((UploadContext) ctx).contentLength()\n                                     : contentLengthInt;\n                                     // CHECKSTYLE:ON\n\n            if (sizeMax >= 0) {\n                if (requestSize != -1 && requestSize > sizeMax) {\n                    throw new SizeLimitExceededException(\n                        format(\"the request was rejected because its size (%s) exceeds the configured maximum (%s)\",\n                                Long.valueOf(requestSize), Long.valueOf(sizeMax)),\n                               requestSize, sizeMax);\n                }\n                input = new LimitedInputStream(input, sizeMax) {\n                    @Override\n                    protected void raiseError(long pSizeMax, long pCount)\n                            throws IOException {\n                        FileUploadException ex = new SizeLimitExceededException(\n                        format(\"the request was rejected because its size (%s) exceeds the configured maximum (%s)\",\n                                Long.valueOf(pCount), Long.valueOf(pSizeMax)),\n                               pCount, pSizeMax);\n                        throw new FileUploadIOException(ex);\n                    }\n                };\n            }\n\n            String charEncoding = headerEncoding;\n            if (charEncoding == null) {\n                charEncoding = ctx.getCharacterEncoding();\n            }\n\n            boundary = getBoundary(contentType);\n            if (boundary == null) {\n                throw new FileUploadException(\"the request was rejected because no multipart boundary was found\");\n            }\n\n            notifier = new MultipartStream.ProgressNotifier(listener, requestSize);\n            try {\n                multi = new MultipartStream(input, boundary, notifier);\n            } catch (IllegalArgumentException iae) {\n                throw new InvalidContentTypeException(\n                        format(\"The boundary specified in the %s header is too long\", CONTENT_TYPE), iae);\n            }\n            multi.setHeaderEncoding(charEncoding);\n\n            skipPreamble = true;\n            findNextItem();\n        }\n\n        /**\n         * Called for finding the next item, if any.\n         *\n         * @return True, if an next item was found, otherwise false.\n         * @throws IOException An I/O error occurred.\n         */\n        private boolean findNextItem() throws IOException {\n            if (eof) {\n                return false;\n            }\n            if (currentItem != null) {\n                currentItem.close();\n                currentItem = null;\n            }\n            for (;;) {\n                boolean nextPart;\n                if (skipPreamble) {\n                    nextPart = multi.skipPreamble();\n                } else {\n                    nextPart = multi.readBoundary();\n                }\n                if (!nextPart) {\n                    if (currentFieldName == null) {\n                        // Outer multipart terminated -> No more data\n                        eof = true;\n                        return false;\n                    }\n                    // Inner multipart terminated -> Return to parsing the outer\n                    multi.setBoundary(boundary);\n                    currentFieldName = null;\n                    continue;\n                }\n                FileItemHeaders headers = getParsedHeaders(multi.readHeaders());\n                if (currentFieldName == null) {\n                    // We're parsing the outer multipart\n                    String fieldName = getFieldName(headers);\n                    if (fieldName != null) {\n                        String subContentType = headers.getHeader(CONTENT_TYPE);\n                        if (subContentType != null\n                                &&  subContentType.toLowerCase(Locale.ENGLISH)\n                                        .startsWith(MULTIPART_MIXED)) {\n                            currentFieldName = fieldName;\n                            // Multiple files associated with this field name\n                            byte[] subBoundary = getBoundary(subContentType);\n                            multi.setBoundary(subBoundary);\n                            skipPreamble = true;\n                            continue;\n                        }\n                        String fileName = getFileName(headers);\n                        currentItem = new FileItemStreamImpl(fileName,\n                                fieldName, headers.getHeader(CONTENT_TYPE),\n                                fileName == null, getContentLength(headers));\n                        currentItem.setHeaders(headers);\n                        notifier.noteItem();\n                        itemValid = true;\n                        return true;\n                    }\n                } else {\n                    String fileName = getFileName(headers);\n                    if (fileName != null) {\n                        currentItem = new FileItemStreamImpl(fileName,\n                                currentFieldName,\n                                headers.getHeader(CONTENT_TYPE),\n                                false, getContentLength(headers));\n                        currentItem.setHeaders(headers);\n                        notifier.noteItem();\n                        itemValid = true;\n                        return true;\n                    }\n                }\n                multi.discardBodyData();\n            }\n        }\n\n        private long getContentLength(FileItemHeaders pHeaders) {\n            try {\n                return Long.parseLong(pHeaders.getHeader(CONTENT_LENGTH));\n            } catch (Exception e) {\n                return -1;\n            }\n        }\n\n        /**\n         * Returns, whether another instance of {@link FileItemStream}\n         * is available.\n         *\n         * @throws FileUploadException Parsing or processing the\n         *   file item failed.\n         * @throws IOException Reading the file item failed.\n         * @return True, if one or more additional file items\n         *   are available, otherwise false.\n         */\n        public boolean hasNext() throws FileUploadException, IOException {\n            if (eof) {\n                return false;\n            }\n            if (itemValid) {\n                return true;\n            }\n            try {\n                return findNextItem();\n            } catch (FileUploadIOException e) {\n                // unwrap encapsulated SizeException\n                throw (FileUploadException) e.getCause();\n            }\n        }\n\n        /**\n         * Returns the next available {@link FileItemStream}.\n         *\n         * @throws java.util.NoSuchElementException No more items are\n         *   available. Use {@link #hasNext()} to prevent this exception.\n         * @throws FileUploadException Parsing or processing the\n         *   file item failed.\n         * @throws IOException Reading the file item failed.\n         * @return FileItemStream instance, which provides\n         *   access to the next file item.\n         */\n        public FileItemStream next() throws FileUploadException, IOException {\n            if (eof  ||  (!itemValid && !hasNext())) {\n                throw new NoSuchElementException();\n            }\n            itemValid = false;\n            return currentItem;\n        }\n\n    }\n\n    /**\n     * This exception is thrown for hiding an inner\n     * {@link FileUploadException} in an {@link IOException}.\n     */\n    public static class FileUploadIOException extends IOException {\n\n        /**\n         * The exceptions UID, for serializing an instance.\n         */\n        private static final long serialVersionUID = -7047616958165584154L;\n\n        /**\n         * The exceptions cause; we overwrite the parent\n         * classes field, which is available since Java\n         * 1.4 only.\n         */\n        private final FileUploadException cause;\n\n        /**\n         * Creates a <code>FileUploadIOException</code> with the\n         * given cause.\n         *\n         * @param pCause The exceptions cause, if any, or null.\n         */\n        public FileUploadIOException(FileUploadException pCause) {\n            // We're not doing super(pCause) cause of 1.3 compatibility.\n            cause = pCause;\n        }\n\n        /**\n         * Returns the exceptions cause.\n         *\n         * @return The exceptions cause, if any, or null.\n         */\n        @Override\n        public Throwable getCause() {\n            return cause;\n        }\n\n    }\n\n    /**\n     * Thrown to indicate that the request is not a multipart request.\n     */\n    public static class InvalidContentTypeException\n            extends FileUploadException {\n\n        /**\n         * The exceptions UID, for serializing an instance.\n         */\n        private static final long serialVersionUID = -9073026332015646668L;\n\n        /**\n         * Constructs a <code>InvalidContentTypeException</code> with no\n         * detail message.\n         */\n        public InvalidContentTypeException() {\n            super();\n        }\n\n        /**\n         * Constructs an <code>InvalidContentTypeException</code> with\n         * the specified detail message.\n         *\n         * @param message The detail message.\n         */\n        public InvalidContentTypeException(String message) {\n            super(message);\n        }\n\n        public InvalidContentTypeException(String msg, Throwable cause) {\n            super(msg, cause);\n        }\n    }\n\n    /**\n     * Thrown to indicate an IOException.\n     */\n    public static class IOFileUploadException extends FileUploadException {\n\n        /**\n         * The exceptions UID, for serializing an instance.\n         */\n        private static final long serialVersionUID = 1749796615868477269L;\n\n        /**\n         * The exceptions cause; we overwrite the parent\n         * classes field, which is available since Java\n         * 1.4 only.\n         */\n        private final IOException cause;\n\n        /**\n         * Creates a new instance with the given cause.\n         *\n         * @param pMsg The detail message.\n         * @param pException The exceptions cause.\n         */\n        public IOFileUploadException(String pMsg, IOException pException) {\n            super(pMsg);\n            cause = pException;\n        }\n\n        /**\n         * Returns the exceptions cause.\n         *\n         * @return The exceptions cause, if any, or null.\n         */\n        @Override\n        public Throwable getCause() {\n            return cause;\n        }\n\n    }\n\n    /**\n     * This exception is thrown, if a requests permitted size\n     * is exceeded.\n     */\n    protected abstract static class SizeException extends FileUploadException {\n\n        /**\n         * Serial version UID, being used, if serialized.\n         */\n        private static final long serialVersionUID = -8776225574705254126L;\n\n        /**\n         * The actual size of the request.\n         */\n        private final long actual;\n\n        /**\n         * The maximum permitted size of the request.\n         */\n        private final long permitted;\n\n        /**\n         * Creates a new instance.\n         *\n         * @param message The detail message.\n         * @param actual The actual number of bytes in the request.\n         * @param permitted The requests size limit, in bytes.\n         */\n        protected SizeException(String message, long actual, long permitted) {\n            super(message);\n            this.actual = actual;\n            this.permitted = permitted;\n        }\n\n        /**\n         * Retrieves the actual size of the request.\n         *\n         * @return The actual size of the request.\n         * @since 1.3\n         */\n        public long getActualSize() {\n            return actual;\n        }\n\n        /**\n         * Retrieves the permitted size of the request.\n         *\n         * @return The permitted size of the request.\n         * @since 1.3\n         */\n        public long getPermittedSize() {\n            return permitted;\n        }\n\n    }\n\n    /**\n     * Thrown to indicate that the request size is not specified. In other\n     * words, it is thrown, if the content-length header is missing or\n     * contains the value -1.\n     *\n     * @deprecated 1.2 As of commons-fileupload 1.2, the presence of a\n     *   content-length header is no longer required.\n     */\n    @Deprecated\n    public static class UnknownSizeException\n        extends FileUploadException {\n\n        /**\n         * The exceptions UID, for serializing an instance.\n         */\n        private static final long serialVersionUID = 7062279004812015273L;\n\n        /**\n         * Constructs a <code>UnknownSizeException</code> with no\n         * detail message.\n         */\n        public UnknownSizeException() {\n            super();\n        }\n\n        /**\n         * Constructs an <code>UnknownSizeException</code> with\n         * the specified detail message.\n         *\n         * @param message The detail message.\n         */\n        public UnknownSizeException(String message) {\n            super(message);\n        }\n\n    }\n\n    /**\n     * Thrown to indicate that the request size exceeds the configured maximum.\n     */\n    public static class SizeLimitExceededException\n            extends SizeException {\n\n        /**\n         * The exceptions UID, for serializing an instance.\n         */\n        private static final long serialVersionUID = -2474893167098052828L;\n\n        /**\n         * @deprecated 1.2 Replaced by\n         * {@link #SizeLimitExceededException(String, long, long)}\n         */\n        @Deprecated\n        public SizeLimitExceededException() {\n            this(null, 0, 0);\n        }\n\n        /**\n         * @deprecated 1.2 Replaced by\n         * {@link #SizeLimitExceededException(String, long, long)}\n         * @param message The exceptions detail message.\n         */\n        @Deprecated\n        public SizeLimitExceededException(String message) {\n            this(message, 0, 0);\n        }\n\n        /**\n         * Constructs a <code>SizeExceededException</code> with\n         * the specified detail message, and actual and permitted sizes.\n         *\n         * @param message   The detail message.\n         * @param actual    The actual request size.\n         * @param permitted The maximum permitted request size.\n         */\n        public SizeLimitExceededException(String message, long actual,\n                long permitted) {\n            super(message, actual, permitted);\n        }\n\n    }\n\n    /**\n     * Thrown to indicate that A files size exceeds the configured maximum.\n     */\n    public static class FileSizeLimitExceededException\n            extends SizeException {\n\n        /**\n         * The exceptions UID, for serializing an instance.\n         */\n        private static final long serialVersionUID = 8150776562029630058L;\n\n        /**\n         * File name of the item, which caused the exception.\n         */\n        private String fileName;\n\n        /**\n         * Field name of the item, which caused the exception.\n         */\n        private String fieldName;\n\n        /**\n         * Constructs a <code>SizeExceededException</code> with\n         * the specified detail message, and actual and permitted sizes.\n         *\n         * @param message   The detail message.\n         * @param actual    The actual request size.\n         * @param permitted The maximum permitted request size.\n         */\n        public FileSizeLimitExceededException(String message, long actual,\n                long permitted) {\n            super(message, actual, permitted);\n        }\n\n        /**\n         * Returns the file name of the item, which caused the\n         * exception.\n         *\n         * @return File name, if known, or null.\n         */\n        public String getFileName() {\n            return fileName;\n        }\n\n        /**\n         * Sets the file name of the item, which caused the\n         * exception.\n         *\n         * @param pFileName the file name of the item, which caused the exception.\n         */\n        public void setFileName(String pFileName) {\n            fileName = pFileName;\n        }\n\n        /**\n         * Returns the field name of the item, which caused the\n         * exception.\n         *\n         * @return Field name, if known, or null.\n         */\n        public String getFieldName() {\n            return fieldName;\n        }\n\n        /**\n         * Sets the field name of the item, which caused the\n         * exception.\n         *\n         * @param pFieldName the field name of the item,\n         *        which caused the exception.\n         */\n        public void setFieldName(String pFieldName) {\n            fieldName = pFieldName;\n        }\n\n    }\n\n    /**\n     * Returns the progress listener.\n     *\n     * @return The progress listener, if any, or null.\n     */\n    public ProgressListener getProgressListener() {\n        return listener;\n    }\n\n    /**\n     * Sets the progress listener.\n     *\n     * @param pListener The progress listener, if any. Defaults to null.\n     */\n    public void setProgressListener(ProgressListener pListener) {\n        listener = pListener;\n    }\n\n}\n"
      },
      {
        "file_path": "src/main/java/org/apache/commons/fileupload/MultipartStream.java",
        "file_name": "MultipartStream.java",
        "vulnerable_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.fileupload;\n\nimport static java.lang.String.format;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\n\nimport org.apache.commons.fileupload.FileUploadBase.FileUploadIOException;\nimport org.apache.commons.fileupload.util.Closeable;\nimport org.apache.commons.fileupload.util.Streams;\n\n/**\n * <p> Low level API for processing file uploads.\n *\n * <p> This class can be used to process data streams conforming to MIME\n * 'multipart' format as defined in\n * <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a>. Arbitrarily\n * large amounts of data in the stream can be processed under constant\n * memory usage.\n *\n * <p> The format of the stream is defined in the following way:<br>\n *\n * <code>\n *   multipart-body := preamble 1*encapsulation close-delimiter epilogue<br>\n *   encapsulation := delimiter body CRLF<br>\n *   delimiter := \"--\" boundary CRLF<br>\n *   close-delimiter := \"--\" boundary \"--\"<br>\n *   preamble := &lt;ignore&gt;<br>\n *   epilogue := &lt;ignore&gt;<br>\n *   body := header-part CRLF body-part<br>\n *   header-part := 1*header CRLF<br>\n *   header := header-name \":\" header-value<br>\n *   header-name := &lt;printable ascii characters except \":\"&gt;<br>\n *   header-value := &lt;any ascii characters except CR & LF&gt;<br>\n *   body-data := &lt;arbitrary data&gt;<br>\n * </code>\n *\n * <p>Note that body-data can contain another mulipart entity.  There\n * is limited support for single pass processing of such nested\n * streams.  The nested stream is <strong>required</strong> to have a\n * boundary token of the same length as the parent stream (see {@link\n * #setBoundary(byte[])}).\n *\n * <p>Here is an example of usage of this class.<br>\n *\n * <pre>\n *   try {\n *     MultipartStream multipartStream = new MultipartStream(input, boundary);\n *     boolean nextPart = multipartStream.skipPreamble();\n *     OutputStream output;\n *     while(nextPart) {\n *       String header = multipartStream.readHeaders();\n *       // process headers\n *       // create some output stream\n *       multipartStream.readBodyData(output);\n *       nextPart = multipartStream.readBoundary();\n *     }\n *   } catch(MultipartStream.MalformedStreamException e) {\n *     // the stream failed to follow required syntax\n *   } catch(IOException e) {\n *     // a read or write error occurred\n *   }\n * </pre>\n *\n * @version $Id$\n */\npublic class MultipartStream {\n\n    /**\n     * Internal class, which is used to invoke the\n     * {@link ProgressListener}.\n     */\n    public static class ProgressNotifier {\n\n        /**\n         * The listener to invoke.\n         */\n        private final ProgressListener listener;\n\n        /**\n         * Number of expected bytes, if known, or -1.\n         */\n        private final long contentLength;\n\n        /**\n         * Number of bytes, which have been read so far.\n         */\n        private long bytesRead;\n\n        /**\n         * Number of items, which have been read so far.\n         */\n        private int items;\n\n        /**\n         * Creates a new instance with the given listener\n         * and content length.\n         *\n         * @param pListener The listener to invoke.\n         * @param pContentLength The expected content length.\n         */\n        ProgressNotifier(ProgressListener pListener, long pContentLength) {\n            listener = pListener;\n            contentLength = pContentLength;\n        }\n\n        /**\n         * Called to indicate that bytes have been read.\n         *\n         * @param pBytes Number of bytes, which have been read.\n         */\n        void noteBytesRead(int pBytes) {\n            /* Indicates, that the given number of bytes have been read from\n             * the input stream.\n             */\n            bytesRead += pBytes;\n            notifyListener();\n        }\n\n        /**\n         * Called to indicate, that a new file item has been detected.\n         */\n        void noteItem() {\n            ++items;\n            notifyListener();\n        }\n\n        /**\n         * Called for notifying the listener.\n         */\n        private void notifyListener() {\n            if (listener != null) {\n                listener.update(bytesRead, contentLength, items);\n            }\n        }\n\n    }\n\n    // ----------------------------------------------------- Manifest constants\n\n    /**\n     * The Carriage Return ASCII character value.\n     */\n    public static final byte CR = 0x0D;\n\n    /**\n     * The Line Feed ASCII character value.\n     */\n    public static final byte LF = 0x0A;\n\n    /**\n     * The dash (-) ASCII character value.\n     */\n    public static final byte DASH = 0x2D;\n\n    /**\n     * The maximum length of <code>header-part</code> that will be\n     * processed (10 kilobytes = 10240 bytes.).\n     */\n    public static final int HEADER_PART_SIZE_MAX = 10240;\n\n    /**\n     * The default length of the buffer used for processing a request.\n     */\n    protected static final int DEFAULT_BUFSIZE = 4096;\n\n    /**\n     * A byte sequence that marks the end of <code>header-part</code>\n     * (<code>CRLFCRLF</code>).\n     */\n    protected static final byte[] HEADER_SEPARATOR = {CR, LF, CR, LF};\n\n    /**\n     * A byte sequence that that follows a delimiter that will be\n     * followed by an encapsulation (<code>CRLF</code>).\n     */\n    protected static final byte[] FIELD_SEPARATOR = {CR, LF};\n\n    /**\n     * A byte sequence that that follows a delimiter of the last\n     * encapsulation in the stream (<code>--</code>).\n     */\n    protected static final byte[] STREAM_TERMINATOR = {DASH, DASH};\n\n    /**\n     * A byte sequence that precedes a boundary (<code>CRLF--</code>).\n     */\n    protected static final byte[] BOUNDARY_PREFIX = {CR, LF, DASH, DASH};\n\n    // ----------------------------------------------------------- Data members\n\n    /**\n     * The input stream from which data is read.\n     */\n    private final InputStream input;\n\n    /**\n     * The length of the boundary token plus the leading <code>CRLF--</code>.\n     */\n    private int boundaryLength;\n\n    /**\n     * The amount of data, in bytes, that must be kept in the buffer in order\n     * to detect delimiters reliably.\n     */\n    private int keepRegion;\n\n    /**\n     * The byte sequence that partitions the stream.\n     */\n    private byte[] boundary;\n\n    /**\n     * The length of the buffer used for processing the request.\n     */\n    private final int bufSize;\n\n    /**\n     * The buffer used for processing the request.\n     */\n    private final byte[] buffer;\n\n    /**\n     * The index of first valid character in the buffer.\n     * <br>\n     * 0 <= head < bufSize\n     */\n    private int head;\n\n    /**\n     * The index of last valid character in the buffer + 1.\n     * <br>\n     * 0 <= tail <= bufSize\n     */\n    private int tail;\n\n    /**\n     * The content encoding to use when reading headers.\n     */\n    private String headerEncoding;\n\n    /**\n     * The progress notifier, if any, or null.\n     */\n    private final ProgressNotifier notifier;\n\n    // ----------------------------------------------------------- Constructors\n\n    /**\n     * Creates a new instance.\n     *\n     * @deprecated 1.2.1 Use {@link #MultipartStream(InputStream, byte[],\n     * org.apache.commons.fileupload.MultipartStream.ProgressNotifier)},\n     * or {@link #MultipartStream(InputStream, byte[], int,\n     * org.apache.commons.fileupload.MultipartStream.ProgressNotifier)}\n     */\n    @Deprecated\n    public MultipartStream() {\n        this(null, null, null);\n    }\n\n    /**\n     * <p> Constructs a <code>MultipartStream</code> with a custom size buffer\n     * and no progress notifier.\n     *\n     * <p> Note that the buffer must be at least big enough to contain the\n     * boundary string, plus 4 characters for CR/LF and double dash, plus at\n     * least one byte of data.  Too small a buffer size setting will degrade\n     * performance.\n     *\n     * @param input    The <code>InputStream</code> to serve as a data source.\n     * @param boundary The token used for dividing the stream into\n     *                 <code>encapsulations</code>.\n     * @param bufSize  The size of the buffer to be used, in bytes.\n     *\n     * @see #MultipartStream(InputStream, byte[],\n     *   MultipartStream.ProgressNotifier)\n     * @deprecated 1.2.1 Use {@link #MultipartStream(InputStream, byte[], int,\n     *  org.apache.commons.fileupload.MultipartStream.ProgressNotifier)}.\n     */\n    @Deprecated\n    public MultipartStream(InputStream input, byte[] boundary, int bufSize) {\n        this(input, boundary, bufSize, null);\n    }\n\n    /**\n     * <p> Constructs a <code>MultipartStream</code> with a custom size buffer.\n     *\n     * <p> Note that the buffer must be at least big enough to contain the\n     * boundary string, plus 4 characters for CR/LF and double dash, plus at\n     * least one byte of data.  Too small a buffer size setting will degrade\n     * performance.\n     *\n     * @param input    The <code>InputStream</code> to serve as a data source.\n     * @param boundary The token used for dividing the stream into\n     *                 <code>encapsulations</code>.\n     * @param bufSize  The size of the buffer to be used, in bytes.\n     * @param pNotifier The notifier, which is used for calling the\n     *                  progress listener, if any.\n     *\n     * @see #MultipartStream(InputStream, byte[],\n     *     MultipartStream.ProgressNotifier)\n     */\n    public MultipartStream(InputStream input,\n            byte[] boundary,\n            int bufSize,\n            ProgressNotifier pNotifier) {\n        this.input = input;\n        this.bufSize = bufSize;\n        this.buffer = new byte[bufSize];\n        this.notifier = pNotifier;\n\n        // We prepend CR/LF to the boundary to chop trailing CR/LF from\n        // body-data tokens.\n        this.boundary = new byte[boundary.length + BOUNDARY_PREFIX.length];\n        this.boundaryLength = boundary.length + BOUNDARY_PREFIX.length;\n        this.keepRegion = this.boundary.length;\n        System.arraycopy(BOUNDARY_PREFIX, 0, this.boundary, 0,\n                BOUNDARY_PREFIX.length);\n        System.arraycopy(boundary, 0, this.boundary, BOUNDARY_PREFIX.length,\n                boundary.length);\n\n        head = 0;\n        tail = 0;\n    }\n\n    /**\n     * <p> Constructs a <code>MultipartStream</code> with a default size buffer.\n     *\n     * @param input    The <code>InputStream</code> to serve as a data source.\n     * @param boundary The token used for dividing the stream into\n     *                 <code>encapsulations</code>.\n     * @param pNotifier An object for calling the progress listener, if any.\n     *\n     *\n     * @see #MultipartStream(InputStream, byte[], int,\n     *     MultipartStream.ProgressNotifier)\n     */\n    MultipartStream(InputStream input,\n            byte[] boundary,\n            ProgressNotifier pNotifier) {\n        this(input, boundary, DEFAULT_BUFSIZE, pNotifier);\n    }\n\n    /**\n     * <p> Constructs a <code>MultipartStream</code> with a default size buffer.\n     *\n     * @param input    The <code>InputStream</code> to serve as a data source.\n     * @param boundary The token used for dividing the stream into\n     *                 <code>encapsulations</code>.\n     *\n     * @deprecated 1.2.1 Use {@link #MultipartStream(InputStream, byte[],\n     *  MultipartStream.ProgressNotifier)}.\n     * @see #MultipartStream(InputStream, byte[], int,\n     *  MultipartStream.ProgressNotifier)\n     */\n    @Deprecated\n    public MultipartStream(InputStream input,\n            byte[] boundary) {\n        this(input, boundary, DEFAULT_BUFSIZE, null);\n    }\n\n    // --------------------------------------------------------- Public methods\n\n    /**\n     * Retrieves the character encoding used when reading the headers of an\n     * individual part. When not specified, or <code>null</code>, the platform\n     * default encoding is used.\n     *\n     * @return The encoding used to read part headers.\n     */\n    public String getHeaderEncoding() {\n        return headerEncoding;\n    }\n\n    /**\n     * Specifies the character encoding to be used when reading the headers of\n     * individual parts. When not specified, or <code>null</code>, the platform\n     * default encoding is used.\n     *\n     * @param encoding The encoding used to read part headers.\n     */\n    public void setHeaderEncoding(String encoding) {\n        headerEncoding = encoding;\n    }\n\n    /**\n     * Reads a byte from the <code>buffer</code>, and refills it as\n     * necessary.\n     *\n     * @return The next byte from the input stream.\n     *\n     * @throws IOException if there is no more data available.\n     */\n    public byte readByte() throws IOException {\n        // Buffer depleted ?\n        if (head == tail) {\n            head = 0;\n            // Refill.\n            tail = input.read(buffer, head, bufSize);\n            if (tail == -1) {\n                // No more data available.\n                throw new IOException(\"No more data is available\");\n            }\n            if (notifier != null) {\n                notifier.noteBytesRead(tail);\n            }\n        }\n        return buffer[head++];\n    }\n\n    /**\n     * Skips a <code>boundary</code> token, and checks whether more\n     * <code>encapsulations</code> are contained in the stream.\n     *\n     * @return <code>true</code> if there are more encapsulations in\n     *         this stream; <code>false</code> otherwise.\n     *\n     * @throws FileUploadIOException if the bytes read from the stream exceeded the size limits\n     * @throws MalformedStreamException if the stream ends unexpectedly or\n     *                                  fails to follow required syntax.\n     */\n    public boolean readBoundary()\n            throws FileUploadIOException, MalformedStreamException {\n        byte[] marker = new byte[2];\n        boolean nextChunk = false;\n\n        head += boundaryLength;\n        try {\n            marker[0] = readByte();\n            if (marker[0] == LF) {\n                // Work around IE5 Mac bug with input type=image.\n                // Because the boundary delimiter, not including the trailing\n                // CRLF, must not appear within any file (RFC 2046, section\n                // 5.1.1), we know the missing CR is due to a buggy browser\n                // rather than a file containing something similar to a\n                // boundary.\n                return true;\n            }\n\n            marker[1] = readByte();\n            if (arrayequals(marker, STREAM_TERMINATOR, 2)) {\n                nextChunk = false;\n            } else if (arrayequals(marker, FIELD_SEPARATOR, 2)) {\n                nextChunk = true;\n            } else {\n                throw new MalformedStreamException(\n                \"Unexpected characters follow a boundary\");\n            }\n        } catch (FileUploadIOException e) {\n            // wraps a SizeException, re-throw as it will be unwrapped later\n            throw e;\n        } catch (IOException e) {\n            throw new MalformedStreamException(\"Stream ended unexpectedly\");\n        }\n        return nextChunk;\n    }\n\n    /**\n     * <p>Changes the boundary token used for partitioning the stream.\n     *\n     * <p>This method allows single pass processing of nested multipart\n     * streams.\n     *\n     * <p>The boundary token of the nested stream is <code>required</code>\n     * to be of the same length as the boundary token in parent stream.\n     *\n     * <p>Restoring the parent stream boundary token after processing of a\n     * nested stream is left to the application.\n     *\n     * @param boundary The boundary to be used for parsing of the nested\n     *                 stream.\n     *\n     * @throws IllegalBoundaryException if the <code>boundary</code>\n     *                                  has a different length than the one\n     *                                  being currently parsed.\n     */\n    public void setBoundary(byte[] boundary)\n            throws IllegalBoundaryException {\n        if (boundary.length != boundaryLength - BOUNDARY_PREFIX.length) {\n            throw new IllegalBoundaryException(\n            \"The length of a boundary token can not be changed\");\n        }\n        System.arraycopy(boundary, 0, this.boundary, BOUNDARY_PREFIX.length,\n                boundary.length);\n    }\n\n    /**\n     * <p>Reads the <code>header-part</code> of the current\n     * <code>encapsulation</code>.\n     *\n     * <p>Headers are returned verbatim to the input stream, including the\n     * trailing <code>CRLF</code> marker. Parsing is left to the\n     * application.\n     *\n     * <p><strong>TODO</strong> allow limiting maximum header size to\n     * protect against abuse.\n     *\n     * @return The <code>header-part</code> of the current encapsulation.\n     *\n     * @throws FileUploadIOException if the bytes read from the stream exceeded the size limits.\n     * @throws MalformedStreamException if the stream ends unexpectedly.\n     */\n    public String readHeaders() throws FileUploadIOException, MalformedStreamException {\n        int i = 0;\n        byte b;\n        // to support multi-byte characters\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        int size = 0;\n        while (i < HEADER_SEPARATOR.length) {\n            try {\n                b = readByte();\n            } catch (FileUploadIOException e) {\n                // wraps a SizeException, re-throw as it will be unwrapped later\n                throw e;\n            } catch (IOException e) {\n                throw new MalformedStreamException(\"Stream ended unexpectedly\");\n            }\n            if (++size > HEADER_PART_SIZE_MAX) {\n                throw new MalformedStreamException(\n                        format(\"Header section has more than %s bytes (maybe it is not properly terminated)\",\n                               Integer.valueOf(HEADER_PART_SIZE_MAX)));\n            }\n            if (b == HEADER_SEPARATOR[i]) {\n                i++;\n            } else {\n                i = 0;\n            }\n            baos.write(b);\n        }\n\n        String headers = null;\n        if (headerEncoding != null) {\n            try {\n                headers = baos.toString(headerEncoding);\n            } catch (UnsupportedEncodingException e) {\n                // Fall back to platform default if specified encoding is not\n                // supported.\n                headers = baos.toString();\n            }\n        } else {\n            headers = baos.toString();\n        }\n\n        return headers;\n    }\n\n    /**\n     * <p>Reads <code>body-data</code> from the current\n     * <code>encapsulation</code> and writes its contents into the\n     * output <code>Stream</code>.\n     *\n     * <p>Arbitrary large amounts of data can be processed by this\n     * method using a constant size buffer. (see {@link\n     * #MultipartStream(InputStream,byte[],int,\n     *   MultipartStream.ProgressNotifier) constructor}).\n     *\n     * @param output The <code>Stream</code> to write data into. May\n     *               be null, in which case this method is equivalent\n     *               to {@link #discardBodyData()}.\n     *\n     * @return the amount of data written.\n     *\n     * @throws MalformedStreamException if the stream ends unexpectedly.\n     * @throws IOException              if an i/o error occurs.\n     */\n    public int readBodyData(OutputStream output)\n            throws MalformedStreamException, IOException {\n        final InputStream istream = newInputStream();\n        return (int) Streams.copy(istream, output, false);\n    }\n\n    /**\n     * Creates a new {@link ItemInputStream}.\n     * @return A new instance of {@link ItemInputStream}.\n     */\n    ItemInputStream newInputStream() {\n        return new ItemInputStream();\n    }\n\n    /**\n     * <p> Reads <code>body-data</code> from the current\n     * <code>encapsulation</code> and discards it.\n     *\n     * <p>Use this method to skip encapsulations you don't need or don't\n     * understand.\n     *\n     * @return The amount of data discarded.\n     *\n     * @throws MalformedStreamException if the stream ends unexpectedly.\n     * @throws IOException              if an i/o error occurs.\n     */\n    public int discardBodyData() throws MalformedStreamException, IOException {\n        return readBodyData(null);\n    }\n\n    /**\n     * Finds the beginning of the first <code>encapsulation</code>.\n     *\n     * @return <code>true</code> if an <code>encapsulation</code> was found in\n     *         the stream.\n     *\n     * @throws IOException if an i/o error occurs.\n     */\n    public boolean skipPreamble() throws IOException {\n        // First delimiter may be not preceeded with a CRLF.\n        System.arraycopy(boundary, 2, boundary, 0, boundary.length - 2);\n        boundaryLength = boundary.length - 2;\n        try {\n            // Discard all data up to the delimiter.\n            discardBodyData();\n\n            // Read boundary - if succeeded, the stream contains an\n            // encapsulation.\n            return readBoundary();\n        } catch (MalformedStreamException e) {\n            return false;\n        } finally {\n            // Restore delimiter.\n            System.arraycopy(boundary, 0, boundary, 2, boundary.length - 2);\n            boundaryLength = boundary.length;\n            boundary[0] = CR;\n            boundary[1] = LF;\n        }\n    }\n\n    /**\n     * Compares <code>count</code> first bytes in the arrays\n     * <code>a</code> and <code>b</code>.\n     *\n     * @param a     The first array to compare.\n     * @param b     The second array to compare.\n     * @param count How many bytes should be compared.\n     *\n     * @return <code>true</code> if <code>count</code> first bytes in arrays\n     *         <code>a</code> and <code>b</code> are equal.\n     */\n    public static boolean arrayequals(byte[] a,\n            byte[] b,\n            int count) {\n        for (int i = 0; i < count; i++) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Searches for a byte of specified value in the <code>buffer</code>,\n     * starting at the specified <code>position</code>.\n     *\n     * @param value The value to find.\n     * @param pos   The starting position for searching.\n     *\n     * @return The position of byte found, counting from beginning of the\n     *         <code>buffer</code>, or <code>-1</code> if not found.\n     */\n    protected int findByte(byte value,\n            int pos) {\n        for (int i = pos; i < tail; i++) {\n            if (buffer[i] == value) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * Searches for the <code>boundary</code> in the <code>buffer</code>\n     * region delimited by <code>head</code> and <code>tail</code>.\n     *\n     * @return The position of the boundary found, counting from the\n     *         beginning of the <code>buffer</code>, or <code>-1</code> if\n     *         not found.\n     */\n    protected int findSeparator() {\n        int first;\n        int match = 0;\n        int maxpos = tail - boundaryLength;\n        for (first = head;\n        (first <= maxpos) && (match != boundaryLength);\n        first++) {\n            first = findByte(boundary[0], first);\n            if (first == -1 || (first > maxpos)) {\n                return -1;\n            }\n            for (match = 1; match < boundaryLength; match++) {\n                if (buffer[first + match] != boundary[match]) {\n                    break;\n                }\n            }\n        }\n        if (match == boundaryLength) {\n            return first - 1;\n        }\n        return -1;\n    }\n\n    /**\n     * Thrown to indicate that the input stream fails to follow the\n     * required syntax.\n     */\n    public static class MalformedStreamException extends IOException {\n\n        /**\n         * The UID to use when serializing this instance.\n         */\n        private static final long serialVersionUID = 6466926458059796677L;\n\n        /**\n         * Constructs a <code>MalformedStreamException</code> with no\n         * detail message.\n         */\n        public MalformedStreamException() {\n            super();\n        }\n\n        /**\n         * Constructs an <code>MalformedStreamException</code> with\n         * the specified detail message.\n         *\n         * @param message The detail message.\n         */\n        public MalformedStreamException(String message) {\n            super(message);\n        }\n\n    }\n\n    /**\n     * Thrown upon attempt of setting an invalid boundary token.\n     */\n    public static class IllegalBoundaryException extends IOException {\n\n        /**\n         * The UID to use when serializing this instance.\n         */\n        private static final long serialVersionUID = -161533165102632918L;\n\n        /**\n         * Constructs an <code>IllegalBoundaryException</code> with no\n         * detail message.\n         */\n        public IllegalBoundaryException() {\n            super();\n        }\n\n        /**\n         * Constructs an <code>IllegalBoundaryException</code> with\n         * the specified detail message.\n         *\n         * @param message The detail message.\n         */\n        public IllegalBoundaryException(String message) {\n            super(message);\n        }\n\n    }\n\n    /**\n     * An {@link InputStream} for reading an items contents.\n     */\n    public class ItemInputStream extends InputStream implements Closeable {\n\n        /**\n         * The number of bytes, which have been read so far.\n         */\n        private long total;\n\n        /**\n         * The number of bytes, which must be hold, because\n         * they might be a part of the boundary.\n         */\n        private int pad;\n\n        /**\n         * The current offset in the buffer.\n         */\n        private int pos;\n\n        /**\n         * Whether the stream is already closed.\n         */\n        private boolean closed;\n\n        /**\n         * Creates a new instance.\n         */\n        ItemInputStream() {\n            findSeparator();\n        }\n\n        /**\n         * Called for finding the separator.\n         */\n        private void findSeparator() {\n            pos = MultipartStream.this.findSeparator();\n            if (pos == -1) {\n                if (tail - head > keepRegion) {\n                    pad = keepRegion;\n                } else {\n                    pad = tail - head;\n                }\n            }\n        }\n\n        /**\n         * Returns the number of bytes, which have been read\n         * by the stream.\n         *\n         * @return Number of bytes, which have been read so far.\n         */\n        public long getBytesRead() {\n            return total;\n        }\n\n        /**\n         * Returns the number of bytes, which are currently\n         * available, without blocking.\n         *\n         * @throws IOException An I/O error occurs.\n         * @return Number of bytes in the buffer.\n         */\n        @Override\n        public int available() throws IOException {\n            if (pos == -1) {\n                return tail - head - pad;\n            }\n            return pos - head;\n        }\n\n        /**\n         * Offset when converting negative bytes to integers.\n         */\n        private static final int BYTE_POSITIVE_OFFSET = 256;\n\n        /**\n         * Returns the next byte in the stream.\n         *\n         * @return The next byte in the stream, as a non-negative\n         *   integer, or -1 for EOF.\n         * @throws IOException An I/O error occurred.\n         */\n        @Override\n        public int read() throws IOException {\n            if (closed) {\n                throw new FileItemStream.ItemSkippedException();\n            }\n            if (available() == 0 && makeAvailable() == 0) {\n                return -1;\n            }\n            ++total;\n            int b = buffer[head++];\n            if (b >= 0) {\n                return b;\n            }\n            return b + BYTE_POSITIVE_OFFSET;\n        }\n\n        /**\n         * Reads bytes into the given buffer.\n         *\n         * @param b The destination buffer, where to write to.\n         * @param off Offset of the first byte in the buffer.\n         * @param len Maximum number of bytes to read.\n         * @return Number of bytes, which have been actually read,\n         *   or -1 for EOF.\n         * @throws IOException An I/O error occurred.\n         */\n        @Override\n        public int read(byte[] b, int off, int len) throws IOException {\n            if (closed) {\n                throw new FileItemStream.ItemSkippedException();\n            }\n            if (len == 0) {\n                return 0;\n            }\n            int res = available();\n            if (res == 0) {\n                res = makeAvailable();\n                if (res == 0) {\n                    return -1;\n                }\n            }\n            res = Math.min(res, len);\n            System.arraycopy(buffer, head, b, off, res);\n            head += res;\n            total += res;\n            return res;\n        }\n\n        /**\n         * Closes the input stream.\n         *\n         * @throws IOException An I/O error occurred.\n         */\n        @Override\n        public void close() throws IOException {\n            close(false);\n        }\n\n        /**\n         * Closes the input stream.\n         *\n         * @param pCloseUnderlying Whether to close the underlying stream\n         *   (hard close)\n         * @throws IOException An I/O error occurred.\n         */\n        public void close(boolean pCloseUnderlying) throws IOException {\n            if (closed) {\n                return;\n            }\n            if (pCloseUnderlying) {\n                closed = true;\n                input.close();\n            } else {\n                for (;;) {\n                    int av = available();\n                    if (av == 0) {\n                        av = makeAvailable();\n                        if (av == 0) {\n                            break;\n                        }\n                    }\n                    skip(av);\n                }\n            }\n            closed = true;\n        }\n\n        /**\n         * Skips the given number of bytes.\n         *\n         * @param bytes Number of bytes to skip.\n         * @return The number of bytes, which have actually been\n         *   skipped.\n         * @throws IOException An I/O error occurred.\n         */\n        @Override\n        public long skip(long bytes) throws IOException {\n            if (closed) {\n                throw new FileItemStream.ItemSkippedException();\n            }\n            int av = available();\n            if (av == 0) {\n                av = makeAvailable();\n                if (av == 0) {\n                    return 0;\n                }\n            }\n            long res = Math.min(av, bytes);\n            head += res;\n            return res;\n        }\n\n        /**\n         * Attempts to read more data.\n         *\n         * @return Number of available bytes\n         * @throws IOException An I/O error occurred.\n         */\n        private int makeAvailable() throws IOException {\n            if (pos != -1) {\n                return 0;\n            }\n\n            // Move the data to the beginning of the buffer.\n            total += tail - head - pad;\n            System.arraycopy(buffer, tail - pad, buffer, 0, pad);\n\n            // Refill buffer with new data.\n            head = 0;\n            tail = pad;\n\n            for (;;) {\n                int bytesRead = input.read(buffer, tail, bufSize - tail);\n                if (bytesRead == -1) {\n                    // The last pad amount is left in the buffer.\n                    // Boundary can't be in there so signal an error\n                    // condition.\n                    final String msg = \"Stream ended unexpectedly\";\n                    throw new MalformedStreamException(msg);\n                }\n                if (notifier != null) {\n                    notifier.noteBytesRead(bytesRead);\n                }\n                tail += bytesRead;\n\n                findSeparator();\n                int av = available();\n\n                if (av > 0 || pos != -1) {\n                    return av;\n                }\n            }\n        }\n\n        /**\n         * Returns, whether the stream is closed.\n         *\n         * @return True, if the stream is closed, otherwise false.\n         */\n        public boolean isClosed() {\n            return closed;\n        }\n\n    }\n\n}\n",
        "human_patch_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.fileupload;\n\nimport static java.lang.String.format;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\n\nimport org.apache.commons.fileupload.FileUploadBase.FileUploadIOException;\nimport org.apache.commons.fileupload.util.Closeable;\nimport org.apache.commons.fileupload.util.Streams;\n\n/**\n * <p> Low level API for processing file uploads.\n *\n * <p> This class can be used to process data streams conforming to MIME\n * 'multipart' format as defined in\n * <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a>. Arbitrarily\n * large amounts of data in the stream can be processed under constant\n * memory usage.\n *\n * <p> The format of the stream is defined in the following way:<br>\n *\n * <code>\n *   multipart-body := preamble 1*encapsulation close-delimiter epilogue<br>\n *   encapsulation := delimiter body CRLF<br>\n *   delimiter := \"--\" boundary CRLF<br>\n *   close-delimiter := \"--\" boundary \"--\"<br>\n *   preamble := &lt;ignore&gt;<br>\n *   epilogue := &lt;ignore&gt;<br>\n *   body := header-part CRLF body-part<br>\n *   header-part := 1*header CRLF<br>\n *   header := header-name \":\" header-value<br>\n *   header-name := &lt;printable ascii characters except \":\"&gt;<br>\n *   header-value := &lt;any ascii characters except CR & LF&gt;<br>\n *   body-data := &lt;arbitrary data&gt;<br>\n * </code>\n *\n * <p>Note that body-data can contain another mulipart entity.  There\n * is limited support for single pass processing of such nested\n * streams.  The nested stream is <strong>required</strong> to have a\n * boundary token of the same length as the parent stream (see {@link\n * #setBoundary(byte[])}).\n *\n * <p>Here is an example of usage of this class.<br>\n *\n * <pre>\n *   try {\n *     MultipartStream multipartStream = new MultipartStream(input, boundary);\n *     boolean nextPart = multipartStream.skipPreamble();\n *     OutputStream output;\n *     while(nextPart) {\n *       String header = multipartStream.readHeaders();\n *       // process headers\n *       // create some output stream\n *       multipartStream.readBodyData(output);\n *       nextPart = multipartStream.readBoundary();\n *     }\n *   } catch(MultipartStream.MalformedStreamException e) {\n *     // the stream failed to follow required syntax\n *   } catch(IOException e) {\n *     // a read or write error occurred\n *   }\n * </pre>\n *\n * @version $Id$\n */\npublic class MultipartStream {\n\n    /**\n     * Internal class, which is used to invoke the\n     * {@link ProgressListener}.\n     */\n    public static class ProgressNotifier {\n\n        /**\n         * The listener to invoke.\n         */\n        private final ProgressListener listener;\n\n        /**\n         * Number of expected bytes, if known, or -1.\n         */\n        private final long contentLength;\n\n        /**\n         * Number of bytes, which have been read so far.\n         */\n        private long bytesRead;\n\n        /**\n         * Number of items, which have been read so far.\n         */\n        private int items;\n\n        /**\n         * Creates a new instance with the given listener\n         * and content length.\n         *\n         * @param pListener The listener to invoke.\n         * @param pContentLength The expected content length.\n         */\n        ProgressNotifier(ProgressListener pListener, long pContentLength) {\n            listener = pListener;\n            contentLength = pContentLength;\n        }\n\n        /**\n         * Called to indicate that bytes have been read.\n         *\n         * @param pBytes Number of bytes, which have been read.\n         */\n        void noteBytesRead(int pBytes) {\n            /* Indicates, that the given number of bytes have been read from\n             * the input stream.\n             */\n            bytesRead += pBytes;\n            notifyListener();\n        }\n\n        /**\n         * Called to indicate, that a new file item has been detected.\n         */\n        void noteItem() {\n            ++items;\n            notifyListener();\n        }\n\n        /**\n         * Called for notifying the listener.\n         */\n        private void notifyListener() {\n            if (listener != null) {\n                listener.update(bytesRead, contentLength, items);\n            }\n        }\n\n    }\n\n    // ----------------------------------------------------- Manifest constants\n\n    /**\n     * The Carriage Return ASCII character value.\n     */\n    public static final byte CR = 0x0D;\n\n    /**\n     * The Line Feed ASCII character value.\n     */\n    public static final byte LF = 0x0A;\n\n    /**\n     * The dash (-) ASCII character value.\n     */\n    public static final byte DASH = 0x2D;\n\n    /**\n     * The maximum length of <code>header-part</code> that will be\n     * processed (10 kilobytes = 10240 bytes.).\n     */\n    public static final int HEADER_PART_SIZE_MAX = 10240;\n\n    /**\n     * The default length of the buffer used for processing a request.\n     */\n    protected static final int DEFAULT_BUFSIZE = 4096;\n\n    /**\n     * A byte sequence that marks the end of <code>header-part</code>\n     * (<code>CRLFCRLF</code>).\n     */\n    protected static final byte[] HEADER_SEPARATOR = {CR, LF, CR, LF};\n\n    /**\n     * A byte sequence that that follows a delimiter that will be\n     * followed by an encapsulation (<code>CRLF</code>).\n     */\n    protected static final byte[] FIELD_SEPARATOR = {CR, LF};\n\n    /**\n     * A byte sequence that that follows a delimiter of the last\n     * encapsulation in the stream (<code>--</code>).\n     */\n    protected static final byte[] STREAM_TERMINATOR = {DASH, DASH};\n\n    /**\n     * A byte sequence that precedes a boundary (<code>CRLF--</code>).\n     */\n    protected static final byte[] BOUNDARY_PREFIX = {CR, LF, DASH, DASH};\n\n    // ----------------------------------------------------------- Data members\n\n    /**\n     * The input stream from which data is read.\n     */\n    private final InputStream input;\n\n    /**\n     * The length of the boundary token plus the leading <code>CRLF--</code>.\n     */\n    private int boundaryLength;\n\n    /**\n     * The amount of data, in bytes, that must be kept in the buffer in order\n     * to detect delimiters reliably.\n     */\n    private int keepRegion;\n\n    /**\n     * The byte sequence that partitions the stream.\n     */\n    private byte[] boundary;\n\n    /**\n     * The length of the buffer used for processing the request.\n     */\n    private final int bufSize;\n\n    /**\n     * The buffer used for processing the request.\n     */\n    private final byte[] buffer;\n\n    /**\n     * The index of first valid character in the buffer.\n     * <br>\n     * 0 <= head < bufSize\n     */\n    private int head;\n\n    /**\n     * The index of last valid character in the buffer + 1.\n     * <br>\n     * 0 <= tail <= bufSize\n     */\n    private int tail;\n\n    /**\n     * The content encoding to use when reading headers.\n     */\n    private String headerEncoding;\n\n    /**\n     * The progress notifier, if any, or null.\n     */\n    private final ProgressNotifier notifier;\n\n    // ----------------------------------------------------------- Constructors\n\n    /**\n     * Creates a new instance.\n     *\n     * @deprecated 1.2.1 Use {@link #MultipartStream(InputStream, byte[], int,\n     * ProgressNotifier)}\n     */\n    @Deprecated\n    public MultipartStream() {\n        this(null, null, null);\n    }\n\n    /**\n     * <p> Constructs a <code>MultipartStream</code> with a custom size buffer\n     * and no progress notifier.\n     *\n     * <p> Note that the buffer must be at least big enough to contain the\n     * boundary string, plus 4 characters for CR/LF and double dash, plus at\n     * least one byte of data.  Too small a buffer size setting will degrade\n     * performance.\n     *\n     * @param input    The <code>InputStream</code> to serve as a data source.\n     * @param boundary The token used for dividing the stream into\n     *                 <code>encapsulations</code>.\n     * @param bufSize  The size of the buffer to be used, in bytes.\n     *\n     * @deprecated 1.2.1 Use {@link #MultipartStream(InputStream, byte[], int,\n     * ProgressNotifier)}.\n     */\n    @Deprecated\n    public MultipartStream(InputStream input, byte[] boundary, int bufSize) {\n        this(input, boundary, bufSize, null);\n    }\n\n    /**\n     * <p> Constructs a <code>MultipartStream</code> with a custom size buffer.\n     *\n     * <p> Note that the buffer must be at least big enough to contain the\n     * boundary string, plus 4 characters for CR/LF and double dash, plus at\n     * least one byte of data.  Too small a buffer size setting will degrade\n     * performance.\n     *\n     * @param input    The <code>InputStream</code> to serve as a data source.\n     * @param boundary The token used for dividing the stream into\n     *                 <code>encapsulations</code>.\n     * @param bufSize  The size of the buffer to be used, in bytes.\n     * @param pNotifier The notifier, which is used for calling the\n     *                  progress listener, if any.\n     *\n     * @throws IllegalArgumentException If the buffer size is too small\n     */\n    public MultipartStream(InputStream input,\n            byte[] boundary,\n            int bufSize,\n            ProgressNotifier pNotifier) {\n        this.input = input;\n        this.bufSize = bufSize;\n        this.buffer = new byte[bufSize];\n        this.notifier = pNotifier;\n\n        // We prepend CR/LF to the boundary to chop trailing CR/LF from\n        // body-data tokens.\n        this.boundaryLength = boundary.length + BOUNDARY_PREFIX.length;\n        if (bufSize < this.boundaryLength + 1) {\n            throw new IllegalArgumentException(\n                    \"The buffer size specified for the MultipartStream is too small\");\n        }\n        this.boundary = new byte[this.boundaryLength];\n        this.keepRegion = this.boundary.length;\n\n        System.arraycopy(BOUNDARY_PREFIX, 0, this.boundary, 0,\n                BOUNDARY_PREFIX.length);\n        System.arraycopy(boundary, 0, this.boundary, BOUNDARY_PREFIX.length,\n                boundary.length);\n\n        head = 0;\n        tail = 0;\n    }\n\n    /**\n     * <p> Constructs a <code>MultipartStream</code> with a default size buffer.\n     *\n     * @param input    The <code>InputStream</code> to serve as a data source.\n     * @param boundary The token used for dividing the stream into\n     *                 <code>encapsulations</code>.\n     * @param pNotifier An object for calling the progress listener, if any.\n     *\n     *\n     * @see #MultipartStream(InputStream, byte[], int, ProgressNotifier)\n     */\n    MultipartStream(InputStream input,\n            byte[] boundary,\n            ProgressNotifier pNotifier) {\n        this(input, boundary, DEFAULT_BUFSIZE, pNotifier);\n    }\n\n    /**\n     * <p> Constructs a <code>MultipartStream</code> with a default size buffer.\n     *\n     * @param input    The <code>InputStream</code> to serve as a data source.\n     * @param boundary The token used for dividing the stream into\n     *                 <code>encapsulations</code>.\n     *\n     * @deprecated 1.2.1 Use {@link #MultipartStream(InputStream, byte[], int,\n     *  ProgressNotifier)}.\n     */\n    @Deprecated\n    public MultipartStream(InputStream input,\n            byte[] boundary) {\n        this(input, boundary, DEFAULT_BUFSIZE, null);\n    }\n\n    // --------------------------------------------------------- Public methods\n\n    /**\n     * Retrieves the character encoding used when reading the headers of an\n     * individual part. When not specified, or <code>null</code>, the platform\n     * default encoding is used.\n     *\n     * @return The encoding used to read part headers.\n     */\n    public String getHeaderEncoding() {\n        return headerEncoding;\n    }\n\n    /**\n     * Specifies the character encoding to be used when reading the headers of\n     * individual parts. When not specified, or <code>null</code>, the platform\n     * default encoding is used.\n     *\n     * @param encoding The encoding used to read part headers.\n     */\n    public void setHeaderEncoding(String encoding) {\n        headerEncoding = encoding;\n    }\n\n    /**\n     * Reads a byte from the <code>buffer</code>, and refills it as\n     * necessary.\n     *\n     * @return The next byte from the input stream.\n     *\n     * @throws IOException if there is no more data available.\n     */\n    public byte readByte() throws IOException {\n        // Buffer depleted ?\n        if (head == tail) {\n            head = 0;\n            // Refill.\n            tail = input.read(buffer, head, bufSize);\n            if (tail == -1) {\n                // No more data available.\n                throw new IOException(\"No more data is available\");\n            }\n            if (notifier != null) {\n                notifier.noteBytesRead(tail);\n            }\n        }\n        return buffer[head++];\n    }\n\n    /**\n     * Skips a <code>boundary</code> token, and checks whether more\n     * <code>encapsulations</code> are contained in the stream.\n     *\n     * @return <code>true</code> if there are more encapsulations in\n     *         this stream; <code>false</code> otherwise.\n     *\n     * @throws FileUploadIOException if the bytes read from the stream exceeded the size limits\n     * @throws MalformedStreamException if the stream ends unexpectedly or\n     *                                  fails to follow required syntax.\n     */\n    public boolean readBoundary()\n            throws FileUploadIOException, MalformedStreamException {\n        byte[] marker = new byte[2];\n        boolean nextChunk = false;\n\n        head += boundaryLength;\n        try {\n            marker[0] = readByte();\n            if (marker[0] == LF) {\n                // Work around IE5 Mac bug with input type=image.\n                // Because the boundary delimiter, not including the trailing\n                // CRLF, must not appear within any file (RFC 2046, section\n                // 5.1.1), we know the missing CR is due to a buggy browser\n                // rather than a file containing something similar to a\n                // boundary.\n                return true;\n            }\n\n            marker[1] = readByte();\n            if (arrayequals(marker, STREAM_TERMINATOR, 2)) {\n                nextChunk = false;\n            } else if (arrayequals(marker, FIELD_SEPARATOR, 2)) {\n                nextChunk = true;\n            } else {\n                throw new MalformedStreamException(\n                \"Unexpected characters follow a boundary\");\n            }\n        } catch (FileUploadIOException e) {\n            // wraps a SizeException, re-throw as it will be unwrapped later\n            throw e;\n        } catch (IOException e) {\n            throw new MalformedStreamException(\"Stream ended unexpectedly\");\n        }\n        return nextChunk;\n    }\n\n    /**\n     * <p>Changes the boundary token used for partitioning the stream.\n     *\n     * <p>This method allows single pass processing of nested multipart\n     * streams.\n     *\n     * <p>The boundary token of the nested stream is <code>required</code>\n     * to be of the same length as the boundary token in parent stream.\n     *\n     * <p>Restoring the parent stream boundary token after processing of a\n     * nested stream is left to the application.\n     *\n     * @param boundary The boundary to be used for parsing of the nested\n     *                 stream.\n     *\n     * @throws IllegalBoundaryException if the <code>boundary</code>\n     *                                  has a different length than the one\n     *                                  being currently parsed.\n     */\n    public void setBoundary(byte[] boundary)\n            throws IllegalBoundaryException {\n        if (boundary.length != boundaryLength - BOUNDARY_PREFIX.length) {\n            throw new IllegalBoundaryException(\n            \"The length of a boundary token can not be changed\");\n        }\n        System.arraycopy(boundary, 0, this.boundary, BOUNDARY_PREFIX.length,\n                boundary.length);\n    }\n\n    /**\n     * <p>Reads the <code>header-part</code> of the current\n     * <code>encapsulation</code>.\n     *\n     * <p>Headers are returned verbatim to the input stream, including the\n     * trailing <code>CRLF</code> marker. Parsing is left to the\n     * application.\n     *\n     * <p><strong>TODO</strong> allow limiting maximum header size to\n     * protect against abuse.\n     *\n     * @return The <code>header-part</code> of the current encapsulation.\n     *\n     * @throws FileUploadIOException if the bytes read from the stream exceeded the size limits.\n     * @throws MalformedStreamException if the stream ends unexpectedly.\n     */\n    public String readHeaders() throws FileUploadIOException, MalformedStreamException {\n        int i = 0;\n        byte b;\n        // to support multi-byte characters\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        int size = 0;\n        while (i < HEADER_SEPARATOR.length) {\n            try {\n                b = readByte();\n            } catch (FileUploadIOException e) {\n                // wraps a SizeException, re-throw as it will be unwrapped later\n                throw e;\n            } catch (IOException e) {\n                throw new MalformedStreamException(\"Stream ended unexpectedly\");\n            }\n            if (++size > HEADER_PART_SIZE_MAX) {\n                throw new MalformedStreamException(\n                        format(\"Header section has more than %s bytes (maybe it is not properly terminated)\",\n                               Integer.valueOf(HEADER_PART_SIZE_MAX)));\n            }\n            if (b == HEADER_SEPARATOR[i]) {\n                i++;\n            } else {\n                i = 0;\n            }\n            baos.write(b);\n        }\n\n        String headers = null;\n        if (headerEncoding != null) {\n            try {\n                headers = baos.toString(headerEncoding);\n            } catch (UnsupportedEncodingException e) {\n                // Fall back to platform default if specified encoding is not\n                // supported.\n                headers = baos.toString();\n            }\n        } else {\n            headers = baos.toString();\n        }\n\n        return headers;\n    }\n\n    /**\n     * <p>Reads <code>body-data</code> from the current\n     * <code>encapsulation</code> and writes its contents into the\n     * output <code>Stream</code>.\n     *\n     * <p>Arbitrary large amounts of data can be processed by this\n     * method using a constant size buffer. (see {@link\n     * #MultipartStream(InputStream,byte[],int,\n     *   MultipartStream.ProgressNotifier) constructor}).\n     *\n     * @param output The <code>Stream</code> to write data into. May\n     *               be null, in which case this method is equivalent\n     *               to {@link #discardBodyData()}.\n     *\n     * @return the amount of data written.\n     *\n     * @throws MalformedStreamException if the stream ends unexpectedly.\n     * @throws IOException              if an i/o error occurs.\n     */\n    public int readBodyData(OutputStream output)\n            throws MalformedStreamException, IOException {\n        final InputStream istream = newInputStream();\n        return (int) Streams.copy(istream, output, false);\n    }\n\n    /**\n     * Creates a new {@link ItemInputStream}.\n     * @return A new instance of {@link ItemInputStream}.\n     */\n    ItemInputStream newInputStream() {\n        return new ItemInputStream();\n    }\n\n    /**\n     * <p> Reads <code>body-data</code> from the current\n     * <code>encapsulation</code> and discards it.\n     *\n     * <p>Use this method to skip encapsulations you don't need or don't\n     * understand.\n     *\n     * @return The amount of data discarded.\n     *\n     * @throws MalformedStreamException if the stream ends unexpectedly.\n     * @throws IOException              if an i/o error occurs.\n     */\n    public int discardBodyData() throws MalformedStreamException, IOException {\n        return readBodyData(null);\n    }\n\n    /**\n     * Finds the beginning of the first <code>encapsulation</code>.\n     *\n     * @return <code>true</code> if an <code>encapsulation</code> was found in\n     *         the stream.\n     *\n     * @throws IOException if an i/o error occurs.\n     */\n    public boolean skipPreamble() throws IOException {\n        // First delimiter may be not preceeded with a CRLF.\n        System.arraycopy(boundary, 2, boundary, 0, boundary.length - 2);\n        boundaryLength = boundary.length - 2;\n        try {\n            // Discard all data up to the delimiter.\n            discardBodyData();\n\n            // Read boundary - if succeeded, the stream contains an\n            // encapsulation.\n            return readBoundary();\n        } catch (MalformedStreamException e) {\n            return false;\n        } finally {\n            // Restore delimiter.\n            System.arraycopy(boundary, 0, boundary, 2, boundary.length - 2);\n            boundaryLength = boundary.length;\n            boundary[0] = CR;\n            boundary[1] = LF;\n        }\n    }\n\n    /**\n     * Compares <code>count</code> first bytes in the arrays\n     * <code>a</code> and <code>b</code>.\n     *\n     * @param a     The first array to compare.\n     * @param b     The second array to compare.\n     * @param count How many bytes should be compared.\n     *\n     * @return <code>true</code> if <code>count</code> first bytes in arrays\n     *         <code>a</code> and <code>b</code> are equal.\n     */\n    public static boolean arrayequals(byte[] a,\n            byte[] b,\n            int count) {\n        for (int i = 0; i < count; i++) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Searches for a byte of specified value in the <code>buffer</code>,\n     * starting at the specified <code>position</code>.\n     *\n     * @param value The value to find.\n     * @param pos   The starting position for searching.\n     *\n     * @return The position of byte found, counting from beginning of the\n     *         <code>buffer</code>, or <code>-1</code> if not found.\n     */\n    protected int findByte(byte value,\n            int pos) {\n        for (int i = pos; i < tail; i++) {\n            if (buffer[i] == value) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * Searches for the <code>boundary</code> in the <code>buffer</code>\n     * region delimited by <code>head</code> and <code>tail</code>.\n     *\n     * @return The position of the boundary found, counting from the\n     *         beginning of the <code>buffer</code>, or <code>-1</code> if\n     *         not found.\n     */\n    protected int findSeparator() {\n        int first;\n        int match = 0;\n        int maxpos = tail - boundaryLength;\n        for (first = head;\n        (first <= maxpos) && (match != boundaryLength);\n        first++) {\n            first = findByte(boundary[0], first);\n            if (first == -1 || (first > maxpos)) {\n                return -1;\n            }\n            for (match = 1; match < boundaryLength; match++) {\n                if (buffer[first + match] != boundary[match]) {\n                    break;\n                }\n            }\n        }\n        if (match == boundaryLength) {\n            return first - 1;\n        }\n        return -1;\n    }\n\n    /**\n     * Thrown to indicate that the input stream fails to follow the\n     * required syntax.\n     */\n    public static class MalformedStreamException extends IOException {\n\n        /**\n         * The UID to use when serializing this instance.\n         */\n        private static final long serialVersionUID = 6466926458059796677L;\n\n        /**\n         * Constructs a <code>MalformedStreamException</code> with no\n         * detail message.\n         */\n        public MalformedStreamException() {\n            super();\n        }\n\n        /**\n         * Constructs an <code>MalformedStreamException</code> with\n         * the specified detail message.\n         *\n         * @param message The detail message.\n         */\n        public MalformedStreamException(String message) {\n            super(message);\n        }\n\n    }\n\n    /**\n     * Thrown upon attempt of setting an invalid boundary token.\n     */\n    public static class IllegalBoundaryException extends IOException {\n\n        /**\n         * The UID to use when serializing this instance.\n         */\n        private static final long serialVersionUID = -161533165102632918L;\n\n        /**\n         * Constructs an <code>IllegalBoundaryException</code> with no\n         * detail message.\n         */\n        public IllegalBoundaryException() {\n            super();\n        }\n\n        /**\n         * Constructs an <code>IllegalBoundaryException</code> with\n         * the specified detail message.\n         *\n         * @param message The detail message.\n         */\n        public IllegalBoundaryException(String message) {\n            super(message);\n        }\n\n    }\n\n    /**\n     * An {@link InputStream} for reading an items contents.\n     */\n    public class ItemInputStream extends InputStream implements Closeable {\n\n        /**\n         * The number of bytes, which have been read so far.\n         */\n        private long total;\n\n        /**\n         * The number of bytes, which must be hold, because\n         * they might be a part of the boundary.\n         */\n        private int pad;\n\n        /**\n         * The current offset in the buffer.\n         */\n        private int pos;\n\n        /**\n         * Whether the stream is already closed.\n         */\n        private boolean closed;\n\n        /**\n         * Creates a new instance.\n         */\n        ItemInputStream() {\n            findSeparator();\n        }\n\n        /**\n         * Called for finding the separator.\n         */\n        private void findSeparator() {\n            pos = MultipartStream.this.findSeparator();\n            if (pos == -1) {\n                if (tail - head > keepRegion) {\n                    pad = keepRegion;\n                } else {\n                    pad = tail - head;\n                }\n            }\n        }\n\n        /**\n         * Returns the number of bytes, which have been read\n         * by the stream.\n         *\n         * @return Number of bytes, which have been read so far.\n         */\n        public long getBytesRead() {\n            return total;\n        }\n\n        /**\n         * Returns the number of bytes, which are currently\n         * available, without blocking.\n         *\n         * @throws IOException An I/O error occurs.\n         * @return Number of bytes in the buffer.\n         */\n        @Override\n        public int available() throws IOException {\n            if (pos == -1) {\n                return tail - head - pad;\n            }\n            return pos - head;\n        }\n\n        /**\n         * Offset when converting negative bytes to integers.\n         */\n        private static final int BYTE_POSITIVE_OFFSET = 256;\n\n        /**\n         * Returns the next byte in the stream.\n         *\n         * @return The next byte in the stream, as a non-negative\n         *   integer, or -1 for EOF.\n         * @throws IOException An I/O error occurred.\n         */\n        @Override\n        public int read() throws IOException {\n            if (closed) {\n                throw new FileItemStream.ItemSkippedException();\n            }\n            if (available() == 0 && makeAvailable() == 0) {\n                return -1;\n            }\n            ++total;\n            int b = buffer[head++];\n            if (b >= 0) {\n                return b;\n            }\n            return b + BYTE_POSITIVE_OFFSET;\n        }\n\n        /**\n         * Reads bytes into the given buffer.\n         *\n         * @param b The destination buffer, where to write to.\n         * @param off Offset of the first byte in the buffer.\n         * @param len Maximum number of bytes to read.\n         * @return Number of bytes, which have been actually read,\n         *   or -1 for EOF.\n         * @throws IOException An I/O error occurred.\n         */\n        @Override\n        public int read(byte[] b, int off, int len) throws IOException {\n            if (closed) {\n                throw new FileItemStream.ItemSkippedException();\n            }\n            if (len == 0) {\n                return 0;\n            }\n            int res = available();\n            if (res == 0) {\n                res = makeAvailable();\n                if (res == 0) {\n                    return -1;\n                }\n            }\n            res = Math.min(res, len);\n            System.arraycopy(buffer, head, b, off, res);\n            head += res;\n            total += res;\n            return res;\n        }\n\n        /**\n         * Closes the input stream.\n         *\n         * @throws IOException An I/O error occurred.\n         */\n        @Override\n        public void close() throws IOException {\n            close(false);\n        }\n\n        /**\n         * Closes the input stream.\n         *\n         * @param pCloseUnderlying Whether to close the underlying stream\n         *   (hard close)\n         * @throws IOException An I/O error occurred.\n         */\n        public void close(boolean pCloseUnderlying) throws IOException {\n            if (closed) {\n                return;\n            }\n            if (pCloseUnderlying) {\n                closed = true;\n                input.close();\n            } else {\n                for (;;) {\n                    int av = available();\n                    if (av == 0) {\n                        av = makeAvailable();\n                        if (av == 0) {\n                            break;\n                        }\n                    }\n                    skip(av);\n                }\n            }\n            closed = true;\n        }\n\n        /**\n         * Skips the given number of bytes.\n         *\n         * @param bytes Number of bytes to skip.\n         * @return The number of bytes, which have actually been\n         *   skipped.\n         * @throws IOException An I/O error occurred.\n         */\n        @Override\n        public long skip(long bytes) throws IOException {\n            if (closed) {\n                throw new FileItemStream.ItemSkippedException();\n            }\n            int av = available();\n            if (av == 0) {\n                av = makeAvailable();\n                if (av == 0) {\n                    return 0;\n                }\n            }\n            long res = Math.min(av, bytes);\n            head += res;\n            return res;\n        }\n\n        /**\n         * Attempts to read more data.\n         *\n         * @return Number of available bytes\n         * @throws IOException An I/O error occurred.\n         */\n        private int makeAvailable() throws IOException {\n            if (pos != -1) {\n                return 0;\n            }\n\n            // Move the data to the beginning of the buffer.\n            total += tail - head - pad;\n            System.arraycopy(buffer, tail - pad, buffer, 0, pad);\n\n            // Refill buffer with new data.\n            head = 0;\n            tail = pad;\n\n            for (;;) {\n                int bytesRead = input.read(buffer, tail, bufSize - tail);\n                if (bytesRead == -1) {\n                    // The last pad amount is left in the buffer.\n                    // Boundary can't be in there so signal an error\n                    // condition.\n                    final String msg = \"Stream ended unexpectedly\";\n                    throw new MalformedStreamException(msg);\n                }\n                if (notifier != null) {\n                    notifier.noteBytesRead(bytesRead);\n                }\n                tail += bytesRead;\n\n                findSeparator();\n                int av = available();\n\n                if (av > 0 || pos != -1) {\n                    return av;\n                }\n            }\n        }\n\n        /**\n         * Returns, whether the stream is closed.\n         *\n         * @return True, if the stream is closed, otherwise false.\n         */\n        public boolean isClosed() {\n            return closed;\n        }\n\n    }\n\n}\n"
      }
    ],
    "file_count": 2
  },
  "VUL4J-12": {
    "vul_id": "VUL4J-12",
    "cve_id": "CVE-2018-17202",
    "project": "apache_commons-imaging",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoderTest#testDecodeBadFile",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/apache/commons-imaging/commit/6a79d35d6654d895d0a4b73b3a9282ec9aaeeb06",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java",
        "file_name": "JpegDecoder.java",
        "vulnerable_code": "/*\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *  under the License.\n */\n\npackage org.apache.commons.imaging.formats.jpeg.decoder;\n\nimport static org.apache.commons.imaging.common.BinaryFunctions.read2Bytes;\nimport static org.apache.commons.imaging.common.BinaryFunctions.readBytes;\n\nimport java.awt.image.BufferedImage;\nimport java.awt.image.ColorModel;\nimport java.awt.image.DataBuffer;\nimport java.awt.image.DirectColorModel;\nimport java.awt.image.Raster;\nimport java.awt.image.WritableRaster;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Properties;\n\nimport org.apache.commons.imaging.ImageReadException;\nimport org.apache.commons.imaging.common.BinaryFileParser;\nimport org.apache.commons.imaging.common.bytesource.ByteSource;\nimport org.apache.commons.imaging.formats.jpeg.JpegConstants;\nimport org.apache.commons.imaging.formats.jpeg.JpegUtils;\nimport org.apache.commons.imaging.formats.jpeg.segments.DhtSegment;\nimport org.apache.commons.imaging.formats.jpeg.segments.DqtSegment;\nimport org.apache.commons.imaging.formats.jpeg.segments.SofnSegment;\nimport org.apache.commons.imaging.formats.jpeg.segments.SosSegment;\n\npublic class JpegDecoder extends BinaryFileParser implements JpegUtils.Visitor {\n    /*\n     * JPEG is an advanced image format that takes significant computation to\n     * decode. Keep decoding fast: - Don't allocate memory inside loops,\n     * allocate it once and reuse. - Minimize calculations per pixel and per\n     * block (using lookup tables for YCbCr->RGB conversion doubled\n     * performance). - Math.round() is slow, use (int)(x+0.5f) instead for\n     * positive numbers.\n     */\n\n    private final DqtSegment.QuantizationTable[] quantizationTables = new DqtSegment.QuantizationTable[4];\n    private final DhtSegment.HuffmanTable[] huffmanDCTables = new DhtSegment.HuffmanTable[4];\n    private final DhtSegment.HuffmanTable[] huffmanACTables = new DhtSegment.HuffmanTable[4];\n    private SofnSegment sofnSegment;\n    private SosSegment sosSegment;\n    private final float[][] scaledQuantizationTables = new float[4][];\n    private BufferedImage image;\n    private ImageReadException imageReadException;\n    private IOException ioException;\n    private final int[] zz = new int[64];\n    private final int[] blockInt = new int[64];\n    private final float[] block = new float[64];\n\n    @Override\n    public boolean beginSOS() {\n        return true;\n    }\n\n    @Override\n    public void visitSOS(final int marker, final byte[] markerBytes, final byte[] imageData) {\n        final ByteArrayInputStream is = new ByteArrayInputStream(imageData);\n        try {\n            final int segmentLength = read2Bytes(\"segmentLength\", is, \"Not a Valid JPEG File\", getByteOrder());\n            final byte[] sosSegmentBytes = readBytes(\"SosSegment\",\n                    is, segmentLength - 2, \"Not a Valid JPEG File\");\n            sosSegment = new SosSegment(marker, sosSegmentBytes);\n\n            int hMax = 0;\n            int vMax = 0;\n            for (int i = 0; i < sofnSegment.numberOfComponents; i++) {\n                hMax = Math.max(hMax,\n                        sofnSegment.getComponents(i).horizontalSamplingFactor);\n                vMax = Math.max(vMax,\n                        sofnSegment.getComponents(i).verticalSamplingFactor);\n            }\n            final int hSize = 8 * hMax;\n            final int vSize = 8 * vMax;\n\n            final JpegInputStream bitInputStream = new JpegInputStream(is);\n            final int xMCUs = (sofnSegment.width + hSize - 1) / hSize;\n            final int yMCUs = (sofnSegment.height + vSize - 1) / vSize;\n            final Block[] mcu = allocateMCUMemory();\n            final Block[] scaledMCU = new Block[mcu.length];\n            for (int i = 0; i < scaledMCU.length; i++) {\n                scaledMCU[i] = new Block(hSize, vSize);\n            }\n            final int[] preds = new int[sofnSegment.numberOfComponents];\n            ColorModel colorModel;\n            WritableRaster raster;\n            if (sofnSegment.numberOfComponents == 3) {\n                colorModel = new DirectColorModel(24, 0x00ff0000, 0x0000ff00,\n                        0x000000ff);\n                raster = Raster.createPackedRaster(DataBuffer.TYPE_INT,\n                        sofnSegment.width, sofnSegment.height, new int[] {\n                                0x00ff0000, 0x0000ff00, 0x000000ff }, null);\n            } else if (sofnSegment.numberOfComponents == 1) {\n                colorModel = new DirectColorModel(24, 0x00ff0000, 0x0000ff00,\n                        0x000000ff);\n                raster = Raster.createPackedRaster(DataBuffer.TYPE_INT,\n                        sofnSegment.width, sofnSegment.height, new int[] {\n                                0x00ff0000, 0x0000ff00, 0x000000ff }, null);\n                // FIXME: why do images come out too bright with CS_GRAY?\n                // colorModel = new ComponentColorModel(\n                // ColorSpace.getInstance(ColorSpace.CS_GRAY), false, true,\n                // Transparency.OPAQUE, DataBuffer.TYPE_BYTE);\n                // raster = colorModel.createCompatibleWritableRaster(\n                // sofnSegment.width, sofnSegment.height);\n            } else {\n                throw new ImageReadException(sofnSegment.numberOfComponents\n                        + \" components are invalid or unsupported\");\n            }\n            final DataBuffer dataBuffer = raster.getDataBuffer();\n\n            for (int y1 = 0; y1 < vSize * yMCUs; y1 += vSize) {\n                for (int x1 = 0; x1 < hSize * xMCUs; x1 += hSize) {\n                    readMCU(bitInputStream, preds, mcu);\n                    rescaleMCU(mcu, hSize, vSize, scaledMCU);\n                    int srcRowOffset = 0;\n                    int dstRowOffset = y1 * sofnSegment.width + x1;\n                    for (int y2 = 0; y2 < vSize && y1 + y2 < sofnSegment.height; y2++) {\n                        for (int x2 = 0; x2 < hSize\n                                && x1 + x2 < sofnSegment.width; x2++) {\n                            if (scaledMCU.length == 3) {\n                                final int Y = scaledMCU[0].samples[srcRowOffset + x2];\n                                final int Cb = scaledMCU[1].samples[srcRowOffset + x2];\n                                final int Cr = scaledMCU[2].samples[srcRowOffset + x2];\n                                final int rgb = YCbCrConverter.convertYCbCrToRGB(Y,\n                                        Cb, Cr);\n                                dataBuffer.setElem(dstRowOffset + x2, rgb);\n                            } else if (mcu.length == 1) {\n                                final int Y = scaledMCU[0].samples[srcRowOffset + x2];\n                                dataBuffer.setElem(dstRowOffset + x2, (Y << 16)\n                                        | (Y << 8) | Y);\n                            } else {\n                                throw new ImageReadException(\n                                        \"Unsupported JPEG with \" + mcu.length\n                                                + \" components\");\n                            }\n                        }\n                        srcRowOffset += hSize;\n                        dstRowOffset += sofnSegment.width;\n                    }\n                }\n            }\n            image = new BufferedImage(colorModel, raster,\n                    colorModel.isAlphaPremultiplied(), new Properties());\n            // byte[] remainder = super.getStreamBytes(is);\n            // for (int i = 0; i < remainder.length; i++)\n            // {\n            // System.out.println(\"\" + i + \" = \" +\n            // Integer.toHexString(remainder[i]));\n            // }\n        } catch (final ImageReadException imageReadEx) {\n            imageReadException = imageReadEx;\n        } catch (final IOException ioEx) {\n            ioException = ioEx;\n        } catch (final RuntimeException ex) {\n            // Corrupt images can throw NPE and IOOBE\n            imageReadException = new ImageReadException(\"Error parsing JPEG\",\n                    ex);\n        }\n    }\n\n    @Override\n    public boolean visitSegment(final int marker, final byte[] markerBytes,\n            final int segmentLength, final byte[] segmentLengthBytes, final byte[] segmentData)\n            throws ImageReadException, IOException {\n        final int[] sofnSegments = {\n                JpegConstants.SOF0_MARKER,\n                JpegConstants.SOF1_MARKER,\n                JpegConstants.SOF2_MARKER,\n                JpegConstants.SOF3_MARKER,\n                JpegConstants.SOF5_MARKER,\n                JpegConstants.SOF6_MARKER,\n                JpegConstants.SOF7_MARKER,\n                JpegConstants.SOF9_MARKER,\n                JpegConstants.SOF10_MARKER,\n                JpegConstants.SOF11_MARKER,\n                JpegConstants.SOF13_MARKER,\n                JpegConstants.SOF14_MARKER,\n                JpegConstants.SOF15_MARKER,\n        };\n\n        if (Arrays.binarySearch(sofnSegments, marker) >= 0) {\n            if (marker != JpegConstants.SOF0_MARKER) {\n                throw new ImageReadException(\"Only sequential, baseline JPEGs \"\n                        + \"are supported at the moment\");\n            }\n            sofnSegment = new SofnSegment(marker, segmentData);\n        } else if (marker == JpegConstants.DQT_MARKER) {\n            final DqtSegment dqtSegment = new DqtSegment(marker, segmentData);\n            for (int i = 0; i < dqtSegment.quantizationTables.size(); i++) {\n                final DqtSegment.QuantizationTable table = dqtSegment.quantizationTables.get(i);\n                if (0 > table.destinationIdentifier\n                        || table.destinationIdentifier >= quantizationTables.length) {\n                    throw new ImageReadException(\n                            \"Invalid quantization table identifier \"\n                                    + table.destinationIdentifier);\n                }\n                quantizationTables[table.destinationIdentifier] = table;\n                final int[] quantizationMatrixInt = new int[64];\n                ZigZag.zigZagToBlock(table.getElements(), quantizationMatrixInt);\n                final float[] quantizationMatrixFloat = new float[64];\n                for (int j = 0; j < 64; j++) {\n                    quantizationMatrixFloat[j] = quantizationMatrixInt[j];\n                }\n                Dct.scaleDequantizationMatrix(quantizationMatrixFloat);\n                scaledQuantizationTables[table.destinationIdentifier] = quantizationMatrixFloat;\n            }\n        } else if (marker == JpegConstants.DHT_MARKER) {\n            final DhtSegment dhtSegment = new DhtSegment(marker, segmentData);\n            for (int i = 0; i < dhtSegment.huffmanTables.size(); i++) {\n                final DhtSegment.HuffmanTable table = dhtSegment.huffmanTables.get(i);\n                DhtSegment.HuffmanTable[] tables;\n                if (table.tableClass == 0) {\n                    tables = huffmanDCTables;\n                } else if (table.tableClass == 1) {\n                    tables = huffmanACTables;\n                } else {\n                    throw new ImageReadException(\"Invalid huffman table class \"\n                            + table.tableClass);\n                }\n                if (0 > table.destinationIdentifier\n                        || table.destinationIdentifier >= tables.length) {\n                    throw new ImageReadException(\n                            \"Invalid huffman table identifier \"\n                                    + table.destinationIdentifier);\n                }\n                tables[table.destinationIdentifier] = table;\n            }\n        }\n        return true;\n    }\n\n    private void rescaleMCU(final Block[] dataUnits, final int hSize, final int vSize, final Block[] ret) {\n        for (int i = 0; i < dataUnits.length; i++) {\n            final Block dataUnit = dataUnits[i];\n            if (dataUnit.width == hSize && dataUnit.height == vSize) {\n                System.arraycopy(dataUnit.samples, 0, ret[i].samples, 0, hSize\n                        * vSize);\n            } else {\n                final int hScale = hSize / dataUnit.width;\n                final int vScale = vSize / dataUnit.height;\n                if (hScale == 2 && vScale == 2) {\n                    int srcRowOffset = 0;\n                    int dstRowOffset = 0;\n                    for (int y = 0; y < dataUnit.height; y++) {\n                        for (int x = 0; x < hSize; x++) {\n                            final int sample = dataUnit.samples[srcRowOffset + (x >> 1)];\n                            ret[i].samples[dstRowOffset + x] = sample;\n                            ret[i].samples[dstRowOffset + hSize + x] = sample;\n                        }\n                        srcRowOffset += dataUnit.width;\n                        dstRowOffset += 2 * hSize;\n                    }\n                } else {\n                    // FIXME: optimize\n                    int dstRowOffset = 0;\n                    for (int y = 0; y < vSize; y++) {\n                        for (int x = 0; x < hSize; x++) {\n                            ret[i].samples[dstRowOffset + x] = dataUnit.samples[(y / vScale)\n                                    * dataUnit.width + (x / hScale)];\n                        }\n                        dstRowOffset += hSize;\n                    }\n                }\n            }\n        }\n    }\n\n    private Block[] allocateMCUMemory() throws ImageReadException {\n        final Block[] mcu = new Block[sosSegment.numberOfComponents];\n        for (int i = 0; i < sosSegment.numberOfComponents; i++) {\n            final SosSegment.Component scanComponent = sosSegment.getComponents(i);\n            SofnSegment.Component frameComponent = null;\n            for (int j = 0; j < sofnSegment.numberOfComponents; j++) {\n                if (sofnSegment.getComponents(j).componentIdentifier == scanComponent.scanComponentSelector) {\n                    frameComponent = sofnSegment.getComponents(j);\n                    break;\n                }\n            }\n            if (frameComponent == null) {\n                throw new ImageReadException(\"Invalid component\");\n            }\n            final Block fullBlock = new Block(\n                    8 * frameComponent.horizontalSamplingFactor,\n                    8 * frameComponent.verticalSamplingFactor);\n            mcu[i] = fullBlock;\n        }\n        return mcu;\n    }\n\n    private void readMCU(final JpegInputStream is, final int[] preds, final Block[] mcu)\n            throws IOException, ImageReadException {\n        for (int i = 0; i < sosSegment.numberOfComponents; i++) {\n            final SosSegment.Component scanComponent = sosSegment.getComponents(i);\n            SofnSegment.Component frameComponent = null;\n            for (int j = 0; j < sofnSegment.numberOfComponents; j++) {\n                if (sofnSegment.getComponents(j).componentIdentifier == scanComponent.scanComponentSelector) {\n                    frameComponent = sofnSegment.getComponents(j);\n                    break;\n                }\n            }\n            if (frameComponent == null) {\n                throw new ImageReadException(\"Invalid component\");\n            }\n            final Block fullBlock = mcu[i];\n            for (int y = 0; y < frameComponent.verticalSamplingFactor; y++) {\n                for (int x = 0; x < frameComponent.horizontalSamplingFactor; x++) {\n                    Arrays.fill(zz, 0);\n                    // page 104 of T.81\n                    final int t = decode(\n                            is,\n                            huffmanDCTables[scanComponent.dcCodingTableSelector]);\n                    int diff = receive(t, is);\n                    diff = extend(diff, t);\n                    zz[0] = preds[i] + diff;\n                    preds[i] = zz[0];\n\n                    // \"Decode_AC_coefficients\", figure F.13, page 106 of T.81\n                    int k = 1;\n                    while (true) {\n                        final int rs = decode(\n                                is,\n                                huffmanACTables[scanComponent.acCodingTableSelector]);\n                        final int ssss = rs & 0xf;\n                        final int rrrr = rs >> 4;\n                        final int r = rrrr;\n\n                        if (ssss == 0) {\n                            if (r == 15) {\n                                k += 16;\n                            } else {\n                                break;\n                            }\n                        } else {\n                            k += r;\n\n                            // \"Decode_ZZ(k)\", figure F.14, page 107 of T.81\n                            zz[k] = receive(ssss, is);\n                            zz[k] = extend(zz[k], ssss);\n\n                            if (k == 63) {\n                                break;\n                            } else {\n                                k++;\n                            }\n                        }\n                    }\n\n                    final int shift = (1 << (sofnSegment.precision - 1));\n                    final int max = (1 << sofnSegment.precision) - 1;\n\n                    final float[] scaledQuantizationTable = scaledQuantizationTables[frameComponent.quantTabDestSelector];\n                    ZigZag.zigZagToBlock(zz, blockInt);\n                    for (int j = 0; j < 64; j++) {\n                        block[j] = blockInt[j] * scaledQuantizationTable[j];\n                    }\n                    Dct.inverseDCT8x8(block);\n\n                    int dstRowOffset = 8 * y * 8\n                            * frameComponent.horizontalSamplingFactor + 8 * x;\n                    int srcNext = 0;\n                    for (int yy = 0; yy < 8; yy++) {\n                        for (int xx = 0; xx < 8; xx++) {\n                            float sample = block[srcNext++];\n                            sample += shift;\n                            int result;\n                            if (sample < 0) {\n                                result = 0;\n                            } else if (sample > max) {\n                                result = max;\n                            } else {\n                                result = fastRound(sample);\n                            }\n                            fullBlock.samples[dstRowOffset + xx] = result;\n                        }\n                        dstRowOffset += 8 * frameComponent.horizontalSamplingFactor;\n                    }\n                }\n            }\n        }\n    }\n\n    private static int fastRound(final float x) {\n        return (int) (x + 0.5f);\n    }\n\n    private int extend(int v, final int t) {\n        // \"EXTEND\", section F.2.2.1, figure F.12, page 105 of T.81\n        int vt = (1 << (t - 1));\n        while (v < vt) {\n            vt = (-1 << t) + 1;\n            v += vt;\n        }\n        return v;\n    }\n\n    private int receive(final int ssss, final JpegInputStream is) throws IOException,\n            ImageReadException {\n        // \"RECEIVE\", section F.2.2.4, figure F.17, page 110 of T.81\n        int i = 0;\n        int v = 0;\n        while (i != ssss) {\n            i++;\n            v = (v << 1) + is.nextBit();\n        }\n        return v;\n    }\n\n    private int decode(final JpegInputStream is, final DhtSegment.HuffmanTable huffmanTable)\n            throws IOException, ImageReadException {\n        // \"DECODE\", section F.2.2.3, figure F.16, page 109 of T.81\n        int i = 1;\n        int code = is.nextBit();\n        while (code > huffmanTable.getMaxCode(i)) {\n            i++;\n            code = (code << 1) | is.nextBit();\n        }\n        int j = huffmanTable.getValPtr(i);\n        j += code - huffmanTable.getMinCode(i);\n        return huffmanTable.getHuffVal(j);\n    }\n\n    public BufferedImage decode(final ByteSource byteSource) throws IOException,\n            ImageReadException {\n        final JpegUtils jpegUtils = new JpegUtils();\n        jpegUtils.traverseJFIF(byteSource, this);\n        if (imageReadException != null) {\n            throw imageReadException;\n        }\n        if (ioException != null) {\n            throw ioException;\n        }\n        return image;\n    }\n}\n",
        "human_patch_code": "/*\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *  under the License.\n */\n\npackage org.apache.commons.imaging.formats.jpeg.decoder;\n\nimport static org.apache.commons.imaging.common.BinaryFunctions.read2Bytes;\nimport static org.apache.commons.imaging.common.BinaryFunctions.readBytes;\n\nimport java.awt.image.BufferedImage;\nimport java.awt.image.ColorModel;\nimport java.awt.image.DataBuffer;\nimport java.awt.image.DirectColorModel;\nimport java.awt.image.Raster;\nimport java.awt.image.WritableRaster;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Properties;\n\nimport org.apache.commons.imaging.ImageReadException;\nimport org.apache.commons.imaging.common.BinaryFileParser;\nimport org.apache.commons.imaging.common.bytesource.ByteSource;\nimport org.apache.commons.imaging.formats.jpeg.JpegConstants;\nimport org.apache.commons.imaging.formats.jpeg.JpegUtils;\nimport org.apache.commons.imaging.formats.jpeg.segments.DhtSegment;\nimport org.apache.commons.imaging.formats.jpeg.segments.DqtSegment;\nimport org.apache.commons.imaging.formats.jpeg.segments.SofnSegment;\nimport org.apache.commons.imaging.formats.jpeg.segments.SosSegment;\n\npublic class JpegDecoder extends BinaryFileParser implements JpegUtils.Visitor {\n    /*\n     * JPEG is an advanced image format that takes significant computation to\n     * decode. Keep decoding fast: - Don't allocate memory inside loops,\n     * allocate it once and reuse. - Minimize calculations per pixel and per\n     * block (using lookup tables for YCbCr->RGB conversion doubled\n     * performance). - Math.round() is slow, use (int)(x+0.5f) instead for\n     * positive numbers.\n     */\n\n    private final DqtSegment.QuantizationTable[] quantizationTables = new DqtSegment.QuantizationTable[4];\n    private final DhtSegment.HuffmanTable[] huffmanDCTables = new DhtSegment.HuffmanTable[4];\n    private final DhtSegment.HuffmanTable[] huffmanACTables = new DhtSegment.HuffmanTable[4];\n    private SofnSegment sofnSegment;\n    private SosSegment sosSegment;\n    private final float[][] scaledQuantizationTables = new float[4][];\n    private BufferedImage image;\n    private ImageReadException imageReadException;\n    private IOException ioException;\n    private final int[] zz = new int[64];\n    private final int[] blockInt = new int[64];\n    private final float[] block = new float[64];\n\n    @Override\n    public boolean beginSOS() {\n        return true;\n    }\n\n    @Override\n    public void visitSOS(final int marker, final byte[] markerBytes, final byte[] imageData) {\n        final ByteArrayInputStream is = new ByteArrayInputStream(imageData);\n        try {\n            final int segmentLength = read2Bytes(\"segmentLength\", is, \"Not a Valid JPEG File\", getByteOrder());\n            final byte[] sosSegmentBytes = readBytes(\"SosSegment\",\n                    is, segmentLength - 2, \"Not a Valid JPEG File\");\n            sosSegment = new SosSegment(marker, sosSegmentBytes);\n\n            int hMax = 0;\n            int vMax = 0;\n            for (int i = 0; i < sofnSegment.numberOfComponents; i++) {\n                hMax = Math.max(hMax,\n                        sofnSegment.getComponents(i).horizontalSamplingFactor);\n                vMax = Math.max(vMax,\n                        sofnSegment.getComponents(i).verticalSamplingFactor);\n            }\n            final int hSize = 8 * hMax;\n            final int vSize = 8 * vMax;\n\n            final JpegInputStream bitInputStream = new JpegInputStream(is);\n            final int xMCUs = (sofnSegment.width + hSize - 1) / hSize;\n            final int yMCUs = (sofnSegment.height + vSize - 1) / vSize;\n            final Block[] mcu = allocateMCUMemory();\n            final Block[] scaledMCU = new Block[mcu.length];\n            for (int i = 0; i < scaledMCU.length; i++) {\n                scaledMCU[i] = new Block(hSize, vSize);\n            }\n            final int[] preds = new int[sofnSegment.numberOfComponents];\n            ColorModel colorModel;\n            WritableRaster raster;\n            if (sofnSegment.numberOfComponents == 3) {\n                colorModel = new DirectColorModel(24, 0x00ff0000, 0x0000ff00,\n                        0x000000ff);\n                raster = Raster.createPackedRaster(DataBuffer.TYPE_INT,\n                        sofnSegment.width, sofnSegment.height, new int[] {\n                                0x00ff0000, 0x0000ff00, 0x000000ff }, null);\n            } else if (sofnSegment.numberOfComponents == 1) {\n                colorModel = new DirectColorModel(24, 0x00ff0000, 0x0000ff00,\n                        0x000000ff);\n                raster = Raster.createPackedRaster(DataBuffer.TYPE_INT,\n                        sofnSegment.width, sofnSegment.height, new int[] {\n                                0x00ff0000, 0x0000ff00, 0x000000ff }, null);\n                // FIXME: why do images come out too bright with CS_GRAY?\n                // colorModel = new ComponentColorModel(\n                // ColorSpace.getInstance(ColorSpace.CS_GRAY), false, true,\n                // Transparency.OPAQUE, DataBuffer.TYPE_BYTE);\n                // raster = colorModel.createCompatibleWritableRaster(\n                // sofnSegment.width, sofnSegment.height);\n            } else {\n                throw new ImageReadException(sofnSegment.numberOfComponents\n                        + \" components are invalid or unsupported\");\n            }\n            final DataBuffer dataBuffer = raster.getDataBuffer();\n\n            for (int y1 = 0; y1 < vSize * yMCUs; y1 += vSize) {\n                for (int x1 = 0; x1 < hSize * xMCUs; x1 += hSize) {\n                    readMCU(bitInputStream, preds, mcu);\n                    rescaleMCU(mcu, hSize, vSize, scaledMCU);\n                    int srcRowOffset = 0;\n                    int dstRowOffset = y1 * sofnSegment.width + x1;\n                    for (int y2 = 0; y2 < vSize && y1 + y2 < sofnSegment.height; y2++) {\n                        for (int x2 = 0; x2 < hSize\n                                && x1 + x2 < sofnSegment.width; x2++) {\n                            if (scaledMCU.length == 3) {\n                                final int Y = scaledMCU[0].samples[srcRowOffset + x2];\n                                final int Cb = scaledMCU[1].samples[srcRowOffset + x2];\n                                final int Cr = scaledMCU[2].samples[srcRowOffset + x2];\n                                final int rgb = YCbCrConverter.convertYCbCrToRGB(Y,\n                                        Cb, Cr);\n                                dataBuffer.setElem(dstRowOffset + x2, rgb);\n                            } else if (mcu.length == 1) {\n                                final int Y = scaledMCU[0].samples[srcRowOffset + x2];\n                                dataBuffer.setElem(dstRowOffset + x2, (Y << 16)\n                                        | (Y << 8) | Y);\n                            } else {\n                                throw new ImageReadException(\n                                        \"Unsupported JPEG with \" + mcu.length\n                                                + \" components\");\n                            }\n                        }\n                        srcRowOffset += hSize;\n                        dstRowOffset += sofnSegment.width;\n                    }\n                }\n            }\n            image = new BufferedImage(colorModel, raster,\n                    colorModel.isAlphaPremultiplied(), new Properties());\n            // byte[] remainder = super.getStreamBytes(is);\n            // for (int i = 0; i < remainder.length; i++)\n            // {\n            // System.out.println(\"\" + i + \" = \" +\n            // Integer.toHexString(remainder[i]));\n            // }\n        } catch (final ImageReadException imageReadEx) {\n            imageReadException = imageReadEx;\n        } catch (final IOException ioEx) {\n            ioException = ioEx;\n        } catch (final RuntimeException ex) {\n            // Corrupt images can throw NPE and IOOBE\n            imageReadException = new ImageReadException(\"Error parsing JPEG\",\n                    ex);\n        }\n    }\n\n    @Override\n    public boolean visitSegment(final int marker, final byte[] markerBytes,\n            final int segmentLength, final byte[] segmentLengthBytes, final byte[] segmentData)\n            throws ImageReadException, IOException {\n        final int[] sofnSegments = {\n                JpegConstants.SOF0_MARKER,\n                JpegConstants.SOF1_MARKER,\n                JpegConstants.SOF2_MARKER,\n                JpegConstants.SOF3_MARKER,\n                JpegConstants.SOF5_MARKER,\n                JpegConstants.SOF6_MARKER,\n                JpegConstants.SOF7_MARKER,\n                JpegConstants.SOF9_MARKER,\n                JpegConstants.SOF10_MARKER,\n                JpegConstants.SOF11_MARKER,\n                JpegConstants.SOF13_MARKER,\n                JpegConstants.SOF14_MARKER,\n                JpegConstants.SOF15_MARKER,\n        };\n\n        if (Arrays.binarySearch(sofnSegments, marker) >= 0) {\n            if (marker != JpegConstants.SOF0_MARKER) {\n                throw new ImageReadException(\"Only sequential, baseline JPEGs \"\n                        + \"are supported at the moment\");\n            }\n            sofnSegment = new SofnSegment(marker, segmentData);\n        } else if (marker == JpegConstants.DQT_MARKER) {\n            final DqtSegment dqtSegment = new DqtSegment(marker, segmentData);\n            for (int i = 0; i < dqtSegment.quantizationTables.size(); i++) {\n                final DqtSegment.QuantizationTable table = dqtSegment.quantizationTables.get(i);\n                if (0 > table.destinationIdentifier\n                        || table.destinationIdentifier >= quantizationTables.length) {\n                    throw new ImageReadException(\n                            \"Invalid quantization table identifier \"\n                                    + table.destinationIdentifier);\n                }\n                quantizationTables[table.destinationIdentifier] = table;\n                final int[] quantizationMatrixInt = new int[64];\n                ZigZag.zigZagToBlock(table.getElements(), quantizationMatrixInt);\n                final float[] quantizationMatrixFloat = new float[64];\n                for (int j = 0; j < 64; j++) {\n                    quantizationMatrixFloat[j] = quantizationMatrixInt[j];\n                }\n                Dct.scaleDequantizationMatrix(quantizationMatrixFloat);\n                scaledQuantizationTables[table.destinationIdentifier] = quantizationMatrixFloat;\n            }\n        } else if (marker == JpegConstants.DHT_MARKER) {\n            final DhtSegment dhtSegment = new DhtSegment(marker, segmentData);\n            for (int i = 0; i < dhtSegment.huffmanTables.size(); i++) {\n                final DhtSegment.HuffmanTable table = dhtSegment.huffmanTables.get(i);\n                DhtSegment.HuffmanTable[] tables;\n                if (table.tableClass == 0) {\n                    tables = huffmanDCTables;\n                } else if (table.tableClass == 1) {\n                    tables = huffmanACTables;\n                } else {\n                    throw new ImageReadException(\"Invalid huffman table class \"\n                            + table.tableClass);\n                }\n                if (0 > table.destinationIdentifier\n                        || table.destinationIdentifier >= tables.length) {\n                    throw new ImageReadException(\n                            \"Invalid huffman table identifier \"\n                                    + table.destinationIdentifier);\n                }\n                tables[table.destinationIdentifier] = table;\n            }\n        }\n        return true;\n    }\n\n    private void rescaleMCU(final Block[] dataUnits, final int hSize, final int vSize, final Block[] ret) {\n        for (int i = 0; i < dataUnits.length; i++) {\n            final Block dataUnit = dataUnits[i];\n            if (dataUnit.width == hSize && dataUnit.height == vSize) {\n                System.arraycopy(dataUnit.samples, 0, ret[i].samples, 0, hSize\n                        * vSize);\n            } else {\n                final int hScale = hSize / dataUnit.width;\n                final int vScale = vSize / dataUnit.height;\n                if (hScale == 2 && vScale == 2) {\n                    int srcRowOffset = 0;\n                    int dstRowOffset = 0;\n                    for (int y = 0; y < dataUnit.height; y++) {\n                        for (int x = 0; x < hSize; x++) {\n                            final int sample = dataUnit.samples[srcRowOffset + (x >> 1)];\n                            ret[i].samples[dstRowOffset + x] = sample;\n                            ret[i].samples[dstRowOffset + hSize + x] = sample;\n                        }\n                        srcRowOffset += dataUnit.width;\n                        dstRowOffset += 2 * hSize;\n                    }\n                } else {\n                    // FIXME: optimize\n                    int dstRowOffset = 0;\n                    for (int y = 0; y < vSize; y++) {\n                        for (int x = 0; x < hSize; x++) {\n                            ret[i].samples[dstRowOffset + x] = dataUnit.samples[(y / vScale)\n                                    * dataUnit.width + (x / hScale)];\n                        }\n                        dstRowOffset += hSize;\n                    }\n                }\n            }\n        }\n    }\n\n    private Block[] allocateMCUMemory() throws ImageReadException {\n        final Block[] mcu = new Block[sosSegment.numberOfComponents];\n        for (int i = 0; i < sosSegment.numberOfComponents; i++) {\n            final SosSegment.Component scanComponent = sosSegment.getComponents(i);\n            SofnSegment.Component frameComponent = null;\n            for (int j = 0; j < sofnSegment.numberOfComponents; j++) {\n                if (sofnSegment.getComponents(j).componentIdentifier == scanComponent.scanComponentSelector) {\n                    frameComponent = sofnSegment.getComponents(j);\n                    break;\n                }\n            }\n            if (frameComponent == null) {\n                throw new ImageReadException(\"Invalid component\");\n            }\n            final Block fullBlock = new Block(\n                    8 * frameComponent.horizontalSamplingFactor,\n                    8 * frameComponent.verticalSamplingFactor);\n            mcu[i] = fullBlock;\n        }\n        return mcu;\n    }\n\n    private void readMCU(final JpegInputStream is, final int[] preds, final Block[] mcu)\n            throws IOException, ImageReadException {\n        for (int i = 0; i < sosSegment.numberOfComponents; i++) {\n            final SosSegment.Component scanComponent = sosSegment.getComponents(i);\n            SofnSegment.Component frameComponent = null;\n            for (int j = 0; j < sofnSegment.numberOfComponents; j++) {\n                if (sofnSegment.getComponents(j).componentIdentifier == scanComponent.scanComponentSelector) {\n                    frameComponent = sofnSegment.getComponents(j);\n                    break;\n                }\n            }\n            if (frameComponent == null) {\n                throw new ImageReadException(\"Invalid component\");\n            }\n            final Block fullBlock = mcu[i];\n            for (int y = 0; y < frameComponent.verticalSamplingFactor; y++) {\n                for (int x = 0; x < frameComponent.horizontalSamplingFactor; x++) {\n                    Arrays.fill(zz, 0);\n                    // page 104 of T.81\n                    final int t = decode(\n                            is,\n                            huffmanDCTables[scanComponent.dcCodingTableSelector]);\n                    int diff = receive(t, is);\n                    diff = extend(diff, t);\n                    zz[0] = preds[i] + diff;\n                    preds[i] = zz[0];\n\n                    // \"Decode_AC_coefficients\", figure F.13, page 106 of T.81\n                    int k = 1;\n                    while (true) {\n                        final int rs = decode(\n                                is,\n                                huffmanACTables[scanComponent.acCodingTableSelector]);\n                        final int ssss = rs & 0xf;\n                        final int rrrr = rs >> 4;\n                        final int r = rrrr;\n\n                        if (ssss == 0) {\n                            if (r == 15) {\n                                k += 16;\n                            } else {\n                                break;\n                            }\n                        } else {\n                            k += r;\n\n                            // \"Decode_ZZ(k)\", figure F.14, page 107 of T.81\n                            zz[k] = receive(ssss, is);\n                            zz[k] = extend(zz[k], ssss);\n\n                            if (k == 63) {\n                                break;\n                            } else {\n                                k++;\n                            }\n                        }\n                    }\n\n                    final int shift = (1 << (sofnSegment.precision - 1));\n                    final int max = (1 << sofnSegment.precision) - 1;\n\n                    final float[] scaledQuantizationTable = scaledQuantizationTables[frameComponent.quantTabDestSelector];\n                    ZigZag.zigZagToBlock(zz, blockInt);\n                    for (int j = 0; j < 64; j++) {\n                        block[j] = blockInt[j] * scaledQuantizationTable[j];\n                    }\n                    Dct.inverseDCT8x8(block);\n\n                    int dstRowOffset = 8 * y * 8\n                            * frameComponent.horizontalSamplingFactor + 8 * x;\n                    int srcNext = 0;\n                    for (int yy = 0; yy < 8; yy++) {\n                        for (int xx = 0; xx < 8; xx++) {\n                            float sample = block[srcNext++];\n                            sample += shift;\n                            int result;\n                            if (sample < 0) {\n                                result = 0;\n                            } else if (sample > max) {\n                                result = max;\n                            } else {\n                                result = fastRound(sample);\n                            }\n                            fullBlock.samples[dstRowOffset + xx] = result;\n                        }\n                        dstRowOffset += 8 * frameComponent.horizontalSamplingFactor;\n                    }\n                }\n            }\n        }\n    }\n\n    private static int fastRound(final float x) {\n        return (int) (x + 0.5f);\n    }\n\n    private int extend(int v, final int t) {\n        // \"EXTEND\", section F.2.2.1, figure F.12, page 105 of T.81\n        int vt = (1 << (t - 1));\n        if (v < vt) {\n            vt = (-1 << t) + 1;\n            v += vt;\n        }\n        return v;\n    }\n\n    private int receive(final int ssss, final JpegInputStream is) throws IOException,\n            ImageReadException {\n        // \"RECEIVE\", section F.2.2.4, figure F.17, page 110 of T.81\n        int i = 0;\n        int v = 0;\n        while (i != ssss) {\n            i++;\n            v = (v << 1) + is.nextBit();\n        }\n        return v;\n    }\n\n    private int decode(final JpegInputStream is, final DhtSegment.HuffmanTable huffmanTable)\n            throws IOException, ImageReadException {\n        // \"DECODE\", section F.2.2.3, figure F.16, page 109 of T.81\n        int i = 1;\n        int code = is.nextBit();\n        while (code > huffmanTable.getMaxCode(i)) {\n            i++;\n            code = (code << 1) | is.nextBit();\n        }\n        int j = huffmanTable.getValPtr(i);\n        j += code - huffmanTable.getMinCode(i);\n        return huffmanTable.getHuffVal(j);\n    }\n\n    public BufferedImage decode(final ByteSource byteSource) throws IOException,\n            ImageReadException {\n        final JpegUtils jpegUtils = new JpegUtils();\n        jpegUtils.traverseJFIF(byteSource, this);\n        if (imageReadException != null) {\n            throw imageReadException;\n        }\n        if (ioException != null) {\n            throw ioException;\n        }\n        return image;\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-13": {
    "vul_id": "VUL4J-13",
    "cve_id": "CVE-2018-17201",
    "project": "apache_commons-imaging",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=org.apache.commons.imaging.formats.rgbe.RgbeReadTest#testErrorDecompressingInvalidFile",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/apache/commons-imaging/commit/f5574bfe285edd79207fe8c30f53cb0af06e26bb",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/org/apache/commons/imaging/formats/rgbe/RgbeInfo.java",
        "file_name": "RgbeInfo.java",
        "vulnerable_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.imaging.formats.rgbe;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.ByteOrder;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.imaging.ImageReadException;\nimport org.apache.commons.imaging.common.BinaryFunctions;\nimport org.apache.commons.imaging.common.ByteConversions;\nimport org.apache.commons.imaging.common.ImageMetadata;\nimport org.apache.commons.imaging.common.GenericImageMetadata;\nimport org.apache.commons.imaging.common.bytesource.ByteSource;\n\nclass RgbeInfo implements Closeable {\n    // #?RADIANCE\n    private static final byte[] HEADER = new byte[] {\n        0x23, 0x3F, 0x52, 0x41, 0x44, 0x49, 0x41, 0x4E, 0x43, 0x45\n    };\n    private static final Pattern RESOLUTION_STRING = Pattern.compile(\"-Y (\\\\d+) \\\\+X (\\\\d+)\");\n\n    private final InputStream in;\n    private GenericImageMetadata metadata;\n    private int width = -1;\n    private int height = -1;\n    private static final byte[] TWO_TWO = new byte[] { 0x2, 0x2 };\n\n    RgbeInfo(final ByteSource byteSource) throws IOException {\n        this.in = byteSource.getInputStream();\n    }\n\n    ImageMetadata getMetadata() throws IOException, ImageReadException {\n        if (null == metadata) {\n            readMetadata();\n        }\n\n        return metadata;\n    }\n\n    int getWidth() throws IOException, ImageReadException {\n        if (-1 == width) {\n            readDimensions();\n        }\n\n        return width;\n    }\n\n    int getHeight() throws IOException, ImageReadException {\n        if (-1 == height) {\n            readDimensions();\n        }\n\n        return height;\n    }\n\n    @Override\n    public void close() throws IOException {\n        in.close();\n    }\n\n    private void readDimensions() throws IOException, ImageReadException {\n        getMetadata(); // Ensure we've read past this\n\n        final InfoHeaderReader reader = new InfoHeaderReader(in);\n        final String resolution = reader.readNextLine();\n        final Matcher matcher = RESOLUTION_STRING.matcher(resolution);\n\n        if (!matcher.matches()) {\n            throw new ImageReadException(\n                    \"Invalid HDR resolution string. Only \\\"-Y N +X M\\\" is supported. Found \\\"\"\n                            + resolution + \"\\\"\");\n        }\n\n        height = Integer.parseInt(matcher.group(1));\n        width = Integer.parseInt(matcher.group(2));\n    }\n\n    private void readMetadata() throws IOException, ImageReadException {\n        BinaryFunctions.readAndVerifyBytes(in, HEADER, \"Not a valid HDR: Incorrect Header\");\n\n        final InfoHeaderReader reader = new InfoHeaderReader(in);\n\n        if (reader.readNextLine().length() != 0) {\n            throw new ImageReadException(\"Not a valid HDR: Incorrect Header\");\n        }\n\n        metadata = new GenericImageMetadata();\n\n        String info = reader.readNextLine();\n\n        while (info.length() != 0) {\n            final int equals = info.indexOf('=');\n\n            if (equals > 0) {\n                final String variable = info.substring(0, equals);\n                final String value = info.substring(equals + 1);\n\n                if (\"FORMAT\".equals(value) && !\"32-bit_rle_rgbe\".equals(value)) {\n                    throw new ImageReadException(\"Only 32-bit_rle_rgbe images are supported, trying to read \" + value);\n                }\n\n                metadata.add(variable, value);\n            } else {\n                metadata.add(\"<command>\", info);\n            }\n\n            info = reader.readNextLine();\n        }\n    }\n\n    public float[][] getPixelData() throws IOException, ImageReadException {\n        // Read into local variables to ensure that we have seeked into the file\n        // far enough\n        final int ht = getHeight();\n        final int wd = getWidth();\n\n        if (wd >= 32768) {\n            throw new ImageReadException(\"Scan lines must be less than 32768 bytes long\");\n        }\n\n        final byte[] scanLineBytes = ByteConversions.toBytes((short) wd,\n                ByteOrder.BIG_ENDIAN);\n        final byte[] rgbe = new byte[wd * 4];\n        final float[][] out = new float[3][wd * ht];\n\n        for (int i = 0; i < ht; i++) {\n            BinaryFunctions.readAndVerifyBytes(in, TWO_TWO, \"Scan line \" + i + \" expected to start with 0x2 0x2\");\n            BinaryFunctions.readAndVerifyBytes(in, scanLineBytes, \"Scan line \" + i + \" length expected\");\n\n            decompress(in, rgbe);\n\n            for (int channel = 0; channel < 3; channel++) {\n                final int channelOffset = channel * wd;\n                final int eOffset = 3 * wd;\n\n                for (int p = 0; p < wd; p++) {\n                    final int mantissa = rgbe[p + eOffset] & 0xff;\n                    final int pos = p + i * wd;\n\n                    if (0 == mantissa) {\n                        out[channel][pos] = 0;\n                    } else {\n                        final float mult = (float) Math.pow(2, mantissa - (128 + 8));\n                        out[channel][pos] = ((rgbe[p + channelOffset] & 0xff) + 0.5f) * mult;\n                    }\n                }\n            }\n        }\n\n        return out;\n    }\n\n    private static void decompress(final InputStream in, final byte[] out)\n            throws IOException {\n        int position = 0;\n        final int total = out.length;\n\n        while (position < total) {\n            final int n = in.read();\n\n            if (n > 128) {\n                final int value = in.read();\n\n                for (int i = 0; i < (n & 0x7f); i++) {\n                    out[position++] = (byte) value;\n                }\n            } else {\n                for (int i = 0; i < n; i++) {\n                    out[position++] = (byte) in.read();\n                }\n            }\n        }\n    }\n}\n",
        "human_patch_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.imaging.formats.rgbe;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.ByteOrder;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.imaging.ImageReadException;\nimport org.apache.commons.imaging.common.BinaryFunctions;\nimport org.apache.commons.imaging.common.ByteConversions;\nimport org.apache.commons.imaging.common.ImageMetadata;\nimport org.apache.commons.imaging.common.GenericImageMetadata;\nimport org.apache.commons.imaging.common.bytesource.ByteSource;\n\nclass RgbeInfo implements Closeable {\n    // #?RADIANCE\n    private static final byte[] HEADER = new byte[] {\n        0x23, 0x3F, 0x52, 0x41, 0x44, 0x49, 0x41, 0x4E, 0x43, 0x45\n    };\n    private static final Pattern RESOLUTION_STRING = Pattern.compile(\"-Y (\\\\d+) \\\\+X (\\\\d+)\");\n\n    private final InputStream in;\n    private GenericImageMetadata metadata;\n    private int width = -1;\n    private int height = -1;\n    private static final byte[] TWO_TWO = new byte[] { 0x2, 0x2 };\n\n    RgbeInfo(final ByteSource byteSource) throws IOException {\n        this.in = byteSource.getInputStream();\n    }\n\n    ImageMetadata getMetadata() throws IOException, ImageReadException {\n        if (null == metadata) {\n            readMetadata();\n        }\n\n        return metadata;\n    }\n\n    int getWidth() throws IOException, ImageReadException {\n        if (-1 == width) {\n            readDimensions();\n        }\n\n        return width;\n    }\n\n    int getHeight() throws IOException, ImageReadException {\n        if (-1 == height) {\n            readDimensions();\n        }\n\n        return height;\n    }\n\n    @Override\n    public void close() throws IOException {\n        in.close();\n    }\n\n    private void readDimensions() throws IOException, ImageReadException {\n        getMetadata(); // Ensure we've read past this\n\n        final InfoHeaderReader reader = new InfoHeaderReader(in);\n        final String resolution = reader.readNextLine();\n        final Matcher matcher = RESOLUTION_STRING.matcher(resolution);\n\n        if (!matcher.matches()) {\n            throw new ImageReadException(\n                    \"Invalid HDR resolution string. Only \\\"-Y N +X M\\\" is supported. Found \\\"\"\n                            + resolution + \"\\\"\");\n        }\n\n        height = Integer.parseInt(matcher.group(1));\n        width = Integer.parseInt(matcher.group(2));\n    }\n\n    private void readMetadata() throws IOException, ImageReadException {\n        BinaryFunctions.readAndVerifyBytes(in, HEADER, \"Not a valid HDR: Incorrect Header\");\n\n        final InfoHeaderReader reader = new InfoHeaderReader(in);\n\n        if (reader.readNextLine().length() != 0) {\n            throw new ImageReadException(\"Not a valid HDR: Incorrect Header\");\n        }\n\n        metadata = new GenericImageMetadata();\n\n        String info = reader.readNextLine();\n\n        while (info.length() != 0) {\n            final int equals = info.indexOf('=');\n\n            if (equals > 0) {\n                final String variable = info.substring(0, equals);\n                final String value = info.substring(equals + 1);\n\n                if (\"FORMAT\".equals(value) && !\"32-bit_rle_rgbe\".equals(value)) {\n                    throw new ImageReadException(\"Only 32-bit_rle_rgbe images are supported, trying to read \" + value);\n                }\n\n                metadata.add(variable, value);\n            } else {\n                metadata.add(\"<command>\", info);\n            }\n\n            info = reader.readNextLine();\n        }\n    }\n\n    public float[][] getPixelData() throws IOException, ImageReadException {\n        // Read into local variables to ensure that we have seeked into the file\n        // far enough\n        final int ht = getHeight();\n        final int wd = getWidth();\n\n        if (wd >= 32768) {\n            throw new ImageReadException(\"Scan lines must be less than 32768 bytes long\");\n        }\n\n        final byte[] scanLineBytes = ByteConversions.toBytes((short) wd,\n                ByteOrder.BIG_ENDIAN);\n        final byte[] rgbe = new byte[wd * 4];\n        final float[][] out = new float[3][wd * ht];\n\n        for (int i = 0; i < ht; i++) {\n            BinaryFunctions.readAndVerifyBytes(in, TWO_TWO, \"Scan line \" + i + \" expected to start with 0x2 0x2\");\n            BinaryFunctions.readAndVerifyBytes(in, scanLineBytes, \"Scan line \" + i + \" length expected\");\n\n            decompress(in, rgbe);\n\n            for (int channel = 0; channel < 3; channel++) {\n                final int channelOffset = channel * wd;\n                final int eOffset = 3 * wd;\n\n                for (int p = 0; p < wd; p++) {\n                    final int mantissa = rgbe[p + eOffset] & 0xff;\n                    final int pos = p + i * wd;\n\n                    if (0 == mantissa) {\n                        out[channel][pos] = 0;\n                    } else {\n                        final float mult = (float) Math.pow(2, mantissa - (128 + 8));\n                        out[channel][pos] = ((rgbe[p + channelOffset] & 0xff) + 0.5f) * mult;\n                    }\n                }\n            }\n        }\n\n        return out;\n    }\n\n    private static void decompress(final InputStream in, final byte[] out)\n            throws IOException,ImageReadException {\n        int position = 0;\n        final int total = out.length;\n\n        while (position < total) {\n            final int n = in.read();\n\n            if (n < 0) {\n                throw new ImageReadException(\"Error decompressing RGBE file\");\n            }\n\n            if (n > 128) {\n                final int value = in.read();\n\n                for (int i = 0; i < (n & 0x7f); i++) {\n                    out[position++] = (byte) value;\n                }\n            } else {\n                for (int i = 0; i < n; i++) {\n                    out[position++] = (byte) in.read();\n                }\n            }\n        }\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-14": {
    "vul_id": "VUL4J-14",
    "cve_id": "CVE-2021-29425",
    "project": "apache_commons-io",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=org.apache.commons.io.FilenameUtilsTestCase#testGetPrefixLength,org.apache.commons.io.FilenameUtilsTestCase#testNormalize",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/apache/commons-io/commit/2736b6fe0b3fa22ec8e2b4184897ecadb021fc78",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/org/apache/commons/io/FilenameUtils.java",
        "file_name": "FilenameUtils.java",
        "vulnerable_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Stack;\n\n/**\n * General file name and file path manipulation utilities.\n * <p>\n * When dealing with file names you can hit problems when moving from a Windows\n * based development machine to a Unix based production machine.\n * This class aims to help avoid those problems.\n * <p>\n * <b>NOTE</b>: You may be able to avoid using this class entirely simply by\n * using JDK {@link java.io.File File} objects and the two argument constructor\n * {@link java.io.File#File(java.io.File, java.lang.String) File(File,String)}.\n * <p>\n * Most methods on this class are designed to work the same on both Unix and Windows.\n * Those that don't include 'System', 'Unix' or 'Windows' in their name.\n * <p>\n * Most methods recognise both separators (forward and back), and both\n * sets of prefixes. See the javadoc of each method for details.\n * <p>\n * This class defines six components within a file name\n * (example C:\\dev\\project\\file.txt):\n * <ul>\n * <li>the prefix - C:\\</li>\n * <li>the path - dev\\project\\</li>\n * <li>the full path - C:\\dev\\project\\</li>\n * <li>the name - file.txt</li>\n * <li>the base name - file</li>\n * <li>the extension - txt</li>\n * </ul>\n * Note that this class works best if directory file names end with a separator.\n * If you omit the last separator, it is impossible to determine if the file name\n * corresponds to a file or a directory. As a result, we have chosen to say\n * it corresponds to a file.\n * <p>\n * This class only supports Unix and Windows style names.\n * Prefixes are matched as follows:\n * <pre>\n * Windows:\n * a\\b\\c.txt           --&gt; \"\"          --&gt; relative\n * \\a\\b\\c.txt          --&gt; \"\\\"         --&gt; current drive absolute\n * C:a\\b\\c.txt         --&gt; \"C:\"        --&gt; drive relative\n * C:\\a\\b\\c.txt        --&gt; \"C:\\\"       --&gt; absolute\n * \\\\server\\a\\b\\c.txt  --&gt; \"\\\\server\\\" --&gt; UNC\n *\n * Unix:\n * a/b/c.txt           --&gt; \"\"          --&gt; relative\n * /a/b/c.txt          --&gt; \"/\"         --&gt; absolute\n * ~/a/b/c.txt         --&gt; \"~/\"        --&gt; current user\n * ~                   --&gt; \"~/\"        --&gt; current user (slash added)\n * ~user/a/b/c.txt     --&gt; \"~user/\"    --&gt; named user\n * ~user               --&gt; \"~user/\"    --&gt; named user (slash added)\n * </pre>\n * Both prefix styles are matched always, irrespective of the machine that you are\n * currently running on.\n * <p>\n * Origin of code: Excalibur, Alexandria, Tomcat, Commons-Utils.\n *\n * @since 1.1\n */\npublic class FilenameUtils {\n\n    private static final String EMPTY_STRING = \"\";\n\n    private static final int NOT_FOUND = -1;\n\n    /**\n     * The extension separator character.\n     * @since 1.4\n     */\n    public static final char EXTENSION_SEPARATOR = '.';\n\n    /**\n     * The extension separator String.\n     * @since 1.4\n     */\n    public static final String EXTENSION_SEPARATOR_STR = Character.toString(EXTENSION_SEPARATOR);\n\n    /**\n     * The Unix separator character.\n     */\n    private static final char UNIX_SEPARATOR = '/';\n\n    /**\n     * The Windows separator character.\n     */\n    private static final char WINDOWS_SEPARATOR = '\\\\';\n\n    /**\n     * The system separator character.\n     */\n    private static final char SYSTEM_SEPARATOR = File.separatorChar;\n\n    /**\n     * The separator character that is the opposite of the system separator.\n     */\n    private static final char OTHER_SEPARATOR;\n    static {\n        if (isSystemWindows()) {\n            OTHER_SEPARATOR = UNIX_SEPARATOR;\n        } else {\n            OTHER_SEPARATOR = WINDOWS_SEPARATOR;\n        }\n    }\n\n    /**\n     * Instances should NOT be constructed in standard programming.\n     */\n    public FilenameUtils() {\n        super();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Determines if Windows file system is in use.\n     *\n     * @return true if the system is Windows\n     */\n    static boolean isSystemWindows() {\n        return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the character is a separator.\n     *\n     * @param ch  the character to check\n     * @return true if it is a separator character\n     */\n    private static boolean isSeparator(final char ch) {\n        return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Normalizes a path, removing double and single dot path steps.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format of the system.\n     * <p>\n     * A trailing slash will be retained.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo/\n     * /foo/./              --&gt;   /foo/\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar/\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo/\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar/\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * (Note the file separator returned will be correct for Windows/Unix)\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     */\n    public static String normalize(final String fileName) {\n        return doNormalize(fileName, SYSTEM_SEPARATOR, true);\n    }\n    /**\n     * Normalizes a path, removing double and single dot path steps.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be retained.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo/\n     * /foo/./              --&gt;   /foo/\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar/\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo/\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar/\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separator should be used.\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     * @since 2.0\n     */\n    public static String normalize(final String fileName, final boolean unixSeparator) {\n        final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(fileName, separator, true);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format of the system.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo\n     * /foo/./              --&gt;   /foo\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * (Note the file separator returned will be correct for Windows/Unix)\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     */\n    public static String normalizeNoEndSeparator(final String fileName) {\n        return doNormalize(fileName, SYSTEM_SEPARATOR, false);\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo\n     * /foo/./              --&gt;   /foo\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar\n     * ~/../bar             --&gt;   null\n     * </pre>\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separator should be used.\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     * @since 2.0\n     */\n    public static String normalizeNoEndSeparator(final String fileName, final boolean unixSeparator) {\n         final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(fileName, separator, false);\n    }\n\n    /**\n     * Internal method to perform the normalization.\n     *\n     * @param fileName  the fileName\n     * @param separator The separator character to use\n     * @param keepSeparator  true to keep the final separator\n     * @return the normalized fileName. Null bytes inside string will be removed.\n     */\n    private static String doNormalize(final String fileName, final char separator, final boolean keepSeparator) {\n        if (fileName == null) {\n            return null;\n        }\n\n        failIfNullBytePresent(fileName);\n\n        int size = fileName.length();\n        if (size == 0) {\n            return fileName;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n\n        final char[] array = new char[size + 2];  // +1 for possible extra slash, +2 for arraycopy\n        fileName.getChars(0, fileName.length(), array, 0);\n\n        // fix separators throughout\n        final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR;\n        for (int i = 0; i < array.length; i++) {\n            if (array[i] == otherSeparator) {\n                array[i] = separator;\n            }\n        }\n\n        // add extra separator on the end to simplify code below\n        boolean lastIsDirectory = true;\n        if (array[size - 1] != separator) {\n            array[size++] = separator;\n            lastIsDirectory = false;\n        }\n\n        // adjoining slashes\n        for (int i = prefix + 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == separator) {\n                System.arraycopy(array, i, array, i - 1, size - i);\n                size--;\n                i--;\n            }\n        }\n\n        // dot slash\n        for (int i = prefix + 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' &&\n                    (i == prefix + 1 || array[i - 2] == separator)) {\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                System.arraycopy(array, i + 1, array, i - 1, size - i);\n                size -=2;\n                i--;\n            }\n        }\n\n        // double dot slash\n        outer:\n        for (int i = prefix + 2; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' && array[i - 2] == '.' &&\n                    (i == prefix + 2 || array[i - 3] == separator)) {\n                if (i == prefix + 2) {\n                    return null;\n                }\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                int j;\n                for (j = i - 4 ; j >= prefix; j--) {\n                    if (array[j] == separator) {\n                        // remove b/../ from a/b/../c\n                        System.arraycopy(array, i + 1, array, j + 1, size - i);\n                        size -= i - j;\n                        i = j + 1;\n                        continue outer;\n                    }\n                }\n                // remove a/../ from a/../c\n                System.arraycopy(array, i + 1, array, prefix, size - i);\n                size -= i + 1 - prefix;\n                i = prefix + 1;\n            }\n        }\n\n        if (size <= 0) {  // should never be less than 0\n            return EMPTY_STRING;\n        }\n        if (size <= prefix) {  // should never be less than prefix\n            return new String(array, 0, size);\n        }\n        if (lastIsDirectory && keepSeparator) {\n            return new String(array, 0, size);  // keep trailing separator\n        }\n        return new String(array, 0, size - 1);  // lose trailing separator\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Concatenates a fileName to a base path using normal command line style rules.\n     * <p>\n     * The effect is equivalent to resultant directory after changing\n     * directory to the first argument, followed by changing directory to\n     * the second argument.\n     * <p>\n     * The first argument is the base path, the second is the path to concatenate.\n     * The returned path is always normalized via {@link #normalize(String)},\n     * thus <code>..</code> is handled.\n     * <p>\n     * If <code>pathToAdd</code> is absolute (has an absolute prefix), then\n     * it will be normalized and returned.\n     * Otherwise, the paths will be joined, normalized and returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo/ + bar          --&gt;   /foo/bar\n     * /foo + bar           --&gt;   /foo/bar\n     * /foo + /bar          --&gt;   /bar\n     * /foo + C:/bar        --&gt;   C:/bar\n     * /foo + C:bar         --&gt;   C:bar (*)\n     * /foo/a/ + ../bar     --&gt;   foo/bar\n     * /foo/ + ../../bar    --&gt;   null\n     * /foo/ + /bar         --&gt;   /bar\n     * /foo/.. + /bar       --&gt;   /bar\n     * /foo + bar/c.txt     --&gt;   /foo/bar/c.txt\n     * /foo/c.txt + bar     --&gt;   /foo/c.txt/bar (!)\n     * </pre>\n     * (*) Note that the Windows relative drive prefix is unreliable when\n     * used with this method.\n     * (!) Note that the first parameter must be a path. If it ends with a name, then\n     * the name will be built into the concatenated path. If this might be a problem,\n     * use {@link #getFullPath(String)} on the base path argument.\n     *\n     * @param basePath  the base path to attach to, always treated as a path\n     * @param fullFileNameToAdd  the fileName (or path) to attach to the base\n     * @return the concatenated path, or null if invalid.  Null bytes inside string will be removed\n     */\n    public static String concat(final String basePath, final String fullFileNameToAdd) {\n        final int prefix = getPrefixLength(fullFileNameToAdd);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix > 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        if (basePath == null) {\n            return null;\n        }\n        final int len = basePath.length();\n        if (len == 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        final char ch = basePath.charAt(len - 1);\n        if (isSeparator(ch)) {\n            return normalize(basePath + fullFileNameToAdd);\n        }\n        return normalize(basePath + '/' + fullFileNameToAdd);\n    }\n\n    /**\n     * Determines whether the {@code parent} directory contains the {@code child} element (a file or directory).\n     * <p>\n     * The files names are expected to be normalized.\n     * </p>\n     *\n     * Edge cases:\n     * <ul>\n     * <li>A {@code directory} must not be null: if null, throw IllegalArgumentException</li>\n     * <li>A directory does not contain itself: return false</li>\n     * <li>A null child file is not contained in any parent: return false</li>\n     * </ul>\n     *\n     * @param canonicalParent\n     *            the file to consider as the parent.\n     * @param canonicalChild\n     *            the file to consider as the child.\n     * @return true is the candidate leaf is under by the specified composite. False otherwise.\n     * @throws IOException\n     *             if an IO error occurs while checking the files.\n     * @since 2.2\n     * @see FileUtils#directoryContains(File, File)\n     */\n    public static boolean directoryContains(final String canonicalParent, final String canonicalChild)\n            throws IOException {\n\n        // Fail fast against NullPointerException\n        if (canonicalParent == null) {\n            throw new IllegalArgumentException(\"Directory must not be null\");\n        }\n\n        if (canonicalChild == null) {\n            return false;\n        }\n\n        if (IOCase.SYSTEM.checkEquals(canonicalParent, canonicalChild)) {\n            return false;\n        }\n\n        return IOCase.SYSTEM.checkStartsWith(canonicalChild, canonicalParent);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts all separators to the Unix separator of forward slash.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToUnix(final String path) {\n        if (path == null || path.indexOf(WINDOWS_SEPARATOR) == NOT_FOUND) {\n            return path;\n        }\n        return path.replace(WINDOWS_SEPARATOR, UNIX_SEPARATOR);\n    }\n\n    /**\n     * Converts all separators to the Windows separator of backslash.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToWindows(final String path) {\n        if (path == null || path.indexOf(UNIX_SEPARATOR) == NOT_FOUND) {\n            return path;\n        }\n        return path.replace(UNIX_SEPARATOR, WINDOWS_SEPARATOR);\n    }\n\n    /**\n     * Converts all separators to the system separator.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToSystem(final String path) {\n        if (path == null) {\n            return null;\n        }\n        return isSystemWindows() ? separatorsToWindows(path) : separatorsToUnix(path);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the length of the fileName prefix, such as <code>C:/</code> or <code>~/</code>.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * <p>\n     * The prefix length includes the first slash in the full fileName\n     * if applicable. Thus, it is possible that the length returned is greater\n     * than the length of the input string.\n     * <pre>\n     * Windows:\n     * a\\b\\c.txt           --&gt; \"\"          --&gt; relative\n     * \\a\\b\\c.txt          --&gt; \"\\\"         --&gt; current drive absolute\n     * C:a\\b\\c.txt         --&gt; \"C:\"        --&gt; drive relative\n     * C:\\a\\b\\c.txt        --&gt; \"C:\\\"       --&gt; absolute\n     * \\\\server\\a\\b\\c.txt  --&gt; \"\\\\server\\\" --&gt; UNC\n     * \\\\\\a\\b\\c.txt        --&gt;  error, length = -1\n     *\n     * Unix:\n     * a/b/c.txt           --&gt; \"\"          --&gt; relative\n     * /a/b/c.txt          --&gt; \"/\"         --&gt; absolute\n     * ~/a/b/c.txt         --&gt; \"~/\"        --&gt; current user\n     * ~                   --&gt; \"~/\"        --&gt; current user (slash added)\n     * ~user/a/b/c.txt     --&gt; \"~user/\"    --&gt; named user\n     * ~user               --&gt; \"~user/\"    --&gt; named user (slash added)\n     * //server/a/b/c.txt  --&gt; \"//server/\"\n     * ///a/b/c.txt        --&gt; error, length = -1\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * ie. both Unix and Windows prefixes are matched regardless.\n     *\n     * Note that a leading // (or \\\\) is used to indicate a UNC name on Windows.\n     * These must be followed by a server name, so double-slashes are not collapsed\n     * to a single slash at the start of the fileName.\n     *\n     * @param fileName  the fileName to find the prefix in, null returns -1\n     * @return the length of the prefix, -1 if invalid or null\n     */\n    public static int getPrefixLength(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int len = fileName.length();\n        if (len == 0) {\n            return 0;\n        }\n        char ch0 = fileName.charAt(0);\n        if (ch0 == ':') {\n            return NOT_FOUND;\n        }\n        if (len == 1) {\n            if (ch0 == '~') {\n                return 2;  // return a length greater than the input\n            }\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        if (ch0 == '~') {\n            int posUnix = fileName.indexOf(UNIX_SEPARATOR, 1);\n            int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 1);\n            if (posUnix == NOT_FOUND && posWin == NOT_FOUND) {\n                return len + 1;  // return a length greater than the input\n            }\n            posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n            posWin = posWin == NOT_FOUND ? posUnix : posWin;\n            return Math.min(posUnix, posWin) + 1;\n        }\n        final char ch1 = fileName.charAt(1);\n        if (ch1 == ':') {\n            ch0 = Character.toUpperCase(ch0);\n            if (ch0 >= 'A' && ch0 <= 'Z') {\n                if (len == 2 || isSeparator(fileName.charAt(2)) == false) {\n                    return 2;\n                }\n                return 3;\n            } else if (ch0 == UNIX_SEPARATOR) {\n                return 1;\n            }\n            return NOT_FOUND;\n\n        } else if (isSeparator(ch0) && isSeparator(ch1)) {\n            int posUnix = fileName.indexOf(UNIX_SEPARATOR, 2);\n            int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 2);\n            if (posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2) {\n                return NOT_FOUND;\n            }\n            posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n            posWin = posWin == NOT_FOUND ? posUnix : posWin;\n            return Math.min(posUnix, posWin) + 1;\n        } else {\n            return isSeparator(ch0) ? 1 : 0;\n        }\n    }\n\n    /**\n     * Returns the index of the last directory separator character.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The position of the last forward or backslash is returned.\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to find the last path separator in, null returns -1\n     * @return the index of the last separator character, or -1 if there\n     * is no such character\n     */\n    public static int indexOfLastSeparator(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int lastUnixPos = fileName.lastIndexOf(UNIX_SEPARATOR);\n        final int lastWindowsPos = fileName.lastIndexOf(WINDOWS_SEPARATOR);\n        return Math.max(lastUnixPos, lastWindowsPos);\n    }\n\n    /**\n     * Returns the index of the last extension separator character, which is a dot.\n     * <p>\n     * This method also checks that there is no directory separator after the last dot. To do this it uses\n     * {@link #indexOfLastSeparator(String)} which will handle a file in either Unix or Windows format.\n     * </p>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on, with the\n     * exception of a possible {@link IllegalArgumentException} on Windows (see below).\n     * </p>\n     * <b>Note:</b> This method used to have a hidden problem for names like \"foo.exe:bar.txt\".\n     * In this case, the name wouldn't be the name of a file, but the identifier of an\n     * alternate data stream (bar.txt) on the file foo.exe. The method used to return\n     * \".txt\" here, which would be misleading. Commons IO 2.7, and later versions, are throwing\n     * an {@link IllegalArgumentException} for names like this.\n     *\n     * @param fileName\n     *            the fileName to find the last extension separator in, null returns -1\n     * @return the index of the last extension separator character, or -1 if there is no such character\n     * @throws IllegalArgumentException <b>Windows only:</b> The fileName parameter is, in fact,\n     * the identifier of an Alternate Data Stream, for example \"foo.exe:bar.txt\".\n     */\n    public static int indexOfExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        if (isSystemWindows()) {\n            // Special handling for NTFS ADS: Don't accept colon in the fileName.\n            final int offset = fileName.indexOf(':', getAdsCriticalOffset(fileName));\n            if (offset != -1) {\n                throw new IllegalArgumentException(\"NTFS ADS separator (':') in file name is forbidden.\");\n            }\n        }\n        final int extensionPos = fileName.lastIndexOf(EXTENSION_SEPARATOR);\n        final int lastSeparator = indexOfLastSeparator(fileName);\n        return lastSeparator > extensionPos ? NOT_FOUND : extensionPos;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the prefix from a full fileName, such as <code>C:/</code>\n     * or <code>~/</code>.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The prefix includes the first slash in the full fileName where applicable.\n     * <pre>\n     * Windows:\n     * a\\b\\c.txt           --&gt; \"\"          --&gt; relative\n     * \\a\\b\\c.txt          --&gt; \"\\\"         --&gt; current drive absolute\n     * C:a\\b\\c.txt         --&gt; \"C:\"        --&gt; drive relative\n     * C:\\a\\b\\c.txt        --&gt; \"C:\\\"       --&gt; absolute\n     * \\\\server\\a\\b\\c.txt  --&gt; \"\\\\server\\\" --&gt; UNC\n     *\n     * Unix:\n     * a/b/c.txt           --&gt; \"\"          --&gt; relative\n     * /a/b/c.txt          --&gt; \"/\"         --&gt; absolute\n     * ~/a/b/c.txt         --&gt; \"~/\"        --&gt; current user\n     * ~                   --&gt; \"~/\"        --&gt; current user (slash added)\n     * ~user/a/b/c.txt     --&gt; \"~user/\"    --&gt; named user\n     * ~user               --&gt; \"~user/\"    --&gt; named user (slash added)\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * ie. both Unix and Windows prefixes are matched regardless.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the prefix of the file, null if invalid. Null bytes inside string will be removed\n     */\n    public static String getPrefix(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        final int len = getPrefixLength(fileName);\n        if (len < 0) {\n            return null;\n        }\n        if (len > fileName.length()) {\n            failIfNullBytePresent(fileName + UNIX_SEPARATOR);\n            return fileName + UNIX_SEPARATOR;\n        }\n        final String path = fileName.substring(0, len);\n        failIfNullBytePresent(path);\n        return path;\n    }\n\n    /**\n     * Gets the path from a full fileName, which excludes the prefix.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before and\n     * including the last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; a\\b\\\n     * ~/a/b/c.txt  --&gt; a/b/\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b/\n     * a/b/c/       --&gt; a/b/c/\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * <p>\n     * This method drops the prefix from the result.\n     * See {@link #getFullPath(String)} for the method that retains the prefix.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid.\n     * Null bytes inside string will be removed\n     */\n    public static String getPath(final String fileName) {\n        return doGetPath(fileName, 1);\n    }\n\n    /**\n     * Gets the path from a full fileName, which excludes the prefix, and\n     * also excluding the final directory separator.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before the\n     * last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; a\\b\n     * ~/a/b/c.txt  --&gt; a/b\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b\n     * a/b/c/       --&gt; a/b/c\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * <p>\n     * This method drops the prefix from the result.\n     * See {@link #getFullPathNoEndSeparator(String)} for the method that retains the prefix.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid.\n     * Null bytes inside string will be removed\n     */\n    public static String getPathNoEndSeparator(final String fileName) {\n        return doGetPath(fileName, 0);\n    }\n\n    /**\n     * Does the work of getting the path.\n     *\n     * @param fileName  the fileName\n     * @param separatorAdd  0 to omit the end separator, 1 to return it\n     * @return the path. Null bytes inside string will be removed\n     */\n    private static String doGetPath(final String fileName, final int separatorAdd) {\n        if (fileName == null) {\n            return null;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n        final int index = indexOfLastSeparator(fileName);\n        final int endIndex = index+separatorAdd;\n        if (prefix >= fileName.length() || index < 0 || prefix >= endIndex) {\n            return EMPTY_STRING;\n        }\n        final String path = fileName.substring(prefix, endIndex);\n        failIfNullBytePresent(path);\n        return path;\n    }\n\n    /**\n     * Gets the full path from a full fileName, which is the prefix + path.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before and\n     * including the last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; C:\\a\\b\\\n     * ~/a/b/c.txt  --&gt; ~/a/b/\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b/\n     * a/b/c/       --&gt; a/b/c/\n     * C:           --&gt; C:\n     * C:\\          --&gt; C:\\\n     * ~            --&gt; ~/\n     * ~/           --&gt; ~/\n     * ~user        --&gt; ~user/\n     * ~user/       --&gt; ~user/\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getFullPath(final String fileName) {\n        return doGetFullPath(fileName, true);\n    }\n\n    /**\n     * Gets the full path from a full fileName, which is the prefix + path,\n     * and also excluding the final directory separator.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before the\n     * last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; C:\\a\\b\n     * ~/a/b/c.txt  --&gt; ~/a/b\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b\n     * a/b/c/       --&gt; a/b/c\n     * C:           --&gt; C:\n     * C:\\          --&gt; C:\\\n     * ~            --&gt; ~\n     * ~/           --&gt; ~\n     * ~user        --&gt; ~user\n     * ~user/       --&gt; ~user\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getFullPathNoEndSeparator(final String fileName) {\n        return doGetFullPath(fileName, false);\n    }\n\n    /**\n     * Does the work of getting the path.\n     *\n     * @param fileName  the fileName\n     * @param includeSeparator  true to include the end separator\n     * @return the path\n     */\n    private static String doGetFullPath(final String fileName, final boolean includeSeparator) {\n        if (fileName == null) {\n            return null;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix >= fileName.length()) {\n            if (includeSeparator) {\n                return getPrefix(fileName);  // add end slash if necessary\n            }\n            return fileName;\n        }\n        final int index = indexOfLastSeparator(fileName);\n        if (index < 0) {\n            return fileName.substring(0, prefix);\n        }\n        int end = index + (includeSeparator ?  1 : 0);\n        if (end == 0) {\n            end++;\n        }\n        return fileName.substring(0, end);\n    }\n\n    /**\n     * Gets the name minus the path from a full fileName.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The text after the last forward or backslash is returned.\n     * <pre>\n     * a/b/c.txt --&gt; c.txt\n     * a.txt     --&gt; a.txt\n     * a/b/c     --&gt; c\n     * a/b/c/    --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the name of the file without the path, or an empty string if none exists.\n     * Null bytes inside string will be removed\n     */\n    public static String getName(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        failIfNullBytePresent(fileName);\n        final int index = indexOfLastSeparator(fileName);\n        return fileName.substring(index + 1);\n    }\n\n    /**\n     * Check the input for null bytes, a sign of unsanitized data being passed to to file level functions.\n     *\n     * This may be used for poison byte attacks.\n     * @param path the path to check\n     */\n    private static void failIfNullBytePresent(final String path) {\n        final int len = path.length();\n        for (int i = 0; i < len; i++) {\n            if (path.charAt(i) == 0) {\n                throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" +\n                        \"known legitimate use cases for such data, but several injection attacks may use it\");\n            }\n        }\n    }\n\n    /**\n     * Gets the base name, minus the full path and extension, from a full fileName.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The text after the last forward or backslash and before the last dot is returned.\n     * <pre>\n     * a/b/c.txt --&gt; c\n     * a.txt     --&gt; a\n     * a/b/c     --&gt; c\n     * a/b/c/    --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the name of the file without the path, or an empty string if none exists. Null bytes inside string\n     * will be removed\n     */\n    public static String getBaseName(final String fileName) {\n        return removeExtension(getName(fileName));\n    }\n\n    /**\n     * Gets the extension of a fileName.\n     * <p>\n     * This method returns the textual part of the fileName after the last dot.\n     * There must be no directory separator after the dot.\n     * <pre>\n     * foo.txt      --&gt; \"txt\"\n     * a/b/c.jpg    --&gt; \"jpg\"\n     * a/b.txt/c    --&gt; \"\"\n     * a/b/c        --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on, with the\n     * exception of a possible {@link IllegalArgumentException} on Windows (see below).\n     * </p>\n     * <p>\n     * <b>Note:</b> This method used to have a hidden problem for names like \"foo.exe:bar.txt\".\n     * In this case, the name wouldn't be the name of a file, but the identifier of an\n     * alternate data stream (bar.txt) on the file foo.exe. The method used to return\n     * \".txt\" here, which would be misleading. Commons IO 2.7, and later versions, are throwing\n     * an {@link IllegalArgumentException} for names like this.\n     *\n     * @param fileName the fileName to retrieve the extension of.\n     * @return the extension of the file or an empty string if none exists or {@code null}\n     * if the fileName is {@code null}.\n     * @throws IllegalArgumentException <b>Windows only:</b> The fileName parameter is, in fact,\n     * the identifier of an Alternate Data Stream, for example \"foo.exe:bar.txt\".\n     */\n    public static String getExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName == null) {\n            return null;\n        }\n        final int index = indexOfExtension(fileName);\n        if (index == NOT_FOUND) {\n            return EMPTY_STRING;\n        }\n        return fileName.substring(index + 1);\n    }\n\n    /**\n     * Special handling for NTFS ADS: Don't accept colon in the fileName.\n     * \n     * @param fileName a file name\n     * @return ADS offsets.\n     */\n    private static int getAdsCriticalOffset(String fileName) {\n        // Step 1: Remove leading path segments.\n        int offset1 = fileName.lastIndexOf(SYSTEM_SEPARATOR);\n        int offset2 = fileName.lastIndexOf(OTHER_SEPARATOR);\n        if (offset1 == -1) {\n            if (offset2 == -1) {\n                return 0;\n            }\n            return offset2 + 1;\n        }\n        if (offset2 == -1) {\n            return offset1 + 1;\n        }\n        return Math.max(offset1, offset2) + 1;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Removes the extension from a fileName.\n     * <p>\n     * This method returns the textual part of the fileName before the last dot.\n     * There must be no directory separator after the dot.\n     * <pre>\n     * foo.txt    --&gt; foo\n     * a\\b\\c.jpg  --&gt; a\\b\\c\n     * a\\b\\c      --&gt; a\\b\\c\n     * a.b\\c      --&gt; a.b\\c\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the fileName minus the extension\n     */\n    public static String removeExtension(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        failIfNullBytePresent(fileName);\n\n        final int index = indexOfExtension(fileName);\n        if (index == NOT_FOUND) {\n            return fileName;\n        }\n        return fileName.substring(0, index);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks whether two fileNames are equal exactly.\n     * <p>\n     * No processing is performed on the fileNames other than comparison,\n     * thus this is merely a null-safe case-sensitive equals.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean equals(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks whether two fileNames are equal using the case rules of the system.\n     * <p>\n     * No processing is performed on the fileNames other than comparison.\n     * The check is case-sensitive on Unix and case-insensitive on Windows.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SYSTEM\n     */\n    public static boolean equalsOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SYSTEM);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks whether two fileNames are equal after both have been normalized.\n     * <p>\n     * Both fileNames are first passed to {@link #normalize(String)}.\n     * The check is then performed in a case-sensitive manner.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean equalsNormalized(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks whether two fileNames are equal after both have been normalized\n     * and using the case rules of the system.\n     * <p>\n     * Both fileNames are first passed to {@link #normalize(String)}.\n     * The check is then performed case-sensitive on Unix and\n     * case-insensitive on Windows.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SYSTEM\n     */\n    public static boolean equalsNormalizedOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SYSTEM);\n    }\n\n    /**\n     * Checks whether two fileNames are equal, optionally normalizing and providing\n     * control over the case-sensitivity.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @param normalized  whether to normalize the fileNames\n     * @param caseSensitivity  what case sensitivity rule to use, null means case-sensitive\n     * @return true if the fileNames are equal, null equals null\n     * @since 1.3\n     */\n    public static boolean equals(\n            String fileName1, String fileName2,\n            final boolean normalized, IOCase caseSensitivity) {\n\n        if (fileName1 == null || fileName2 == null) {\n            return fileName1 == null && fileName2 == null;\n        }\n        if (normalized) {\n            fileName1 = normalize(fileName1);\n            fileName2 = normalize(fileName2);\n            if (fileName1 == null || fileName2 == null) {\n                throw new NullPointerException(\n                    \"Error normalizing one or both of the file names\");\n            }\n        }\n        if (caseSensitivity == null) {\n            caseSensitivity = IOCase.SENSITIVE;\n        }\n        return caseSensitivity.checkEquals(fileName1, fileName2);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks whether the extension of the fileName is that specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extension  the extension to check for, null or empty checks for no extension\n     * @return true if the fileName has the specified extension\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final String extension) {\n        if (fileName == null) {\n            return false;\n        }\n        failIfNullBytePresent(fileName);\n\n        if (extension == null || extension.isEmpty()) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        return fileExt.equals(extension);\n    }\n\n    /**\n     * Checks whether the extension of the fileName is one of those specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extensions  the extensions to check for, null checks for no extension\n     * @return true if the fileName is one of the extensions\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final String[] extensions) {\n        if (fileName == null) {\n            return false;\n        }\n        failIfNullBytePresent(fileName);\n\n        if (extensions == null || extensions.length == 0) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        for (final String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the extension of the fileName is one of those specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extensions  the extensions to check for, null checks for no extension\n     * @return true if the fileName is one of the extensions\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final Collection<String> extensions) {\n        if (fileName == null) {\n            return false;\n        }\n        failIfNullBytePresent(fileName);\n\n        if (extensions == null || extensions.isEmpty()) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        for (final String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher,\n     * always testing case-sensitive.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * This is the same as often found on Dos/Unix command lines.\n     * The check is case-sensitive always.\n     * <pre>\n     * wildcardMatch(\"c.txt\", \"*.txt\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.jpg\")      --&gt; false\n     * wildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.???\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.????\")     --&gt; false\n     * </pre>\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @return true if the fileName matches the wildcard string\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean wildcardMatch(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher\n     * using the case rules of the system.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * This is the same as often found on Dos/Unix command lines.\n     * The check is case-sensitive on Unix and case-insensitive on Windows.\n     * <pre>\n     * wildcardMatch(\"c.txt\", \"*.txt\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.jpg\")      --&gt; false\n     * wildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.???\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.????\")     --&gt; false\n     * </pre>\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @return true if the fileName matches the wildcard string\n     * @see IOCase#SYSTEM\n     */\n    public static boolean wildcardMatchOnSystem(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SYSTEM);\n    }\n\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher\n     * allowing control over case-sensitivity.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @param caseSensitivity  what case sensitivity rule to use, null means case-sensitive\n     * @return true if the fileName matches the wildcard string\n     * @since 1.3\n     */\n    public static boolean wildcardMatch(final String fileName, final String wildcardMatcher, IOCase caseSensitivity) {\n        if (fileName == null && wildcardMatcher == null) {\n            return true;\n        }\n        if (fileName == null || wildcardMatcher == null) {\n            return false;\n        }\n        if (caseSensitivity == null) {\n            caseSensitivity = IOCase.SENSITIVE;\n        }\n        final String[] wcs = splitOnTokens(wildcardMatcher);\n        boolean anyChars = false;\n        int textIdx = 0;\n        int wcsIdx = 0;\n        final Stack<int[]> backtrack = new Stack<>();\n\n        // loop around a backtrack stack, to handle complex * matching\n        do {\n            if (backtrack.size() > 0) {\n                final int[] array = backtrack.pop();\n                wcsIdx = array[0];\n                textIdx = array[1];\n                anyChars = true;\n            }\n\n            // loop whilst tokens and text left to process\n            while (wcsIdx < wcs.length) {\n\n                if (wcs[wcsIdx].equals(\"?\")) {\n                    // ? so move to next text char\n                    textIdx++;\n                    if (textIdx > fileName.length()) {\n                        break;\n                    }\n                    anyChars = false;\n\n                } else if (wcs[wcsIdx].equals(\"*\")) {\n                    // set any chars status\n                    anyChars = true;\n                    if (wcsIdx == wcs.length - 1) {\n                        textIdx = fileName.length();\n                    }\n\n                } else {\n                    // matching text token\n                    if (anyChars) {\n                        // any chars then try to locate text token\n                        textIdx = caseSensitivity.checkIndexOf(fileName, textIdx, wcs[wcsIdx]);\n                        if (textIdx == NOT_FOUND) {\n                            // token not found\n                            break;\n                        }\n                        final int repeat = caseSensitivity.checkIndexOf(fileName, textIdx + 1, wcs[wcsIdx]);\n                        if (repeat >= 0) {\n                            backtrack.push(new int[] {wcsIdx, repeat});\n                        }\n                    } else {\n                        // matching from current position\n                        if (!caseSensitivity.checkRegionMatches(fileName, textIdx, wcs[wcsIdx])) {\n                            // couldnt match token\n                            break;\n                        }\n                    }\n\n                    // matched text token, move text index to end of matched token\n                    textIdx += wcs[wcsIdx].length();\n                    anyChars = false;\n                }\n\n                wcsIdx++;\n            }\n\n            // full match\n            if (wcsIdx == wcs.length && textIdx == fileName.length()) {\n                return true;\n            }\n\n        } while (backtrack.size() > 0);\n\n        return false;\n    }\n\n    /**\n     * Splits a string into a number of tokens.\n     * The text is split by '?' and '*'.\n     * Where multiple '*' occur consecutively they are collapsed into a single '*'.\n     *\n     * @param text  the text to split\n     * @return the array of tokens, never null\n     */\n    static String[] splitOnTokens(final String text) {\n        // used by wildcardMatch\n        // package level so a unit test may run on this\n\n        if (text.indexOf('?') == NOT_FOUND && text.indexOf('*') == NOT_FOUND) {\n            return new String[] { text };\n        }\n\n        final char[] array = text.toCharArray();\n        final ArrayList<String> list = new ArrayList<>();\n        final StringBuilder buffer = new StringBuilder();\n        char prevChar = 0;\n        for (final char ch : array) {\n            if (ch == '?' || ch == '*') {\n                if (buffer.length() != 0) {\n                    list.add(buffer.toString());\n                    buffer.setLength(0);\n                }\n                if (ch == '?') {\n                    list.add(\"?\");\n                } else if (prevChar != '*') {// ch == '*' here; check if previous char was '*'\n                    list.add(\"*\");\n                }\n            } else {\n                buffer.append(ch);\n            }\n            prevChar = ch;\n        }\n        if (buffer.length() != 0) {\n            list.add(buffer.toString());\n        }\n\n        return list.toArray( new String[ list.size() ] );\n    }\n\n}\n",
        "human_patch_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Stack;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * General file name and file path manipulation utilities.\n * <p>\n * When dealing with file names you can hit problems when moving from a Windows\n * based development machine to a Unix based production machine.\n * This class aims to help avoid those problems.\n * <p>\n * <b>NOTE</b>: You may be able to avoid using this class entirely simply by\n * using JDK {@link java.io.File File} objects and the two argument constructor\n * {@link java.io.File#File(java.io.File, java.lang.String) File(File,String)}.\n * <p>\n * Most methods on this class are designed to work the same on both Unix and Windows.\n * Those that don't include 'System', 'Unix' or 'Windows' in their name.\n * <p>\n * Most methods recognise both separators (forward and back), and both\n * sets of prefixes. See the javadoc of each method for details.\n * <p>\n * This class defines six components within a file name\n * (example C:\\dev\\project\\file.txt):\n * <ul>\n * <li>the prefix - C:\\</li>\n * <li>the path - dev\\project\\</li>\n * <li>the full path - C:\\dev\\project\\</li>\n * <li>the name - file.txt</li>\n * <li>the base name - file</li>\n * <li>the extension - txt</li>\n * </ul>\n * Note that this class works best if directory file names end with a separator.\n * If you omit the last separator, it is impossible to determine if the file name\n * corresponds to a file or a directory. As a result, we have chosen to say\n * it corresponds to a file.\n * <p>\n * This class only supports Unix and Windows style names.\n * Prefixes are matched as follows:\n * <pre>\n * Windows:\n * a\\b\\c.txt           --&gt; \"\"          --&gt; relative\n * \\a\\b\\c.txt          --&gt; \"\\\"         --&gt; current drive absolute\n * C:a\\b\\c.txt         --&gt; \"C:\"        --&gt; drive relative\n * C:\\a\\b\\c.txt        --&gt; \"C:\\\"       --&gt; absolute\n * \\\\server\\a\\b\\c.txt  --&gt; \"\\\\server\\\" --&gt; UNC\n *\n * Unix:\n * a/b/c.txt           --&gt; \"\"          --&gt; relative\n * /a/b/c.txt          --&gt; \"/\"         --&gt; absolute\n * ~/a/b/c.txt         --&gt; \"~/\"        --&gt; current user\n * ~                   --&gt; \"~/\"        --&gt; current user (slash added)\n * ~user/a/b/c.txt     --&gt; \"~user/\"    --&gt; named user\n * ~user               --&gt; \"~user/\"    --&gt; named user (slash added)\n * </pre>\n * Both prefix styles are matched always, irrespective of the machine that you are\n * currently running on.\n * <p>\n * Origin of code: Excalibur, Alexandria, Tomcat, Commons-Utils.\n *\n * @since 1.1\n */\npublic class FilenameUtils {\n\n    private static final String EMPTY_STRING = \"\";\n\n    private static final int NOT_FOUND = -1;\n\n    /**\n     * The extension separator character.\n     * @since 1.4\n     */\n    public static final char EXTENSION_SEPARATOR = '.';\n\n    /**\n     * The extension separator String.\n     * @since 1.4\n     */\n    public static final String EXTENSION_SEPARATOR_STR = Character.toString(EXTENSION_SEPARATOR);\n\n    /**\n     * The Unix separator character.\n     */\n    private static final char UNIX_SEPARATOR = '/';\n\n    /**\n     * The Windows separator character.\n     */\n    private static final char WINDOWS_SEPARATOR = '\\\\';\n\n    /**\n     * The system separator character.\n     */\n    private static final char SYSTEM_SEPARATOR = File.separatorChar;\n\n    /**\n     * The separator character that is the opposite of the system separator.\n     */\n    private static final char OTHER_SEPARATOR;\n    static {\n        if (isSystemWindows()) {\n            OTHER_SEPARATOR = UNIX_SEPARATOR;\n        } else {\n            OTHER_SEPARATOR = WINDOWS_SEPARATOR;\n        }\n    }\n\n    /**\n     * Instances should NOT be constructed in standard programming.\n     */\n    public FilenameUtils() {\n        super();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Determines if Windows file system is in use.\n     *\n     * @return true if the system is Windows\n     */\n    static boolean isSystemWindows() {\n        return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the character is a separator.\n     *\n     * @param ch  the character to check\n     * @return true if it is a separator character\n     */\n    private static boolean isSeparator(final char ch) {\n        return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Normalizes a path, removing double and single dot path steps.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format of the system.\n     * <p>\n     * A trailing slash will be retained.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo/\n     * /foo/./              --&gt;   /foo/\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar/\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo/\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar/\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * (Note the file separator returned will be correct for Windows/Unix)\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     */\n    public static String normalize(final String fileName) {\n        return doNormalize(fileName, SYSTEM_SEPARATOR, true);\n    }\n    /**\n     * Normalizes a path, removing double and single dot path steps.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be retained.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo/\n     * /foo/./              --&gt;   /foo/\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar/\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo/\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar/\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separator should be used.\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     * @since 2.0\n     */\n    public static String normalize(final String fileName, final boolean unixSeparator) {\n        final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(fileName, separator, true);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format of the system.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo\n     * /foo/./              --&gt;   /foo\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * (Note the file separator returned will be correct for Windows/Unix)\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     */\n    public static String normalizeNoEndSeparator(final String fileName) {\n        return doNormalize(fileName, SYSTEM_SEPARATOR, false);\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo\n     * /foo/./              --&gt;   /foo\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar\n     * ~/../bar             --&gt;   null\n     * </pre>\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separator should be used.\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     * @since 2.0\n     */\n    public static String normalizeNoEndSeparator(final String fileName, final boolean unixSeparator) {\n         final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(fileName, separator, false);\n    }\n\n    /**\n     * Internal method to perform the normalization.\n     *\n     * @param fileName  the fileName\n     * @param separator The separator character to use\n     * @param keepSeparator  true to keep the final separator\n     * @return the normalized fileName. Null bytes inside string will be removed.\n     */\n    private static String doNormalize(final String fileName, final char separator, final boolean keepSeparator) {\n        if (fileName == null) {\n            return null;\n        }\n\n        failIfNullBytePresent(fileName);\n\n        int size = fileName.length();\n        if (size == 0) {\n            return fileName;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n\n        final char[] array = new char[size + 2];  // +1 for possible extra slash, +2 for arraycopy\n        fileName.getChars(0, fileName.length(), array, 0);\n\n        // fix separators throughout\n        final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR;\n        for (int i = 0; i < array.length; i++) {\n            if (array[i] == otherSeparator) {\n                array[i] = separator;\n            }\n        }\n\n        // add extra separator on the end to simplify code below\n        boolean lastIsDirectory = true;\n        if (array[size - 1] != separator) {\n            array[size++] = separator;\n            lastIsDirectory = false;\n        }\n\n        // adjoining slashes\n        for (int i = prefix + 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == separator) {\n                System.arraycopy(array, i, array, i - 1, size - i);\n                size--;\n                i--;\n            }\n        }\n\n        // dot slash\n        for (int i = prefix + 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' &&\n                    (i == prefix + 1 || array[i - 2] == separator)) {\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                System.arraycopy(array, i + 1, array, i - 1, size - i);\n                size -=2;\n                i--;\n            }\n        }\n\n        // double dot slash\n        outer:\n        for (int i = prefix + 2; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' && array[i - 2] == '.' &&\n                    (i == prefix + 2 || array[i - 3] == separator)) {\n                if (i == prefix + 2) {\n                    return null;\n                }\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                int j;\n                for (j = i - 4 ; j >= prefix; j--) {\n                    if (array[j] == separator) {\n                        // remove b/../ from a/b/../c\n                        System.arraycopy(array, i + 1, array, j + 1, size - i);\n                        size -= i - j;\n                        i = j + 1;\n                        continue outer;\n                    }\n                }\n                // remove a/../ from a/../c\n                System.arraycopy(array, i + 1, array, prefix, size - i);\n                size -= i + 1 - prefix;\n                i = prefix + 1;\n            }\n        }\n\n        if (size <= 0) {  // should never be less than 0\n            return EMPTY_STRING;\n        }\n        if (size <= prefix) {  // should never be less than prefix\n            return new String(array, 0, size);\n        }\n        if (lastIsDirectory && keepSeparator) {\n            return new String(array, 0, size);  // keep trailing separator\n        }\n        return new String(array, 0, size - 1);  // lose trailing separator\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Concatenates a fileName to a base path using normal command line style rules.\n     * <p>\n     * The effect is equivalent to resultant directory after changing\n     * directory to the first argument, followed by changing directory to\n     * the second argument.\n     * <p>\n     * The first argument is the base path, the second is the path to concatenate.\n     * The returned path is always normalized via {@link #normalize(String)},\n     * thus <code>..</code> is handled.\n     * <p>\n     * If <code>pathToAdd</code> is absolute (has an absolute prefix), then\n     * it will be normalized and returned.\n     * Otherwise, the paths will be joined, normalized and returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo/ + bar          --&gt;   /foo/bar\n     * /foo + bar           --&gt;   /foo/bar\n     * /foo + /bar          --&gt;   /bar\n     * /foo + C:/bar        --&gt;   C:/bar\n     * /foo + C:bar         --&gt;   C:bar (*)\n     * /foo/a/ + ../bar     --&gt;   foo/bar\n     * /foo/ + ../../bar    --&gt;   null\n     * /foo/ + /bar         --&gt;   /bar\n     * /foo/.. + /bar       --&gt;   /bar\n     * /foo + bar/c.txt     --&gt;   /foo/bar/c.txt\n     * /foo/c.txt + bar     --&gt;   /foo/c.txt/bar (!)\n     * </pre>\n     * (*) Note that the Windows relative drive prefix is unreliable when\n     * used with this method.\n     * (!) Note that the first parameter must be a path. If it ends with a name, then\n     * the name will be built into the concatenated path. If this might be a problem,\n     * use {@link #getFullPath(String)} on the base path argument.\n     *\n     * @param basePath  the base path to attach to, always treated as a path\n     * @param fullFileNameToAdd  the fileName (or path) to attach to the base\n     * @return the concatenated path, or null if invalid.  Null bytes inside string will be removed\n     */\n    public static String concat(final String basePath, final String fullFileNameToAdd) {\n        final int prefix = getPrefixLength(fullFileNameToAdd);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix > 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        if (basePath == null) {\n            return null;\n        }\n        final int len = basePath.length();\n        if (len == 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        final char ch = basePath.charAt(len - 1);\n        if (isSeparator(ch)) {\n            return normalize(basePath + fullFileNameToAdd);\n        }\n        return normalize(basePath + '/' + fullFileNameToAdd);\n    }\n\n    /**\n     * Determines whether the {@code parent} directory contains the {@code child} element (a file or directory).\n     * <p>\n     * The files names are expected to be normalized.\n     * </p>\n     *\n     * Edge cases:\n     * <ul>\n     * <li>A {@code directory} must not be null: if null, throw IllegalArgumentException</li>\n     * <li>A directory does not contain itself: return false</li>\n     * <li>A null child file is not contained in any parent: return false</li>\n     * </ul>\n     *\n     * @param canonicalParent\n     *            the file to consider as the parent.\n     * @param canonicalChild\n     *            the file to consider as the child.\n     * @return true is the candidate leaf is under by the specified composite. False otherwise.\n     * @throws IOException\n     *             if an IO error occurs while checking the files.\n     * @since 2.2\n     * @see FileUtils#directoryContains(File, File)\n     */\n    public static boolean directoryContains(final String canonicalParent, final String canonicalChild)\n            throws IOException {\n\n        // Fail fast against NullPointerException\n        if (canonicalParent == null) {\n            throw new IllegalArgumentException(\"Directory must not be null\");\n        }\n\n        if (canonicalChild == null) {\n            return false;\n        }\n\n        if (IOCase.SYSTEM.checkEquals(canonicalParent, canonicalChild)) {\n            return false;\n        }\n\n        return IOCase.SYSTEM.checkStartsWith(canonicalChild, canonicalParent);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts all separators to the Unix separator of forward slash.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToUnix(final String path) {\n        if (path == null || path.indexOf(WINDOWS_SEPARATOR) == NOT_FOUND) {\n            return path;\n        }\n        return path.replace(WINDOWS_SEPARATOR, UNIX_SEPARATOR);\n    }\n\n    /**\n     * Converts all separators to the Windows separator of backslash.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToWindows(final String path) {\n        if (path == null || path.indexOf(UNIX_SEPARATOR) == NOT_FOUND) {\n            return path;\n        }\n        return path.replace(UNIX_SEPARATOR, WINDOWS_SEPARATOR);\n    }\n\n    /**\n     * Converts all separators to the system separator.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToSystem(final String path) {\n        if (path == null) {\n            return null;\n        }\n        return isSystemWindows() ? separatorsToWindows(path) : separatorsToUnix(path);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the length of the fileName prefix, such as <code>C:/</code> or <code>~/</code>.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * <p>\n     * The prefix length includes the first slash in the full fileName\n     * if applicable. Thus, it is possible that the length returned is greater\n     * than the length of the input string.\n     * <pre>\n     * Windows:\n     * a\\b\\c.txt           --&gt; \"\"          --&gt; relative\n     * \\a\\b\\c.txt          --&gt; \"\\\"         --&gt; current drive absolute\n     * C:a\\b\\c.txt         --&gt; \"C:\"        --&gt; drive relative\n     * C:\\a\\b\\c.txt        --&gt; \"C:\\\"       --&gt; absolute\n     * \\\\server\\a\\b\\c.txt  --&gt; \"\\\\server\\\" --&gt; UNC\n     * \\\\\\a\\b\\c.txt        --&gt;  error, length = -1\n     *\n     * Unix:\n     * a/b/c.txt           --&gt; \"\"          --&gt; relative\n     * /a/b/c.txt          --&gt; \"/\"         --&gt; absolute\n     * ~/a/b/c.txt         --&gt; \"~/\"        --&gt; current user\n     * ~                   --&gt; \"~/\"        --&gt; current user (slash added)\n     * ~user/a/b/c.txt     --&gt; \"~user/\"    --&gt; named user\n     * ~user               --&gt; \"~user/\"    --&gt; named user (slash added)\n     * //server/a/b/c.txt  --&gt; \"//server/\"\n     * ///a/b/c.txt        --&gt; error, length = -1\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * ie. both Unix and Windows prefixes are matched regardless.\n     *\n     * Note that a leading // (or \\\\) is used to indicate a UNC name on Windows.\n     * These must be followed by a server name, so double-slashes are not collapsed\n     * to a single slash at the start of the fileName.\n     *\n     * @param fileName  the fileName to find the prefix in, null returns -1\n     * @return the length of the prefix, -1 if invalid or null\n     */\n    public static int getPrefixLength(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int len = fileName.length();\n        if (len == 0) {\n            return 0;\n        }\n        char ch0 = fileName.charAt(0);\n        if (ch0 == ':') {\n            return NOT_FOUND;\n        }\n        if (len == 1) {\n            if (ch0 == '~') {\n                return 2;  // return a length greater than the input\n            }\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        if (ch0 == '~') {\n            int posUnix = fileName.indexOf(UNIX_SEPARATOR, 1);\n            int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 1);\n            if (posUnix == NOT_FOUND && posWin == NOT_FOUND) {\n                return len + 1;  // return a length greater than the input\n            }\n            posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n            posWin = posWin == NOT_FOUND ? posUnix : posWin;\n            return Math.min(posUnix, posWin) + 1;\n        }\n        final char ch1 = fileName.charAt(1);\n        if (ch1 == ':') {\n            ch0 = Character.toUpperCase(ch0);\n            if (ch0 >= 'A' && ch0 <= 'Z') {\n                if (len == 2 || isSeparator(fileName.charAt(2)) == false) {\n                    return 2;\n                }\n                return 3;\n            } else if (ch0 == UNIX_SEPARATOR) {\n                return 1;\n            }\n            return NOT_FOUND;\n\n        } else if (isSeparator(ch0) && isSeparator(ch1)) {\n            int posUnix = fileName.indexOf(UNIX_SEPARATOR, 2);\n            int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 2);\n            if (posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2) {\n                return NOT_FOUND;\n            }\n            posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n            posWin = posWin == NOT_FOUND ? posUnix : posWin;\n            int pos = Math.min(posUnix, posWin) + 1;\n            String hostnamePart = fileName.substring(2, pos - 1);\n            return isValidHostName(hostnamePart) ? pos : NOT_FOUND;\n        } else {\n            return isSeparator(ch0) ? 1 : 0;\n        }\n    }\n\n    /**\n     * Returns the index of the last directory separator character.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The position of the last forward or backslash is returned.\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to find the last path separator in, null returns -1\n     * @return the index of the last separator character, or -1 if there\n     * is no such character\n     */\n    public static int indexOfLastSeparator(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int lastUnixPos = fileName.lastIndexOf(UNIX_SEPARATOR);\n        final int lastWindowsPos = fileName.lastIndexOf(WINDOWS_SEPARATOR);\n        return Math.max(lastUnixPos, lastWindowsPos);\n    }\n\n    /**\n     * Returns the index of the last extension separator character, which is a dot.\n     * <p>\n     * This method also checks that there is no directory separator after the last dot. To do this it uses\n     * {@link #indexOfLastSeparator(String)} which will handle a file in either Unix or Windows format.\n     * </p>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on, with the\n     * exception of a possible {@link IllegalArgumentException} on Windows (see below).\n     * </p>\n     * <b>Note:</b> This method used to have a hidden problem for names like \"foo.exe:bar.txt\".\n     * In this case, the name wouldn't be the name of a file, but the identifier of an\n     * alternate data stream (bar.txt) on the file foo.exe. The method used to return\n     * \".txt\" here, which would be misleading. Commons IO 2.7, and later versions, are throwing\n     * an {@link IllegalArgumentException} for names like this.\n     *\n     * @param fileName\n     *            the fileName to find the last extension separator in, null returns -1\n     * @return the index of the last extension separator character, or -1 if there is no such character\n     * @throws IllegalArgumentException <b>Windows only:</b> The fileName parameter is, in fact,\n     * the identifier of an Alternate Data Stream, for example \"foo.exe:bar.txt\".\n     */\n    public static int indexOfExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        if (isSystemWindows()) {\n            // Special handling for NTFS ADS: Don't accept colon in the fileName.\n            final int offset = fileName.indexOf(':', getAdsCriticalOffset(fileName));\n            if (offset != -1) {\n                throw new IllegalArgumentException(\"NTFS ADS separator (':') in file name is forbidden.\");\n            }\n        }\n        final int extensionPos = fileName.lastIndexOf(EXTENSION_SEPARATOR);\n        final int lastSeparator = indexOfLastSeparator(fileName);\n        return lastSeparator > extensionPos ? NOT_FOUND : extensionPos;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the prefix from a full fileName, such as <code>C:/</code>\n     * or <code>~/</code>.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The prefix includes the first slash in the full fileName where applicable.\n     * <pre>\n     * Windows:\n     * a\\b\\c.txt           --&gt; \"\"          --&gt; relative\n     * \\a\\b\\c.txt          --&gt; \"\\\"         --&gt; current drive absolute\n     * C:a\\b\\c.txt         --&gt; \"C:\"        --&gt; drive relative\n     * C:\\a\\b\\c.txt        --&gt; \"C:\\\"       --&gt; absolute\n     * \\\\server\\a\\b\\c.txt  --&gt; \"\\\\server\\\" --&gt; UNC\n     *\n     * Unix:\n     * a/b/c.txt           --&gt; \"\"          --&gt; relative\n     * /a/b/c.txt          --&gt; \"/\"         --&gt; absolute\n     * ~/a/b/c.txt         --&gt; \"~/\"        --&gt; current user\n     * ~                   --&gt; \"~/\"        --&gt; current user (slash added)\n     * ~user/a/b/c.txt     --&gt; \"~user/\"    --&gt; named user\n     * ~user               --&gt; \"~user/\"    --&gt; named user (slash added)\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * ie. both Unix and Windows prefixes are matched regardless.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the prefix of the file, null if invalid. Null bytes inside string will be removed\n     */\n    public static String getPrefix(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        final int len = getPrefixLength(fileName);\n        if (len < 0) {\n            return null;\n        }\n        if (len > fileName.length()) {\n            failIfNullBytePresent(fileName + UNIX_SEPARATOR);\n            return fileName + UNIX_SEPARATOR;\n        }\n        final String path = fileName.substring(0, len);\n        failIfNullBytePresent(path);\n        return path;\n    }\n\n    /**\n     * Gets the path from a full fileName, which excludes the prefix.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before and\n     * including the last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; a\\b\\\n     * ~/a/b/c.txt  --&gt; a/b/\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b/\n     * a/b/c/       --&gt; a/b/c/\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * <p>\n     * This method drops the prefix from the result.\n     * See {@link #getFullPath(String)} for the method that retains the prefix.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid.\n     * Null bytes inside string will be removed\n     */\n    public static String getPath(final String fileName) {\n        return doGetPath(fileName, 1);\n    }\n\n    /**\n     * Gets the path from a full fileName, which excludes the prefix, and\n     * also excluding the final directory separator.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before the\n     * last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; a\\b\n     * ~/a/b/c.txt  --&gt; a/b\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b\n     * a/b/c/       --&gt; a/b/c\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * <p>\n     * This method drops the prefix from the result.\n     * See {@link #getFullPathNoEndSeparator(String)} for the method that retains the prefix.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid.\n     * Null bytes inside string will be removed\n     */\n    public static String getPathNoEndSeparator(final String fileName) {\n        return doGetPath(fileName, 0);\n    }\n\n    /**\n     * Does the work of getting the path.\n     *\n     * @param fileName  the fileName\n     * @param separatorAdd  0 to omit the end separator, 1 to return it\n     * @return the path. Null bytes inside string will be removed\n     */\n    private static String doGetPath(final String fileName, final int separatorAdd) {\n        if (fileName == null) {\n            return null;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n        final int index = indexOfLastSeparator(fileName);\n        final int endIndex = index+separatorAdd;\n        if (prefix >= fileName.length() || index < 0 || prefix >= endIndex) {\n            return EMPTY_STRING;\n        }\n        final String path = fileName.substring(prefix, endIndex);\n        failIfNullBytePresent(path);\n        return path;\n    }\n\n    /**\n     * Gets the full path from a full fileName, which is the prefix + path.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before and\n     * including the last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; C:\\a\\b\\\n     * ~/a/b/c.txt  --&gt; ~/a/b/\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b/\n     * a/b/c/       --&gt; a/b/c/\n     * C:           --&gt; C:\n     * C:\\          --&gt; C:\\\n     * ~            --&gt; ~/\n     * ~/           --&gt; ~/\n     * ~user        --&gt; ~user/\n     * ~user/       --&gt; ~user/\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getFullPath(final String fileName) {\n        return doGetFullPath(fileName, true);\n    }\n\n    /**\n     * Gets the full path from a full fileName, which is the prefix + path,\n     * and also excluding the final directory separator.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before the\n     * last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; C:\\a\\b\n     * ~/a/b/c.txt  --&gt; ~/a/b\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b\n     * a/b/c/       --&gt; a/b/c\n     * C:           --&gt; C:\n     * C:\\          --&gt; C:\\\n     * ~            --&gt; ~\n     * ~/           --&gt; ~\n     * ~user        --&gt; ~user\n     * ~user/       --&gt; ~user\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getFullPathNoEndSeparator(final String fileName) {\n        return doGetFullPath(fileName, false);\n    }\n\n    /**\n     * Does the work of getting the path.\n     *\n     * @param fileName  the fileName\n     * @param includeSeparator  true to include the end separator\n     * @return the path\n     */\n    private static String doGetFullPath(final String fileName, final boolean includeSeparator) {\n        if (fileName == null) {\n            return null;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix >= fileName.length()) {\n            if (includeSeparator) {\n                return getPrefix(fileName);  // add end slash if necessary\n            }\n            return fileName;\n        }\n        final int index = indexOfLastSeparator(fileName);\n        if (index < 0) {\n            return fileName.substring(0, prefix);\n        }\n        int end = index + (includeSeparator ?  1 : 0);\n        if (end == 0) {\n            end++;\n        }\n        return fileName.substring(0, end);\n    }\n\n    /**\n     * Gets the name minus the path from a full fileName.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The text after the last forward or backslash is returned.\n     * <pre>\n     * a/b/c.txt --&gt; c.txt\n     * a.txt     --&gt; a.txt\n     * a/b/c     --&gt; c\n     * a/b/c/    --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the name of the file without the path, or an empty string if none exists.\n     * Null bytes inside string will be removed\n     */\n    public static String getName(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        failIfNullBytePresent(fileName);\n        final int index = indexOfLastSeparator(fileName);\n        return fileName.substring(index + 1);\n    }\n\n    /**\n     * Check the input for null bytes, a sign of unsanitized data being passed to to file level functions.\n     *\n     * This may be used for poison byte attacks.\n     * @param path the path to check\n     */\n    private static void failIfNullBytePresent(final String path) {\n        final int len = path.length();\n        for (int i = 0; i < len; i++) {\n            if (path.charAt(i) == 0) {\n                throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" +\n                        \"known legitimate use cases for such data, but several injection attacks may use it\");\n            }\n        }\n    }\n\n    /**\n     * Gets the base name, minus the full path and extension, from a full fileName.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The text after the last forward or backslash and before the last dot is returned.\n     * <pre>\n     * a/b/c.txt --&gt; c\n     * a.txt     --&gt; a\n     * a/b/c     --&gt; c\n     * a/b/c/    --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the name of the file without the path, or an empty string if none exists. Null bytes inside string\n     * will be removed\n     */\n    public static String getBaseName(final String fileName) {\n        return removeExtension(getName(fileName));\n    }\n\n    /**\n     * Gets the extension of a fileName.\n     * <p>\n     * This method returns the textual part of the fileName after the last dot.\n     * There must be no directory separator after the dot.\n     * <pre>\n     * foo.txt      --&gt; \"txt\"\n     * a/b/c.jpg    --&gt; \"jpg\"\n     * a/b.txt/c    --&gt; \"\"\n     * a/b/c        --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on, with the\n     * exception of a possible {@link IllegalArgumentException} on Windows (see below).\n     * </p>\n     * <p>\n     * <b>Note:</b> This method used to have a hidden problem for names like \"foo.exe:bar.txt\".\n     * In this case, the name wouldn't be the name of a file, but the identifier of an\n     * alternate data stream (bar.txt) on the file foo.exe. The method used to return\n     * \".txt\" here, which would be misleading. Commons IO 2.7, and later versions, are throwing\n     * an {@link IllegalArgumentException} for names like this.\n     *\n     * @param fileName the fileName to retrieve the extension of.\n     * @return the extension of the file or an empty string if none exists or {@code null}\n     * if the fileName is {@code null}.\n     * @throws IllegalArgumentException <b>Windows only:</b> The fileName parameter is, in fact,\n     * the identifier of an Alternate Data Stream, for example \"foo.exe:bar.txt\".\n     */\n    public static String getExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName == null) {\n            return null;\n        }\n        final int index = indexOfExtension(fileName);\n        if (index == NOT_FOUND) {\n            return EMPTY_STRING;\n        }\n        return fileName.substring(index + 1);\n    }\n\n    /**\n     * Special handling for NTFS ADS: Don't accept colon in the fileName.\n     * \n     * @param fileName a file name\n     * @return ADS offsets.\n     */\n    private static int getAdsCriticalOffset(String fileName) {\n        // Step 1: Remove leading path segments.\n        int offset1 = fileName.lastIndexOf(SYSTEM_SEPARATOR);\n        int offset2 = fileName.lastIndexOf(OTHER_SEPARATOR);\n        if (offset1 == -1) {\n            if (offset2 == -1) {\n                return 0;\n            }\n            return offset2 + 1;\n        }\n        if (offset2 == -1) {\n            return offset1 + 1;\n        }\n        return Math.max(offset1, offset2) + 1;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Removes the extension from a fileName.\n     * <p>\n     * This method returns the textual part of the fileName before the last dot.\n     * There must be no directory separator after the dot.\n     * <pre>\n     * foo.txt    --&gt; foo\n     * a\\b\\c.jpg  --&gt; a\\b\\c\n     * a\\b\\c      --&gt; a\\b\\c\n     * a.b\\c      --&gt; a.b\\c\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the fileName minus the extension\n     */\n    public static String removeExtension(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        failIfNullBytePresent(fileName);\n\n        final int index = indexOfExtension(fileName);\n        if (index == NOT_FOUND) {\n            return fileName;\n        }\n        return fileName.substring(0, index);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks whether two fileNames are equal exactly.\n     * <p>\n     * No processing is performed on the fileNames other than comparison,\n     * thus this is merely a null-safe case-sensitive equals.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean equals(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks whether two fileNames are equal using the case rules of the system.\n     * <p>\n     * No processing is performed on the fileNames other than comparison.\n     * The check is case-sensitive on Unix and case-insensitive on Windows.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SYSTEM\n     */\n    public static boolean equalsOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SYSTEM);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks whether two fileNames are equal after both have been normalized.\n     * <p>\n     * Both fileNames are first passed to {@link #normalize(String)}.\n     * The check is then performed in a case-sensitive manner.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean equalsNormalized(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks whether two fileNames are equal after both have been normalized\n     * and using the case rules of the system.\n     * <p>\n     * Both fileNames are first passed to {@link #normalize(String)}.\n     * The check is then performed case-sensitive on Unix and\n     * case-insensitive on Windows.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SYSTEM\n     */\n    public static boolean equalsNormalizedOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SYSTEM);\n    }\n\n    /**\n     * Checks whether two fileNames are equal, optionally normalizing and providing\n     * control over the case-sensitivity.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @param normalized  whether to normalize the fileNames\n     * @param caseSensitivity  what case sensitivity rule to use, null means case-sensitive\n     * @return true if the fileNames are equal, null equals null\n     * @since 1.3\n     */\n    public static boolean equals(\n            String fileName1, String fileName2,\n            final boolean normalized, IOCase caseSensitivity) {\n\n        if (fileName1 == null || fileName2 == null) {\n            return fileName1 == null && fileName2 == null;\n        }\n        if (normalized) {\n            fileName1 = normalize(fileName1);\n            fileName2 = normalize(fileName2);\n            if (fileName1 == null || fileName2 == null) {\n                throw new NullPointerException(\n                    \"Error normalizing one or both of the file names\");\n            }\n        }\n        if (caseSensitivity == null) {\n            caseSensitivity = IOCase.SENSITIVE;\n        }\n        return caseSensitivity.checkEquals(fileName1, fileName2);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks whether the extension of the fileName is that specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extension  the extension to check for, null or empty checks for no extension\n     * @return true if the fileName has the specified extension\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final String extension) {\n        if (fileName == null) {\n            return false;\n        }\n        failIfNullBytePresent(fileName);\n\n        if (extension == null || extension.isEmpty()) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        return fileExt.equals(extension);\n    }\n\n    /**\n     * Checks whether the extension of the fileName is one of those specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extensions  the extensions to check for, null checks for no extension\n     * @return true if the fileName is one of the extensions\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final String[] extensions) {\n        if (fileName == null) {\n            return false;\n        }\n        failIfNullBytePresent(fileName);\n\n        if (extensions == null || extensions.length == 0) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        for (final String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the extension of the fileName is one of those specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extensions  the extensions to check for, null checks for no extension\n     * @return true if the fileName is one of the extensions\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final Collection<String> extensions) {\n        if (fileName == null) {\n            return false;\n        }\n        failIfNullBytePresent(fileName);\n\n        if (extensions == null || extensions.isEmpty()) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        for (final String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher,\n     * always testing case-sensitive.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * This is the same as often found on Dos/Unix command lines.\n     * The check is case-sensitive always.\n     * <pre>\n     * wildcardMatch(\"c.txt\", \"*.txt\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.jpg\")      --&gt; false\n     * wildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.???\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.????\")     --&gt; false\n     * </pre>\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @return true if the fileName matches the wildcard string\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean wildcardMatch(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher\n     * using the case rules of the system.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * This is the same as often found on Dos/Unix command lines.\n     * The check is case-sensitive on Unix and case-insensitive on Windows.\n     * <pre>\n     * wildcardMatch(\"c.txt\", \"*.txt\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.jpg\")      --&gt; false\n     * wildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.???\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.????\")     --&gt; false\n     * </pre>\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @return true if the fileName matches the wildcard string\n     * @see IOCase#SYSTEM\n     */\n    public static boolean wildcardMatchOnSystem(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SYSTEM);\n    }\n\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher\n     * allowing control over case-sensitivity.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @param caseSensitivity  what case sensitivity rule to use, null means case-sensitive\n     * @return true if the fileName matches the wildcard string\n     * @since 1.3\n     */\n    public static boolean wildcardMatch(final String fileName, final String wildcardMatcher, IOCase caseSensitivity) {\n        if (fileName == null && wildcardMatcher == null) {\n            return true;\n        }\n        if (fileName == null || wildcardMatcher == null) {\n            return false;\n        }\n        if (caseSensitivity == null) {\n            caseSensitivity = IOCase.SENSITIVE;\n        }\n        final String[] wcs = splitOnTokens(wildcardMatcher);\n        boolean anyChars = false;\n        int textIdx = 0;\n        int wcsIdx = 0;\n        final Stack<int[]> backtrack = new Stack<>();\n\n        // loop around a backtrack stack, to handle complex * matching\n        do {\n            if (backtrack.size() > 0) {\n                final int[] array = backtrack.pop();\n                wcsIdx = array[0];\n                textIdx = array[1];\n                anyChars = true;\n            }\n\n            // loop whilst tokens and text left to process\n            while (wcsIdx < wcs.length) {\n\n                if (wcs[wcsIdx].equals(\"?\")) {\n                    // ? so move to next text char\n                    textIdx++;\n                    if (textIdx > fileName.length()) {\n                        break;\n                    }\n                    anyChars = false;\n\n                } else if (wcs[wcsIdx].equals(\"*\")) {\n                    // set any chars status\n                    anyChars = true;\n                    if (wcsIdx == wcs.length - 1) {\n                        textIdx = fileName.length();\n                    }\n\n                } else {\n                    // matching text token\n                    if (anyChars) {\n                        // any chars then try to locate text token\n                        textIdx = caseSensitivity.checkIndexOf(fileName, textIdx, wcs[wcsIdx]);\n                        if (textIdx == NOT_FOUND) {\n                            // token not found\n                            break;\n                        }\n                        final int repeat = caseSensitivity.checkIndexOf(fileName, textIdx + 1, wcs[wcsIdx]);\n                        if (repeat >= 0) {\n                            backtrack.push(new int[] {wcsIdx, repeat});\n                        }\n                    } else {\n                        // matching from current position\n                        if (!caseSensitivity.checkRegionMatches(fileName, textIdx, wcs[wcsIdx])) {\n                            // couldnt match token\n                            break;\n                        }\n                    }\n\n                    // matched text token, move text index to end of matched token\n                    textIdx += wcs[wcsIdx].length();\n                    anyChars = false;\n                }\n\n                wcsIdx++;\n            }\n\n            // full match\n            if (wcsIdx == wcs.length && textIdx == fileName.length()) {\n                return true;\n            }\n\n        } while (backtrack.size() > 0);\n\n        return false;\n    }\n\n    /**\n     * Splits a string into a number of tokens.\n     * The text is split by '?' and '*'.\n     * Where multiple '*' occur consecutively they are collapsed into a single '*'.\n     *\n     * @param text  the text to split\n     * @return the array of tokens, never null\n     */\n    static String[] splitOnTokens(final String text) {\n        // used by wildcardMatch\n        // package level so a unit test may run on this\n\n        if (text.indexOf('?') == NOT_FOUND && text.indexOf('*') == NOT_FOUND) {\n            return new String[] { text };\n        }\n\n        final char[] array = text.toCharArray();\n        final ArrayList<String> list = new ArrayList<>();\n        final StringBuilder buffer = new StringBuilder();\n        char prevChar = 0;\n        for (final char ch : array) {\n            if (ch == '?' || ch == '*') {\n                if (buffer.length() != 0) {\n                    list.add(buffer.toString());\n                    buffer.setLength(0);\n                }\n                if (ch == '?') {\n                    list.add(\"?\");\n                } else if (prevChar != '*') {// ch == '*' here; check if previous char was '*'\n                    list.add(\"*\");\n                }\n            } else {\n                buffer.append(ch);\n            }\n            prevChar = ch;\n        }\n        if (buffer.length() != 0) {\n            list.add(buffer.toString());\n        }\n\n        return list.toArray( new String[ list.size() ] );\n    }\n\n    /**\n     * Checks whether a given string is a valid host name according to\n     * RFC 3986.\n     *\n     * <p>Accepted are IP addresses (v4 and v6) as well as what the\n     * RFC calls a \"reg-name\". Percent encoded names don't seem to be\n     * valid names in UNC paths.</p>\n     *\n     * @see \"https://tools.ietf.org/html/rfc3986#section-3.2.2\"\n     * @param name the hostname to validate\n     * @return true if the given name is a valid host name\n     */\n    private static boolean isValidHostName(String name) {\n        return isIPv4Address(name) || isIPv6Address(name) || isRFC3986HostName(name);\n    }\n\n    private static final Pattern IPV4_PATTERN =\n        Pattern.compile(\"^(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})$\");\n    private static final int IPV4_MAX_OCTET_VALUE = 255;\n\n    // mostly copied from org.apache.commons.validator.routines.InetAddressValidator#isValidInet4Address\n    private static boolean isIPv4Address(String name) {\n        Matcher m = IPV4_PATTERN.matcher(name);\n        if (!m.matches() || m.groupCount() != 4) {\n            return false;\n        }\n\n        // verify that address subgroups are legal\n        for (int i = 1; i < 5; i++) {\n            String ipSegment = m.group(i);\n            if (ipSegment == null || ipSegment.length() == 0) {\n                return false;\n            }\n\n            int iIpSegment = 0;\n\n            try {\n                iIpSegment = Integer.parseInt(ipSegment);\n            } catch(NumberFormatException e) {\n                return false;\n            }\n\n            if (iIpSegment > IPV4_MAX_OCTET_VALUE) {\n                return false;\n            }\n\n            if (ipSegment.length() > 1 && ipSegment.startsWith(\"0\")) {\n                return false;\n            }\n\n        }\n\n        return true;\n    }\n\n    private static final int IPV6_MAX_HEX_GROUPS = 8;\n    private static final int IPV6_MAX_HEX_DIGITS_PER_GROUP = 4;\n    private static final int MAX_UNSIGNED_SHORT = 0xffff;\n    private static final int BASE_16 = 16;\n\n    // copied from org.apache.commons.validator.routines.InetAddressValidator#isValidInet6Address\n    private static boolean isIPv6Address(String inet6Address) {\n        boolean containsCompressedZeroes = inet6Address.contains(\"::\");\n        if (containsCompressedZeroes && (inet6Address.indexOf(\"::\") != inet6Address.lastIndexOf(\"::\"))) {\n            return false;\n        }\n        if ((inet6Address.startsWith(\":\") && !inet6Address.startsWith(\"::\"))\n                || (inet6Address.endsWith(\":\") && !inet6Address.endsWith(\"::\"))) {\n            return false;\n        }\n        String[] octets = inet6Address.split(\":\");\n        if (containsCompressedZeroes) {\n            List<String> octetList = new ArrayList<String>(Arrays.asList(octets));\n            if (inet6Address.endsWith(\"::\")) {\n                // String.split() drops ending empty segments\n                octetList.add(\"\");\n            } else if (inet6Address.startsWith(\"::\") && !octetList.isEmpty()) {\n                octetList.remove(0);\n            }\n            octets = octetList.toArray(new String[octetList.size()]);\n        }\n        if (octets.length > IPV6_MAX_HEX_GROUPS) {\n            return false;\n        }\n        int validOctets = 0;\n        int emptyOctets = 0; // consecutive empty chunks\n        for (int index = 0; index < octets.length; index++) {\n            String octet = octets[index];\n            if (octet.length() == 0) {\n                emptyOctets++;\n                if (emptyOctets > 1) {\n                    return false;\n                }\n            } else {\n                emptyOctets = 0;\n                // Is last chunk an IPv4 address?\n                if (index == octets.length - 1 && octet.contains(\".\")) {\n                    if (!isIPv4Address(octet)) {\n                        return false;\n                    }\n                    validOctets += 2;\n                    continue;\n                }\n                if (octet.length() > IPV6_MAX_HEX_DIGITS_PER_GROUP) {\n                    return false;\n                }\n                int octetInt = 0;\n                try {\n                    octetInt = Integer.parseInt(octet, BASE_16);\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n                if (octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT) {\n                    return false;\n                }\n            }\n            validOctets++;\n        }\n        if (validOctets > IPV6_MAX_HEX_GROUPS || (validOctets < IPV6_MAX_HEX_GROUPS && !containsCompressedZeroes)) {\n            return false;\n        }\n        return true;\n    }\n\n    private static final Pattern REG_NAME_PART_PATTERN = Pattern.compile(\"^[a-zA-Z0-9][a-zA-Z0-9-]*$\");\n\n    private static boolean isRFC3986HostName(String name) {\n        String[] parts = name.split(\"\\\\.\", -1);\n        for (int i = 0; i < parts.length; i++) {\n            if (parts[i].length() == 0) {\n                // trailing dot is legal, otherwise we've hit a .. sequence\n                return i == parts.length - 1;\n            }\n            if (!REG_NAME_PART_PATTERN.matcher(parts[i]).matches()) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-15": {
    "vul_id": "VUL4J-15",
    "cve_id": "CVE-2016-8739",
    "project": "apache_cxf",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn -pl rt/rs/extensions/providers -Dtest=org.apache.cxf.jaxrs.provider.atom.AtomPojoProviderTest test",
    "test_all_cmd": "mvn -pl rt/rs/extensions/providers",
    "human_patch_url": "https://github.com/apache/cxf/commit/d9e2a6e7",
    "vulnerable_files": [
      {
        "file_path": "rt/rs/extensions/providers/src/main/java/org/apache/cxf/jaxrs/provider/atom/AbstractAtomProvider.java",
        "file_name": "AbstractAtomProvider.java",
        "vulnerable_code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.cxf.jaxrs.provider.atom;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Type;\nimport java.util.logging.Logger;\n\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core.MultivaluedMap;\nimport javax.ws.rs.ext.MessageBodyReader;\nimport javax.ws.rs.ext.MessageBodyWriter;\n\nimport org.apache.abdera.Abdera;\nimport org.apache.abdera.model.Document;\nimport org.apache.abdera.model.Element;\nimport org.apache.abdera.parser.Parser;\nimport org.apache.abdera.parser.ParserOptions;\nimport org.apache.abdera.writer.Writer;\nimport org.apache.cxf.common.logging.LogUtils;\nimport org.apache.cxf.jaxrs.utils.ExceptionUtils;\n\npublic abstract class AbstractAtomProvider<T extends Element> \n    implements MessageBodyWriter<T>, MessageBodyReader<T> {\n\n    private static final Logger LOG = LogUtils.getL7dLogger(AbstractAtomProvider.class);\n    private static final Abdera ATOM_ENGINE = new Abdera();\n    private boolean autodetectCharset;\n    private boolean formattedOutput;\n    \n    public long getSize(T element, Class<?> type, Type genericType, Annotation[] annotations, MediaType mt) {\n        return -1;\n    }\n\n    public void writeTo(T element, Class<?> clazz, Type type, Annotation[] a, \n                        MediaType mt, MultivaluedMap<String, Object> headers, OutputStream os) \n        throws IOException {\n        if (MediaType.APPLICATION_JSON_TYPE.isCompatible(mt)) {\n            Writer w = createWriter(\"json\");\n            if (w == null) {\n                throw ExceptionUtils.toNotSupportedException(null, null);\n            }\n            element.writeTo(w, os);   \n        } else if (formattedOutput) {\n            Writer w = createWriter(\"prettyxml\");\n            if (w != null) {\n                element.writeTo(w, os);\n            } else {\n                element.writeTo(os);\n            }\n        } else {\n            element.writeTo(os);\n        }\n    }\n\n    protected Writer createWriter(String writerName) {\n        Writer w = ATOM_ENGINE.getWriterFactory().getWriter(writerName);\n        if (w == null) {\n            LOG.fine(\"Atom writer \\\"\" + writerName + \"\\\" is not available\");\n        }\n        return w;\n    }\n    \n    public T readFrom(Class<T> clazz, Type t, Annotation[] a, MediaType mt, \n                         MultivaluedMap<String, String> headers, InputStream is) \n        throws IOException {\n        Parser parser = ATOM_ENGINE.getParser();\n        synchronized (parser) {\n            ParserOptions options = parser.getDefaultParserOptions();\n            if (options != null) {\n                options.setAutodetectCharset(autodetectCharset);\n                options.setResolveEntities(false);\n            }\n        }\n        Document<T> doc = parser.parse(is);\n        return doc.getRoot();\n    }\n\n    public void setFormattedOutput(boolean formattedOutput) {\n        this.formattedOutput = formattedOutput;\n    }\n\n    public void setAutodetectCharset(boolean autodetectCharset) {\n        this.autodetectCharset = autodetectCharset;\n    }\n}\n",
        "human_patch_code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.cxf.jaxrs.provider.atom;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Type;\nimport java.util.logging.Logger;\n\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core.MultivaluedMap;\nimport javax.ws.rs.ext.MessageBodyReader;\nimport javax.ws.rs.ext.MessageBodyWriter;\nimport javax.xml.stream.XMLStreamReader;\n\nimport org.apache.abdera.Abdera;\nimport org.apache.abdera.model.Document;\nimport org.apache.abdera.model.Element;\nimport org.apache.abdera.parser.Parser;\nimport org.apache.abdera.parser.ParserOptions;\nimport org.apache.abdera.writer.Writer;\nimport org.apache.cxf.common.logging.LogUtils;\nimport org.apache.cxf.jaxrs.utils.ExceptionUtils;\nimport org.apache.cxf.staxutils.StaxUtils;\n\npublic abstract class AbstractAtomProvider<T extends Element> \n    implements MessageBodyWriter<T>, MessageBodyReader<T> {\n\n    private static final Logger LOG = LogUtils.getL7dLogger(AbstractAtomProvider.class);\n    private static final Abdera ATOM_ENGINE = new Abdera();\n    private boolean autodetectCharset;\n    private boolean formattedOutput;\n    \n    public long getSize(T element, Class<?> type, Type genericType, Annotation[] annotations, MediaType mt) {\n        return -1;\n    }\n\n    public void writeTo(T element, Class<?> clazz, Type type, Annotation[] a, \n                        MediaType mt, MultivaluedMap<String, Object> headers, OutputStream os) \n        throws IOException {\n        if (MediaType.APPLICATION_JSON_TYPE.isCompatible(mt)) {\n            Writer w = createWriter(\"json\");\n            if (w == null) {\n                throw ExceptionUtils.toNotSupportedException(null, null);\n            }\n            element.writeTo(w, os);   \n        } else if (formattedOutput) {\n            Writer w = createWriter(\"prettyxml\");\n            if (w != null) {\n                element.writeTo(w, os);\n            } else {\n                element.writeTo(os);\n            }\n        } else {\n            element.writeTo(os);\n        }\n    }\n\n    protected Writer createWriter(String writerName) {\n        Writer w = ATOM_ENGINE.getWriterFactory().getWriter(writerName);\n        if (w == null) {\n            LOG.fine(\"Atom writer \\\"\" + writerName + \"\\\" is not available\");\n        }\n        return w;\n    }\n    \n    public T readFrom(Class<T> clazz, Type t, Annotation[] a, MediaType mt, \n                         MultivaluedMap<String, String> headers, InputStream is) \n        throws IOException {\n        Parser parser = ATOM_ENGINE.getParser();\n        synchronized (parser) {\n            ParserOptions options = parser.getDefaultParserOptions();\n            if (options != null) {\n                options.setAutodetectCharset(autodetectCharset);\n            }\n        }\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(is);\n        Document<T> doc = parser.parse(reader);\n        return doc.getRoot();\n    }\n\n    public void setFormattedOutput(boolean formattedOutput) {\n        this.formattedOutput = formattedOutput;\n    }\n\n    public void setAutodetectCharset(boolean autodetectCharset) {\n        this.autodetectCharset = autodetectCharset;\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-16": {
    "vul_id": "VUL4J-16",
    "cve_id": "CVE-2015-5253",
    "project": "apache_cxf",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn -pl rt/rs/security/sso/saml -Dtest=org.apache.cxf.rs.security.saml.sso.CombinedValidatorTest#testWrappingAttack3 test",
    "test_all_cmd": "mvn -pl rt/rs/security/sso/saml",
    "human_patch_url": "https://github.com/apache/cxf/commit/845eccb6484b43ba02875c71e824db23ae4f20c0",
    "vulnerable_files": [
      {
        "file_path": "rt/rs/security/sso/saml/src/main/java/org/apache/cxf/rs/security/saml/sso/SAMLSSOResponseValidator.java",
        "file_name": "SAMLSSOResponseValidator.java",
        "vulnerable_code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.cxf.rs.security.saml.sso;\n\nimport java.util.Date;\nimport java.util.List;\nimport java.util.logging.Logger;\n\nimport org.w3c.dom.Element;\n\nimport org.apache.cxf.common.logging.LogUtils;\nimport org.apache.wss4j.common.ext.WSSecurityException;\nimport org.apache.wss4j.common.saml.builder.SAML2Constants;\nimport org.apache.wss4j.common.util.DOM2Writer;\nimport org.opensaml.saml.saml2.core.AudienceRestriction;\nimport org.opensaml.saml.saml2.core.AuthnStatement;\n\n/**\n * Validate a SAML 2.0 Protocol Response according to the Web SSO profile. The Response\n * should be validated by the SAMLProtocolResponseValidator first.\n */\npublic class SAMLSSOResponseValidator {\n    \n    private static final Logger LOG = LogUtils.getL7dLogger(SAMLSSOResponseValidator.class);\n    \n    private String issuerIDP;\n    private String assertionConsumerURL;\n    private String clientAddress;\n    private String requestId;\n    private String spIdentifier;\n    private boolean enforceAssertionsSigned = true;\n    private boolean enforceKnownIssuer = true;\n    private TokenReplayCache<String> replayCache;\n    \n    /**\n     * Enforce that Assertions must be signed if the POST binding was used. The default is true.\n     */\n    public void setEnforceAssertionsSigned(boolean enforceAssertionsSigned) {\n        this.enforceAssertionsSigned = enforceAssertionsSigned;\n    }\n    \n    /**\n     * Enforce that the Issuer of the received Response/Assertion is known. The default is true.\n     */\n    public void setEnforceKnownIssuer(boolean enforceKnownIssuer) {\n        this.enforceKnownIssuer = enforceKnownIssuer;\n    }\n    \n    /**\n     * Validate a SAML 2 Protocol Response\n     * @param samlResponse\n     * @param postBinding\n     * @return a SSOValidatorResponse object\n     * @throws WSSecurityException\n     */\n    public SSOValidatorResponse validateSamlResponse(\n        org.opensaml.saml.saml2.core.Response samlResponse,\n        boolean postBinding\n    ) throws WSSecurityException {\n        // Check the Issuer\n        validateIssuer(samlResponse.getIssuer());\n\n        // The Response must contain at least one Assertion.\n        if (samlResponse.getAssertions() == null || samlResponse.getAssertions().isEmpty()) {\n            LOG.fine(\"The Response must contain at least one Assertion\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // The Response must contain a Destination that matches the assertionConsumerURL if it is\n        // signed\n        String destination = samlResponse.getDestination();\n        if (samlResponse.isSigned()\n            && (destination == null || !destination.equals(assertionConsumerURL))) {\n            LOG.fine(\"The Response must contain a destination that matches the assertion consumer URL\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // Validate Assertions\n        boolean foundValidSubject = false;\n        Date sessionNotOnOrAfter = null;\n        for (org.opensaml.saml.saml2.core.Assertion assertion : samlResponse.getAssertions()) {\n            // Check the Issuer\n            if (assertion.getIssuer() == null) {\n                LOG.fine(\"Assertion Issuer must not be null\");\n                throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n            }\n            validateIssuer(assertion.getIssuer());\n            \n            if (enforceAssertionsSigned && postBinding && assertion.getSignature() == null) {\n                LOG.fine(\"If the HTTP Post binding is used to deliver the Response, \"\n                         + \"the enclosed assertions must be signed\");\n                throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n            }\n            \n            // Check for AuthnStatements and validate the Subject accordingly\n            if (assertion.getAuthnStatements() != null\n                && !assertion.getAuthnStatements().isEmpty()) {\n                org.opensaml.saml.saml2.core.Subject subject = assertion.getSubject();\n                if (validateAuthenticationSubject(subject, assertion.getID(), postBinding)) {\n                    validateAudienceRestrictionCondition(assertion.getConditions());\n                    foundValidSubject = true;\n                    // Store Session NotOnOrAfter\n                    for (AuthnStatement authnStatment : assertion.getAuthnStatements()) {\n                        if (authnStatment.getSessionNotOnOrAfter() != null) {\n                            sessionNotOnOrAfter = authnStatment.getSessionNotOnOrAfter().toDate();\n                        }\n                    }\n                }\n            }\n            \n        }\n        \n        if (!foundValidSubject) {\n            LOG.fine(\"The Response did not contain any Authentication Statement that matched \"\n                     + \"the Subject Confirmation criteria\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        SSOValidatorResponse validatorResponse = new SSOValidatorResponse();\n        validatorResponse.setResponseId(samlResponse.getID());\n        validatorResponse.setSessionNotOnOrAfter(sessionNotOnOrAfter);\n        if (samlResponse.getIssueInstant() != null) {\n            validatorResponse.setCreated(samlResponse.getIssueInstant().toDate());\n        }\n        \n        // the assumption for now is that SAMLResponse will contain only a single assertion\n        Element assertionElement = samlResponse.getAssertions().get(0).getDOM();\n        Element clonedAssertionElement = (Element)assertionElement.cloneNode(true);\n        validatorResponse.setAssertionElement(clonedAssertionElement);\n        validatorResponse.setAssertion(DOM2Writer.nodeToString(clonedAssertionElement));\n        \n        return validatorResponse;\n    }\n    \n    /**\n     * Validate the Issuer (if it exists)\n     */\n    private void validateIssuer(org.opensaml.saml.saml2.core.Issuer issuer) throws WSSecurityException {\n        if (issuer == null) {\n            return;\n        }\n        \n        // Issuer value must match (be contained in) Issuer IDP\n        if (enforceKnownIssuer && !issuerIDP.startsWith(issuer.getValue())) {\n            LOG.fine(\"Issuer value: \" + issuer.getValue() + \" does not match issuer IDP: \" \n                + issuerIDP);\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // Format must be nameid-format-entity\n        if (issuer.getFormat() != null\n            && !SAML2Constants.NAMEID_FORMAT_ENTITY.equals(issuer.getFormat())) {\n            LOG.fine(\"Issuer format is not null and does not equal: \" \n                + SAML2Constants.NAMEID_FORMAT_ENTITY);\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n    }\n    \n    /**\n     * Validate the Subject (of an Authentication Statement).\n     */\n    private boolean validateAuthenticationSubject(\n        org.opensaml.saml.saml2.core.Subject subject, String id, boolean postBinding\n    ) throws WSSecurityException {\n        if (subject.getSubjectConfirmations() == null) {\n            return false;\n        }\n        \n        boolean foundBearerSubjectConf = false;\n        // We need to find a Bearer Subject Confirmation method\n        for (org.opensaml.saml.saml2.core.SubjectConfirmation subjectConf \n            : subject.getSubjectConfirmations()) {\n            if (SAML2Constants.CONF_BEARER.equals(subjectConf.getMethod())) {\n                foundBearerSubjectConf = true;\n                validateSubjectConfirmation(subjectConf.getSubjectConfirmationData(), id, postBinding);\n            }\n        }\n        \n        return foundBearerSubjectConf;\n    }\n    \n    /**\n     * Validate a (Bearer) Subject Confirmation\n     */\n    private void validateSubjectConfirmation(\n        org.opensaml.saml.saml2.core.SubjectConfirmationData subjectConfData, String id, boolean postBinding\n    ) throws WSSecurityException {\n        if (subjectConfData == null) {\n            LOG.fine(\"Subject Confirmation Data of a Bearer Subject Confirmation is null\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // Recipient must match assertion consumer URL\n        String recipient = subjectConfData.getRecipient();\n        if (recipient == null || !recipient.equals(assertionConsumerURL)) {\n            LOG.fine(\"Recipient \" + recipient + \" does not match assertion consumer URL \"\n                + assertionConsumerURL);\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // We must have a NotOnOrAfter timestamp\n        if (subjectConfData.getNotOnOrAfter() == null\n            || subjectConfData.getNotOnOrAfter().isBeforeNow()) {\n            LOG.fine(\"Subject Conf Data does not contain NotOnOrAfter or it has expired\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // Need to keep bearer assertion IDs based on NotOnOrAfter to detect replay attacks\n        if (postBinding && replayCache != null) {\n            if (replayCache.getId(id) == null) {\n                Date expires = subjectConfData.getNotOnOrAfter().toDate();\n                Date currentTime = new Date();\n                long ttl = expires.getTime() - currentTime.getTime();\n                replayCache.putId(id, ttl / 1000L);\n            } else {\n                LOG.fine(\"Replay attack with token id: \" + id);\n                throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n            }\n        }\n        \n        // Check address\n        if (subjectConfData.getAddress() != null\n            && !subjectConfData.getAddress().equals(clientAddress)) {\n            LOG.fine(\"Subject Conf Data address \" + subjectConfData.getAddress() + \" does match\"\n                     + \" client address \" + clientAddress);\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // It must not contain a NotBefore timestamp\n        if (subjectConfData.getNotBefore() != null) {\n            LOG.fine(\"The Subject Conf Data must not contain a NotBefore timestamp\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // InResponseTo must match the AuthnRequest request Id\n        if (requestId != null && !requestId.equals(subjectConfData.getInResponseTo())) {\n            LOG.fine(\"The InResponseTo String does match the original request id \" + requestId);\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n    }\n    \n    private void validateAudienceRestrictionCondition(\n        org.opensaml.saml.saml2.core.Conditions conditions\n    ) throws WSSecurityException {\n        if (conditions == null) {\n            LOG.fine(\"Conditions are null\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        List<AudienceRestriction> audienceRestrs = conditions.getAudienceRestrictions();\n        if (!matchSaml2AudienceRestriction(spIdentifier, audienceRestrs)) {\n            LOG.fine(\"Assertion does not contain unique subject provider identifier \" \n                     + spIdentifier + \" in the audience restriction conditions\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n    }\n    \n    \n    private boolean matchSaml2AudienceRestriction(\n        String appliesTo, List<AudienceRestriction> audienceRestrictions\n    ) {\n        boolean oneMatchFound = false;\n        if (audienceRestrictions != null && !audienceRestrictions.isEmpty()) {\n            for (AudienceRestriction audienceRestriction : audienceRestrictions) {\n                if (audienceRestriction.getAudiences() != null) {\n                    boolean matchFound = false;\n                    for (org.opensaml.saml.saml2.core.Audience audience : audienceRestriction.getAudiences()) {\n                        if (appliesTo.equals(audience.getAudienceURI())) {\n                            matchFound = true;\n                            oneMatchFound = true;\n                            break;\n                        }\n                    }\n                    if (!matchFound) {\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return oneMatchFound;\n    }\n\n    public String getIssuerIDP() {\n        return issuerIDP;\n    }\n\n    public void setIssuerIDP(String issuerIDP) {\n        this.issuerIDP = issuerIDP;\n    }\n\n    public String getAssertionConsumerURL() {\n        return assertionConsumerURL;\n    }\n\n    public void setAssertionConsumerURL(String assertionConsumerURL) {\n        this.assertionConsumerURL = assertionConsumerURL;\n    }\n\n    public String getClientAddress() {\n        return clientAddress;\n    }\n\n    public void setClientAddress(String clientAddress) {\n        this.clientAddress = clientAddress;\n    }\n\n    public String getRequestId() {\n        return requestId;\n    }\n\n    public void setRequestId(String requestId) {\n        this.requestId = requestId;\n    }\n\n    public String getSpIdentifier() {\n        return spIdentifier;\n    }\n\n    public void setSpIdentifier(String spIdentifier) {\n        this.spIdentifier = spIdentifier;\n    }\n    \n    public void setReplayCache(TokenReplayCache<String> replayCache) {\n        this.replayCache = replayCache;\n    }\n    \n}\n",
        "human_patch_code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.cxf.rs.security.saml.sso;\n\nimport java.util.Date;\nimport java.util.List;\nimport java.util.logging.Logger;\n\nimport org.w3c.dom.Element;\n\nimport org.apache.cxf.common.logging.LogUtils;\nimport org.apache.wss4j.common.ext.WSSecurityException;\nimport org.apache.wss4j.common.saml.builder.SAML2Constants;\nimport org.apache.wss4j.common.util.DOM2Writer;\nimport org.opensaml.saml.saml2.core.AudienceRestriction;\nimport org.opensaml.saml.saml2.core.AuthnStatement;\n\n/**\n * Validate a SAML 2.0 Protocol Response according to the Web SSO profile. The Response\n * should be validated by the SAMLProtocolResponseValidator first.\n */\npublic class SAMLSSOResponseValidator {\n    \n    private static final Logger LOG = LogUtils.getL7dLogger(SAMLSSOResponseValidator.class);\n    \n    private String issuerIDP;\n    private String assertionConsumerURL;\n    private String clientAddress;\n    private String requestId;\n    private String spIdentifier;\n    private boolean enforceAssertionsSigned = true;\n    private boolean enforceKnownIssuer = true;\n    private TokenReplayCache<String> replayCache;\n    \n    /**\n     * Enforce that Assertions must be signed if the POST binding was used. The default is true.\n     */\n    public void setEnforceAssertionsSigned(boolean enforceAssertionsSigned) {\n        this.enforceAssertionsSigned = enforceAssertionsSigned;\n    }\n    \n    /**\n     * Enforce that the Issuer of the received Response/Assertion is known. The default is true.\n     */\n    public void setEnforceKnownIssuer(boolean enforceKnownIssuer) {\n        this.enforceKnownIssuer = enforceKnownIssuer;\n    }\n    \n    /**\n     * Validate a SAML 2 Protocol Response\n     * @param samlResponse\n     * @param postBinding\n     * @return a SSOValidatorResponse object\n     * @throws WSSecurityException\n     */\n    public SSOValidatorResponse validateSamlResponse(\n        org.opensaml.saml.saml2.core.Response samlResponse,\n        boolean postBinding\n    ) throws WSSecurityException {\n        // Check the Issuer\n        validateIssuer(samlResponse.getIssuer());\n\n        // The Response must contain at least one Assertion.\n        if (samlResponse.getAssertions() == null || samlResponse.getAssertions().isEmpty()) {\n            LOG.fine(\"The Response must contain at least one Assertion\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // The Response must contain a Destination that matches the assertionConsumerURL if it is\n        // signed\n        String destination = samlResponse.getDestination();\n        if (samlResponse.isSigned()\n            && (destination == null || !destination.equals(assertionConsumerURL))) {\n            LOG.fine(\"The Response must contain a destination that matches the assertion consumer URL\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // Validate Assertions\n        org.opensaml.saml.saml2.core.Assertion validAssertion = null;\n        Date sessionNotOnOrAfter = null;\n        for (org.opensaml.saml.saml2.core.Assertion assertion : samlResponse.getAssertions()) {\n            // Check the Issuer\n            if (assertion.getIssuer() == null) {\n                LOG.fine(\"Assertion Issuer must not be null\");\n                throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n            }\n            validateIssuer(assertion.getIssuer());\n            \n            if (enforceAssertionsSigned && postBinding && assertion.getSignature() == null) {\n                LOG.fine(\"If the HTTP Post binding is used to deliver the Response, \"\n                         + \"the enclosed assertions must be signed\");\n                throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n            }\n            \n            // Check for AuthnStatements and validate the Subject accordingly\n            if (assertion.getAuthnStatements() != null\n                && !assertion.getAuthnStatements().isEmpty()) {\n                org.opensaml.saml.saml2.core.Subject subject = assertion.getSubject();\n                if (validateAuthenticationSubject(subject, assertion.getID(), postBinding)) {\n                    validateAudienceRestrictionCondition(assertion.getConditions());\n                    validAssertion = assertion;\n                    // Store Session NotOnOrAfter\n                    for (AuthnStatement authnStatment : assertion.getAuthnStatements()) {\n                        if (authnStatment.getSessionNotOnOrAfter() != null) {\n                            sessionNotOnOrAfter = authnStatment.getSessionNotOnOrAfter().toDate();\n                        }\n                    }\n                }\n            }\n        }\n        \n        if (validAssertion == null) {\n            LOG.fine(\"The Response did not contain any Authentication Statement that matched \"\n                     + \"the Subject Confirmation criteria\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        SSOValidatorResponse validatorResponse = new SSOValidatorResponse();\n        validatorResponse.setResponseId(samlResponse.getID());\n        validatorResponse.setSessionNotOnOrAfter(sessionNotOnOrAfter);\n        if (samlResponse.getIssueInstant() != null) {\n            validatorResponse.setCreated(samlResponse.getIssueInstant().toDate());\n        }\n        \n        // the assumption for now is that SAMLResponse will contain only a single assertion\n        Element assertionElement = validAssertion.getDOM();\n        Element clonedAssertionElement = (Element)assertionElement.cloneNode(true);\n        validatorResponse.setAssertionElement(clonedAssertionElement);\n        validatorResponse.setAssertion(DOM2Writer.nodeToString(clonedAssertionElement));\n        \n        return validatorResponse;\n    }\n    \n    /**\n     * Validate the Issuer (if it exists)\n     */\n    private void validateIssuer(org.opensaml.saml.saml2.core.Issuer issuer) throws WSSecurityException {\n        if (issuer == null) {\n            return;\n        }\n        \n        // Issuer value must match (be contained in) Issuer IDP\n        if (enforceKnownIssuer && !issuerIDP.startsWith(issuer.getValue())) {\n            LOG.fine(\"Issuer value: \" + issuer.getValue() + \" does not match issuer IDP: \" \n                + issuerIDP);\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // Format must be nameid-format-entity\n        if (issuer.getFormat() != null\n            && !SAML2Constants.NAMEID_FORMAT_ENTITY.equals(issuer.getFormat())) {\n            LOG.fine(\"Issuer format is not null and does not equal: \" \n                + SAML2Constants.NAMEID_FORMAT_ENTITY);\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n    }\n    \n    /**\n     * Validate the Subject (of an Authentication Statement).\n     */\n    private boolean validateAuthenticationSubject(\n        org.opensaml.saml.saml2.core.Subject subject, String id, boolean postBinding\n    ) throws WSSecurityException {\n        if (subject.getSubjectConfirmations() == null) {\n            return false;\n        }\n        \n        boolean foundBearerSubjectConf = false;\n        // We need to find a Bearer Subject Confirmation method\n        for (org.opensaml.saml.saml2.core.SubjectConfirmation subjectConf \n            : subject.getSubjectConfirmations()) {\n            if (SAML2Constants.CONF_BEARER.equals(subjectConf.getMethod())) {\n                foundBearerSubjectConf = true;\n                validateSubjectConfirmation(subjectConf.getSubjectConfirmationData(), id, postBinding);\n            }\n        }\n        \n        return foundBearerSubjectConf;\n    }\n    \n    /**\n     * Validate a (Bearer) Subject Confirmation\n     */\n    private void validateSubjectConfirmation(\n        org.opensaml.saml.saml2.core.SubjectConfirmationData subjectConfData, String id, boolean postBinding\n    ) throws WSSecurityException {\n        if (subjectConfData == null) {\n            LOG.fine(\"Subject Confirmation Data of a Bearer Subject Confirmation is null\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // Recipient must match assertion consumer URL\n        String recipient = subjectConfData.getRecipient();\n        if (recipient == null || !recipient.equals(assertionConsumerURL)) {\n            LOG.fine(\"Recipient \" + recipient + \" does not match assertion consumer URL \"\n                + assertionConsumerURL);\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // We must have a NotOnOrAfter timestamp\n        if (subjectConfData.getNotOnOrAfter() == null\n            || subjectConfData.getNotOnOrAfter().isBeforeNow()) {\n            LOG.fine(\"Subject Conf Data does not contain NotOnOrAfter or it has expired\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // Need to keep bearer assertion IDs based on NotOnOrAfter to detect replay attacks\n        if (postBinding && replayCache != null) {\n            if (replayCache.getId(id) == null) {\n                Date expires = subjectConfData.getNotOnOrAfter().toDate();\n                Date currentTime = new Date();\n                long ttl = expires.getTime() - currentTime.getTime();\n                replayCache.putId(id, ttl / 1000L);\n            } else {\n                LOG.fine(\"Replay attack with token id: \" + id);\n                throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n            }\n        }\n        \n        // Check address\n        if (subjectConfData.getAddress() != null\n            && !subjectConfData.getAddress().equals(clientAddress)) {\n            LOG.fine(\"Subject Conf Data address \" + subjectConfData.getAddress() + \" does match\"\n                     + \" client address \" + clientAddress);\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // It must not contain a NotBefore timestamp\n        if (subjectConfData.getNotBefore() != null) {\n            LOG.fine(\"The Subject Conf Data must not contain a NotBefore timestamp\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // InResponseTo must match the AuthnRequest request Id\n        if (requestId != null && !requestId.equals(subjectConfData.getInResponseTo())) {\n            LOG.fine(\"The InResponseTo String does match the original request id \" + requestId);\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n    }\n    \n    private void validateAudienceRestrictionCondition(\n        org.opensaml.saml.saml2.core.Conditions conditions\n    ) throws WSSecurityException {\n        if (conditions == null) {\n            LOG.fine(\"Conditions are null\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        List<AudienceRestriction> audienceRestrs = conditions.getAudienceRestrictions();\n        if (!matchSaml2AudienceRestriction(spIdentifier, audienceRestrs)) {\n            LOG.fine(\"Assertion does not contain unique subject provider identifier \" \n                     + spIdentifier + \" in the audience restriction conditions\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n    }\n    \n    \n    private boolean matchSaml2AudienceRestriction(\n        String appliesTo, List<AudienceRestriction> audienceRestrictions\n    ) {\n        boolean oneMatchFound = false;\n        if (audienceRestrictions != null && !audienceRestrictions.isEmpty()) {\n            for (AudienceRestriction audienceRestriction : audienceRestrictions) {\n                if (audienceRestriction.getAudiences() != null) {\n                    boolean matchFound = false;\n                    for (org.opensaml.saml.saml2.core.Audience audience : audienceRestriction.getAudiences()) {\n                        if (appliesTo.equals(audience.getAudienceURI())) {\n                            matchFound = true;\n                            oneMatchFound = true;\n                            break;\n                        }\n                    }\n                    if (!matchFound) {\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return oneMatchFound;\n    }\n\n    public String getIssuerIDP() {\n        return issuerIDP;\n    }\n\n    public void setIssuerIDP(String issuerIDP) {\n        this.issuerIDP = issuerIDP;\n    }\n\n    public String getAssertionConsumerURL() {\n        return assertionConsumerURL;\n    }\n\n    public void setAssertionConsumerURL(String assertionConsumerURL) {\n        this.assertionConsumerURL = assertionConsumerURL;\n    }\n\n    public String getClientAddress() {\n        return clientAddress;\n    }\n\n    public void setClientAddress(String clientAddress) {\n        this.clientAddress = clientAddress;\n    }\n\n    public String getRequestId() {\n        return requestId;\n    }\n\n    public void setRequestId(String requestId) {\n        this.requestId = requestId;\n    }\n\n    public String getSpIdentifier() {\n        return spIdentifier;\n    }\n\n    public void setSpIdentifier(String spIdentifier) {\n        this.spIdentifier = spIdentifier;\n    }\n    \n    public void setReplayCache(TokenReplayCache<String> replayCache) {\n        this.replayCache = replayCache;\n    }\n    \n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-17": {
    "vul_id": "VUL4J-17",
    "cve_id": "HTTPCLIENT-1803",
    "project": "apache_httpcomponents-client",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl httpclient -Dtest=org.apache.http.client.utils.TestURIBuilder#testMalformedPath",
    "test_all_cmd": "mvn test -pl httpclient",
    "human_patch_url": "https://github.com/apache/httpcomponents-client/commit/0554271750599756d4946c0d7ba43d04b1a7b22",
    "vulnerable_files": [
      {
        "file_path": "httpclient/src/main/java/org/apache/http/client/utils/URIBuilder.java",
        "file_name": "URIBuilder.java",
        "vulnerable_code": "/*\n * ====================================================================\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n * ====================================================================\n *\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Software Foundation.  For more\n * information on the Apache Software Foundation, please see\n * <http://www.apache.org/>.\n *\n */\npackage org.apache.http.client.utils;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.apache.http.Consts;\nimport org.apache.http.NameValuePair;\nimport org.apache.http.conn.util.InetAddressUtils;\nimport org.apache.http.message.BasicNameValuePair;\n\n/**\n * Builder for {@link URI} instances.\n *\n * @since 4.2\n */\npublic class URIBuilder {\n\n    private String scheme;\n    private String encodedSchemeSpecificPart;\n    private String encodedAuthority;\n    private String userInfo;\n    private String encodedUserInfo;\n    private String host;\n    private int port;\n    private String path;\n    private String encodedPath;\n    private String encodedQuery;\n    private List<NameValuePair> queryParams;\n    private String query;\n    private Charset charset;\n    private String fragment;\n    private String encodedFragment;\n\n    /**\n     * Constructs an empty instance.\n     */\n    public URIBuilder() {\n        super();\n        this.port = -1;\n    }\n\n    /**\n     * Construct an instance from the string which must be a valid URI.\n     *\n     * @param string a valid URI in string form\n     * @throws URISyntaxException if the input is not a valid URI\n     */\n    public URIBuilder(final String string) throws URISyntaxException {\n        super();\n        digestURI(new URI(string));\n    }\n\n    /**\n     * Construct an instance from the provided URI.\n     * @param uri\n     */\n    public URIBuilder(final URI uri) {\n        super();\n        digestURI(uri);\n    }\n\n    /**\n     * @since 4.4\n     */\n    public URIBuilder setCharset(final Charset charset) {\n        this.charset = charset;\n        return this;\n    }\n\n    /**\n     * @since 4.4\n     */\n    public Charset getCharset() {\n        return charset;\n    }\n\n    private List <NameValuePair> parseQuery(final String query, final Charset charset) {\n        if (query != null && !query.isEmpty()) {\n            return URLEncodedUtils.parse(query, charset);\n        }\n        return null;\n    }\n\n    /**\n     * Builds a {@link URI} instance.\n     */\n    public URI build() throws URISyntaxException {\n        return new URI(buildString());\n    }\n\n    private String buildString() {\n        final StringBuilder sb = new StringBuilder();\n        if (this.scheme != null) {\n            sb.append(this.scheme).append(':');\n        }\n        if (this.encodedSchemeSpecificPart != null) {\n            sb.append(this.encodedSchemeSpecificPart);\n        } else {\n            if (this.encodedAuthority != null) {\n                sb.append(\"//\").append(this.encodedAuthority);\n            } else if (this.host != null) {\n                sb.append(\"//\");\n                if (this.encodedUserInfo != null) {\n                    sb.append(this.encodedUserInfo).append(\"@\");\n                } else if (this.userInfo != null) {\n                    sb.append(encodeUserInfo(this.userInfo)).append(\"@\");\n                }\n                if (InetAddressUtils.isIPv6Address(this.host)) {\n                    sb.append(\"[\").append(this.host).append(\"]\");\n                } else {\n                    sb.append(this.host);\n                }\n                if (this.port >= 0) {\n                    sb.append(\":\").append(this.port);\n                }\n            }\n            if (this.encodedPath != null) {\n                sb.append(normalizePath(this.encodedPath));\n            } else if (this.path != null) {\n                sb.append(encodePath(normalizePath(this.path)));\n            }\n            if (this.encodedQuery != null) {\n                sb.append(\"?\").append(this.encodedQuery);\n            } else if (this.queryParams != null) {\n                sb.append(\"?\").append(encodeUrlForm(this.queryParams));\n            } else if (this.query != null) {\n                sb.append(\"?\").append(encodeUric(this.query));\n            }\n        }\n        if (this.encodedFragment != null) {\n            sb.append(\"#\").append(this.encodedFragment);\n        } else if (this.fragment != null) {\n            sb.append(\"#\").append(encodeUric(this.fragment));\n        }\n        return sb.toString();\n    }\n\n    private void digestURI(final URI uri) {\n        this.scheme = uri.getScheme();\n        this.encodedSchemeSpecificPart = uri.getRawSchemeSpecificPart();\n        this.encodedAuthority = uri.getRawAuthority();\n        this.host = uri.getHost();\n        this.port = uri.getPort();\n        this.encodedUserInfo = uri.getRawUserInfo();\n        this.userInfo = uri.getUserInfo();\n        this.encodedPath = uri.getRawPath();\n        this.path = uri.getPath();\n        this.encodedQuery = uri.getRawQuery();\n        this.queryParams = parseQuery(uri.getRawQuery(), this.charset != null ? this.charset : Consts.UTF_8);\n        this.encodedFragment = uri.getRawFragment();\n        this.fragment = uri.getFragment();\n    }\n\n    private String encodeUserInfo(final String userInfo) {\n        return URLEncodedUtils.encUserInfo(userInfo, this.charset != null ? this.charset : Consts.UTF_8);\n    }\n\n    private String encodePath(final String path) {\n        return URLEncodedUtils.encPath(path, this.charset != null ? this.charset : Consts.UTF_8);\n    }\n\n    private String encodeUrlForm(final List<NameValuePair> params) {\n        return URLEncodedUtils.format(params, this.charset != null ? this.charset : Consts.UTF_8);\n    }\n\n    private String encodeUric(final String fragment) {\n        return URLEncodedUtils.encUric(fragment, this.charset != null ? this.charset : Consts.UTF_8);\n    }\n\n    /**\n     * Sets URI scheme.\n     */\n    public URIBuilder setScheme(final String scheme) {\n        this.scheme = scheme;\n        return this;\n    }\n\n    /**\n     * Sets URI user info. The value is expected to be unescaped and may contain non ASCII\n     * characters.\n     */\n    public URIBuilder setUserInfo(final String userInfo) {\n        this.userInfo = userInfo;\n        this.encodedSchemeSpecificPart = null;\n        this.encodedAuthority = null;\n        this.encodedUserInfo = null;\n        return this;\n    }\n\n    /**\n     * Sets URI user info as a combination of username and password. These values are expected to\n     * be unescaped and may contain non ASCII characters.\n     */\n    public URIBuilder setUserInfo(final String username, final String password) {\n        return setUserInfo(username + ':' + password);\n    }\n\n    /**\n     * Sets URI host.\n     */\n    public URIBuilder setHost(final String host) {\n        this.host = host;\n        this.encodedSchemeSpecificPart = null;\n        this.encodedAuthority = null;\n        return this;\n    }\n\n    /**\n     * Sets URI port.\n     */\n    public URIBuilder setPort(final int port) {\n        this.port = port < 0 ? -1 : port;\n        this.encodedSchemeSpecificPart = null;\n        this.encodedAuthority = null;\n        return this;\n    }\n\n    /**\n     * Sets URI path. The value is expected to be unescaped and may contain non ASCII characters.\n     */\n    public URIBuilder setPath(final String path) {\n        this.path = path;\n        this.encodedSchemeSpecificPart = null;\n        this.encodedPath = null;\n        return this;\n    }\n\n    /**\n     * Removes URI query.\n     */\n    public URIBuilder removeQuery() {\n        this.queryParams = null;\n        this.query = null;\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        return this;\n    }\n\n    /**\n     * Sets URI query.\n     * <p>\n     * The value is expected to be encoded form data.\n     *\n     * @deprecated (4.3) use {@link #setParameters(List)} or {@link #setParameters(NameValuePair...)}\n     *\n     * @see URLEncodedUtils#parse\n     */\n    @Deprecated\n    public URIBuilder setQuery(final String query) {\n        this.queryParams = parseQuery(query, this.charset != null ? this.charset : Consts.UTF_8);\n        this.query = null;\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        return this;\n    }\n\n    /**\n     * Sets URI query parameters. The parameter name / values are expected to be unescaped\n     * and may contain non ASCII characters.\n     * <p>\n     * Please note query parameters and custom query component are mutually exclusive. This method\n     * will remove custom query if present.\n     * </p>\n     *\n     * @since 4.3\n     */\n    public URIBuilder setParameters(final List <NameValuePair> nvps) {\n        if (this.queryParams == null) {\n            this.queryParams = new ArrayList<NameValuePair>();\n        } else {\n            this.queryParams.clear();\n        }\n        this.queryParams.addAll(nvps);\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        this.query = null;\n        return this;\n    }\n\n    /**\n     * Adds URI query parameters. The parameter name / values are expected to be unescaped\n     * and may contain non ASCII characters.\n     * <p>\n     * Please note query parameters and custom query component are mutually exclusive. This method\n     * will remove custom query if present.\n     * </p>\n     *\n     * @since 4.3\n     */\n    public URIBuilder addParameters(final List <NameValuePair> nvps) {\n        if (this.queryParams == null) {\n            this.queryParams = new ArrayList<NameValuePair>();\n        }\n        this.queryParams.addAll(nvps);\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        this.query = null;\n        return this;\n    }\n\n    /**\n     * Sets URI query parameters. The parameter name / values are expected to be unescaped\n     * and may contain non ASCII characters.\n     * <p>\n     * Please note query parameters and custom query component are mutually exclusive. This method\n     * will remove custom query if present.\n     * </p>\n     *\n     * @since 4.3\n     */\n    public URIBuilder setParameters(final NameValuePair... nvps) {\n        if (this.queryParams == null) {\n            this.queryParams = new ArrayList<NameValuePair>();\n        } else {\n            this.queryParams.clear();\n        }\n        for (final NameValuePair nvp: nvps) {\n            this.queryParams.add(nvp);\n        }\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        this.query = null;\n        return this;\n    }\n\n    /**\n     * Adds parameter to URI query. The parameter name and value are expected to be unescaped\n     * and may contain non ASCII characters.\n     * <p>\n     * Please note query parameters and custom query component are mutually exclusive. This method\n     * will remove custom query if present.\n     * </p>\n     */\n    public URIBuilder addParameter(final String param, final String value) {\n        if (this.queryParams == null) {\n            this.queryParams = new ArrayList<NameValuePair>();\n        }\n        this.queryParams.add(new BasicNameValuePair(param, value));\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        this.query = null;\n        return this;\n    }\n\n    /**\n     * Sets parameter of URI query overriding existing value if set. The parameter name and value\n     * are expected to be unescaped and may contain non ASCII characters.\n     * <p>\n     * Please note query parameters and custom query component are mutually exclusive. This method\n     * will remove custom query if present.\n     * </p>\n     */\n    public URIBuilder setParameter(final String param, final String value) {\n        if (this.queryParams == null) {\n            this.queryParams = new ArrayList<NameValuePair>();\n        }\n        if (!this.queryParams.isEmpty()) {\n            for (final Iterator<NameValuePair> it = this.queryParams.iterator(); it.hasNext(); ) {\n                final NameValuePair nvp = it.next();\n                if (nvp.getName().equals(param)) {\n                    it.remove();\n                }\n            }\n        }\n        this.queryParams.add(new BasicNameValuePair(param, value));\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        this.query = null;\n        return this;\n    }\n\n    /**\n     * Clears URI query parameters.\n     *\n     * @since 4.3\n     */\n    public URIBuilder clearParameters() {\n        this.queryParams = null;\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        return this;\n    }\n\n    /**\n     * Sets custom URI query. The value is expected to be unescaped and may contain non ASCII\n     * characters.\n     * <p>\n     * Please note query parameters and custom query component are mutually exclusive. This method\n     * will remove query parameters if present.\n     * </p>\n     *\n     * @since 4.3\n     */\n    public URIBuilder setCustomQuery(final String query) {\n        this.query = query;\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        this.queryParams = null;\n        return this;\n    }\n\n    /**\n     * Sets URI fragment. The value is expected to be unescaped and may contain non ASCII\n     * characters.\n     */\n    public URIBuilder setFragment(final String fragment) {\n        this.fragment = fragment;\n        this.encodedFragment = null;\n        return this;\n    }\n\n    /**\n     * @since 4.3\n     */\n    public boolean isAbsolute() {\n        return this.scheme != null;\n    }\n\n    /**\n     * @since 4.3\n     */\n    public boolean isOpaque() {\n        return this.path == null;\n    }\n\n    public String getScheme() {\n        return this.scheme;\n    }\n\n    public String getUserInfo() {\n        return this.userInfo;\n    }\n\n    public String getHost() {\n        return this.host;\n    }\n\n    public int getPort() {\n        return this.port;\n    }\n\n    public String getPath() {\n        return this.path;\n    }\n\n    public List<NameValuePair> getQueryParams() {\n        if (this.queryParams != null) {\n            return new ArrayList<NameValuePair>(this.queryParams);\n        } else {\n            return new ArrayList<NameValuePair>();\n        }\n    }\n\n    public String getFragment() {\n        return this.fragment;\n    }\n\n    @Override\n    public String toString() {\n        return buildString();\n    }\n\n    private static String normalizePath(final String path) {\n        String s = path;\n        if (s == null) {\n            return null;\n        }\n        int n = 0;\n        for (; n < s.length(); n++) {\n            if (s.charAt(n) != '/') {\n                break;\n            }\n        }\n        if (n > 1) {\n            s = s.substring(n - 1);\n        }\n        return s;\n    }\n\n}\n",
        "human_patch_code": "/*\n * ====================================================================\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n * ====================================================================\n *\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Software Foundation.  For more\n * information on the Apache Software Foundation, please see\n * <http://www.apache.org/>.\n *\n */\npackage org.apache.http.client.utils;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.apache.http.Consts;\nimport org.apache.http.NameValuePair;\nimport org.apache.http.conn.util.InetAddressUtils;\nimport org.apache.http.message.BasicNameValuePair;\n\n/**\n * Builder for {@link URI} instances.\n *\n * @since 4.2\n */\npublic class URIBuilder {\n\n    private String scheme;\n    private String encodedSchemeSpecificPart;\n    private String encodedAuthority;\n    private String userInfo;\n    private String encodedUserInfo;\n    private String host;\n    private int port;\n    private String path;\n    private String encodedPath;\n    private String encodedQuery;\n    private List<NameValuePair> queryParams;\n    private String query;\n    private Charset charset;\n    private String fragment;\n    private String encodedFragment;\n\n    /**\n     * Constructs an empty instance.\n     */\n    public URIBuilder() {\n        super();\n        this.port = -1;\n    }\n\n    /**\n     * Construct an instance from the string which must be a valid URI.\n     *\n     * @param string a valid URI in string form\n     * @throws URISyntaxException if the input is not a valid URI\n     */\n    public URIBuilder(final String string) throws URISyntaxException {\n        super();\n        digestURI(new URI(string));\n    }\n\n    /**\n     * Construct an instance from the provided URI.\n     * @param uri\n     */\n    public URIBuilder(final URI uri) {\n        super();\n        digestURI(uri);\n    }\n\n    /**\n     * @since 4.4\n     */\n    public URIBuilder setCharset(final Charset charset) {\n        this.charset = charset;\n        return this;\n    }\n\n    /**\n     * @since 4.4\n     */\n    public Charset getCharset() {\n        return charset;\n    }\n\n    private List <NameValuePair> parseQuery(final String query, final Charset charset) {\n        if (query != null && !query.isEmpty()) {\n            return URLEncodedUtils.parse(query, charset);\n        }\n        return null;\n    }\n\n    /**\n     * Builds a {@link URI} instance.\n     */\n    public URI build() throws URISyntaxException {\n        return new URI(buildString());\n    }\n\n    private String buildString() {\n        final StringBuilder sb = new StringBuilder();\n        if (this.scheme != null) {\n            sb.append(this.scheme).append(':');\n        }\n        if (this.encodedSchemeSpecificPart != null) {\n            sb.append(this.encodedSchemeSpecificPart);\n        } else {\n            if (this.encodedAuthority != null) {\n                sb.append(\"//\").append(this.encodedAuthority);\n            } else if (this.host != null) {\n                sb.append(\"//\");\n                if (this.encodedUserInfo != null) {\n                    sb.append(this.encodedUserInfo).append(\"@\");\n                } else if (this.userInfo != null) {\n                    sb.append(encodeUserInfo(this.userInfo)).append(\"@\");\n                }\n                if (InetAddressUtils.isIPv6Address(this.host)) {\n                    sb.append(\"[\").append(this.host).append(\"]\");\n                } else {\n                    sb.append(this.host);\n                }\n                if (this.port >= 0) {\n                    sb.append(\":\").append(this.port);\n                }\n            }\n            if (this.encodedPath != null) {\n                sb.append(normalizePath(this.encodedPath));\n            } else if (this.path != null) {\n                sb.append(encodePath(normalizePath(this.path)));\n            }\n            if (this.encodedQuery != null) {\n                sb.append(\"?\").append(this.encodedQuery);\n            } else if (this.queryParams != null) {\n                sb.append(\"?\").append(encodeUrlForm(this.queryParams));\n            } else if (this.query != null) {\n                sb.append(\"?\").append(encodeUric(this.query));\n            }\n        }\n        if (this.encodedFragment != null) {\n            sb.append(\"#\").append(this.encodedFragment);\n        } else if (this.fragment != null) {\n            sb.append(\"#\").append(encodeUric(this.fragment));\n        }\n        return sb.toString();\n    }\n\n    private void digestURI(final URI uri) {\n        this.scheme = uri.getScheme();\n        this.encodedSchemeSpecificPart = uri.getRawSchemeSpecificPart();\n        this.encodedAuthority = uri.getRawAuthority();\n        this.host = uri.getHost();\n        this.port = uri.getPort();\n        this.encodedUserInfo = uri.getRawUserInfo();\n        this.userInfo = uri.getUserInfo();\n        this.encodedPath = uri.getRawPath();\n        this.path = uri.getPath();\n        this.encodedQuery = uri.getRawQuery();\n        this.queryParams = parseQuery(uri.getRawQuery(), this.charset != null ? this.charset : Consts.UTF_8);\n        this.encodedFragment = uri.getRawFragment();\n        this.fragment = uri.getFragment();\n    }\n\n    private String encodeUserInfo(final String userInfo) {\n        return URLEncodedUtils.encUserInfo(userInfo, this.charset != null ? this.charset : Consts.UTF_8);\n    }\n\n    private String encodePath(final String path) {\n        return URLEncodedUtils.encPath(path, this.charset != null ? this.charset : Consts.UTF_8);\n    }\n\n    private String encodeUrlForm(final List<NameValuePair> params) {\n        return URLEncodedUtils.format(params, this.charset != null ? this.charset : Consts.UTF_8);\n    }\n\n    private String encodeUric(final String fragment) {\n        return URLEncodedUtils.encUric(fragment, this.charset != null ? this.charset : Consts.UTF_8);\n    }\n\n    /**\n     * Sets URI scheme.\n     */\n    public URIBuilder setScheme(final String scheme) {\n        this.scheme = scheme;\n        return this;\n    }\n\n    /**\n     * Sets URI user info. The value is expected to be unescaped and may contain non ASCII\n     * characters.\n     */\n    public URIBuilder setUserInfo(final String userInfo) {\n        this.userInfo = userInfo;\n        this.encodedSchemeSpecificPart = null;\n        this.encodedAuthority = null;\n        this.encodedUserInfo = null;\n        return this;\n    }\n\n    /**\n     * Sets URI user info as a combination of username and password. These values are expected to\n     * be unescaped and may contain non ASCII characters.\n     */\n    public URIBuilder setUserInfo(final String username, final String password) {\n        return setUserInfo(username + ':' + password);\n    }\n\n    /**\n     * Sets URI host.\n     */\n    public URIBuilder setHost(final String host) {\n        this.host = host;\n        this.encodedSchemeSpecificPart = null;\n        this.encodedAuthority = null;\n        return this;\n    }\n\n    /**\n     * Sets URI port.\n     */\n    public URIBuilder setPort(final int port) {\n        this.port = port < 0 ? -1 : port;\n        this.encodedSchemeSpecificPart = null;\n        this.encodedAuthority = null;\n        return this;\n    }\n\n    /**\n     * Sets URI path. The value is expected to be unescaped and may contain non ASCII characters.\n     */\n    public URIBuilder setPath(final String path) {\n        this.path = path;\n        this.encodedSchemeSpecificPart = null;\n        this.encodedPath = null;\n        return this;\n    }\n\n    /**\n     * Removes URI query.\n     */\n    public URIBuilder removeQuery() {\n        this.queryParams = null;\n        this.query = null;\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        return this;\n    }\n\n    /**\n     * Sets URI query.\n     * <p>\n     * The value is expected to be encoded form data.\n     *\n     * @deprecated (4.3) use {@link #setParameters(List)} or {@link #setParameters(NameValuePair...)}\n     *\n     * @see URLEncodedUtils#parse\n     */\n    @Deprecated\n    public URIBuilder setQuery(final String query) {\n        this.queryParams = parseQuery(query, this.charset != null ? this.charset : Consts.UTF_8);\n        this.query = null;\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        return this;\n    }\n\n    /**\n     * Sets URI query parameters. The parameter name / values are expected to be unescaped\n     * and may contain non ASCII characters.\n     * <p>\n     * Please note query parameters and custom query component are mutually exclusive. This method\n     * will remove custom query if present.\n     * </p>\n     *\n     * @since 4.3\n     */\n    public URIBuilder setParameters(final List <NameValuePair> nvps) {\n        if (this.queryParams == null) {\n            this.queryParams = new ArrayList<NameValuePair>();\n        } else {\n            this.queryParams.clear();\n        }\n        this.queryParams.addAll(nvps);\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        this.query = null;\n        return this;\n    }\n\n    /**\n     * Adds URI query parameters. The parameter name / values are expected to be unescaped\n     * and may contain non ASCII characters.\n     * <p>\n     * Please note query parameters and custom query component are mutually exclusive. This method\n     * will remove custom query if present.\n     * </p>\n     *\n     * @since 4.3\n     */\n    public URIBuilder addParameters(final List <NameValuePair> nvps) {\n        if (this.queryParams == null) {\n            this.queryParams = new ArrayList<NameValuePair>();\n        }\n        this.queryParams.addAll(nvps);\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        this.query = null;\n        return this;\n    }\n\n    /**\n     * Sets URI query parameters. The parameter name / values are expected to be unescaped\n     * and may contain non ASCII characters.\n     * <p>\n     * Please note query parameters and custom query component are mutually exclusive. This method\n     * will remove custom query if present.\n     * </p>\n     *\n     * @since 4.3\n     */\n    public URIBuilder setParameters(final NameValuePair... nvps) {\n        if (this.queryParams == null) {\n            this.queryParams = new ArrayList<NameValuePair>();\n        } else {\n            this.queryParams.clear();\n        }\n        for (final NameValuePair nvp: nvps) {\n            this.queryParams.add(nvp);\n        }\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        this.query = null;\n        return this;\n    }\n\n    /**\n     * Adds parameter to URI query. The parameter name and value are expected to be unescaped\n     * and may contain non ASCII characters.\n     * <p>\n     * Please note query parameters and custom query component are mutually exclusive. This method\n     * will remove custom query if present.\n     * </p>\n     */\n    public URIBuilder addParameter(final String param, final String value) {\n        if (this.queryParams == null) {\n            this.queryParams = new ArrayList<NameValuePair>();\n        }\n        this.queryParams.add(new BasicNameValuePair(param, value));\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        this.query = null;\n        return this;\n    }\n\n    /**\n     * Sets parameter of URI query overriding existing value if set. The parameter name and value\n     * are expected to be unescaped and may contain non ASCII characters.\n     * <p>\n     * Please note query parameters and custom query component are mutually exclusive. This method\n     * will remove custom query if present.\n     * </p>\n     */\n    public URIBuilder setParameter(final String param, final String value) {\n        if (this.queryParams == null) {\n            this.queryParams = new ArrayList<NameValuePair>();\n        }\n        if (!this.queryParams.isEmpty()) {\n            for (final Iterator<NameValuePair> it = this.queryParams.iterator(); it.hasNext(); ) {\n                final NameValuePair nvp = it.next();\n                if (nvp.getName().equals(param)) {\n                    it.remove();\n                }\n            }\n        }\n        this.queryParams.add(new BasicNameValuePair(param, value));\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        this.query = null;\n        return this;\n    }\n\n    /**\n     * Clears URI query parameters.\n     *\n     * @since 4.3\n     */\n    public URIBuilder clearParameters() {\n        this.queryParams = null;\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        return this;\n    }\n\n    /**\n     * Sets custom URI query. The value is expected to be unescaped and may contain non ASCII\n     * characters.\n     * <p>\n     * Please note query parameters and custom query component are mutually exclusive. This method\n     * will remove query parameters if present.\n     * </p>\n     *\n     * @since 4.3\n     */\n    public URIBuilder setCustomQuery(final String query) {\n        this.query = query;\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        this.queryParams = null;\n        return this;\n    }\n\n    /**\n     * Sets URI fragment. The value is expected to be unescaped and may contain non ASCII\n     * characters.\n     */\n    public URIBuilder setFragment(final String fragment) {\n        this.fragment = fragment;\n        this.encodedFragment = null;\n        return this;\n    }\n\n    /**\n     * @since 4.3\n     */\n    public boolean isAbsolute() {\n        return this.scheme != null;\n    }\n\n    /**\n     * @since 4.3\n     */\n    public boolean isOpaque() {\n        return this.path == null;\n    }\n\n    public String getScheme() {\n        return this.scheme;\n    }\n\n    public String getUserInfo() {\n        return this.userInfo;\n    }\n\n    public String getHost() {\n        return this.host;\n    }\n\n    public int getPort() {\n        return this.port;\n    }\n\n    public String getPath() {\n        return this.path;\n    }\n\n    public List<NameValuePair> getQueryParams() {\n        if (this.queryParams != null) {\n            return new ArrayList<NameValuePair>(this.queryParams);\n        } else {\n            return new ArrayList<NameValuePair>();\n        }\n    }\n\n    public String getFragment() {\n        return this.fragment;\n    }\n\n    @Override\n    public String toString() {\n        return buildString();\n    }\n\n    private static String normalizePath(final String path) {\n        String s = path;\n        if (s == null) {\n            return \"/\";\n        }\n        int n = 0;\n        for (; n < s.length(); n++) {\n            if (s.charAt(n) != '/') {\n                break;\n            }\n        }\n        if (n > 1) {\n            s = s.substring(n - 1);\n        }\n        if (!s.startsWith(\"/\")) {\n            s = \"/\" + s;\n        }\n        return s;\n    }\n\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-18": {
    "vul_id": "VUL4J-18",
    "cve_id": "CVE-2019-0225",
    "project": "apache_jspwiki",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl jspwiki-main -Dtest=org.apache.wiki.WikiServletTest#testNastyDoPost,org.apache.wiki.WikiServletTest#testDoGet",
    "test_all_cmd": "mvn test -pl jspwiki-main",
    "human_patch_url": "https://github.com/apache/jspwiki/commit/88d89d6523802c044cfcb7930cba40d8eeb21da2",
    "vulnerable_files": [
      {
        "file_path": "jspwiki-main/src/main/java/org/apache/wiki/url/DefaultURLConstructor.java",
        "file_name": "DefaultURLConstructor.java",
        "vulnerable_code": "/*\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n */\npackage org.apache.wiki.url;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Properties;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.wiki.WikiContext;\nimport org.apache.wiki.WikiEngine;\nimport org.apache.wiki.ui.Command;\nimport org.apache.wiki.ui.CommandResolver;\nimport org.apache.wiki.util.TextUtil;\n\n/**\n *  Implements the default URL constructor using links directly to the\n *  JSP pages.  This is what JSPWiki by default is using.  For example,\n *  WikiContext.VIEW points at \"Wiki.jsp\", etc.\n *\n *  @since 2.2\n */\npublic class DefaultURLConstructor\n    implements URLConstructor\n{\n    protected WikiEngine m_engine;\n\n    /**\n     *  Contains the absolute path of the JSPWiki Web application without the\n     *  actual servlet (which is the m_urlPrefix).\n     */\n    protected String m_pathPrefix = \"\";\n\n    /**\n     *\n     * {@inheritDoc}\n     */\n    public void initialize( WikiEngine engine,\n                            Properties properties )\n    {\n        m_engine = engine;\n\n        m_pathPrefix = engine.getBaseURL() + \"/\";\n    }\n\n    /**\n     *  Does replacement of some particular variables.  The variables are:\n     *\n     *  <ul>\n     *  <li> \"%u\" - inserts either the base URL (when absolute is required), or the base path\n     *       (which is an absolute path without the host name).\n     *  <li> \"%U\" - always inserts the base URL\n     *  <li> \"%p\" - always inserts the base path\n     *  <li> \"%n\" - inserts the page name\n     *  </ul>\n     *\n     * @param baseptrn  The pattern to use\n     * @param name The page name\n     * @param absolute If true, %u is always the entire base URL, otherwise it depends on\n     *                 the setting in jspwiki.properties.\n     * @return A replacement.\n     */\n    protected final String doReplacement( String baseptrn, String name, boolean absolute )\n    {\n        String baseurl = m_pathPrefix;\n\n        if( absolute ) baseurl = m_engine.getBaseURL() + \"/\";\n\n        baseptrn = TextUtil.replaceString( baseptrn, \"%u\", baseurl );\n        baseptrn = TextUtil.replaceString( baseptrn, \"%U\", m_engine.getBaseURL() );\n        baseptrn = TextUtil.replaceString( baseptrn, \"%n\", encodeURI(name) );\n        baseptrn = TextUtil.replaceString( baseptrn, \"%p\", m_pathPrefix );\n\n        return baseptrn;\n    }\n\n    /**\n     *  URLEncoder returns pluses, when we want to have the percent\n     *  encoding.  See http://issues.apache.org/bugzilla/show_bug.cgi?id=39278\n     *  for more info.\n     *\n     *  We also convert any %2F's back to slashes to make nicer-looking URLs.\n     */\n    private String encodeURI( String uri )\n    {\n        uri = m_engine.encodeName(uri);\n\n        uri = StringUtils.replace( uri, \"+\", \"%20\" );\n        uri = StringUtils.replace( uri, \"%2F\", \"/\" );\n\n        return uri;\n    }\n\n    /**\n     * Returns the URL pattern for a supplied wiki request context.\n     * @param context the wiki context\n     * @param name the wiki page\n     * @return A pattern for replacement.\n     * @throws IllegalArgumentException if the context cannot be found\n     */\n    public static String getURLPattern( String context, String name )\n        throws IllegalArgumentException\n    {\n        if( context.equals(WikiContext.VIEW) && name == null)\n        {\n            // FIXME\n            return \"%uWiki.jsp\";\n        }\n\n        // Find the action matching our pattern (could throw exception)\n        Command command = CommandResolver.findCommand( context );\n\n        return command.getURLPattern();\n    }\n\n    /**\n     *  Constructs the actual URL based on the context.\n     */\n    private String makeURL( String context,\n                            String name,\n                            boolean absolute )\n    {\n        return doReplacement( getURLPattern(context,name), name, absolute );\n    }\n\n    /**\n     *  Constructs the URL with a bunch of parameters.\n     *  @param parameters If null or empty, no parameters are added.\n     *\n     *  {@inheritDoc}\n     */\n    public String makeURL( String context,\n                           String name,\n                           boolean absolute,\n                           String parameters )\n    {\n        if( parameters != null && parameters.length() > 0 )\n        {\n            if( context.equals(WikiContext.ATTACH) )\n            {\n                parameters = \"?\"+parameters;\n            }\n            else if( context.equals(WikiContext.NONE) )\n            {\n                parameters = (name.indexOf('?') != -1 ) ? \"&amp;\" : \"?\" + parameters;\n            }\n            else\n            {\n                parameters = \"&amp;\"+parameters;\n            }\n        }\n        else\n        {\n            parameters = \"\";\n        }\n        return makeURL( context, name, absolute )+parameters;\n    }\n\n    /**\n     *  Should parse the \"page\" parameter from the actual\n     *  request.\n     *\n     *  {@inheritDoc}\n     */\n    public String parsePage( String context,\n                             HttpServletRequest request,\n                             String encoding )\n        throws UnsupportedEncodingException\n    {\n        String pagereq = request.getParameter( \"page\" );\n\n        if( context.equals(WikiContext.ATTACH) )\n        {\n            pagereq = parsePageFromURL( request, encoding );\n        }\n\n        return pagereq;\n    }\n\n    /**\n     *  There's a bug in Tomcat until 5.5.16 at least: The \"+\" sign is not\n     *  properly decoded by the servlet container, and therefore request.getPathInfo()\n     *  will return faulty results for paths which contains + signs to signify spaces.\n     *  <p>\n     *  This method provides a workaround by simply parsing the getRequestURI(), which\n     *  is returned from the servlet container undedecoded.\n     *  <p>\n     *  Please see <a href=\"http://issues.apache.org/bugzilla/show_bug.cgi?id=39278\">Tomcat Bug 39278</a>\n     *  for more information.\n     *\n     *  @param request A HTTP servlet request\n     *  @param encoding The used encoding\n     *  @return a String, decoded by JSPWiki, specifying extra path information that comes\n     *          after the servlet path but before the query string in the request URL;\n     *          or null if the URL does not have any extra path information\n     *  @throws UnsupportedEncodingException\n     */\n    /*\n    private static String getPathInfo( HttpServletRequest request, String encoding )\n        throws UnsupportedEncodingException\n    {\n        String c = request.getContextPath(); // Undecoded\n        String s = request.getServletPath(); // Decoded\n        String u = request.getRequestURI();  // Undecoded\n\n        c = URLDecoder.decode( c, encoding );\n        u = URLDecoder.decode( u, encoding );\n\n        String pi = u.substring( s.length()+c.length() );\n\n        if( pi.length() == 0 ) pi = null;\n\n        return pi;\n    }\n    */\n    /**\n     *  Takes the name of the page from the request URI.\n     *  The initial slash is also removed.  If there is no page,\n     *  returns null.\n     *\n     *  @param request The request to parse\n     *  @param encoding The encoding to use\n     *\n     *  @return a parsed page name, or null, if it cannot be found\n     *\n     *  @throws UnsupportedEncodingException If the encoding is not recognized.\n     */\n    public static String parsePageFromURL( HttpServletRequest request,\n                                           String encoding )\n        throws UnsupportedEncodingException\n    {\n        String name = request.getPathInfo();\n\n        if( name == null || name.length() <= 1 )\n        {\n            return null;\n        }\n        else if( name.charAt(0) == '/' )\n        {\n            name = name.substring(1);\n        }\n\n        //\n        //  This is required, because by default all URLs are handled\n        //  as Latin1, even if they are really UTF-8.\n        //\n\n        // name = TextUtil.urlDecode( name, encoding );\n\n        return name;\n    }\n\n\n    /**\n     *  This method is not needed for the DefaultURLConstructor.\n     *\n     * @param request The HTTP Request that was used to end up in this page.\n     * @return \"Wiki.jsp\", \"PageInfo.jsp\", etc.  Just return the name,\n     *         JSPWiki will figure out the page.\n     */\n    public String getForwardPage( HttpServletRequest request )\n    {\n        return request.getPathInfo();\n    }\n}\n",
        "human_patch_code": "/*\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n */\npackage org.apache.wiki.url;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Properties;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.wiki.WikiContext;\nimport org.apache.wiki.WikiEngine;\nimport org.apache.wiki.ui.Command;\nimport org.apache.wiki.ui.CommandResolver;\nimport org.apache.wiki.util.TextUtil;\n\n/**\n *  Implements the default URL constructor using links directly to the\n *  JSP pages.  This is what JSPWiki by default is using.  For example,\n *  WikiContext.VIEW points at \"Wiki.jsp\", etc.\n *\n *  @since 2.2\n */\npublic class DefaultURLConstructor\n    implements URLConstructor\n{\n    protected WikiEngine m_engine;\n\n    /**\n     *  Contains the absolute path of the JSPWiki Web application without the\n     *  actual servlet (which is the m_urlPrefix).\n     */\n    protected String m_pathPrefix = \"\";\n\n    /**\n     *\n     * {@inheritDoc}\n     */\n    public void initialize( WikiEngine engine,\n                            Properties properties )\n    {\n        m_engine = engine;\n\n        m_pathPrefix = engine.getBaseURL() + \"/\";\n    }\n\n    /**\n     *  Does replacement of some particular variables.  The variables are:\n     *\n     *  <ul>\n     *  <li> \"%u\" - inserts either the base URL (when absolute is required), or the base path\n     *       (which is an absolute path without the host name).\n     *  <li> \"%U\" - always inserts the base URL\n     *  <li> \"%p\" - always inserts the base path\n     *  <li> \"%n\" - inserts the page name\n     *  </ul>\n     *\n     * @param baseptrn  The pattern to use\n     * @param name The page name\n     * @param absolute If true, %u is always the entire base URL, otherwise it depends on\n     *                 the setting in jspwiki.properties.\n     * @return A replacement.\n     */\n    protected final String doReplacement( String baseptrn, String name, boolean absolute )\n    {\n        String baseurl = m_pathPrefix;\n\n        if( absolute ) baseurl = m_engine.getBaseURL() + \"/\";\n\n        baseptrn = TextUtil.replaceString( baseptrn, \"%u\", baseurl );\n        baseptrn = TextUtil.replaceString( baseptrn, \"%U\", m_engine.getBaseURL() );\n        baseptrn = TextUtil.replaceString( baseptrn, \"%n\", encodeURI(name) );\n        baseptrn = TextUtil.replaceString( baseptrn, \"%p\", m_pathPrefix );\n\n        return baseptrn;\n    }\n\n    /**\n     *  URLEncoder returns pluses, when we want to have the percent\n     *  encoding.  See http://issues.apache.org/bugzilla/show_bug.cgi?id=39278\n     *  for more info.\n     *\n     *  We also convert any %2F's back to slashes to make nicer-looking URLs.\n     */\n    private String encodeURI( String uri )\n    {\n        uri = m_engine.encodeName(uri);\n\n        uri = StringUtils.replace( uri, \"+\", \"%20\" );\n        uri = StringUtils.replace( uri, \"%2F\", \"/\" );\n\n        return uri;\n    }\n\n    /**\n     * Returns the URL pattern for a supplied wiki request context.\n     * @param context the wiki context\n     * @param name the wiki page\n     * @return A pattern for replacement.\n     * @throws IllegalArgumentException if the context cannot be found\n     */\n    public static String getURLPattern( String context, String name )\n        throws IllegalArgumentException\n    {\n        if( context.equals(WikiContext.VIEW) && name == null)\n        {\n            // FIXME\n            return \"%uWiki.jsp\";\n        }\n\n        // Find the action matching our pattern (could throw exception)\n        Command command = CommandResolver.findCommand( context );\n\n        return command.getURLPattern();\n    }\n\n    /**\n     *  Constructs the actual URL based on the context.\n     */\n    private String makeURL( String context,\n                            String name,\n                            boolean absolute )\n    {\n        return doReplacement( getURLPattern(context,name), name, absolute );\n    }\n\n    /**\n     *  Constructs the URL with a bunch of parameters.\n     *  @param parameters If null or empty, no parameters are added.\n     *\n     *  {@inheritDoc}\n     */\n    public String makeURL( String context,\n                           String name,\n                           boolean absolute,\n                           String parameters )\n    {\n        if( parameters != null && parameters.length() > 0 )\n        {\n            if( context.equals(WikiContext.ATTACH) )\n            {\n                parameters = \"?\"+parameters;\n            }\n            else if( context.equals(WikiContext.NONE) )\n            {\n                parameters = (name.indexOf('?') != -1 ) ? \"&amp;\" : \"?\" + parameters;\n            }\n            else\n            {\n                parameters = \"&amp;\"+parameters;\n            }\n        }\n        else\n        {\n            parameters = \"\";\n        }\n        return makeURL( context, name, absolute )+parameters;\n    }\n\n    /**\n     *  Should parse the \"page\" parameter from the actual\n     *  request.\n     *\n     *  {@inheritDoc}\n     */\n    public String parsePage( String context,\n                             HttpServletRequest request,\n                             String encoding )\n        throws UnsupportedEncodingException\n    {\n        String pagereq = request.getParameter( \"page\" );\n\n        if( context.equals(WikiContext.ATTACH) )\n        {\n            pagereq = parsePageFromURL( request, encoding );\n        }\n\n        return pagereq;\n    }\n\n    /**\n     *  There's a bug in Tomcat until 5.5.16 at least: The \"+\" sign is not\n     *  properly decoded by the servlet container, and therefore request.getPathInfo()\n     *  will return faulty results for paths which contains + signs to signify spaces.\n     *  <p>\n     *  This method provides a workaround by simply parsing the getRequestURI(), which\n     *  is returned from the servlet container undedecoded.\n     *  <p>\n     *  Please see <a href=\"http://issues.apache.org/bugzilla/show_bug.cgi?id=39278\">Tomcat Bug 39278</a>\n     *  for more information.\n     *\n     *  @param request A HTTP servlet request\n     *  @param encoding The used encoding\n     *  @return a String, decoded by JSPWiki, specifying extra path information that comes\n     *          after the servlet path but before the query string in the request URL;\n     *          or null if the URL does not have any extra path information\n     *  @throws UnsupportedEncodingException\n     */\n    /*\n    private static String getPathInfo( HttpServletRequest request, String encoding )\n        throws UnsupportedEncodingException\n    {\n        String c = request.getContextPath(); // Undecoded\n        String s = request.getServletPath(); // Decoded\n        String u = request.getRequestURI();  // Undecoded\n\n        c = URLDecoder.decode( c, encoding );\n        u = URLDecoder.decode( u, encoding );\n\n        String pi = u.substring( s.length()+c.length() );\n\n        if( pi.length() == 0 ) pi = null;\n\n        return pi;\n    }\n    */\n    /**\n     *  Takes the name of the page from the request URI.\n     *  The initial slash is also removed.  If there is no page,\n     *  returns null.\n     *\n     *  @param request The request to parse\n     *  @param encoding The encoding to use\n     *\n     *  @return a parsed page name, or null, if it cannot be found\n     *\n     *  @throws UnsupportedEncodingException If the encoding is not recognized.\n     */\n    public static String parsePageFromURL( HttpServletRequest request,\n                                           String encoding )\n        throws UnsupportedEncodingException\n    {\n        String name = request.getPathInfo();\n\n        if( name == null || name.length() <= 1 )\n        {\n            return null;\n        }\n        else if( name.charAt(0) == '/' )\n        {\n            name = name.substring(1);\n        }\n\n        //\n        //  This is required, because by default all URLs are handled\n        //  as Latin1, even if they are really UTF-8.\n        //\n\n        // name = TextUtil.urlDecode( name, encoding );\n\n        return name;\n    }\n\n\n    /**\n     *  This method is not needed for the DefaultURLConstructor.\n     *\n     * @param request The HTTP Request that was used to end up in this page.\n     * @return \"Wiki.jsp\", \"PageInfo.jsp\", etc.  Just return the name,\n     *         JSPWiki will figure out the page.\n     */\n    public String getForwardPage( HttpServletRequest request )\n    {\n        return \"Wiki.jsp\";\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-19": {
    "vul_id": "VUL4J-19",
    "cve_id": "PDFBOX-3341",
    "project": "apache_pdfbox",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl pdfbox -Dtest=org.apache.pdfbox.encryption.TestSymmetricKeyEncryption",
    "test_all_cmd": "mvn test -pl pdfbox",
    "human_patch_url": "https://github.com/bqcuong/vul4j/commit/c90825da4d28d7b1ae9b1484b9a010206be3dec5",
    "vulnerable_files": [
      {
        "file_path": "pdfbox/src/main/java/org/apache/pdfbox/pdmodel/encryption/StandardSecurityHandler.java",
        "file_name": "StandardSecurityHandler.java",
        "vulnerable_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.pdfbox.pdmodel.encryption;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.nio.charset.Charset;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Arrays;\n \nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport org.apache.pdfbox.cos.COSArray;\nimport org.apache.pdfbox.cos.COSName;\nimport org.apache.pdfbox.cos.COSString;\nimport org.apache.pdfbox.pdmodel.PDDocument;\nimport org.apache.pdfbox.util.Charsets;\n\n/**\n * The standard security handler. This security handler protects document with password.\n * @see StandardProtectionPolicy to see how to protect document with this security handler.\n * @author Ben Litchfield\n * @author Benoit Guillon\n * @author Manuel Kasper\n */\npublic final class StandardSecurityHandler extends SecurityHandler\n{\n    /**\n     * Log instance.\n     */\n    private static final Log LOG = LogFactory.getLog(StandardSecurityHandler.class);\n\n    /** Type of security handler. */\n    public static final String FILTER = \"Standard\";\n\n    /** Protection policy class for this handler. */\n    public static final Class<?> PROTECTION_POLICY_CLASS = StandardProtectionPolicy.class;\n\n    /** Standard padding for encryption. */\n    private static final byte[] ENCRYPT_PADDING =\n    {\n        (byte)0x28, (byte)0xBF, (byte)0x4E, (byte)0x5E, (byte)0x4E,\n        (byte)0x75, (byte)0x8A, (byte)0x41, (byte)0x64, (byte)0x00,\n        (byte)0x4E, (byte)0x56, (byte)0xFF, (byte)0xFA, (byte)0x01,\n        (byte)0x08, (byte)0x2E, (byte)0x2E, (byte)0x00, (byte)0xB6,\n        (byte)0xD0, (byte)0x68, (byte)0x3E, (byte)0x80, (byte)0x2F,\n        (byte)0x0C, (byte)0xA9, (byte)0xFE, (byte)0x64, (byte)0x53,\n        (byte)0x69, (byte)0x7A\n    };\n\n    // hashes used for Algorithm 2.B, depending on remainder from E modulo 3\n    private static final String[] HASHES_2B = new String[] {\"SHA-256\", \"SHA-384\", \"SHA-512\"};\n\n    private static final int DEFAULT_VERSION = 1;\n\n    private StandardProtectionPolicy policy;\n\n    /**\n     * Constructor.\n     */\n    public StandardSecurityHandler()\n    {\n    }\n\n    /**\n     * Constructor used for encryption.\n     *\n     * @param p The protection policy.\n     */\n    public StandardSecurityHandler(StandardProtectionPolicy p)\n    {\n        policy = p;\n        keyLength = policy.getEncryptionKeyLength();\n    }\n\n    /**\n     * Computes the version number of the StandardSecurityHandler\n     * regarding the encryption key length.\n     * See PDF Spec 1.6 p 93 and PDF 1.7 AEL3\n     *\n     * @return The computed version number.\n     */\n    private int computeVersionNumber()\n    {\n        if(keyLength == 40)\n        {\n            return DEFAULT_VERSION;\n        }\n        else if (keyLength == 128 && policy.isPreferAES())\n        {\n            return 4;\n        }\n        else if (keyLength == 256)\n        {\n            return 5;\n        }\n\n        return 2;\n    }\n\n    /**\n     * Computes the revision version of the StandardSecurityHandler to\n     * use regarding the version number and the permissions bits set.\n     * See PDF Spec 1.6 p98\n     * \n     * @param version The version number.\n     *\n     * @return The computed revision number.\n     */\n    private int computeRevisionNumber(int version)\n    {\n        if(version < 2 && !policy.getPermissions().hasAnyRevision3PermissionSet())\n        {\n            return 2;\n        }\n        if (version == 5)\n        {\n            // note about revision 5: \"Shall not be used. This value was used by a deprecated Adobe extension.\"\n            return 6;    \n        }\n        if (version == 4)\n        {\n            return 4;\n        }\n        if ( version == 2 || version == 3 || policy.getPermissions().hasAnyRevision3PermissionSet())\n        {\n            return 3;\n        }\n        return 4;\n    }\n\n    /**\n     * Prepares everything to decrypt the document.\n     *\n     * Only if decryption of single objects is needed this should be called.\n     *\n     * @param encryption  encryption dictionary\n     * @param documentIDArray  document id\n     * @param decryptionMaterial Information used to decrypt the document.\n     *\n     * @throws IOException If there is an error accessing data.\n     */\n    @Override\n    public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                     DecryptionMaterial decryptionMaterial)\n                                     throws IOException\n    {\n        if(!(decryptionMaterial instanceof StandardDecryptionMaterial))\n        {\n            throw new IOException(\"Decryption material is not compatible with the document\");\n        }\n        setDecryptMetadata(encryption.isEncryptMetaData());\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n\n        String password = material.getPassword();\n        if(password == null)\n        {\n            password = \"\";\n        }\n\n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        int dicLength = encryption.getVersion() == 1 ? 5 : encryption.getLength() / 8;\n\n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);\n\n        // we need to know whether the meta data was encrypted for password calculation\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        \n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        byte[] ue = null, oe = null;\n\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        \n        AccessPermission currentAccessPermission;\n\n        if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                                 dicPermissions, documentIDBytes, dicRevision,\n                                 dicLength, encryptMetadata) )\n        {\n            currentAccessPermission = AccessPermission.getOwnerAccessPermission();\n            setCurrentAccessPermission(currentAccessPermission);\n            \n            byte[] computedPassword;\n            if (dicRevision == 6 || dicRevision == 5)\n            {\n                computedPassword = password.getBytes(passwordCharset);\n            }\n            else\n            {\n                computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                        ownerKey, dicRevision, dicLength );\n            }\n            \n            encryptionKey =\n                computeEncryptedKey(\n                    computedPassword,\n                    ownerKey, userKey, oe, ue,\n                    dicPermissions,\n                    documentIDBytes,\n                    dicRevision,\n                    dicLength,\n                    encryptMetadata, true );\n        }\n        else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                           dicPermissions, documentIDBytes, dicRevision,\n                           dicLength, encryptMetadata) )\n        {\n            currentAccessPermission = new AccessPermission(dicPermissions);\n            setCurrentAccessPermission(currentAccessPermission);\n            \n            encryptionKey =\n                computeEncryptedKey(\n                    password.getBytes(passwordCharset),\n                    ownerKey, userKey, oe, ue,\n                    dicPermissions,\n                    documentIDBytes,\n                    dicRevision,\n                    dicLength,\n                    encryptMetadata, false );\n        }\n        else\n        {\n            throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n        }\n\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }\n\n        if (encryption.getVersion() == 4 || encryption.getVersion() == 5)\n        {\n            // detect whether AES encryption is used. This assumes that the encryption algo is \n            // stored in the PDCryptFilterDictionary\n            // However, crypt filters are used only when V is 4 or 5.\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n\n            if (stdCryptFilterDictionary != null)\n            {\n                COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n                setAES(COSName.AESV2.equals(cryptFilterMethod) || \n                       COSName.AESV3.equals(cryptFilterMethod));\n            }\n        }\n    }\n\n    private byte[] getDocumentIDBytes(COSArray documentIDArray)\n    {\n        //some documents may not have document id, see\n        //test\\encryption\\encrypted_doc_no_id.pdf\n        byte[] documentIDBytes;\n        if( documentIDArray != null && documentIDArray.size() >= 1 )\n        {\n            COSString id = (COSString)documentIDArray.getObject( 0 );\n            documentIDBytes = id.getBytes();\n        }\n        else\n        {\n            documentIDBytes = new byte[0];\n        }\n        return documentIDBytes;\n    }\n\n    // Algorithm 13: validate permissions (\"Perms\" field). Relaxed to accomodate buggy encoders\n    // https://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/adobe_supplement_iso32000.pdf\n    private void validatePerms(PDEncryption encryption, int dicPermissions, boolean encryptMetadata) throws IOException\n    {\n        try\n        {\n            // \"Decrypt the 16-byte Perms string using AES-256 in ECB mode with an \n            // initialization vector of zero and the file encryption key as the key.\"\n            Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(encryptionKey, \"AES\"));\n            byte[] perms = cipher.doFinal(encryption.getPerms());\n            \n            // \"Verify that bytes 9-11 of the result are the characters \u2018a\u2019, \u2018d\u2019, \u2018b\u2019.\"\n            if (perms[9] != 'a' || perms[10] != 'd' || perms[11] != 'b')\n            {\n                LOG.warn(\"Verification of permissions failed (constant)\");\n            }\n            \n            // \"Bytes 0-3 of the decrypted Perms entry, treated as a little-endian integer, \n            // are the user permissions. They should match the value in the P key.\"\n            int permsP = perms[0] & 0xFF | (perms[1] & 0xFF) << 8 | (perms[2] & 0xFF) << 16 |\n                    (perms[3] & 0xFF) << 24;\n            \n            if (permsP != dicPermissions)\n            {\n                LOG.warn(\"Verification of permissions failed (\" + String.format(\"%08X\",permsP) +\n                        \" != \" + String.format(\"%08X\",dicPermissions) + \")\");\n            }\n            \n            if (encryptMetadata && perms[8] != 'T' || !encryptMetadata && perms[8] != 'F')\n            {\n                LOG.warn(\"Verification of permissions failed (EncryptMetadata)\");\n            }\n        }\n        catch (GeneralSecurityException e)\n        {\n            logIfStrongEncryptionMissing();\n            throw new IOException(e);\n        }\n    }\n    \n    /**\n     * Prepare document for encryption.\n     *\n     * @param document The documeent to encrypt.\n     *\n     * @throws IOException If there is an error accessing data.\n     */\n    @Override\n    public void prepareDocumentForEncryption(PDDocument document) throws IOException\n    {\n        PDEncryption encryptionDictionary = document.getEncryption();\n        if(encryptionDictionary == null)\n        {\n            encryptionDictionary = new PDEncryption();\n        }\n        int version = computeVersionNumber();\n        int revision = computeRevisionNumber(version);\n        encryptionDictionary.setFilter(FILTER);\n        encryptionDictionary.setVersion(version);\n        if (version != 4 && version != 5)\n        {\n            // remove CF, StmF, and StrF entries that may be left from a previous encryption\n            encryptionDictionary.removeV45filters();\n        }\n        encryptionDictionary.setRevision(revision);\n        encryptionDictionary.setLength(keyLength);\n\n        String ownerPassword = policy.getOwnerPassword();\n        String userPassword = policy.getUserPassword();\n        if( ownerPassword == null )\n        {\n            ownerPassword = \"\";\n        }\n        if( userPassword == null )\n        {\n            userPassword = \"\";\n        }\n \n        // If no owner password is set, use the user password instead.\n        if (ownerPassword.isEmpty())\n        {\n            ownerPassword = userPassword;\n        }\n\n        int permissionInt = policy.getPermissions().getPermissionBytes();\n\n        encryptionDictionary.setPermissions(permissionInt);\n\n        int length = keyLength/8;\n\n        if (revision == 6)\n        {\n            prepareEncryptionDictRev6(ownerPassword, userPassword, encryptionDictionary, permissionInt);\n        }\n        else\n        {\n            prepareEncryptionDictRev2345(ownerPassword, userPassword, encryptionDictionary, permissionInt,\n                    document, revision, length);\n        }\n\n        document.setEncryptionDictionary( encryptionDictionary );\n        document.getDocument().setEncryptionDictionary(encryptionDictionary.getCOSDictionary());\n    }\n\n    private void prepareEncryptionDictRev6(String ownerPassword, String userPassword,\n            PDEncryption encryptionDictionary, int permissionInt)\n            throws IOException\n    {\n        try\n        {\n            SecureRandom rnd = new SecureRandom();\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n\n            // make a random 256-bit file encryption key\n            encryptionKey = new byte[32];\n            rnd.nextBytes(encryptionKey);\n\n            // Algorithm 8a: Compute U\n            byte[] userPasswordBytes = truncate127(userPassword.getBytes(Charsets.UTF_8));\n            byte[] userValidationSalt = new byte[8];\n            byte[] userKeySalt = new byte[8];\n            rnd.nextBytes(userValidationSalt);\n            rnd.nextBytes(userKeySalt);\n            byte[] hashU = computeHash2B(concat(userPasswordBytes, userValidationSalt),\n                    userPasswordBytes, null);\n            byte[] u = concat(hashU, userValidationSalt, userKeySalt);\n\n            // Algorithm 8b: Compute UE\n            byte[] hashUE = computeHash2B(concat(userPasswordBytes, userKeySalt),\n                    userPasswordBytes, null);\n            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(hashUE, \"AES\"),\n                    new IvParameterSpec(new byte[16]));\n            byte[] ue = cipher.doFinal(encryptionKey);\n\n            // Algorithm 9a: Compute O\n            byte[] ownerPasswordBytes = truncate127(ownerPassword.getBytes(Charsets.UTF_8));\n            byte[] ownerValidationSalt = new byte[8];\n            byte[] ownerKeySalt = new byte[8];\n            rnd.nextBytes(ownerValidationSalt);\n            rnd.nextBytes(ownerKeySalt);\n            byte[] hashO = computeHash2B(concat(ownerPasswordBytes, ownerValidationSalt, u),\n                    ownerPasswordBytes, u);\n            byte[] o = concat(hashO, ownerValidationSalt, ownerKeySalt);\n\n            // Algorithm 9b: Compute OE\n            byte[] hashOE = computeHash2B(concat(ownerPasswordBytes, ownerKeySalt, u),\n                    ownerPasswordBytes, u);\n            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(hashOE, \"AES\"),\n                    new IvParameterSpec(new byte[16]));\n            byte[] oe = cipher.doFinal(encryptionKey);\n\n            // Set keys and other required constants in encryption dictionary\n            encryptionDictionary.setUserKey(u);\n            encryptionDictionary.setUserEncryptionKey(ue);\n            encryptionDictionary.setOwnerKey(o);\n            encryptionDictionary.setOwnerEncryptionKey(oe);\n\n            prepareEncryptionDictAES(encryptionDictionary, COSName.AESV3);\n\n            // Algorithm 10: compute \"Perms\" value\n            byte[] perms = new byte[16];\n            perms[0] = (byte) permissionInt;\n            perms[1] = (byte) (permissionInt >>> 8);\n            perms[2] = (byte) (permissionInt >>> 16);\n            perms[3] = (byte) (permissionInt >>> 24);\n            perms[4] = (byte) 0xFF;\n            perms[5] = (byte) 0xFF;\n            perms[6] = (byte) 0xFF;\n            perms[7] = (byte) 0xFF;\n            perms[8] = 'T';    // we always encrypt Metadata\n            perms[9] = 'a';\n            perms[10] = 'd';\n            perms[11] = 'b';\n            for (int i = 12; i <= 15; i++)\n            {\n                perms[i] = (byte) rnd.nextInt();\n            }\n\n            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(encryptionKey, \"AES\"),\n                    new IvParameterSpec(new byte[16]));\n\n            byte[] permsEnc = cipher.doFinal(perms);\n\n            encryptionDictionary.setPerms(permsEnc);\n        }\n        catch (GeneralSecurityException e)\n        {\n            logIfStrongEncryptionMissing();\n            throw new IOException(e);\n        }\n    }\n\n    private void prepareEncryptionDictRev2345(String ownerPassword, String userPassword,\n            PDEncryption encryptionDictionary, int permissionInt, PDDocument document, \n            int revision, int length)\n            throws IOException\n    {\n        COSArray idArray = document.getDocument().getDocumentID();\n\n        //check if the document has an id yet.  If it does not then generate one\n        if (idArray == null || idArray.size() < 2)\n        {\n            MessageDigest md = MessageDigests.getMD5();\n            BigInteger time = BigInteger.valueOf(System.currentTimeMillis());\n            md.update(time.toByteArray());\n            md.update(ownerPassword.getBytes(Charsets.ISO_8859_1));\n            md.update(userPassword.getBytes(Charsets.ISO_8859_1));\n            md.update(document.getDocument().toString().getBytes(Charsets.ISO_8859_1));\n\n            byte[] id = md.digest(this.toString().getBytes(Charsets.ISO_8859_1));\n            COSString idString = new COSString(id);\n\n            idArray = new COSArray();\n            idArray.add(idString);\n            idArray.add(idString);\n            document.getDocument().setDocumentID(idArray);\n        }\n\n        COSString id = (COSString) idArray.getObject(0);\n\n        byte[] ownerBytes = computeOwnerPassword(\n                ownerPassword.getBytes(Charsets.ISO_8859_1),\n                userPassword.getBytes(Charsets.ISO_8859_1), revision, length);\n\n        byte[] userBytes = computeUserPassword(\n                userPassword.getBytes(Charsets.ISO_8859_1),\n                ownerBytes, permissionInt, id.getBytes(), revision, length, true);\n\n        encryptionKey = computeEncryptedKey(userPassword.getBytes(Charsets.ISO_8859_1), ownerBytes,\n                null, null, null, permissionInt, id.getBytes(), revision, length, true, false);\n\n        encryptionDictionary.setOwnerKey(ownerBytes);\n        encryptionDictionary.setUserKey(userBytes);\n        \n        if (revision == 4)\n        {\n            prepareEncryptionDictAES(encryptionDictionary, COSName.AESV2);\n        }\n    }\n\n    private void prepareEncryptionDictAES(PDEncryption encryptionDictionary, COSName aesVName)\n    {\n        PDCryptFilterDictionary cryptFilterDictionary = new PDCryptFilterDictionary();\n        cryptFilterDictionary.setCryptFilterMethod(aesVName);\n        cryptFilterDictionary.setLength(keyLength);\n        encryptionDictionary.setStdCryptFilterDictionary(cryptFilterDictionary);\n        encryptionDictionary.setStreamFilterName(COSName.STD_CF);\n        encryptionDictionary.setStringFilterName(COSName.STD_CF);\n        setAES(true);\n    }\n\n    /**\n     * Check for owner password.\n     *\n     * @param ownerPassword The owner password.\n     * @param user The u entry of the encryption dictionary.\n     * @param owner The o entry of the encryption dictionary.\n     * @param permissions The set of permissions on the document.\n     * @param id The document id.\n     * @param encRevision The encryption algorithm revision.\n     * @param length The encryption key length.\n     * @param encryptMetadata The encryption metadata\n     *\n     * @return True If the ownerPassword param is the owner password.\n     *\n     * @throws IOException If there is an error accessing data.\n     */\n    public boolean isOwnerPassword(byte[] ownerPassword, byte[] user, byte[] owner,\n                                   int permissions, byte[] id, int encRevision, int length,\n                                   boolean encryptMetadata) throws IOException\n    {\n        if (encRevision == 6 || encRevision == 5)\n        {            \n            byte[] truncatedOwnerPassword = truncate127(ownerPassword);\n            \n            byte[] oHash = new byte[32];\n            byte[] oValidationSalt = new byte[8];\n            System.arraycopy(owner, 0, oHash, 0, 32);\n            System.arraycopy(owner, 32, oValidationSalt, 0, 8);\n            \n            byte[] hash;\n            if (encRevision == 5)\n            {\n                hash = computeSHA256(truncatedOwnerPassword, oValidationSalt, user);\n            }\n            else\n            {\n                hash = computeHash2A(truncatedOwnerPassword, oValidationSalt, user);\n            }\n\n            return Arrays.equals(hash, oHash);\n        }\n        else\n        {\n            byte[] userPassword = getUserPassword( ownerPassword, owner, encRevision, length );\n            return isUserPassword( userPassword, user, owner, permissions, id, encRevision, length,\n                                   encryptMetadata );\n        }\n    }\n\n    /**\n     * Get the user password based on the owner password.\n     *\n     * @param ownerPassword The plaintext owner password.\n     * @param owner The o entry of the encryption dictionary.\n     * @param encRevision The encryption revision number.\n     * @param length The key length.\n     *\n     * @return The u entry of the encryption dictionary.\n     *\n     * @throws IOException If there is an error accessing data while generating the user password.\n     */\n    public byte[] getUserPassword( byte[] ownerPassword,  byte[] owner, int encRevision,\n                                   int length ) throws IOException\n    {\n        ByteArrayOutputStream result = new ByteArrayOutputStream();\n        byte[] rc4Key = computeRC4key(ownerPassword, encRevision, length);\n\n        if( encRevision == 2 )\n        {\n            encryptDataRC4(rc4Key, owner, result);\n        }\n        else if( encRevision == 3 || encRevision == 4)\n        {\n            byte[] iterationKey = new byte[ rc4Key.length ];\n            byte[] otemp = new byte[ owner.length ];\n            System.arraycopy( owner, 0, otemp, 0, owner.length );\n            \n            for( int i=19; i>=0; i-- )\n            {\n                System.arraycopy( rc4Key, 0, iterationKey, 0, rc4Key.length );\n                for( int j=0; j< iterationKey.length; j++ )\n                {\n                    iterationKey[j] = (byte)(iterationKey[j] ^ (byte)i);\n                }\n                result.reset();\n                encryptDataRC4(iterationKey, otemp, result);\n                otemp = result.toByteArray();\n            }\n        }\n        return result.toByteArray();\n    }\n\n    /**\n     * Compute the encryption key.\n     *\n     * @param password The password to compute the encrypted key.\n     * @param o The O entry of the encryption dictionary.\n     * @param u The U entry of the encryption dictionary.\n     * @param oe The OE entry of the encryption dictionary.\n     * @param ue The UE entry of the encryption dictionary.\n     * @param permissions The permissions for the document.\n     * @param id The document id.\n     * @param encRevision The revision of the encryption algorithm.\n     * @param length The length of the encryption key.\n     * @param encryptMetadata The encryption metadata\n     * @param isOwnerPassword whether the password given is the owner password (for revision 6)\n     *\n     * @return The encrypted key bytes.\n     *\n     * @throws IOException If there is an error with encryption.\n     */\n    public byte[] computeEncryptedKey(byte[] password, byte[] o, byte[] u, byte[] oe, byte[] ue,\n                                      int permissions, byte[] id, int encRevision, int length,\n                                      boolean encryptMetadata, boolean isOwnerPassword)\n                                      throws IOException\n    {\n        if (encRevision == 6 || encRevision == 5)\n        {\n            return computeEncryptedKeyRev56(password, isOwnerPassword, o, u, oe, ue, encRevision);\n        }\n        else\n        {\n            return computeEncryptedKeyRev234(password, o, permissions, id, encryptMetadata, length, encRevision);\n        }\n    }\n\n    private byte[] computeEncryptedKeyRev234(byte[] password, byte[] o, int permissions, \n            byte[] id, boolean encryptMetadata, int length, int encRevision)\n    {\n        //Algorithm 2, based on MD5\n\n        //PDFReference 1.4 pg 78\n        byte[] padded = truncateOrPad(password);\n\n        MessageDigest md = MessageDigests.getMD5();\n        md.update(padded);\n\n        md.update(o);\n\n        md.update((byte) permissions);\n        md.update((byte) (permissions >>> 8));\n        md.update((byte) (permissions >>> 16));\n        md.update((byte) (permissions >>> 24));\n\n        md.update(id);\n\n        //(Security handlers of revision 4 or greater) If document metadata is not being\n        // encrypted, pass 4 bytes with the value 0xFFFFFFFF to the MD5 hash function.\n        //see 7.6.3.3 Algorithm 2 Step f of PDF 32000-1:2008\n        if (encRevision == 4 && !encryptMetadata)\n        {\n            md.update(new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff });\n        }\n        byte[] digest = md.digest();\n\n        if (encRevision == 3 || encRevision == 4)\n        {\n            for (int i = 0; i < 50; i++)\n            {\n                md.update(digest, 0, length);\n                digest = md.digest();\n            }\n        }\n\n        byte[] result = new byte[length];\n        System.arraycopy(digest, 0, result, 0, length);\n        return result;\n    }\n\n    private byte[] computeEncryptedKeyRev56(byte[] password, boolean isOwnerPassword, \n            byte[] o, byte[] u, byte[] oe, byte[] ue, int encRevision) \n            throws IOException\n    {\n        byte[] hash, fileKeyEnc;\n\n        if (isOwnerPassword)\n        {\n            byte[] oKeySalt = new byte[8];\n            System.arraycopy(o, 40, oKeySalt, 0, 8);\n\n            if (encRevision == 5)\n            {\n                hash = computeSHA256(password, oKeySalt, u);\n            }\n            else\n            {\n                hash = computeHash2A(password, oKeySalt, u);\n            }\n\n            fileKeyEnc = oe;\n        }\n        else\n        {\n            byte[] uKeySalt = new byte[8];\n            System.arraycopy(u, 40, uKeySalt, 0, 8);\n\n            if (encRevision == 5)\n            {\n                hash = computeSHA256(password, uKeySalt, null);\n            }\n            else\n            {\n                hash = computeHash2A(password, uKeySalt, null);\n            }\n\n            fileKeyEnc = ue;\n        }\n        try\n        {\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(hash, \"AES\"), new IvParameterSpec(new byte[16]));\n            return cipher.doFinal(fileKeyEnc);\n        }\n        catch (GeneralSecurityException e)\n        {\n            logIfStrongEncryptionMissing();\n            throw new IOException(e);\n        }\n    }\n\n    /**\n     * This will compute the user password hash.\n     *\n     * @param password The plain text password.\n     * @param owner The owner password hash.\n     * @param permissions The document permissions.\n     * @param id The document id.\n     * @param encRevision The revision of the encryption.\n     * @param length The length of the encryption key.\n     * @param encryptMetadata The encryption metadata\n     *\n     * @return The user password.\n     *\n     * @throws IOException if the password could not be computed\n     */\n    public byte[] computeUserPassword(byte[] password, byte[] owner, int permissions,\n                                      byte[] id, int encRevision, int length,\n                                      boolean encryptMetadata) throws IOException\n    {\n        ByteArrayOutputStream result = new ByteArrayOutputStream();\n        byte[] encKey = computeEncryptedKey( password, owner, null, null, null, permissions,\n                id, encRevision, length, encryptMetadata, true );\n        \n        if( encRevision == 2 )\n        {\n            encryptDataRC4(encKey, ENCRYPT_PADDING, result );\n        }\n        else if( encRevision == 3 || encRevision == 4 )\n        {\n            MessageDigest md = MessageDigests.getMD5();\n            md.update( ENCRYPT_PADDING );\n\n            md.update( id );\n            result.write( md.digest() );\n\n            byte[] iterationKey = new byte[ encKey.length ];\n            for( int i=0; i<20; i++ )\n            {\n                System.arraycopy( encKey, 0, iterationKey, 0, iterationKey.length );\n                for( int j=0; j< iterationKey.length; j++ )\n                {\n                    iterationKey[j] = (byte)(iterationKey[j] ^ i);\n                }\n                ByteArrayInputStream input = new ByteArrayInputStream(result.toByteArray());\n                result.reset();\n                encryptDataRC4(iterationKey, input, result);\n            }\n\n            byte[] finalResult = new byte[32];\n            System.arraycopy( result.toByteArray(), 0, finalResult, 0, 16 );\n            System.arraycopy( ENCRYPT_PADDING, 0, finalResult, 16, 16 );\n            result.reset();\n            result.write( finalResult );\n        }\n        return result.toByteArray();\n    }\n\n    /**\n     * Compute the owner entry in the encryption dictionary.\n     *\n     * @param ownerPassword The plaintext owner password.\n     * @param userPassword The plaintext user password.\n     * @param encRevision The revision number of the encryption algorithm.\n     * @param length The length of the encryption key.\n     *\n     * @return The o entry of the encryption dictionary.\n     *\n     * @throws IOException if the owner password could not be computed\n     */\n    public byte[] computeOwnerPassword(byte[] ownerPassword, byte[] userPassword,\n                                       int encRevision,  int length ) throws IOException\n    {\n        if( encRevision == 2 && length != 5 )\n        {\n            throw new IOException(\"Expected length=5 actual=\" + length );\n        }\n        \n        byte[] rc4Key = computeRC4key(ownerPassword, encRevision, length);\n        byte[] paddedUser = truncateOrPad( userPassword );\n\n        ByteArrayOutputStream encrypted = new ByteArrayOutputStream();\n        encryptDataRC4(rc4Key, new ByteArrayInputStream(paddedUser), encrypted);\n\n        if( encRevision == 3 || encRevision == 4 )\n        {\n            byte[] iterationKey = new byte[ rc4Key.length ];\n            for( int i=1; i<20; i++ )\n            {\n                System.arraycopy( rc4Key, 0, iterationKey, 0, rc4Key.length );\n                for( int j=0; j< iterationKey.length; j++ )\n                {\n                    iterationKey[j] = (byte)(iterationKey[j] ^ (byte)i);\n                }\n                ByteArrayInputStream input = new ByteArrayInputStream( encrypted.toByteArray() );\n                encrypted.reset();\n                encryptDataRC4(iterationKey, input, encrypted );\n            }\n        }\n\n        return encrypted.toByteArray();\n    }\n\n    // steps (a) to (d) of \"Algorithm 3: Computing the encryption dictionary?s O (owner password) value\".\n    private byte[] computeRC4key(byte[] ownerPassword, int encRevision, int length)\n    {\n        MessageDigest md = MessageDigests.getMD5();\n        byte[] digest = md.digest(truncateOrPad(ownerPassword));\n        if (encRevision == 3 || encRevision == 4)\n        {\n            for (int i = 0; i < 50; i++)\n            {\n                // this deviates from the spec - however, omitting the length\n                // parameter prevents the file to be opened in Adobe Reader\n                // with the owner password when the key length is 40 bit (= 5 bytes)\n                md.update(digest, 0, length);\n                digest = md.digest();\n            }\n        }\n        byte[] rc4Key = new byte[length];\n        System.arraycopy(digest, 0, rc4Key, 0, length);\n        return rc4Key;\n    }\n\n\n    /**\n     * This will take the password and truncate or pad it as necessary.\n     *\n     * @param password The password to pad or truncate.\n     *\n     * @return The padded or truncated password.\n     */\n    private byte[] truncateOrPad( byte[] password )\n    {\n        byte[] padded = new byte[ ENCRYPT_PADDING.length ];\n        int bytesBeforePad = Math.min( password.length, padded.length );\n        System.arraycopy( password, 0, padded, 0, bytesBeforePad );\n        System.arraycopy( ENCRYPT_PADDING, 0, padded, bytesBeforePad,\n                          ENCRYPT_PADDING.length-bytesBeforePad );\n        return padded;\n    }\n\n    /**\n     * Check if a plaintext password is the user password.\n     *\n     * @param password The plaintext password.\n     * @param user The u entry of the encryption dictionary.\n     * @param owner The o entry of the encryption dictionary.\n     * @param permissions The permissions set in the PDF.\n     * @param id The document id used for encryption.\n     * @param encRevision The revision of the encryption algorithm.\n     * @param length The length of the encryption key.\n     * @param encryptMetadata The encryption metadata\n     *\n     * @return true If the plaintext password is the user password.\n     *\n     * @throws IOException If there is an error accessing data.\n     */\n    public boolean isUserPassword(byte[] password, byte[] user, byte[] owner, int permissions,\n                                  byte[] id, int encRevision, int length, boolean encryptMetadata)\n                                  throws IOException\n    {\n        if( encRevision == 2 )\n        {\n            byte[] passwordBytes = computeUserPassword( password, owner, permissions, id, encRevision,\n                                                        length, encryptMetadata );\n            return Arrays.equals(user, passwordBytes);\n        }\n        else if( encRevision == 3 || encRevision == 4 )\n        {\n            byte[] passwordBytes = computeUserPassword( password, owner, permissions, id, encRevision,\n                                                        length, encryptMetadata );\n            // compare first 16 bytes only\n            return Arrays.equals(Arrays.copyOf(user, 16), Arrays.copyOf(passwordBytes, 16));\n        }\n        else if (encRevision == 6 || encRevision == 5)\n        {\n            byte[] truncatedPassword = truncate127(password);\n            \n            byte[] uHash = new byte[32];\n            byte[] uValidationSalt = new byte[8];\n            System.arraycopy(user, 0, uHash, 0, 32);\n            System.arraycopy(user, 32, uValidationSalt, 0, 8);\n\n            byte[] hash;\n            if (encRevision == 5)\n            {\n                hash = computeSHA256(truncatedPassword, uValidationSalt, null);\n            }\n            else\n            {\n                hash = computeHash2A(truncatedPassword, uValidationSalt, null);\n            }\n\n            return Arrays.equals(hash, uHash);\n        }\n        else\n        {\n            throw new IOException( \"Unknown Encryption Revision \" + encRevision );\n        }\n    }\n\n    /**\n     * Check if a plaintext password is the user password.\n     *\n     * @param password The plaintext password.\n     * @param user The u entry of the encryption dictionary.\n     * @param owner The o entry of the encryption dictionary.\n     * @param permissions The permissions set in the PDF.\n     * @param id The document id used for encryption.\n     * @param encRevision The revision of the encryption algorithm.\n     * @param length The length of the encryption key.\n     * @param encryptMetadata The encryption metadata\n     *\n     * @return true If the plaintext password is the user password.\n     *\n     * @throws IOException If there is an error accessing data.\n     */\n    public boolean isUserPassword(String password, byte[] user, byte[] owner, int permissions,\n                                  byte[] id, int encRevision,  int length, boolean encryptMetadata)\n                                  throws IOException\n    {\n        if (encRevision == 6 || encRevision == 5)\n        {\n            return isUserPassword(password.getBytes(Charsets.UTF_8), user, owner, permissions, id,\n                    encRevision, length, encryptMetadata);\n        }\n        else\n        {\n            return isUserPassword(password.getBytes(Charsets.ISO_8859_1), user, owner, permissions, id,\n                    encRevision, length, encryptMetadata);\n        }\n    }\n\n    /**\n     * Check for owner password.\n     *\n     * @param password The owner password.\n     * @param user The u entry of the encryption dictionary.\n     * @param owner The o entry of the encryption dictionary.\n     * @param permissions The set of permissions on the document.\n     * @param id The document id.\n     * @param encRevision The encryption algorithm revision.\n     * @param length The encryption key length.\n     * @param encryptMetadata The encryption metadata\n     *\n     * @return True If the ownerPassword param is the owner password.\n     *\n     * @throws IOException If there is an error accessing data.\n     */\n    public boolean isOwnerPassword(String password, byte[] user, byte[] owner, int permissions,\n                                   byte[] id, int encRevision, int length, boolean encryptMetadata)\n                                   throws IOException\n    {\n        return isOwnerPassword(password.getBytes(Charsets.ISO_8859_1), user,owner,permissions, id,\n                               encRevision, length, encryptMetadata);\n    }\n\n    // Algorithm 2.A from ISO 32000-1\n    private byte[] computeHash2A(byte[] password, byte[] salt, byte[] u) throws IOException\n    {\n        byte[] userKey;\n        if (u == null)\n        {\n            userKey = new byte[0];\n        }\n        else if (u.length < 48)\n        {\n            throw new IOException(\"Bad U length\");\n        }\n        else if (u.length > 48)\n        {\n            // must truncate\n            userKey = new byte[48];\n            System.arraycopy(u, 0, userKey, 0, 48);\n        }\n        else\n        {\n            userKey = u;\n        }\n\n        byte[] truncatedPassword = truncate127(password);\n        byte[] input = concat(truncatedPassword, salt, userKey);\n        return computeHash2B(input, truncatedPassword, userKey);\n    }\n    \n    // Algorithm 2.B from ISO 32000-2\n    private static byte[] computeHash2B(byte[] input, byte[] password, byte[] userKey)\n            throws IOException\n    {\n        try\n        {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            byte[] k = md.digest(input);\n            \n            byte[] e = null;\n            for (int round = 0; round < 64 || ((int)e[e.length-1] & 0xFF) > round - 32; round++)\n            {                \n                byte[] k1;\n                if (userKey != null && userKey.length >= 48)\n                {\n                    k1 = new byte[64*(password.length + k.length + 48)];\n                }\n                else\n                {\n                    k1 = new byte[64*(password.length + k.length)];\n                }\n                \n                int pos = 0;\n                for (int i = 0; i < 64; i++)\n                {\n                    System.arraycopy(password, 0, k1, pos, password.length);\n                    pos += password.length;\n                    System.arraycopy(k, 0, k1, pos, k.length);\n                    pos += k.length;\n                    if (userKey != null && userKey.length >= 48)\n                    {\n                        System.arraycopy(userKey, 0, k1, pos, 48);\n                        pos += 48;\n                    }\n                }\n                \n                byte[] kFirst = new byte[16];\n                byte[] kSecond = new byte[16];\n                System.arraycopy(k, 0, kFirst, 0, 16);\n                System.arraycopy(k, 16, kSecond, 0, 16);\n                \n                Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n                SecretKeySpec keySpec = new SecretKeySpec(kFirst, \"AES\");\n                IvParameterSpec ivSpec = new IvParameterSpec(kSecond);\n                cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n                e = cipher.doFinal(k1);\n                \n                byte[] eFirst = new byte[16];\n                System.arraycopy(e, 0, eFirst, 0, 16);\n                BigInteger bi = new BigInteger(1, eFirst);\n                BigInteger remainder = bi.mod(new BigInteger(\"3\"));\n                String nextHash = HASHES_2B[remainder.intValue()];\n                \n                md = MessageDigest.getInstance(nextHash);\n                k = md.digest(e);\n            }\n            \n            if (k.length > 32)\n            {\n                byte[] kTrunc = new byte[32];\n                System.arraycopy(k, 0, kTrunc, 0, 32);\n                return kTrunc;\n            }\n            else\n            {\n                return k;\n            }            \n        }\n        catch (GeneralSecurityException e)\n        {\n            logIfStrongEncryptionMissing();\n            throw new IOException(e);\n        }\n    }\n\n    private static byte[] computeSHA256(byte[] input, byte[] password, byte[] userKey) \n            throws IOException\n    {\n        try\n        {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(input);\n            md.update(password);\n            return userKey == null ? md.digest() : md.digest(userKey);\n        }\n        catch (NoSuchAlgorithmException e)\n        {\n            throw new IOException(e);\n        }\n    }\n    \n    private static byte[] concat(byte[] a, byte[] b)\n    {\n        byte[] o = new byte[a.length + b.length];\n        System.arraycopy(a, 0, o, 0, a.length);\n        System.arraycopy(b, 0, o, a.length, b.length);\n        return o;\n    }\n    \n    private static byte[] concat(byte[] a, byte[] b, byte[] c)\n    {\n        byte[] o = new byte[a.length + b.length + c.length];\n        System.arraycopy(a, 0, o, 0, a.length);\n        System.arraycopy(b, 0, o, a.length, b.length);\n        System.arraycopy(c, 0, o, a.length + b.length, c.length);\n        return o;\n    }\n    \n    private static byte[] truncate127(byte[] in)\n    {\n        if (in.length <= 127)\n        {\n            return in;\n        }\n        byte[] trunc = new byte[127];\n        System.arraycopy(in, 0, trunc, 0, 127);\n        return trunc;\n    }\n\n    private static void logIfStrongEncryptionMissing()\n    {\n        try\n        {\n            if (Cipher.getMaxAllowedKeyLength(\"AES\") != Integer.MAX_VALUE)\n            {\n                LOG.warn(\"JCE unlimited strength jurisdiction policy files are not installed\");\n            }\n        }\n        catch (NoSuchAlgorithmException ex)\n        {\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean hasProtectionPolicy()\n    {\n        return policy != null;\n    }\n}\n",
        "human_patch_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.pdfbox.pdmodel.encryption;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.nio.charset.Charset;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Arrays;\n \nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport org.apache.pdfbox.cos.COSArray;\nimport org.apache.pdfbox.cos.COSName;\nimport org.apache.pdfbox.cos.COSString;\nimport org.apache.pdfbox.pdmodel.PDDocument;\nimport org.apache.pdfbox.util.Charsets;\n\n/**\n * The standard security handler. This security handler protects document with password.\n * @see StandardProtectionPolicy to see how to protect document with this security handler.\n * @author Ben Litchfield\n * @author Benoit Guillon\n * @author Manuel Kasper\n */\npublic final class StandardSecurityHandler extends SecurityHandler\n{\n    /**\n     * Log instance.\n     */\n    private static final Log LOG = LogFactory.getLog(StandardSecurityHandler.class);\n\n    /** Type of security handler. */\n    public static final String FILTER = \"Standard\";\n\n    /** Protection policy class for this handler. */\n    public static final Class<?> PROTECTION_POLICY_CLASS = StandardProtectionPolicy.class;\n\n    /** Standard padding for encryption. */\n    private static final byte[] ENCRYPT_PADDING =\n    {\n        (byte)0x28, (byte)0xBF, (byte)0x4E, (byte)0x5E, (byte)0x4E,\n        (byte)0x75, (byte)0x8A, (byte)0x41, (byte)0x64, (byte)0x00,\n        (byte)0x4E, (byte)0x56, (byte)0xFF, (byte)0xFA, (byte)0x01,\n        (byte)0x08, (byte)0x2E, (byte)0x2E, (byte)0x00, (byte)0xB6,\n        (byte)0xD0, (byte)0x68, (byte)0x3E, (byte)0x80, (byte)0x2F,\n        (byte)0x0C, (byte)0xA9, (byte)0xFE, (byte)0x64, (byte)0x53,\n        (byte)0x69, (byte)0x7A\n    };\n\n    // hashes used for Algorithm 2.B, depending on remainder from E modulo 3\n    private static final String[] HASHES_2B = new String[] {\"SHA-256\", \"SHA-384\", \"SHA-512\"};\n\n    private static final int DEFAULT_VERSION = 1;\n\n    private StandardProtectionPolicy policy;\n\n    /**\n     * Constructor.\n     */\n    public StandardSecurityHandler()\n    {\n    }\n\n    /**\n     * Constructor used for encryption.\n     *\n     * @param p The protection policy.\n     */\n    public StandardSecurityHandler(StandardProtectionPolicy p)\n    {\n        policy = p;\n        keyLength = policy.getEncryptionKeyLength();\n    }\n\n    /**\n     * Computes the version number of the StandardSecurityHandler\n     * regarding the encryption key length.\n     * See PDF Spec 1.6 p 93 and PDF 1.7 AEL3\n     *\n     * @return The computed version number.\n     */\n    private int computeVersionNumber()\n    {\n        if(keyLength == 40)\n        {\n            return DEFAULT_VERSION;\n        }\n        else if (keyLength == 128 && policy.isPreferAES())\n        {\n            return 4;\n        }\n        else if (keyLength == 256)\n        {\n            return 5;\n        }\n\n        return 2;\n    }\n\n    /**\n     * Computes the revision version of the StandardSecurityHandler to\n     * use regarding the version number and the permissions bits set.\n     * See PDF Spec 1.6 p98\n     * \n     * @param version The version number.\n     *\n     * @return The computed revision number.\n     */\n    private int computeRevisionNumber(int version)\n    {\n        if(version < 2 && !policy.getPermissions().hasAnyRevision3PermissionSet())\n        {\n            return 2;\n        }\n        if (version == 5)\n        {\n            // note about revision 5: \"Shall not be used. This value was used by a deprecated Adobe extension.\"\n            return 6;    \n        }\n        if (version == 4)\n        {\n            return 4;\n        }\n        if ( version == 2 || version == 3 || policy.getPermissions().hasAnyRevision3PermissionSet())\n        {\n            return 3;\n        }\n        return 4;\n    }\n\n    /**\n     * Prepares everything to decrypt the document.\n     *\n     * Only if decryption of single objects is needed this should be called.\n     *\n     * @param encryption  encryption dictionary\n     * @param documentIDArray  document id\n     * @param decryptionMaterial Information used to decrypt the document.\n     *\n     * @throws IOException If there is an error accessing data.\n     */\n    @Override\n    public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                     DecryptionMaterial decryptionMaterial)\n                                     throws IOException\n    {\n        if(!(decryptionMaterial instanceof StandardDecryptionMaterial))\n        {\n            throw new IOException(\"Decryption material is not compatible with the document\");\n        }\n        setDecryptMetadata(encryption.isEncryptMetaData());\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n\n        String password = material.getPassword();\n        if(password == null)\n        {\n            password = \"\";\n        }\n\n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        int dicLength = encryption.getVersion() == 1 ? 5 : encryption.getLength() / 8;\n\n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);\n\n        // we need to know whether the meta data was encrypted for password calculation\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        \n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        byte[] ue = null, oe = null;\n\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        \n        AccessPermission currentAccessPermission;\n\n        if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                                 dicPermissions, documentIDBytes, dicRevision,\n                                 dicLength, encryptMetadata) )\n        {\n            currentAccessPermission = AccessPermission.getOwnerAccessPermission();\n            setCurrentAccessPermission(currentAccessPermission);\n            \n            byte[] computedPassword;\n            if (dicRevision == 6 || dicRevision == 5)\n            {\n                computedPassword = password.getBytes(passwordCharset);\n            }\n            else\n            {\n                computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                        ownerKey, dicRevision, dicLength );\n            }\n            \n            encryptionKey =\n                computeEncryptedKey(\n                    computedPassword,\n                    ownerKey, userKey, oe, ue,\n                    dicPermissions,\n                    documentIDBytes,\n                    dicRevision,\n                    dicLength,\n                    encryptMetadata, true );\n        }\n        else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                           dicPermissions, documentIDBytes, dicRevision,\n                           dicLength, encryptMetadata) )\n        {\n            currentAccessPermission = new AccessPermission(dicPermissions);\n            currentAccessPermission.setReadOnly();\n            setCurrentAccessPermission(currentAccessPermission);\n            \n            encryptionKey =\n                computeEncryptedKey(\n                    password.getBytes(passwordCharset),\n                    ownerKey, userKey, oe, ue,\n                    dicPermissions,\n                    documentIDBytes,\n                    dicRevision,\n                    dicLength,\n                    encryptMetadata, false );\n        }\n        else\n        {\n            throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n        }\n\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }\n\n        if (encryption.getVersion() == 4 || encryption.getVersion() == 5)\n        {\n            // detect whether AES encryption is used. This assumes that the encryption algo is \n            // stored in the PDCryptFilterDictionary\n            // However, crypt filters are used only when V is 4 or 5.\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n\n            if (stdCryptFilterDictionary != null)\n            {\n                COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n                setAES(COSName.AESV2.equals(cryptFilterMethod) || \n                       COSName.AESV3.equals(cryptFilterMethod));\n            }\n        }\n    }\n\n    private byte[] getDocumentIDBytes(COSArray documentIDArray)\n    {\n        //some documents may not have document id, see\n        //test\\encryption\\encrypted_doc_no_id.pdf\n        byte[] documentIDBytes;\n        if( documentIDArray != null && documentIDArray.size() >= 1 )\n        {\n            COSString id = (COSString)documentIDArray.getObject( 0 );\n            documentIDBytes = id.getBytes();\n        }\n        else\n        {\n            documentIDBytes = new byte[0];\n        }\n        return documentIDBytes;\n    }\n\n    // Algorithm 13: validate permissions (\"Perms\" field). Relaxed to accomodate buggy encoders\n    // https://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/adobe_supplement_iso32000.pdf\n    private void validatePerms(PDEncryption encryption, int dicPermissions, boolean encryptMetadata) throws IOException\n    {\n        try\n        {\n            // \"Decrypt the 16-byte Perms string using AES-256 in ECB mode with an \n            // initialization vector of zero and the file encryption key as the key.\"\n            Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(encryptionKey, \"AES\"));\n            byte[] perms = cipher.doFinal(encryption.getPerms());\n            \n            // \"Verify that bytes 9-11 of the result are the characters \u2018a\u2019, \u2018d\u2019, \u2018b\u2019.\"\n            if (perms[9] != 'a' || perms[10] != 'd' || perms[11] != 'b')\n            {\n                LOG.warn(\"Verification of permissions failed (constant)\");\n            }\n            \n            // \"Bytes 0-3 of the decrypted Perms entry, treated as a little-endian integer, \n            // are the user permissions. They should match the value in the P key.\"\n            int permsP = perms[0] & 0xFF | (perms[1] & 0xFF) << 8 | (perms[2] & 0xFF) << 16 |\n                    (perms[3] & 0xFF) << 24;\n            \n            if (permsP != dicPermissions)\n            {\n                LOG.warn(\"Verification of permissions failed (\" + String.format(\"%08X\",permsP) +\n                        \" != \" + String.format(\"%08X\",dicPermissions) + \")\");\n            }\n            \n            if (encryptMetadata && perms[8] != 'T' || !encryptMetadata && perms[8] != 'F')\n            {\n                LOG.warn(\"Verification of permissions failed (EncryptMetadata)\");\n            }\n        }\n        catch (GeneralSecurityException e)\n        {\n            logIfStrongEncryptionMissing();\n            throw new IOException(e);\n        }\n    }\n    \n    /**\n     * Prepare document for encryption.\n     *\n     * @param document The documeent to encrypt.\n     *\n     * @throws IOException If there is an error accessing data.\n     */\n    @Override\n    public void prepareDocumentForEncryption(PDDocument document) throws IOException\n    {\n        PDEncryption encryptionDictionary = document.getEncryption();\n        if(encryptionDictionary == null)\n        {\n            encryptionDictionary = new PDEncryption();\n        }\n        int version = computeVersionNumber();\n        int revision = computeRevisionNumber(version);\n        encryptionDictionary.setFilter(FILTER);\n        encryptionDictionary.setVersion(version);\n        if (version != 4 && version != 5)\n        {\n            // remove CF, StmF, and StrF entries that may be left from a previous encryption\n            encryptionDictionary.removeV45filters();\n        }\n        encryptionDictionary.setRevision(revision);\n        encryptionDictionary.setLength(keyLength);\n\n        String ownerPassword = policy.getOwnerPassword();\n        String userPassword = policy.getUserPassword();\n        if( ownerPassword == null )\n        {\n            ownerPassword = \"\";\n        }\n        if( userPassword == null )\n        {\n            userPassword = \"\";\n        }\n \n        // If no owner password is set, use the user password instead.\n        if (ownerPassword.isEmpty())\n        {\n            ownerPassword = userPassword;\n        }\n\n        int permissionInt = policy.getPermissions().getPermissionBytes();\n\n        encryptionDictionary.setPermissions(permissionInt);\n\n        int length = keyLength/8;\n\n        if (revision == 6)\n        {\n            prepareEncryptionDictRev6(ownerPassword, userPassword, encryptionDictionary, permissionInt);\n        }\n        else\n        {\n            prepareEncryptionDictRev2345(ownerPassword, userPassword, encryptionDictionary, permissionInt,\n                    document, revision, length);\n        }\n\n        document.setEncryptionDictionary( encryptionDictionary );\n        document.getDocument().setEncryptionDictionary(encryptionDictionary.getCOSDictionary());\n    }\n\n    private void prepareEncryptionDictRev6(String ownerPassword, String userPassword,\n            PDEncryption encryptionDictionary, int permissionInt)\n            throws IOException\n    {\n        try\n        {\n            SecureRandom rnd = new SecureRandom();\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n\n            // make a random 256-bit file encryption key\n            encryptionKey = new byte[32];\n            rnd.nextBytes(encryptionKey);\n\n            // Algorithm 8a: Compute U\n            byte[] userPasswordBytes = truncate127(userPassword.getBytes(Charsets.UTF_8));\n            byte[] userValidationSalt = new byte[8];\n            byte[] userKeySalt = new byte[8];\n            rnd.nextBytes(userValidationSalt);\n            rnd.nextBytes(userKeySalt);\n            byte[] hashU = computeHash2B(concat(userPasswordBytes, userValidationSalt),\n                    userPasswordBytes, null);\n            byte[] u = concat(hashU, userValidationSalt, userKeySalt);\n\n            // Algorithm 8b: Compute UE\n            byte[] hashUE = computeHash2B(concat(userPasswordBytes, userKeySalt),\n                    userPasswordBytes, null);\n            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(hashUE, \"AES\"),\n                    new IvParameterSpec(new byte[16]));\n            byte[] ue = cipher.doFinal(encryptionKey);\n\n            // Algorithm 9a: Compute O\n            byte[] ownerPasswordBytes = truncate127(ownerPassword.getBytes(Charsets.UTF_8));\n            byte[] ownerValidationSalt = new byte[8];\n            byte[] ownerKeySalt = new byte[8];\n            rnd.nextBytes(ownerValidationSalt);\n            rnd.nextBytes(ownerKeySalt);\n            byte[] hashO = computeHash2B(concat(ownerPasswordBytes, ownerValidationSalt, u),\n                    ownerPasswordBytes, u);\n            byte[] o = concat(hashO, ownerValidationSalt, ownerKeySalt);\n\n            // Algorithm 9b: Compute OE\n            byte[] hashOE = computeHash2B(concat(ownerPasswordBytes, ownerKeySalt, u),\n                    ownerPasswordBytes, u);\n            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(hashOE, \"AES\"),\n                    new IvParameterSpec(new byte[16]));\n            byte[] oe = cipher.doFinal(encryptionKey);\n\n            // Set keys and other required constants in encryption dictionary\n            encryptionDictionary.setUserKey(u);\n            encryptionDictionary.setUserEncryptionKey(ue);\n            encryptionDictionary.setOwnerKey(o);\n            encryptionDictionary.setOwnerEncryptionKey(oe);\n\n            prepareEncryptionDictAES(encryptionDictionary, COSName.AESV3);\n\n            // Algorithm 10: compute \"Perms\" value\n            byte[] perms = new byte[16];\n            perms[0] = (byte) permissionInt;\n            perms[1] = (byte) (permissionInt >>> 8);\n            perms[2] = (byte) (permissionInt >>> 16);\n            perms[3] = (byte) (permissionInt >>> 24);\n            perms[4] = (byte) 0xFF;\n            perms[5] = (byte) 0xFF;\n            perms[6] = (byte) 0xFF;\n            perms[7] = (byte) 0xFF;\n            perms[8] = 'T';    // we always encrypt Metadata\n            perms[9] = 'a';\n            perms[10] = 'd';\n            perms[11] = 'b';\n            for (int i = 12; i <= 15; i++)\n            {\n                perms[i] = (byte) rnd.nextInt();\n            }\n\n            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(encryptionKey, \"AES\"),\n                    new IvParameterSpec(new byte[16]));\n\n            byte[] permsEnc = cipher.doFinal(perms);\n\n            encryptionDictionary.setPerms(permsEnc);\n        }\n        catch (GeneralSecurityException e)\n        {\n            logIfStrongEncryptionMissing();\n            throw new IOException(e);\n        }\n    }\n\n    private void prepareEncryptionDictRev2345(String ownerPassword, String userPassword,\n            PDEncryption encryptionDictionary, int permissionInt, PDDocument document, \n            int revision, int length)\n            throws IOException\n    {\n        COSArray idArray = document.getDocument().getDocumentID();\n\n        //check if the document has an id yet.  If it does not then generate one\n        if (idArray == null || idArray.size() < 2)\n        {\n            MessageDigest md = MessageDigests.getMD5();\n            BigInteger time = BigInteger.valueOf(System.currentTimeMillis());\n            md.update(time.toByteArray());\n            md.update(ownerPassword.getBytes(Charsets.ISO_8859_1));\n            md.update(userPassword.getBytes(Charsets.ISO_8859_1));\n            md.update(document.getDocument().toString().getBytes(Charsets.ISO_8859_1));\n\n            byte[] id = md.digest(this.toString().getBytes(Charsets.ISO_8859_1));\n            COSString idString = new COSString(id);\n\n            idArray = new COSArray();\n            idArray.add(idString);\n            idArray.add(idString);\n            document.getDocument().setDocumentID(idArray);\n        }\n\n        COSString id = (COSString) idArray.getObject(0);\n\n        byte[] ownerBytes = computeOwnerPassword(\n                ownerPassword.getBytes(Charsets.ISO_8859_1),\n                userPassword.getBytes(Charsets.ISO_8859_1), revision, length);\n\n        byte[] userBytes = computeUserPassword(\n                userPassword.getBytes(Charsets.ISO_8859_1),\n                ownerBytes, permissionInt, id.getBytes(), revision, length, true);\n\n        encryptionKey = computeEncryptedKey(userPassword.getBytes(Charsets.ISO_8859_1), ownerBytes,\n                null, null, null, permissionInt, id.getBytes(), revision, length, true, false);\n\n        encryptionDictionary.setOwnerKey(ownerBytes);\n        encryptionDictionary.setUserKey(userBytes);\n        \n        if (revision == 4)\n        {\n            prepareEncryptionDictAES(encryptionDictionary, COSName.AESV2);\n        }\n    }\n\n    private void prepareEncryptionDictAES(PDEncryption encryptionDictionary, COSName aesVName)\n    {\n        PDCryptFilterDictionary cryptFilterDictionary = new PDCryptFilterDictionary();\n        cryptFilterDictionary.setCryptFilterMethod(aesVName);\n        cryptFilterDictionary.setLength(keyLength);\n        encryptionDictionary.setStdCryptFilterDictionary(cryptFilterDictionary);\n        encryptionDictionary.setStreamFilterName(COSName.STD_CF);\n        encryptionDictionary.setStringFilterName(COSName.STD_CF);\n        setAES(true);\n    }\n\n    /**\n     * Check for owner password.\n     *\n     * @param ownerPassword The owner password.\n     * @param user The u entry of the encryption dictionary.\n     * @param owner The o entry of the encryption dictionary.\n     * @param permissions The set of permissions on the document.\n     * @param id The document id.\n     * @param encRevision The encryption algorithm revision.\n     * @param length The encryption key length.\n     * @param encryptMetadata The encryption metadata\n     *\n     * @return True If the ownerPassword param is the owner password.\n     *\n     * @throws IOException If there is an error accessing data.\n     */\n    public boolean isOwnerPassword(byte[] ownerPassword, byte[] user, byte[] owner,\n                                   int permissions, byte[] id, int encRevision, int length,\n                                   boolean encryptMetadata) throws IOException\n    {\n        if (encRevision == 6 || encRevision == 5)\n        {            \n            byte[] truncatedOwnerPassword = truncate127(ownerPassword);\n            \n            byte[] oHash = new byte[32];\n            byte[] oValidationSalt = new byte[8];\n            System.arraycopy(owner, 0, oHash, 0, 32);\n            System.arraycopy(owner, 32, oValidationSalt, 0, 8);\n            \n            byte[] hash;\n            if (encRevision == 5)\n            {\n                hash = computeSHA256(truncatedOwnerPassword, oValidationSalt, user);\n            }\n            else\n            {\n                hash = computeHash2A(truncatedOwnerPassword, oValidationSalt, user);\n            }\n\n            return Arrays.equals(hash, oHash);\n        }\n        else\n        {\n            byte[] userPassword = getUserPassword( ownerPassword, owner, encRevision, length );\n            return isUserPassword( userPassword, user, owner, permissions, id, encRevision, length,\n                                   encryptMetadata );\n        }\n    }\n\n    /**\n     * Get the user password based on the owner password.\n     *\n     * @param ownerPassword The plaintext owner password.\n     * @param owner The o entry of the encryption dictionary.\n     * @param encRevision The encryption revision number.\n     * @param length The key length.\n     *\n     * @return The u entry of the encryption dictionary.\n     *\n     * @throws IOException If there is an error accessing data while generating the user password.\n     */\n    public byte[] getUserPassword( byte[] ownerPassword,  byte[] owner, int encRevision,\n                                   int length ) throws IOException\n    {\n        ByteArrayOutputStream result = new ByteArrayOutputStream();\n        byte[] rc4Key = computeRC4key(ownerPassword, encRevision, length);\n\n        if( encRevision == 2 )\n        {\n            encryptDataRC4(rc4Key, owner, result);\n        }\n        else if( encRevision == 3 || encRevision == 4)\n        {\n            byte[] iterationKey = new byte[ rc4Key.length ];\n            byte[] otemp = new byte[ owner.length ];\n            System.arraycopy( owner, 0, otemp, 0, owner.length );\n            \n            for( int i=19; i>=0; i-- )\n            {\n                System.arraycopy( rc4Key, 0, iterationKey, 0, rc4Key.length );\n                for( int j=0; j< iterationKey.length; j++ )\n                {\n                    iterationKey[j] = (byte)(iterationKey[j] ^ (byte)i);\n                }\n                result.reset();\n                encryptDataRC4(iterationKey, otemp, result);\n                otemp = result.toByteArray();\n            }\n        }\n        return result.toByteArray();\n    }\n\n    /**\n     * Compute the encryption key.\n     *\n     * @param password The password to compute the encrypted key.\n     * @param o The O entry of the encryption dictionary.\n     * @param u The U entry of the encryption dictionary.\n     * @param oe The OE entry of the encryption dictionary.\n     * @param ue The UE entry of the encryption dictionary.\n     * @param permissions The permissions for the document.\n     * @param id The document id.\n     * @param encRevision The revision of the encryption algorithm.\n     * @param length The length of the encryption key.\n     * @param encryptMetadata The encryption metadata\n     * @param isOwnerPassword whether the password given is the owner password (for revision 6)\n     *\n     * @return The encrypted key bytes.\n     *\n     * @throws IOException If there is an error with encryption.\n     */\n    public byte[] computeEncryptedKey(byte[] password, byte[] o, byte[] u, byte[] oe, byte[] ue,\n                                      int permissions, byte[] id, int encRevision, int length,\n                                      boolean encryptMetadata, boolean isOwnerPassword)\n                                      throws IOException\n    {\n        if (encRevision == 6 || encRevision == 5)\n        {\n            return computeEncryptedKeyRev56(password, isOwnerPassword, o, u, oe, ue, encRevision);\n        }\n        else\n        {\n            return computeEncryptedKeyRev234(password, o, permissions, id, encryptMetadata, length, encRevision);\n        }\n    }\n\n    private byte[] computeEncryptedKeyRev234(byte[] password, byte[] o, int permissions, \n            byte[] id, boolean encryptMetadata, int length, int encRevision)\n    {\n        //Algorithm 2, based on MD5\n\n        //PDFReference 1.4 pg 78\n        byte[] padded = truncateOrPad(password);\n\n        MessageDigest md = MessageDigests.getMD5();\n        md.update(padded);\n\n        md.update(o);\n\n        md.update((byte) permissions);\n        md.update((byte) (permissions >>> 8));\n        md.update((byte) (permissions >>> 16));\n        md.update((byte) (permissions >>> 24));\n\n        md.update(id);\n\n        //(Security handlers of revision 4 or greater) If document metadata is not being\n        // encrypted, pass 4 bytes with the value 0xFFFFFFFF to the MD5 hash function.\n        //see 7.6.3.3 Algorithm 2 Step f of PDF 32000-1:2008\n        if (encRevision == 4 && !encryptMetadata)\n        {\n            md.update(new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff });\n        }\n        byte[] digest = md.digest();\n\n        if (encRevision == 3 || encRevision == 4)\n        {\n            for (int i = 0; i < 50; i++)\n            {\n                md.update(digest, 0, length);\n                digest = md.digest();\n            }\n        }\n\n        byte[] result = new byte[length];\n        System.arraycopy(digest, 0, result, 0, length);\n        return result;\n    }\n\n    private byte[] computeEncryptedKeyRev56(byte[] password, boolean isOwnerPassword, \n            byte[] o, byte[] u, byte[] oe, byte[] ue, int encRevision) \n            throws IOException\n    {\n        byte[] hash, fileKeyEnc;\n\n        if (isOwnerPassword)\n        {\n            byte[] oKeySalt = new byte[8];\n            System.arraycopy(o, 40, oKeySalt, 0, 8);\n\n            if (encRevision == 5)\n            {\n                hash = computeSHA256(password, oKeySalt, u);\n            }\n            else\n            {\n                hash = computeHash2A(password, oKeySalt, u);\n            }\n\n            fileKeyEnc = oe;\n        }\n        else\n        {\n            byte[] uKeySalt = new byte[8];\n            System.arraycopy(u, 40, uKeySalt, 0, 8);\n\n            if (encRevision == 5)\n            {\n                hash = computeSHA256(password, uKeySalt, null);\n            }\n            else\n            {\n                hash = computeHash2A(password, uKeySalt, null);\n            }\n\n            fileKeyEnc = ue;\n        }\n        try\n        {\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(hash, \"AES\"), new IvParameterSpec(new byte[16]));\n            return cipher.doFinal(fileKeyEnc);\n        }\n        catch (GeneralSecurityException e)\n        {\n            logIfStrongEncryptionMissing();\n            throw new IOException(e);\n        }\n    }\n\n    /**\n     * This will compute the user password hash.\n     *\n     * @param password The plain text password.\n     * @param owner The owner password hash.\n     * @param permissions The document permissions.\n     * @param id The document id.\n     * @param encRevision The revision of the encryption.\n     * @param length The length of the encryption key.\n     * @param encryptMetadata The encryption metadata\n     *\n     * @return The user password.\n     *\n     * @throws IOException if the password could not be computed\n     */\n    public byte[] computeUserPassword(byte[] password, byte[] owner, int permissions,\n                                      byte[] id, int encRevision, int length,\n                                      boolean encryptMetadata) throws IOException\n    {\n        ByteArrayOutputStream result = new ByteArrayOutputStream();\n        byte[] encKey = computeEncryptedKey( password, owner, null, null, null, permissions,\n                id, encRevision, length, encryptMetadata, true );\n        \n        if( encRevision == 2 )\n        {\n            encryptDataRC4(encKey, ENCRYPT_PADDING, result );\n        }\n        else if( encRevision == 3 || encRevision == 4 )\n        {\n            MessageDigest md = MessageDigests.getMD5();\n            md.update( ENCRYPT_PADDING );\n\n            md.update( id );\n            result.write( md.digest() );\n\n            byte[] iterationKey = new byte[ encKey.length ];\n            for( int i=0; i<20; i++ )\n            {\n                System.arraycopy( encKey, 0, iterationKey, 0, iterationKey.length );\n                for( int j=0; j< iterationKey.length; j++ )\n                {\n                    iterationKey[j] = (byte)(iterationKey[j] ^ i);\n                }\n                ByteArrayInputStream input = new ByteArrayInputStream(result.toByteArray());\n                result.reset();\n                encryptDataRC4(iterationKey, input, result);\n            }\n\n            byte[] finalResult = new byte[32];\n            System.arraycopy( result.toByteArray(), 0, finalResult, 0, 16 );\n            System.arraycopy( ENCRYPT_PADDING, 0, finalResult, 16, 16 );\n            result.reset();\n            result.write( finalResult );\n        }\n        return result.toByteArray();\n    }\n\n    /**\n     * Compute the owner entry in the encryption dictionary.\n     *\n     * @param ownerPassword The plaintext owner password.\n     * @param userPassword The plaintext user password.\n     * @param encRevision The revision number of the encryption algorithm.\n     * @param length The length of the encryption key.\n     *\n     * @return The o entry of the encryption dictionary.\n     *\n     * @throws IOException if the owner password could not be computed\n     */\n    public byte[] computeOwnerPassword(byte[] ownerPassword, byte[] userPassword,\n                                       int encRevision,  int length ) throws IOException\n    {\n        if( encRevision == 2 && length != 5 )\n        {\n            throw new IOException(\"Expected length=5 actual=\" + length );\n        }\n        \n        byte[] rc4Key = computeRC4key(ownerPassword, encRevision, length);\n        byte[] paddedUser = truncateOrPad( userPassword );\n\n        ByteArrayOutputStream encrypted = new ByteArrayOutputStream();\n        encryptDataRC4(rc4Key, new ByteArrayInputStream(paddedUser), encrypted);\n\n        if( encRevision == 3 || encRevision == 4 )\n        {\n            byte[] iterationKey = new byte[ rc4Key.length ];\n            for( int i=1; i<20; i++ )\n            {\n                System.arraycopy( rc4Key, 0, iterationKey, 0, rc4Key.length );\n                for( int j=0; j< iterationKey.length; j++ )\n                {\n                    iterationKey[j] = (byte)(iterationKey[j] ^ (byte)i);\n                }\n                ByteArrayInputStream input = new ByteArrayInputStream( encrypted.toByteArray() );\n                encrypted.reset();\n                encryptDataRC4(iterationKey, input, encrypted );\n            }\n        }\n\n        return encrypted.toByteArray();\n    }\n\n    // steps (a) to (d) of \"Algorithm 3: Computing the encryption dictionary?s O (owner password) value\".\n    private byte[] computeRC4key(byte[] ownerPassword, int encRevision, int length)\n    {\n        MessageDigest md = MessageDigests.getMD5();\n        byte[] digest = md.digest(truncateOrPad(ownerPassword));\n        if (encRevision == 3 || encRevision == 4)\n        {\n            for (int i = 0; i < 50; i++)\n            {\n                // this deviates from the spec - however, omitting the length\n                // parameter prevents the file to be opened in Adobe Reader\n                // with the owner password when the key length is 40 bit (= 5 bytes)\n                md.update(digest, 0, length);\n                digest = md.digest();\n            }\n        }\n        byte[] rc4Key = new byte[length];\n        System.arraycopy(digest, 0, rc4Key, 0, length);\n        return rc4Key;\n    }\n\n\n    /**\n     * This will take the password and truncate or pad it as necessary.\n     *\n     * @param password The password to pad or truncate.\n     *\n     * @return The padded or truncated password.\n     */\n    private byte[] truncateOrPad( byte[] password )\n    {\n        byte[] padded = new byte[ ENCRYPT_PADDING.length ];\n        int bytesBeforePad = Math.min( password.length, padded.length );\n        System.arraycopy( password, 0, padded, 0, bytesBeforePad );\n        System.arraycopy( ENCRYPT_PADDING, 0, padded, bytesBeforePad,\n                          ENCRYPT_PADDING.length-bytesBeforePad );\n        return padded;\n    }\n\n    /**\n     * Check if a plaintext password is the user password.\n     *\n     * @param password The plaintext password.\n     * @param user The u entry of the encryption dictionary.\n     * @param owner The o entry of the encryption dictionary.\n     * @param permissions The permissions set in the PDF.\n     * @param id The document id used for encryption.\n     * @param encRevision The revision of the encryption algorithm.\n     * @param length The length of the encryption key.\n     * @param encryptMetadata The encryption metadata\n     *\n     * @return true If the plaintext password is the user password.\n     *\n     * @throws IOException If there is an error accessing data.\n     */\n    public boolean isUserPassword(byte[] password, byte[] user, byte[] owner, int permissions,\n                                  byte[] id, int encRevision, int length, boolean encryptMetadata)\n                                  throws IOException\n    {\n        if( encRevision == 2 )\n        {\n            byte[] passwordBytes = computeUserPassword( password, owner, permissions, id, encRevision,\n                                                        length, encryptMetadata );\n            return Arrays.equals(user, passwordBytes);\n        }\n        else if( encRevision == 3 || encRevision == 4 )\n        {\n            byte[] passwordBytes = computeUserPassword( password, owner, permissions, id, encRevision,\n                                                        length, encryptMetadata );\n            // compare first 16 bytes only\n            return Arrays.equals(Arrays.copyOf(user, 16), Arrays.copyOf(passwordBytes, 16));\n        }\n        else if (encRevision == 6 || encRevision == 5)\n        {\n            byte[] truncatedPassword = truncate127(password);\n            \n            byte[] uHash = new byte[32];\n            byte[] uValidationSalt = new byte[8];\n            System.arraycopy(user, 0, uHash, 0, 32);\n            System.arraycopy(user, 32, uValidationSalt, 0, 8);\n\n            byte[] hash;\n            if (encRevision == 5)\n            {\n                hash = computeSHA256(truncatedPassword, uValidationSalt, null);\n            }\n            else\n            {\n                hash = computeHash2A(truncatedPassword, uValidationSalt, null);\n            }\n\n            return Arrays.equals(hash, uHash);\n        }\n        else\n        {\n            throw new IOException( \"Unknown Encryption Revision \" + encRevision );\n        }\n    }\n\n    /**\n     * Check if a plaintext password is the user password.\n     *\n     * @param password The plaintext password.\n     * @param user The u entry of the encryption dictionary.\n     * @param owner The o entry of the encryption dictionary.\n     * @param permissions The permissions set in the PDF.\n     * @param id The document id used for encryption.\n     * @param encRevision The revision of the encryption algorithm.\n     * @param length The length of the encryption key.\n     * @param encryptMetadata The encryption metadata\n     *\n     * @return true If the plaintext password is the user password.\n     *\n     * @throws IOException If there is an error accessing data.\n     */\n    public boolean isUserPassword(String password, byte[] user, byte[] owner, int permissions,\n                                  byte[] id, int encRevision,  int length, boolean encryptMetadata)\n                                  throws IOException\n    {\n        if (encRevision == 6 || encRevision == 5)\n        {\n            return isUserPassword(password.getBytes(Charsets.UTF_8), user, owner, permissions, id,\n                    encRevision, length, encryptMetadata);\n        }\n        else\n        {\n            return isUserPassword(password.getBytes(Charsets.ISO_8859_1), user, owner, permissions, id,\n                    encRevision, length, encryptMetadata);\n        }\n    }\n\n    /**\n     * Check for owner password.\n     *\n     * @param password The owner password.\n     * @param user The u entry of the encryption dictionary.\n     * @param owner The o entry of the encryption dictionary.\n     * @param permissions The set of permissions on the document.\n     * @param id The document id.\n     * @param encRevision The encryption algorithm revision.\n     * @param length The encryption key length.\n     * @param encryptMetadata The encryption metadata\n     *\n     * @return True If the ownerPassword param is the owner password.\n     *\n     * @throws IOException If there is an error accessing data.\n     */\n    public boolean isOwnerPassword(String password, byte[] user, byte[] owner, int permissions,\n                                   byte[] id, int encRevision, int length, boolean encryptMetadata)\n                                   throws IOException\n    {\n        return isOwnerPassword(password.getBytes(Charsets.ISO_8859_1), user,owner,permissions, id,\n                               encRevision, length, encryptMetadata);\n    }\n\n    // Algorithm 2.A from ISO 32000-1\n    private byte[] computeHash2A(byte[] password, byte[] salt, byte[] u) throws IOException\n    {\n        byte[] userKey;\n        if (u == null)\n        {\n            userKey = new byte[0];\n        }\n        else if (u.length < 48)\n        {\n            throw new IOException(\"Bad U length\");\n        }\n        else if (u.length > 48)\n        {\n            // must truncate\n            userKey = new byte[48];\n            System.arraycopy(u, 0, userKey, 0, 48);\n        }\n        else\n        {\n            userKey = u;\n        }\n\n        byte[] truncatedPassword = truncate127(password);\n        byte[] input = concat(truncatedPassword, salt, userKey);\n        return computeHash2B(input, truncatedPassword, userKey);\n    }\n    \n    // Algorithm 2.B from ISO 32000-2\n    private static byte[] computeHash2B(byte[] input, byte[] password, byte[] userKey)\n            throws IOException\n    {\n        try\n        {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            byte[] k = md.digest(input);\n            \n            byte[] e = null;\n            for (int round = 0; round < 64 || ((int)e[e.length-1] & 0xFF) > round - 32; round++)\n            {                \n                byte[] k1;\n                if (userKey != null && userKey.length >= 48)\n                {\n                    k1 = new byte[64*(password.length + k.length + 48)];\n                }\n                else\n                {\n                    k1 = new byte[64*(password.length + k.length)];\n                }\n                \n                int pos = 0;\n                for (int i = 0; i < 64; i++)\n                {\n                    System.arraycopy(password, 0, k1, pos, password.length);\n                    pos += password.length;\n                    System.arraycopy(k, 0, k1, pos, k.length);\n                    pos += k.length;\n                    if (userKey != null && userKey.length >= 48)\n                    {\n                        System.arraycopy(userKey, 0, k1, pos, 48);\n                        pos += 48;\n                    }\n                }\n                \n                byte[] kFirst = new byte[16];\n                byte[] kSecond = new byte[16];\n                System.arraycopy(k, 0, kFirst, 0, 16);\n                System.arraycopy(k, 16, kSecond, 0, 16);\n                \n                Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n                SecretKeySpec keySpec = new SecretKeySpec(kFirst, \"AES\");\n                IvParameterSpec ivSpec = new IvParameterSpec(kSecond);\n                cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n                e = cipher.doFinal(k1);\n                \n                byte[] eFirst = new byte[16];\n                System.arraycopy(e, 0, eFirst, 0, 16);\n                BigInteger bi = new BigInteger(1, eFirst);\n                BigInteger remainder = bi.mod(new BigInteger(\"3\"));\n                String nextHash = HASHES_2B[remainder.intValue()];\n                \n                md = MessageDigest.getInstance(nextHash);\n                k = md.digest(e);\n            }\n            \n            if (k.length > 32)\n            {\n                byte[] kTrunc = new byte[32];\n                System.arraycopy(k, 0, kTrunc, 0, 32);\n                return kTrunc;\n            }\n            else\n            {\n                return k;\n            }            \n        }\n        catch (GeneralSecurityException e)\n        {\n            logIfStrongEncryptionMissing();\n            throw new IOException(e);\n        }\n    }\n\n    private static byte[] computeSHA256(byte[] input, byte[] password, byte[] userKey) \n            throws IOException\n    {\n        try\n        {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(input);\n            md.update(password);\n            return userKey == null ? md.digest() : md.digest(userKey);\n        }\n        catch (NoSuchAlgorithmException e)\n        {\n            throw new IOException(e);\n        }\n    }\n    \n    private static byte[] concat(byte[] a, byte[] b)\n    {\n        byte[] o = new byte[a.length + b.length];\n        System.arraycopy(a, 0, o, 0, a.length);\n        System.arraycopy(b, 0, o, a.length, b.length);\n        return o;\n    }\n    \n    private static byte[] concat(byte[] a, byte[] b, byte[] c)\n    {\n        byte[] o = new byte[a.length + b.length + c.length];\n        System.arraycopy(a, 0, o, 0, a.length);\n        System.arraycopy(b, 0, o, a.length, b.length);\n        System.arraycopy(c, 0, o, a.length + b.length, c.length);\n        return o;\n    }\n    \n    private static byte[] truncate127(byte[] in)\n    {\n        if (in.length <= 127)\n        {\n            return in;\n        }\n        byte[] trunc = new byte[127];\n        System.arraycopy(in, 0, trunc, 0, 127);\n        return trunc;\n    }\n\n    private static void logIfStrongEncryptionMissing()\n    {\n        try\n        {\n            if (Cipher.getMaxAllowedKeyLength(\"AES\") != Integer.MAX_VALUE)\n            {\n                LOG.warn(\"JCE unlimited strength jurisdiction policy files are not installed\");\n            }\n        }\n        catch (NoSuchAlgorithmException ex)\n        {\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean hasProtectionPolicy()\n    {\n        return policy != null;\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-20": {
    "vul_id": "VUL4J-20",
    "cve_id": "CVE-2018-11797",
    "project": "apache_pdfbox",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl pdfbox -Dtest=org.apache.pdfbox.pdmodel.TestPDDocument#testCVE_2018_11797",
    "test_all_cmd": "mvn test -pl pdfbox",
    "human_patch_url": "https://github.com/apache/pdfbox/commit/0e14d6a42cc965e23bb1b40f04b4c002dc173b88",
    "vulnerable_files": [
      {
        "file_path": "pdfbox/src/main/java/org/apache/pdfbox/cos/COSArray.java",
        "file_name": "COSArray.java",
        "vulnerable_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.pdfbox.cos;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.apache.pdfbox.pdmodel.common.COSObjectable;\n\n/**\n * An array of PDFBase objects as part of the PDF document.\n *\n * @author Ben Litchfield\n */\npublic class COSArray extends COSBase implements Iterable<COSBase>, COSUpdateInfo\n{\n    private final List<COSBase> objects = new ArrayList<>();\n    private boolean needToBeUpdated;\n\n    /**\n     * Constructor.\n     */\n    public COSArray()\n    {\n        //default constructor\n    }\n\n    /**\n     * This will add an object to the array.\n     *\n     * @param object The object to add to the array.\n     */\n    public void add( COSBase object )\n    {\n        objects.add( object );\n    }\n\n    /**\n     * This will add an object to the array.\n     *\n     * @param object The object to add to the array.\n     */\n    public void add( COSObjectable object )\n    {\n        objects.add( object.getCOSObject() );\n    }\n\n    /**\n     * Add the specified object at the ith location and push the rest to the\n     * right.\n     *\n     * @param i The index to add at.\n     * @param object The object to add at that index.\n     */\n    public void add( int i, COSBase object)\n    {\n        objects.add( i, object );\n    }\n\n    /**\n     * This will remove all of the objects in the collection.\n     */\n    public void clear()\n    {\n        objects.clear();\n    }\n\n    /**\n     * This will remove all of the objects in the collection.\n     *\n     * @param objectsList The list of objects to remove from the collection.\n     */\n    public void removeAll( Collection<COSBase> objectsList )\n    {\n        objects.removeAll( objectsList );\n    }\n\n    /**\n     * This will retain all of the objects in the collection.\n     *\n     * @param objectsList The list of objects to retain from the collection.\n     */\n    public void retainAll( Collection<COSBase> objectsList )\n    {\n        objects.retainAll( objectsList );\n    }\n\n    /**\n     * This will add an object to the array.\n     *\n     * @param objectsList The object to add to the array.\n     */\n    public void addAll( Collection<COSBase> objectsList )\n    {\n        objects.addAll( objectsList );\n    }\n\n    /**\n     * This will add all objects to this array.\n     *\n     * @param objectList The objects to add.\n     */\n    public void addAll( COSArray objectList )\n    {\n        if( objectList != null )\n        {\n            objects.addAll( objectList.objects );\n        }\n    }\n\n    /**\n     * Add the specified object at the ith location and push the rest to the\n     * right.\n     *\n     * @param i The index to add at.\n     * @param objectList The object to add at that index.\n     */\n    public void addAll( int i, Collection<COSBase> objectList )\n    {\n        objects.addAll( i, objectList );\n    }\n\n    /**\n     * This will set an object at a specific index.\n     *\n     * @param index zero based index into array.\n     * @param object The object to set.\n     */\n    public void set( int index, COSBase object )\n    {\n        objects.set( index, object );\n    }\n\n    /**\n     * This will set an object at a specific index.\n     *\n     * @param index zero based index into array.\n     * @param intVal The object to set.\n     */\n    public void set( int index, int intVal )\n    {\n        objects.set( index, COSInteger.get(intVal) );\n    }\n\n    /**\n     * This will set an object at a specific index.\n     *\n     * @param index zero based index into array.\n     * @param object The object to set.\n     */\n    public void set( int index, COSObjectable object )\n    {\n        COSBase base = null;\n        if( object != null )\n        {\n            base = object.getCOSObject();\n        }\n        objects.set( index, base );\n    }\n\n    /**\n     * This will get an object from the array.  This will dereference the object.\n     * If the object is COSNull then null will be returned.\n     *\n     * @param index The index into the array to get the object.\n     *\n     * @return The object at the requested index.\n     */\n    public COSBase getObject( int index )\n    {\n        Object obj = objects.get( index );\n        if( obj instanceof COSObject )\n        {\n            obj = ((COSObject)obj).getObject();\n        }\n        if (obj instanceof COSNull)\n        {\n            obj = null;\n        }\n        return (COSBase)obj;\n    }\n\n    /**\n     * This will get an object from the array.  This will NOT dereference\n     * the COS object.\n     *\n     * @param index The index into the array to get the object.\n     *\n     * @return The object at the requested index.\n     */\n    public COSBase get( int index )\n    {\n        return objects.get( index );\n    }\n\n    /**\n     * Get the value of the array as an integer.\n     *\n     * @param index The index into the list.\n     *\n     * @return The value at that index or -1 if does not exist.\n     */\n    public int getInt( int index )\n    {\n        return getInt( index, -1 );\n    }\n\n    /**\n     * Get the value of the array as an integer, return the default if it does not exist.\n     *\n     * @param index The value of the array.\n     * @param defaultValue The value to return if the value is null.\n     * @return The value at the index or the defaultValue.\n     */\n    public int getInt( int index, int defaultValue )\n    {\n        int retval = defaultValue;\n        if ( index < size() )\n        {\n            Object obj = objects.get( index );\n            if( obj instanceof COSNumber )\n            {\n                retval = ((COSNumber)obj).intValue();\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * Set the value in the array as an integer.\n     *\n     * @param index The index into the array.\n     * @param value The value to set.\n     */\n    public void setInt( int index, int value )\n    {\n        set( index, COSInteger.get( value ) );\n    }\n\n    /**\n     * Set the value in the array as a name.\n     * @param index The index into the array.\n     * @param name The name to set in the array.\n     */\n    public void setName( int index, String name )\n    {\n        set( index, COSName.getPDFName( name ) );\n    }\n\n    /**\n     * Get the value of the array as a string.\n     *\n     * @param index The index into the array.\n     * @return The name converted to a string or null if it does not exist.\n     */\n    public String getName( int index )\n    {\n        return getName( index, null );\n    }\n\n    /**\n     * Get an entry in the array that is expected to be a COSName.\n     * @param index The index into the array.\n     * @param defaultValue The value to return if it is null.\n     * @return The value at the index or defaultValue if none is found.\n     */\n    public String getName( int index, String defaultValue )\n    {\n        String retval = defaultValue;\n        if( index < size() )\n        {\n            Object obj = objects.get( index );\n            if( obj instanceof COSName )\n            {\n                retval = ((COSName)obj).getName();\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * Set the value in the array as a string.\n     * @param index The index into the array.\n     * @param string The string to set in the array.\n     */\n    public void setString( int index, String string )\n    {\n        if ( string != null )\n        {\n            set( index, new COSString( string ) );\n        }\n        else\n        {\n            set( index, null );\n        }\n    }   \n\n    /**\n     * Get the value of the array as a string.\n     *\n     * @param index The index into the array.\n     * @return The string or null if it does not exist.\n     */\n    public String getString( int index )\n    {\n        return getString( index, null );\n    }\n\n    /**\n     * Get an entry in the array that is expected to be a COSName.\n     * @param index The index into the array.\n     * @param defaultValue The value to return if it is null.\n     * @return The value at the index or defaultValue if none is found.\n     */\n    public String getString( int index, String defaultValue )\n    {\n        String retval = defaultValue;\n        if( index < size() )\n        {\n            Object obj = objects.get( index );\n            if( obj instanceof COSString )\n            {\n                retval = ((COSString)obj).getString();\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * This will get the size of this array.\n     *\n     * @return The number of elements in the array.\n     */\n    public int size()\n    {\n        return objects.size();\n    }\n\n    /**\n     * This will remove an element from the array.\n     *\n     * @param i The index of the object to remove.\n     *\n     * @return The object that was removed.\n     */\n    public COSBase remove( int i )\n    {\n        return objects.remove( i );\n    }\n\n    /**\n     * This will remove an element from the array.\n     *\n     * @param o The object to remove.\n     *\n     * @return <code>true</code> if the object was removed, <code>false</code>\n     *  otherwise\n     */\n    public boolean remove( COSBase o )\n    {\n        return objects.remove( o );\n    }\n\n    /**\n     * This will remove an element from the array.\n     * This method will also remove a reference to the object.\n     *\n     * @param o The object to remove.\n     * @return <code>true</code> if the object was removed, <code>false</code>\n     *  otherwise\n     */\n    public boolean removeObject(COSBase o)\n    {\n        boolean removed = this.remove(o);\n        if (!removed)\n        {\n            for (int i = 0; i < this.size(); i++)\n            {\n                COSBase entry = this.get(i);\n                if (entry instanceof COSObject)\n                {\n                    COSObject objEntry = (COSObject) entry;\n                    if (objEntry.getObject().equals(o))\n                    {\n                        return this.remove(entry);\n                    }\n                }\n            }\n        }\n        return removed;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString()\n    {\n        return \"COSArray{\" + objects + \"}\";\n    }\n\n    /**\n     * Get access to the list.\n     *\n     * @return an iterator over the array elements\n     */\n    @Override\n    public Iterator<COSBase> iterator()\n    {\n        return objects.iterator();\n    }\n\n    /**\n     * This will return the index of the entry or -1 if it is not found.\n     *\n     * @param object The object to search for.\n     * @return The index of the object or -1.\n     */\n    public int indexOf( COSBase object )\n    {\n        int retval = -1;\n        for( int i=0; retval < 0 && i<size(); i++ )\n        {\n            if( get( i ).equals( object ) )\n            {\n                retval = i;\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * This will return the index of the entry or -1 if it is not found.\n     * This method will also find references to indirect objects.\n     *\n     * @param object The object to search for.\n     * @return The index of the object or -1.\n     */\n    public int indexOfObject(COSBase object)\n    {\n        int retval = -1;\n        for (int i = 0; retval < 0 && i < this.size(); i++)\n        {\n            COSBase item = this.get(i);\n            if (item.equals(object))\n            {\n                retval = i;\n                break;\n            }\n            else if (item instanceof COSObject && ((COSObject) item).getObject().equals(object))\n            {\n                retval = i;\n                break;\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * This will add null values until the size of the array is at least\n     * as large as the parameter.  If the array is already larger than the\n     * parameter then nothing is done.\n     *\n     * @param size The desired size of the array.\n     */\n    public void growToSize( int size )\n    {\n        growToSize( size, null );\n    }\n\n    /**\n     * This will add the object until the size of the array is at least\n     * as large as the parameter.  If the array is already larger than the\n     * parameter then nothing is done.\n     *\n     * @param size The desired size of the array.\n     * @param object The object to fill the array with.\n     */\n    public void growToSize( int size, COSBase object )\n    {\n        while( size() < size )\n        {\n            add( object );\n        }\n    }\n\n    /**\n     * visitor pattern double dispatch method.\n     *\n     * @param visitor The object to notify when visiting this object.\n     * @return any object, depending on the visitor implementation, or null\n     * @throws IOException If an error occurs while visiting this object.\n     */\n    @Override\n    public Object accept(ICOSVisitor visitor) throws IOException\n    {\n        return visitor.visitFromArray(this);\n    }\n\n    @Override\n    public boolean isNeedToBeUpdated() \n    {\n      return needToBeUpdated;\n    }\n    \n    @Override\n    public void setNeedToBeUpdated(boolean flag) \n    {\n      needToBeUpdated = flag;\n    }\n\n    /**\n     * This will take an COSArray of numbers and convert it to a float[].\n     *\n     * @return This COSArray as an array of float numbers.\n     */\n    public float[] toFloatArray()\n    {\n        float[] retval = new float[size()];\n        for (int i = 0; i < size(); i++)\n        {\n            retval[i] = ((COSNumber)getObject( i )).floatValue();\n        }\n        return retval;\n    }\n\n    /**\n     * Clear the current contents of the COSArray and set it with the float[].\n     *\n     * @param value The new value of the float array.\n     */\n    public void setFloatArray( float[] value )\n    {\n        this.clear();\n        for (float aValue : value)\n        {\n            add(new COSFloat(aValue));\n        }\n    }\n\n    /**\n     *  Return contents of COSArray as a Java List.\n     *\n     *  @return the COSArray as List\n     */\n    public List<? extends COSBase> toList()\n    {\n        List<COSBase> retList = new ArrayList<>(size());\n        for (int i = 0; i < size(); i++)\n        {\n            retList.add(get(i));\n        }\n        return retList;\n    }\n}\n",
        "human_patch_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.pdfbox.cos;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.apache.pdfbox.pdmodel.common.COSObjectable;\n\n/**\n * An array of PDFBase objects as part of the PDF document.\n *\n * @author Ben Litchfield\n */\npublic class COSArray extends COSBase implements Iterable<COSBase>, COSUpdateInfo\n{\n    private final List<COSBase> objects = new ArrayList<>();\n    private boolean needToBeUpdated;\n\n    /**\n     * Constructor.\n     */\n    public COSArray()\n    {\n        //default constructor\n    }\n\n    /**\n     * This will add an object to the array.\n     *\n     * @param object The object to add to the array.\n     */\n    public void add( COSBase object )\n    {\n        objects.add( object );\n    }\n\n    /**\n     * This will add an object to the array.\n     *\n     * @param object The object to add to the array.\n     */\n    public void add( COSObjectable object )\n    {\n        objects.add( object.getCOSObject() );\n    }\n\n    /**\n     * Add the specified object at the ith location and push the rest to the\n     * right.\n     *\n     * @param i The index to add at.\n     * @param object The object to add at that index.\n     */\n    public void add( int i, COSBase object)\n    {\n        objects.add( i, object );\n    }\n\n    /**\n     * This will remove all of the objects in the collection.\n     */\n    public void clear()\n    {\n        objects.clear();\n    }\n\n    /**\n     * This will remove all of the objects in the collection.\n     *\n     * @param objectsList The list of objects to remove from the collection.\n     */\n    public void removeAll( Collection<COSBase> objectsList )\n    {\n        objects.removeAll( objectsList );\n    }\n\n    /**\n     * This will retain all of the objects in the collection.\n     *\n     * @param objectsList The list of objects to retain from the collection.\n     */\n    public void retainAll( Collection<COSBase> objectsList )\n    {\n        objects.retainAll( objectsList );\n    }\n\n    /**\n     * This will add an object to the array.\n     *\n     * @param objectsList The object to add to the array.\n     */\n    public void addAll( Collection<COSBase> objectsList )\n    {\n        objects.addAll( objectsList );\n    }\n\n    /**\n     * This will add all objects to this array.\n     *\n     * @param objectList The objects to add.\n     */\n    public void addAll( COSArray objectList )\n    {\n        if( objectList != null )\n        {\n            objects.addAll( objectList.objects );\n        }\n    }\n\n    /**\n     * Add the specified object at the ith location and push the rest to the\n     * right.\n     *\n     * @param i The index to add at.\n     * @param objectList The object to add at that index.\n     */\n    public void addAll( int i, Collection<COSBase> objectList )\n    {\n        objects.addAll( i, objectList );\n    }\n\n    /**\n     * This will set an object at a specific index.\n     *\n     * @param index zero based index into array.\n     * @param object The object to set.\n     */\n    public void set( int index, COSBase object )\n    {\n        objects.set( index, object );\n    }\n\n    /**\n     * This will set an object at a specific index.\n     *\n     * @param index zero based index into array.\n     * @param intVal The object to set.\n     */\n    public void set( int index, int intVal )\n    {\n        objects.set( index, COSInteger.get(intVal) );\n    }\n\n    /**\n     * This will set an object at a specific index.\n     *\n     * @param index zero based index into array.\n     * @param object The object to set.\n     */\n    public void set( int index, COSObjectable object )\n    {\n        COSBase base = null;\n        if( object != null )\n        {\n            base = object.getCOSObject();\n        }\n        objects.set( index, base );\n    }\n\n    /**\n     * This will get an object from the array.  This will dereference the object.\n     * If the object is COSNull then null will be returned.\n     *\n     * @param index The index into the array to get the object.\n     *\n     * @return The object at the requested index.\n     */\n    public COSBase getObject( int index )\n    {\n        Object obj = objects.get( index );\n        if( obj instanceof COSObject )\n        {\n            obj = ((COSObject)obj).getObject();\n        }\n        if (obj instanceof COSNull)\n        {\n            obj = null;\n        }\n        return (COSBase)obj;\n    }\n\n    /**\n     * This will get an object from the array.  This will NOT dereference\n     * the COS object.\n     *\n     * @param index The index into the array to get the object.\n     *\n     * @return The object at the requested index.\n     */\n    public COSBase get( int index )\n    {\n        return objects.get( index );\n    }\n\n    /**\n     * Get the value of the array as an integer.\n     *\n     * @param index The index into the list.\n     *\n     * @return The value at that index or -1 if does not exist.\n     */\n    public int getInt( int index )\n    {\n        return getInt( index, -1 );\n    }\n\n    /**\n     * Get the value of the array as an integer, return the default if it does not exist.\n     *\n     * @param index The value of the array.\n     * @param defaultValue The value to return if the value is null.\n     * @return The value at the index or the defaultValue.\n     */\n    public int getInt( int index, int defaultValue )\n    {\n        int retval = defaultValue;\n        if ( index < size() )\n        {\n            Object obj = objects.get( index );\n            if( obj instanceof COSNumber )\n            {\n                retval = ((COSNumber)obj).intValue();\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * Set the value in the array as an integer.\n     *\n     * @param index The index into the array.\n     * @param value The value to set.\n     */\n    public void setInt( int index, int value )\n    {\n        set( index, COSInteger.get( value ) );\n    }\n\n    /**\n     * Set the value in the array as a name.\n     * @param index The index into the array.\n     * @param name The name to set in the array.\n     */\n    public void setName( int index, String name )\n    {\n        set( index, COSName.getPDFName( name ) );\n    }\n\n    /**\n     * Get the value of the array as a string.\n     *\n     * @param index The index into the array.\n     * @return The name converted to a string or null if it does not exist.\n     */\n    public String getName( int index )\n    {\n        return getName( index, null );\n    }\n\n    /**\n     * Get an entry in the array that is expected to be a COSName.\n     * @param index The index into the array.\n     * @param defaultValue The value to return if it is null.\n     * @return The value at the index or defaultValue if none is found.\n     */\n    public String getName( int index, String defaultValue )\n    {\n        String retval = defaultValue;\n        if( index < size() )\n        {\n            Object obj = objects.get( index );\n            if( obj instanceof COSName )\n            {\n                retval = ((COSName)obj).getName();\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * Set the value in the array as a string.\n     * @param index The index into the array.\n     * @param string The string to set in the array.\n     */\n    public void setString( int index, String string )\n    {\n        if ( string != null )\n        {\n            set( index, new COSString( string ) );\n        }\n        else\n        {\n            set( index, null );\n        }\n    }   \n\n    /**\n     * Get the value of the array as a string.\n     *\n     * @param index The index into the array.\n     * @return The string or null if it does not exist.\n     */\n    public String getString( int index )\n    {\n        return getString( index, null );\n    }\n\n    /**\n     * Get an entry in the array that is expected to be a COSName.\n     * @param index The index into the array.\n     * @param defaultValue The value to return if it is null.\n     * @return The value at the index or defaultValue if none is found.\n     */\n    public String getString( int index, String defaultValue )\n    {\n        String retval = defaultValue;\n        if( index < size() )\n        {\n            Object obj = objects.get( index );\n            if( obj instanceof COSString )\n            {\n                retval = ((COSString)obj).getString();\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * This will get the size of this array.\n     *\n     * @return The number of elements in the array.\n     */\n    public int size()\n    {\n        return objects.size();\n    }\n\n    /**\n     * This will remove an element from the array.\n     *\n     * @param i The index of the object to remove.\n     *\n     * @return The object that was removed.\n     */\n    public COSBase remove( int i )\n    {\n        return objects.remove( i );\n    }\n\n    /**\n     * This will remove an element from the array.\n     *\n     * @param o The object to remove.\n     *\n     * @return <code>true</code> if the object was removed, <code>false</code>\n     *  otherwise\n     */\n    public boolean remove( COSBase o )\n    {\n        return objects.remove( o );\n    }\n\n    /**\n     * This will remove an element from the array.\n     * This method will also remove a reference to the object.\n     *\n     * @param o The object to remove.\n     * @return <code>true</code> if the object was removed, <code>false</code>\n     *  otherwise\n     */\n    public boolean removeObject(COSBase o)\n    {\n        boolean removed = this.remove(o);\n        if (!removed)\n        {\n            for (int i = 0; i < this.size(); i++)\n            {\n                COSBase entry = this.get(i);\n                if (entry instanceof COSObject)\n                {\n                    COSObject objEntry = (COSObject) entry;\n                    if (objEntry.getObject().equals(o))\n                    {\n                        return this.remove(entry);\n                    }\n                }\n            }\n        }\n        return removed;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString()\n    {\n        return \"COSArray{\" + objects + \"}\";\n    }\n\n    /**\n     * Get access to the list.\n     *\n     * @return an iterator over the array elements\n     */\n    @Override\n    public Iterator<COSBase> iterator()\n    {\n        return objects.iterator();\n    }\n\n    /**\n     * This will return the index of the entry or -1 if it is not found.\n     *\n     * @param object The object to search for.\n     * @return The index of the object or -1.\n     */\n    public int indexOf( COSBase object )\n    {\n        int retval = -1;\n        for( int i=0; retval < 0 && i<size(); i++ )\n        {\n            if( get( i ).equals( object ) )\n            {\n                retval = i;\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * This will return the index of the entry or -1 if it is not found.\n     * This method will also find references to indirect objects.\n     *\n     * @param object The object to search for.\n     * @return The index of the object or -1.\n     */\n    public int indexOfObject(COSBase object)\n    {\n        int retval = -1;\n        for (int i = 0; retval < 0 && i < this.size(); i++)\n        {\n            COSBase item = this.get(i);\n            if (item.equals(object))\n            {\n                retval = i;\n                break;\n            }\n            else if (item instanceof COSObject && ((COSObject) item).getObject().equals(object))\n            {\n                retval = i;\n                break;\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * This will add null values until the size of the array is at least\n     * as large as the parameter.  If the array is already larger than the\n     * parameter then nothing is done.\n     *\n     * @param size The desired size of the array.\n     */\n    public void growToSize( int size )\n    {\n        growToSize( size, null );\n    }\n\n    /**\n     * This will add the object until the size of the array is at least\n     * as large as the parameter.  If the array is already larger than the\n     * parameter then nothing is done.\n     *\n     * @param size The desired size of the array.\n     * @param object The object to fill the array with.\n     */\n    public void growToSize( int size, COSBase object )\n    {\n        while( size() < size )\n        {\n            add( object );\n        }\n    }\n\n    /**\n     * visitor pattern double dispatch method.\n     *\n     * @param visitor The object to notify when visiting this object.\n     * @return any object, depending on the visitor implementation, or null\n     * @throws IOException If an error occurs while visiting this object.\n     */\n    @Override\n    public Object accept(ICOSVisitor visitor) throws IOException\n    {\n        return visitor.visitFromArray(this);\n    }\n\n    @Override\n    public boolean isNeedToBeUpdated() \n    {\n      return needToBeUpdated;\n    }\n    \n    @Override\n    public void setNeedToBeUpdated(boolean flag) \n    {\n      needToBeUpdated = flag;\n    }\n\n    /**\n     * This will take an COSArray of numbers and convert it to a float[].\n     *\n     * @return This COSArray as an array of float numbers.\n     */\n    public float[] toFloatArray()\n    {\n        float[] retval = new float[size()];\n        for (int i = 0; i < size(); i++)\n        {\n            COSBase base = getObject(i);\n            retval[i] =\n                base instanceof COSNumber ? ((COSNumber) base).floatValue() : 0;\n        }\n        return retval;\n    }\n\n    /**\n     * Clear the current contents of the COSArray and set it with the float[].\n     *\n     * @param value The new value of the float array.\n     */\n    public void setFloatArray( float[] value )\n    {\n        this.clear();\n        for (float aValue : value)\n        {\n            add(new COSFloat(aValue));\n        }\n    }\n\n    /**\n     *  Return contents of COSArray as a Java List.\n     *\n     *  @return the COSArray as List\n     */\n    public List<? extends COSBase> toList()\n    {\n        List<COSBase> retList = new ArrayList<>(size());\n        for (int i = 0; i < size(); i++)\n        {\n            retList.add(get(i));\n        }\n        return retList;\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-22": {
    "vul_id": "VUL4J-22",
    "cve_id": "CVE-2016-6802",
    "project": "apache_shiro",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl web -Dtest=org.apache.shiro.web.util.WebUtilsTest",
    "test_all_cmd": "mvn test -pl web",
    "human_patch_url": "https://github.com/apache/shiro/commit/b15ab927709ca18ea4a02538be01919a19ab65af",
    "vulnerable_files": [
      {
        "file_path": "web/src/main/java/org/apache/shiro/web/util/WebUtils.java",
        "file_name": "WebUtils.java",
        "vulnerable_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.util;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.subject.support.DefaultSubjectContext;\nimport org.apache.shiro.util.StringUtils;\nimport org.apache.shiro.web.env.EnvironmentLoader;\nimport org.apache.shiro.web.env.WebEnvironment;\nimport org.apache.shiro.web.filter.AccessControlFilter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.util.Map;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n * <p/>\n * Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @since 0.9\n */\npublic class WebUtils {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(WebUtils.class);\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_SHIRO_THREAD_CONTEXT_KEY\";\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_SHIRO_THREAD_CONTEXT_KEY\";\n\n    /**\n     * {@link org.apache.shiro.session.Session Session} key used to save a request and later restore it, for example when redirecting to a\n     * requested page after login, equal to {@code shiroSavedRequest}.\n     */\n    public static final String SAVED_REQUEST_KEY = \"shiroSavedRequest\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding</code>\n     * returns <code>null</code>, according to the Servlet spec.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * Detects include request URL if called within a RequestDispatcher include.\n     * <p/>\n     * For example, for a request to URL\n     * <p/>\n     * <code>http://www.somehost.com/myapp/my/url.jsp</code>,\n     * <p/>\n     * for an application deployed to <code>/mayapp</code> (the application's context path), this method would return\n     * <p/>\n     * <code>/my/url.jsp</code>.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should</i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return normalize(decodeAndCleanUriString(request, uri));\n    }\n\n    /**\n     * Normalize a relative URI path that may have relative values (\"/./\",\n     * \"/../\", and so on ) it it.  <strong>WARNING</strong> - This method is\n     * useful only for normalizing application-generated paths.  It does not\n     * try to perform security checks for malicious input.\n     * Normalize operations were was happily taken from org.apache.catalina.util.RequestUtil in\n     * Tomcat trunk, r939305\n     *\n     * @param path Relative path to be normalized\n     * @return normalized path\n     */\n    public static String normalize(String path) {\n        return normalize(path, true);\n    }\n\n    /**\n     * Normalize a relative URI path that may have relative values (\"/./\",\n     * \"/../\", and so on ) it it.  <strong>WARNING</strong> - This method is\n     * useful only for normalizing application-generated paths.  It does not\n     * try to perform security checks for malicious input.\n     * Normalize operations were was happily taken from org.apache.catalina.util.RequestUtil in\n     * Tomcat trunk, r939305\n     *\n     * @param path             Relative path to be normalized\n     * @param replaceBackSlash Should '\\\\' be replaced with '/'\n     * @return normalized path\n     */\n    private static String normalize(String path, boolean replaceBackSlash) {\n\n        if (path == null)\n            return null;\n\n        // Create a place for the normalized path\n        String normalized = path;\n\n        if (replaceBackSlash && normalized.indexOf('\\\\') >= 0)\n            normalized = normalized.replace('\\\\', '/');\n\n        if (normalized.equals(\"/.\"))\n            return \"/\";\n\n        // Add a leading \"/\" if necessary\n        if (!normalized.startsWith(\"/\"))\n            normalized = \"/\" + normalized;\n\n        // Resolve occurrences of \"//\" in the normalized path\n        while (true) {\n            int index = normalized.indexOf(\"//\");\n            if (index < 0)\n                break;\n            normalized = normalized.substring(0, index) +\n                    normalized.substring(index + 1);\n        }\n\n        // Resolve occurrences of \"/./\" in the normalized path\n        while (true) {\n            int index = normalized.indexOf(\"/./\");\n            if (index < 0)\n                break;\n            normalized = normalized.substring(0, index) +\n                    normalized.substring(index + 2);\n        }\n\n        // Resolve occurrences of \"/../\" in the normalized path\n        while (true) {\n            int index = normalized.indexOf(\"/../\");\n            if (index < 0)\n                break;\n            if (index == 0)\n                return (null);  // Trying to go outside our context\n            int index2 = normalized.lastIndexOf('/', index - 1);\n            normalized = normalized.substring(0, index2) +\n                    normalized.substring(index + 3);\n        }\n\n        // Return the normalized path that we have completed\n        return (normalized);\n\n    }\n\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * @param request the incoming HttpServletRequest\n     * @param uri     the application's URI string\n     * @return the supplied URI string stripped of any extraneous portion after a ';'.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    /**\n     * Find the Shiro {@link WebEnvironment} for this web application, which is typically loaded via the\n     * {@link org.apache.shiro.web.env.EnvironmentLoaderListener}.\n     * <p/>\n     * This implementation rethrows an exception that happened on environment startup to differentiate between a failed\n     * environment startup and no environment at all.\n     *\n     * @param sc ServletContext to find the web application context for\n     * @return the root WebApplicationContext for this web app\n     * @throws IllegalStateException if the root WebApplicationContext could not be found\n     * @see org.apache.shiro.web.env.EnvironmentLoader#ENVIRONMENT_ATTRIBUTE_KEY\n     * @since 1.2\n     */\n    public static WebEnvironment getRequiredWebEnvironment(ServletContext sc)\n            throws IllegalStateException {\n\n        WebEnvironment we = getWebEnvironment(sc);\n        if (we == null) {\n            throw new IllegalStateException(\"No WebEnvironment found: no EnvironmentLoaderListener registered?\");\n        }\n        return we;\n    }\n\n    /**\n     * Find the Shiro {@link WebEnvironment} for this web application, which is typically loaded via\n     * {@link org.apache.shiro.web.env.EnvironmentLoaderListener}.\n     * <p/>\n     * This implementation rethrows an exception that happened on environment startup to differentiate between a failed\n     * environment startup and no environment at all.\n     *\n     * @param sc ServletContext to find the web application context for\n     * @return the root WebApplicationContext for this web app, or <code>null</code> if none\n     * @see org.apache.shiro.web.env.EnvironmentLoader#ENVIRONMENT_ATTRIBUTE_KEY\n     * @since 1.2\n     */\n    public static WebEnvironment getWebEnvironment(ServletContext sc) {\n        return getWebEnvironment(sc, EnvironmentLoader.ENVIRONMENT_ATTRIBUTE_KEY);\n    }\n\n    /**\n     * Find the Shiro {@link WebEnvironment} for this web application.\n     *\n     * @param sc       ServletContext to find the web application context for\n     * @param attrName the name of the ServletContext attribute to look for\n     * @return the desired WebEnvironment for this web app, or <code>null</code> if none\n     * @since 1.2\n     */\n    public static WebEnvironment getWebEnvironment(ServletContext sc, String attrName) {\n        if (sc == null) {\n            throw new IllegalArgumentException(\"ServletContext argument must not be null.\");\n        }\n        Object attr = sc.getAttribute(attrName);\n        if (attr == null) {\n            return null;\n        }\n        if (attr instanceof RuntimeException) {\n            throw (RuntimeException) attr;\n        }\n        if (attr instanceof Error) {\n            throw (Error) attr;\n        }\n        if (attr instanceof Exception) {\n            throw new IllegalStateException((Exception) attr);\n        }\n        if (!(attr instanceof WebEnvironment)) {\n            throw new IllegalStateException(\"Context attribute is not of type WebEnvironment: \" + attr);\n        }\n        return (WebEnvironment) attr;\n    }\n\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)</code>.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see #DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({\"deprecation\"})\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        } catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc +\n                        \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request's\n     * {@link ServletRequest#getCharacterEncoding() character encoding}, and if that\n     * <code>null</code>, falls back to the {@link #DEFAULT_CHARACTER_ENCODING}.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null</code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    /*\n     * Returns {@code true} IFF the specified {@code SubjectContext}:\n     * <ol>\n     * <li>A {@link WebSubjectContext} instance</li>\n     * <li>The {@code WebSubjectContext}'s request/response pair are not null</li>\n     * <li>The request is an {@link HttpServletRequest} instance</li>\n     * <li>The response is an {@link HttpServletResponse} instance</li>\n     * </ol>\n     *\n     * @param context the SubjectContext to check to see if it is HTTP compatible.\n     * @return {@code true} IFF the specified context has HTTP request/response objects, {@code false} otherwise.\n     * @since 1.0\n     */\n\n    public static boolean isWeb(Object requestPairSource) {\n        return requestPairSource instanceof RequestPairSource && isWeb((RequestPairSource) requestPairSource);\n    }\n\n    public static boolean isHttp(Object requestPairSource) {\n        return requestPairSource instanceof RequestPairSource && isHttp((RequestPairSource) requestPairSource);\n    }\n\n    public static ServletRequest getRequest(Object requestPairSource) {\n        if (requestPairSource instanceof RequestPairSource) {\n            return ((RequestPairSource) requestPairSource).getServletRequest();\n        }\n        return null;\n    }\n\n    public static ServletResponse getResponse(Object requestPairSource) {\n        if (requestPairSource instanceof RequestPairSource) {\n            return ((RequestPairSource) requestPairSource).getServletResponse();\n        }\n        return null;\n    }\n\n    public static HttpServletRequest getHttpRequest(Object requestPairSource) {\n        ServletRequest request = getRequest(requestPairSource);\n        if (request instanceof HttpServletRequest) {\n            return (HttpServletRequest) request;\n        }\n        return null;\n    }\n\n    public static HttpServletResponse getHttpResponse(Object requestPairSource) {\n        ServletResponse response = getResponse(requestPairSource);\n        if (response instanceof HttpServletResponse) {\n            return (HttpServletResponse) response;\n        }\n        return null;\n    }\n\n    private static boolean isWeb(RequestPairSource source) {\n        ServletRequest request = source.getServletRequest();\n        ServletResponse response = source.getServletResponse();\n        return request != null && response != null;\n    }\n\n    private static boolean isHttp(RequestPairSource source) {\n        ServletRequest request = source.getServletRequest();\n        ServletResponse response = source.getServletResponse();\n        return request instanceof HttpServletRequest && response instanceof HttpServletResponse;\n    }\n\n    /**\n     * Returns {@code true} if a session is allowed to be created for a subject-associated request, {@code false}\n     * otherwise.\n     * <p/>\n     * <b>This method exists for Shiro's internal framework needs and should never be called by Shiro end-users.  It\n     * could be changed/removed at any time.</b>\n     *\n     * @param requestPairSource a {@link RequestPairSource} instance, almost always a\n     *                          {@link org.apache.shiro.web.subject.WebSubject WebSubject} instance.\n     * @return {@code true} if a session is allowed to be created for a subject-associated request, {@code false}\n     *         otherwise.\n     */\n    public static boolean _isSessionCreationEnabled(Object requestPairSource) {\n        if (requestPairSource instanceof RequestPairSource) {\n            RequestPairSource source = (RequestPairSource) requestPairSource;\n            return _isSessionCreationEnabled(source.getServletRequest());\n        }\n        return true; //by default\n    }\n\n    /**\n     * Returns {@code true} if a session is allowed to be created for a subject-associated request, {@code false}\n     * otherwise.\n     * <p/>\n     * <b>This method exists for Shiro's internal framework needs and should never be called by Shiro end-users.  It\n     * could be changed/removed at any time.</b>\n     *\n     * @param request incoming servlet request.\n     * @return {@code true} if a session is allowed to be created for a subject-associated request, {@code false}\n     *         otherwise.\n     */\n    public static boolean _isSessionCreationEnabled(ServletRequest request) {\n        if (request != null) {\n            Object val = request.getAttribute(DefaultSubjectContext.SESSION_CREATION_ENABLED);\n            if (val != null && val instanceof Boolean) {\n                return (Boolean) val;\n            }\n        }\n        return true; //by default\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletRequest</code> to an\n     * <code>HttpServletRequest</code>:\n     * <p/>\n     * <code>return (HttpServletRequest)request;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>request</code> argument casted to an <code>HttpServletRequest</code>.\n     */\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletResponse</code> to an\n     * <code>HttpServletResponse</code>:\n     * <p/>\n     * <code>return (HttpServletResponse)response;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param response the outgoing ServletResponse\n     * @return the <code>response</code> argument casted to an <code>HttpServletResponse</code>.\n     */\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters.\n     *\n     * @param request          the servlet request.\n     * @param response         the servlet response.\n     * @param url              the URL to redirect the user to.\n     * @param queryParams      a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative  true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request  the servlet request.\n     * @param response the servlet response.\n     * @param url      the URL to redirect the user to.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url) throws IOException {\n        issueRedirect(request, response, url, null, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request     the servlet request.\n     * @param response    the servlet response.\n     * @param url         the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams) throws IOException {\n        issueRedirect(request, response, url, queryParams, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request         the servlet request.\n     * @param response        the servlet response.\n     * @param url             the URL to redirect the user to.\n     * @param queryParams     a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative) throws IOException {\n        issueRedirect(request, response, url, queryParams, contextRelative, true);\n    }\n\n    /**\n     * <p>Checks to see if a request param is considered true using a loose matching strategy for\n     * general values that indicate that something is true or enabled, etc.</p>\n     * <p/>\n     * <p>Values that are considered \"true\" include (case-insensitive): true, t, 1, enabled, y, yes, on.</p>\n     *\n     * @param request   the servlet request\n     * @param paramName @return true if the param value is considered true or false if it isn't.\n     * @return true if the given parameter is considered \"true\" - false otherwise.\n     */\n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String value = getCleanParam(request, paramName);\n        return value != null &&\n                (value.equalsIgnoreCase(\"true\") ||\n                        value.equalsIgnoreCase(\"t\") ||\n                        value.equalsIgnoreCase(\"1\") ||\n                        value.equalsIgnoreCase(\"enabled\") ||\n                        value.equalsIgnoreCase(\"y\") ||\n                        value.equalsIgnoreCase(\"yes\") ||\n                        value.equalsIgnoreCase(\"on\"));\n    }\n\n    /**\n     * Convenience method that returns a request parameter value, first running it through\n     * {@link StringUtils#clean(String)}.\n     *\n     * @param request   the servlet request.\n     * @param paramName the parameter name.\n     * @return the clean param value, or null if the param does not exist or is empty.\n     */\n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean(request.getParameter(paramName));\n    }\n\n    public static void saveRequest(ServletRequest request) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession();\n        HttpServletRequest httpRequest = toHttp(request);\n        SavedRequest savedRequest = new SavedRequest(httpRequest);\n        session.setAttribute(SAVED_REQUEST_KEY, savedRequest);\n    }\n\n    public static SavedRequest getAndClearSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = getSavedRequest(request);\n        if (savedRequest != null) {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession();\n            session.removeAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    public static SavedRequest getSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = null;\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n            savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    /**\n     * Redirects the to the request url from a previously\n     * {@link #saveRequest(javax.servlet.ServletRequest) saved} request, or if there is no saved request, redirects the\n     * end user to the specified {@code fallbackUrl}.  If there is no saved request or fallback url, this method\n     * throws an {@link IllegalStateException}.\n     * <p/>\n     * This method is primarily used to support a common login scenario - if an unauthenticated user accesses a\n     * page that requires authentication, it is expected that request is\n     * {@link #saveRequest(javax.servlet.ServletRequest) saved} first and then redirected to the login page. Then,\n     * after a successful login, this method can be called to redirect them back to their originally requested URL, a\n     * nice usability feature.\n     *\n     * @param request     the incoming request\n     * @param response    the outgoing response\n     * @param fallbackUrl the fallback url to redirect to if there is no saved request available.\n     * @throws IllegalStateException if there is no saved request and the {@code fallbackUrl} is {@code null}.\n     * @throws IOException           if there is an error redirecting\n     * @since 1.0\n     */\n    public static void redirectToSavedRequest(ServletRequest request, ServletResponse response, String fallbackUrl)\n            throws IOException {\n        String successUrl = null;\n        boolean contextRelative = true;\n        SavedRequest savedRequest = WebUtils.getAndClearSavedRequest(request);\n        if (savedRequest != null && savedRequest.getMethod().equalsIgnoreCase(AccessControlFilter.GET_METHOD)) {\n            successUrl = savedRequest.getRequestUrl();\n            contextRelative = false;\n        }\n\n        if (successUrl == null) {\n            successUrl = fallbackUrl;\n        }\n\n        if (successUrl == null) {\n            throw new IllegalStateException(\"Success URL not available via saved request or via the \" +\n                    \"successUrlFallback method parameter. One of these must be non-null for \" +\n                    \"issueSuccessRedirect() to work.\");\n        }\n\n        WebUtils.issueRedirect(request, response, successUrl, null, contextRelative);\n    }\n\n}\n",
        "human_patch_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.shiro.web.util;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.subject.support.DefaultSubjectContext;\nimport org.apache.shiro.util.StringUtils;\nimport org.apache.shiro.web.env.EnvironmentLoader;\nimport org.apache.shiro.web.env.WebEnvironment;\nimport org.apache.shiro.web.filter.AccessControlFilter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.util.Map;\n\n/**\n * Simple utility class for operations used across multiple class hierarchies in the web framework code.\n * <p/>\n * Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,\n * and in these cases, we have retained all license, copyright and author information.\n *\n * @since 0.9\n */\npublic class WebUtils {\n\n    //TODO - complete JavaDoc\n\n    private static final Logger log = LoggerFactory.getLogger(WebUtils.class);\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_SHIRO_THREAD_CONTEXT_KEY\";\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_SHIRO_THREAD_CONTEXT_KEY\";\n\n    /**\n     * {@link org.apache.shiro.session.Session Session} key used to save a request and later restore it, for example when redirecting to a\n     * requested page after login, equal to {@code shiroSavedRequest}.\n     */\n    public static final String SAVED_REQUEST_KEY = \"shiroSavedRequest\";\n\n    /**\n     * Standard Servlet 2.3+ spec request attributes for include URI and paths.\n     * <p>If included via a RequestDispatcher, the current resource will see the\n     * originating request. Its own URI and paths are exposed as request attributes.\n     */\n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    /**\n     * Standard Servlet 2.4+ spec request attributes for forward URI and paths.\n     * <p>If forwarded to via a RequestDispatcher, the current resource will see its\n     * own URI and paths. The originating URI and paths are exposed as request attributes.\n     */\n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    /**\n     * Default character encoding to use when <code>request.getCharacterEncoding</code>\n     * returns <code>null</code>, according to the Servlet spec.\n     *\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     */\n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    /**\n     * Return the path within the web application for the given request.\n     * Detects include request URL if called within a RequestDispatcher include.\n     * <p/>\n     * For example, for a request to URL\n     * <p/>\n     * <code>http://www.somehost.com/myapp/my/url.jsp</code>,\n     * <p/>\n     * for an application deployed to <code>/mayapp</code> (the application's context path), this method would return\n     * <p/>\n     * <code>/my/url.jsp</code>.\n     *\n     * @param request current HTTP request\n     * @return the path within the web application\n     */\n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            // Normal case: URI contains context path.\n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            // Special case: rather unusual.\n            return requestUri;\n        }\n    }\n\n    /**\n     * Return the request URI for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getRequestURI()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     * <p>The URI that the web container resolves <i>should</i> be correct, but some\n     * containers like JBoss/Jetty incorrectly include \";\" strings like \";jsessionid\"\n     * in the URI. This method cuts off such incorrect appendices.\n     *\n     * @param request current HTTP request\n     * @return the request URI\n     */\n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return normalize(decodeAndCleanUriString(request, uri));\n    }\n\n    /**\n     * Normalize a relative URI path that may have relative values (\"/./\",\n     * \"/../\", and so on ) it it.  <strong>WARNING</strong> - This method is\n     * useful only for normalizing application-generated paths.  It does not\n     * try to perform security checks for malicious input.\n     * Normalize operations were was happily taken from org.apache.catalina.util.RequestUtil in\n     * Tomcat trunk, r939305\n     *\n     * @param path Relative path to be normalized\n     * @return normalized path\n     */\n    public static String normalize(String path) {\n        return normalize(path, true);\n    }\n\n    /**\n     * Normalize a relative URI path that may have relative values (\"/./\",\n     * \"/../\", and so on ) it it.  <strong>WARNING</strong> - This method is\n     * useful only for normalizing application-generated paths.  It does not\n     * try to perform security checks for malicious input.\n     * Normalize operations were was happily taken from org.apache.catalina.util.RequestUtil in\n     * Tomcat trunk, r939305\n     *\n     * @param path             Relative path to be normalized\n     * @param replaceBackSlash Should '\\\\' be replaced with '/'\n     * @return normalized path\n     */\n    private static String normalize(String path, boolean replaceBackSlash) {\n\n        if (path == null)\n            return null;\n\n        // Create a place for the normalized path\n        String normalized = path;\n\n        if (replaceBackSlash && normalized.indexOf('\\\\') >= 0)\n            normalized = normalized.replace('\\\\', '/');\n\n        if (normalized.equals(\"/.\"))\n            return \"/\";\n\n        // Add a leading \"/\" if necessary\n        if (!normalized.startsWith(\"/\"))\n            normalized = \"/\" + normalized;\n\n        // Resolve occurrences of \"//\" in the normalized path\n        while (true) {\n            int index = normalized.indexOf(\"//\");\n            if (index < 0)\n                break;\n            normalized = normalized.substring(0, index) +\n                    normalized.substring(index + 1);\n        }\n\n        // Resolve occurrences of \"/./\" in the normalized path\n        while (true) {\n            int index = normalized.indexOf(\"/./\");\n            if (index < 0)\n                break;\n            normalized = normalized.substring(0, index) +\n                    normalized.substring(index + 2);\n        }\n\n        // Resolve occurrences of \"/../\" in the normalized path\n        while (true) {\n            int index = normalized.indexOf(\"/../\");\n            if (index < 0)\n                break;\n            if (index == 0)\n                return (null);  // Trying to go outside our context\n            int index2 = normalized.lastIndexOf('/', index - 1);\n            normalized = normalized.substring(0, index2) +\n                    normalized.substring(index + 3);\n        }\n\n        // Return the normalized path that we have completed\n        return (normalized);\n\n    }\n\n\n    /**\n     * Decode the supplied URI string and strips any extraneous portion after a ';'.\n     *\n     * @param request the incoming HttpServletRequest\n     * @param uri     the application's URI string\n     * @return the supplied URI string stripped of any extraneous portion after a ';'.\n     */\n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    /**\n     * Return the context path for the given request, detecting an include request\n     * URL if called within a RequestDispatcher include.\n     * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>\n     * decoded by the servlet container, this method will decode it.\n     *\n     * @param request current HTTP request\n     * @return the context path\n     */\n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        contextPath = normalize(decodeRequestString(request, contextPath));\n        if (\"/\".equals(contextPath)) {\n            // the normalize method will return a \"/\" and includes on Jetty, will also be a \"/\".\n            contextPath = \"\";\n        }\n        return contextPath;\n    }\n\n    /**\n     * Find the Shiro {@link WebEnvironment} for this web application, which is typically loaded via the\n     * {@link org.apache.shiro.web.env.EnvironmentLoaderListener}.\n     * <p/>\n     * This implementation rethrows an exception that happened on environment startup to differentiate between a failed\n     * environment startup and no environment at all.\n     *\n     * @param sc ServletContext to find the web application context for\n     * @return the root WebApplicationContext for this web app\n     * @throws IllegalStateException if the root WebApplicationContext could not be found\n     * @see org.apache.shiro.web.env.EnvironmentLoader#ENVIRONMENT_ATTRIBUTE_KEY\n     * @since 1.2\n     */\n    public static WebEnvironment getRequiredWebEnvironment(ServletContext sc)\n            throws IllegalStateException {\n\n        WebEnvironment we = getWebEnvironment(sc);\n        if (we == null) {\n            throw new IllegalStateException(\"No WebEnvironment found: no EnvironmentLoaderListener registered?\");\n        }\n        return we;\n    }\n\n    /**\n     * Find the Shiro {@link WebEnvironment} for this web application, which is typically loaded via\n     * {@link org.apache.shiro.web.env.EnvironmentLoaderListener}.\n     * <p/>\n     * This implementation rethrows an exception that happened on environment startup to differentiate between a failed\n     * environment startup and no environment at all.\n     *\n     * @param sc ServletContext to find the web application context for\n     * @return the root WebApplicationContext for this web app, or <code>null</code> if none\n     * @see org.apache.shiro.web.env.EnvironmentLoader#ENVIRONMENT_ATTRIBUTE_KEY\n     * @since 1.2\n     */\n    public static WebEnvironment getWebEnvironment(ServletContext sc) {\n        return getWebEnvironment(sc, EnvironmentLoader.ENVIRONMENT_ATTRIBUTE_KEY);\n    }\n\n    /**\n     * Find the Shiro {@link WebEnvironment} for this web application.\n     *\n     * @param sc       ServletContext to find the web application context for\n     * @param attrName the name of the ServletContext attribute to look for\n     * @return the desired WebEnvironment for this web app, or <code>null</code> if none\n     * @since 1.2\n     */\n    public static WebEnvironment getWebEnvironment(ServletContext sc, String attrName) {\n        if (sc == null) {\n            throw new IllegalArgumentException(\"ServletContext argument must not be null.\");\n        }\n        Object attr = sc.getAttribute(attrName);\n        if (attr == null) {\n            return null;\n        }\n        if (attr instanceof RuntimeException) {\n            throw (RuntimeException) attr;\n        }\n        if (attr instanceof Error) {\n            throw (Error) attr;\n        }\n        if (attr instanceof Exception) {\n            throw new IllegalStateException((Exception) attr);\n        }\n        if (!(attr instanceof WebEnvironment)) {\n            throw new IllegalStateException(\"Context attribute is not of type WebEnvironment: \" + attr);\n        }\n        return (WebEnvironment) attr;\n    }\n\n\n    /**\n     * Decode the given source string with a URLDecoder. The encoding will be taken\n     * from the request, falling back to the default \"ISO-8859-1\".\n     * <p>The default implementation uses <code>URLDecoder.decode(input, enc)</code>.\n     *\n     * @param request current HTTP request\n     * @param source  the String to decode\n     * @return the decoded String\n     * @see #DEFAULT_CHARACTER_ENCODING\n     * @see javax.servlet.ServletRequest#getCharacterEncoding\n     * @see java.net.URLDecoder#decode(String, String)\n     * @see java.net.URLDecoder#decode(String)\n     */\n    @SuppressWarnings({\"deprecation\"})\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        } catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc +\n                        \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    /**\n     * Determine the encoding for the given request.\n     * Can be overridden in subclasses.\n     * <p>The default implementation checks the request's\n     * {@link ServletRequest#getCharacterEncoding() character encoding}, and if that\n     * <code>null</code>, falls back to the {@link #DEFAULT_CHARACTER_ENCODING}.\n     *\n     * @param request current HTTP request\n     * @return the encoding for the request (never <code>null</code>)\n     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n     */\n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    /*\n     * Returns {@code true} IFF the specified {@code SubjectContext}:\n     * <ol>\n     * <li>A {@link WebSubjectContext} instance</li>\n     * <li>The {@code WebSubjectContext}'s request/response pair are not null</li>\n     * <li>The request is an {@link HttpServletRequest} instance</li>\n     * <li>The response is an {@link HttpServletResponse} instance</li>\n     * </ol>\n     *\n     * @param context the SubjectContext to check to see if it is HTTP compatible.\n     * @return {@code true} IFF the specified context has HTTP request/response objects, {@code false} otherwise.\n     * @since 1.0\n     */\n\n    public static boolean isWeb(Object requestPairSource) {\n        return requestPairSource instanceof RequestPairSource && isWeb((RequestPairSource) requestPairSource);\n    }\n\n    public static boolean isHttp(Object requestPairSource) {\n        return requestPairSource instanceof RequestPairSource && isHttp((RequestPairSource) requestPairSource);\n    }\n\n    public static ServletRequest getRequest(Object requestPairSource) {\n        if (requestPairSource instanceof RequestPairSource) {\n            return ((RequestPairSource) requestPairSource).getServletRequest();\n        }\n        return null;\n    }\n\n    public static ServletResponse getResponse(Object requestPairSource) {\n        if (requestPairSource instanceof RequestPairSource) {\n            return ((RequestPairSource) requestPairSource).getServletResponse();\n        }\n        return null;\n    }\n\n    public static HttpServletRequest getHttpRequest(Object requestPairSource) {\n        ServletRequest request = getRequest(requestPairSource);\n        if (request instanceof HttpServletRequest) {\n            return (HttpServletRequest) request;\n        }\n        return null;\n    }\n\n    public static HttpServletResponse getHttpResponse(Object requestPairSource) {\n        ServletResponse response = getResponse(requestPairSource);\n        if (response instanceof HttpServletResponse) {\n            return (HttpServletResponse) response;\n        }\n        return null;\n    }\n\n    private static boolean isWeb(RequestPairSource source) {\n        ServletRequest request = source.getServletRequest();\n        ServletResponse response = source.getServletResponse();\n        return request != null && response != null;\n    }\n\n    private static boolean isHttp(RequestPairSource source) {\n        ServletRequest request = source.getServletRequest();\n        ServletResponse response = source.getServletResponse();\n        return request instanceof HttpServletRequest && response instanceof HttpServletResponse;\n    }\n\n    /**\n     * Returns {@code true} if a session is allowed to be created for a subject-associated request, {@code false}\n     * otherwise.\n     * <p/>\n     * <b>This method exists for Shiro's internal framework needs and should never be called by Shiro end-users.  It\n     * could be changed/removed at any time.</b>\n     *\n     * @param requestPairSource a {@link RequestPairSource} instance, almost always a\n     *                          {@link org.apache.shiro.web.subject.WebSubject WebSubject} instance.\n     * @return {@code true} if a session is allowed to be created for a subject-associated request, {@code false}\n     *         otherwise.\n     */\n    public static boolean _isSessionCreationEnabled(Object requestPairSource) {\n        if (requestPairSource instanceof RequestPairSource) {\n            RequestPairSource source = (RequestPairSource) requestPairSource;\n            return _isSessionCreationEnabled(source.getServletRequest());\n        }\n        return true; //by default\n    }\n\n    /**\n     * Returns {@code true} if a session is allowed to be created for a subject-associated request, {@code false}\n     * otherwise.\n     * <p/>\n     * <b>This method exists for Shiro's internal framework needs and should never be called by Shiro end-users.  It\n     * could be changed/removed at any time.</b>\n     *\n     * @param request incoming servlet request.\n     * @return {@code true} if a session is allowed to be created for a subject-associated request, {@code false}\n     *         otherwise.\n     */\n    public static boolean _isSessionCreationEnabled(ServletRequest request) {\n        if (request != null) {\n            Object val = request.getAttribute(DefaultSubjectContext.SESSION_CREATION_ENABLED);\n            if (val != null && val instanceof Boolean) {\n                return (Boolean) val;\n            }\n        }\n        return true; //by default\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletRequest</code> to an\n     * <code>HttpServletRequest</code>:\n     * <p/>\n     * <code>return (HttpServletRequest)request;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param request the incoming ServletRequest\n     * @return the <code>request</code> argument casted to an <code>HttpServletRequest</code>.\n     */\n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    /**\n     * A convenience method that merely casts the incoming <code>ServletResponse</code> to an\n     * <code>HttpServletResponse</code>:\n     * <p/>\n     * <code>return (HttpServletResponse)response;</code>\n     * <p/>\n     * Logic could be changed in the future for logging or throwing an meaningful exception in\n     * non HTTP request environments (e.g. Portlet API).\n     *\n     * @param response the outgoing ServletResponse\n     * @return the <code>response</code> argument casted to an <code>HttpServletResponse</code>.\n     */\n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters.\n     *\n     * @param request          the servlet request.\n     * @param response         the servlet response.\n     * @param url              the URL to redirect the user to.\n     * @param queryParams      a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative  true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @param http10Compatible whether to stay compatible with HTTP 1.0 clients.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request  the servlet request.\n     * @param response the servlet response.\n     * @param url      the URL to redirect the user to.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url) throws IOException {\n        issueRedirect(request, response, url, null, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request     the servlet request.\n     * @param response    the servlet response.\n     * @param url         the URL to redirect the user to.\n     * @param queryParams a map of parameters that should be set as request parameters for the new request.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams) throws IOException {\n        issueRedirect(request, response, url, queryParams, true, true);\n    }\n\n    /**\n     * Redirects the current request to a new URL based on the given parameters and default values\n     * for unspecified parameters.\n     *\n     * @param request         the servlet request.\n     * @param response        the servlet response.\n     * @param url             the URL to redirect the user to.\n     * @param queryParams     a map of parameters that should be set as request parameters for the new request.\n     * @param contextRelative true if the URL is relative to the servlet context path, or false if the URL is absolute.\n     * @throws java.io.IOException if thrown by response methods.\n     */\n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative) throws IOException {\n        issueRedirect(request, response, url, queryParams, contextRelative, true);\n    }\n\n    /**\n     * <p>Checks to see if a request param is considered true using a loose matching strategy for\n     * general values that indicate that something is true or enabled, etc.</p>\n     * <p/>\n     * <p>Values that are considered \"true\" include (case-insensitive): true, t, 1, enabled, y, yes, on.</p>\n     *\n     * @param request   the servlet request\n     * @param paramName @return true if the param value is considered true or false if it isn't.\n     * @return true if the given parameter is considered \"true\" - false otherwise.\n     */\n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String value = getCleanParam(request, paramName);\n        return value != null &&\n                (value.equalsIgnoreCase(\"true\") ||\n                        value.equalsIgnoreCase(\"t\") ||\n                        value.equalsIgnoreCase(\"1\") ||\n                        value.equalsIgnoreCase(\"enabled\") ||\n                        value.equalsIgnoreCase(\"y\") ||\n                        value.equalsIgnoreCase(\"yes\") ||\n                        value.equalsIgnoreCase(\"on\"));\n    }\n\n    /**\n     * Convenience method that returns a request parameter value, first running it through\n     * {@link StringUtils#clean(String)}.\n     *\n     * @param request   the servlet request.\n     * @param paramName the parameter name.\n     * @return the clean param value, or null if the param does not exist or is empty.\n     */\n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean(request.getParameter(paramName));\n    }\n\n    public static void saveRequest(ServletRequest request) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession();\n        HttpServletRequest httpRequest = toHttp(request);\n        SavedRequest savedRequest = new SavedRequest(httpRequest);\n        session.setAttribute(SAVED_REQUEST_KEY, savedRequest);\n    }\n\n    public static SavedRequest getAndClearSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = getSavedRequest(request);\n        if (savedRequest != null) {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession();\n            session.removeAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    public static SavedRequest getSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = null;\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n            savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    /**\n     * Redirects the to the request url from a previously\n     * {@link #saveRequest(javax.servlet.ServletRequest) saved} request, or if there is no saved request, redirects the\n     * end user to the specified {@code fallbackUrl}.  If there is no saved request or fallback url, this method\n     * throws an {@link IllegalStateException}.\n     * <p/>\n     * This method is primarily used to support a common login scenario - if an unauthenticated user accesses a\n     * page that requires authentication, it is expected that request is\n     * {@link #saveRequest(javax.servlet.ServletRequest) saved} first and then redirected to the login page. Then,\n     * after a successful login, this method can be called to redirect them back to their originally requested URL, a\n     * nice usability feature.\n     *\n     * @param request     the incoming request\n     * @param response    the outgoing response\n     * @param fallbackUrl the fallback url to redirect to if there is no saved request available.\n     * @throws IllegalStateException if there is no saved request and the {@code fallbackUrl} is {@code null}.\n     * @throws IOException           if there is an error redirecting\n     * @since 1.0\n     */\n    public static void redirectToSavedRequest(ServletRequest request, ServletResponse response, String fallbackUrl)\n            throws IOException {\n        String successUrl = null;\n        boolean contextRelative = true;\n        SavedRequest savedRequest = WebUtils.getAndClearSavedRequest(request);\n        if (savedRequest != null && savedRequest.getMethod().equalsIgnoreCase(AccessControlFilter.GET_METHOD)) {\n            successUrl = savedRequest.getRequestUrl();\n            contextRelative = false;\n        }\n\n        if (successUrl == null) {\n            successUrl = fallbackUrl;\n        }\n\n        if (successUrl == null) {\n            throw new IllegalStateException(\"Success URL not available via saved request or via the \" +\n                    \"successUrlFallback method parameter. One of these must be non-null for \" +\n                    \"issueSuccessRedirect() to work.\");\n        }\n\n        WebUtils.issueRedirect(request, response, successUrl, null, contextRelative);\n    }\n\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-23": {
    "vul_id": "VUL4J-23",
    "cve_id": "CVE-2016-5394",
    "project": "apache_sling",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl bundles/extensions/xss -Dtest=org.apache.sling.xss.impl.XSSAPIImplTest",
    "test_all_cmd": "mvn test -pl bundles/extensions/xss",
    "human_patch_url": "https://github.com/apache/sling/commit/7d2365a248943071a44d8495655186e4f14ea294",
    "vulnerable_files": [
      {
        "file_path": "bundles/extensions/xss/src/main/java/org/apache/sling/xss/impl/XSSAPIImpl.java",
        "file_name": "XSSAPIImpl.java",
        "vulnerable_code": "/*******************************************************************************\n * Licensed to the Apache Software Foundation (ASF) under one or\n * more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to you under the\n * Apache License, Version 2.0 (the \"License\"); you may not use\n * this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0 Unless required by\n * applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n ******************************************************************************/\npackage org.apache.sling.xss.impl;\n\nimport java.io.StringReader;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.Nonnull;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.apache.felix.scr.annotations.Activate;\nimport org.apache.felix.scr.annotations.Component;\nimport org.apache.felix.scr.annotations.Deactivate;\nimport org.apache.felix.scr.annotations.Reference;\nimport org.apache.felix.scr.annotations.Service;\nimport org.apache.sling.api.SlingHttpServletRequest;\nimport org.apache.sling.api.resource.ResourceResolver;\nimport org.apache.sling.commons.json.JSONArray;\nimport org.apache.sling.commons.json.JSONException;\nimport org.apache.sling.commons.json.JSONObject;\nimport org.apache.sling.xss.ProtectionContext;\nimport org.apache.sling.xss.XSSAPI;\nimport org.apache.sling.xss.XSSFilter;\nimport org.owasp.encoder.Encode;\nimport org.owasp.esapi.ESAPI;\nimport org.owasp.esapi.Validator;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.XMLReader;\n\n@Component\n@Service(value = XSSAPI.class)\npublic class XSSAPIImpl implements XSSAPI {\n    private static final Logger LOGGER = LoggerFactory.getLogger(XSSAPIImpl.class);\n\n    @Reference\n    private XSSFilter xssFilter = null;\n\n    private Validator validator = ESAPI.validator();\n\n    private static final Pattern PATTERN_AUTO_DIMENSION = Pattern.compile(\"['\\\"]?auto['\\\"]?\");\n\n    private SAXParserFactory factory;\n\n    @Activate\n    @SuppressWarnings(\"unused\")\n    protected void activate() {\n        factory = SAXParserFactory.newInstance();\n        factory.setValidating(false);\n        factory.setNamespaceAware(true);\n    }\n\n    @Deactivate\n    @SuppressWarnings(\"unused\")\n    protected void deactivate() {\n        factory = null;\n    }\n\n    // =============================================================================================\n    // VALIDATORS\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidInteger(String, int)\n     */\n    @Override\n    public Integer getValidInteger(String integer, int defaultValue) {\n        if (integer != null && integer.length() > 0) {\n            try {\n                return validator.getValidInteger(\"XSS\", integer, -2000000000, 2000000000, false);\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidLong(String, long)\n     */\n    @Override\n    public Long getValidLong(String source, long defaultValue) {\n        if (source != null && source.length() > 0) {\n            try {\n                LongValidationRule ivr = new LongValidationRule( \"number\", ESAPI.encoder(), -9000000000000000000L, 9000000000000000000L );\n                ivr.setAllowNull(false);\n                return ivr.getValid(\"XSS\", source);\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidDouble(String, double)\n     */\n    @Override\n    public Double getValidDouble(String source, double defaultValue) {\n        if (source != null && source.length() > 0) {\n            try {\n                return validator.getValidDouble(\"XSS\", source, 0d, Double.MAX_VALUE, false);\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidDimension(String, String)\n     */\n    @Override\n    public String getValidDimension(String dimension, String defaultValue) {\n        if (dimension != null && dimension.length() > 0) {\n            if (PATTERN_AUTO_DIMENSION.matcher(dimension).matches()) {\n                return \"\\\"auto\\\"\";\n            }\n\n            try {\n                return validator.getValidInteger(\"XSS\", dimension, -10000, 10000, false).toString();\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    private static final String LINK_PREFIX = \"<a href=\\\"\";\n    private static final String LINK_SUFFIX = \"\\\"></a>\";\n\n    private static final String MANGLE_NAMESPACE_OUT_SUFFIX = \":\";\n\n    private static final String MANGLE_NAMESPACE_OUT = \"/([^:/]+):\";\n\n    private static final Pattern MANGLE_NAMESPACE_PATTERN = Pattern.compile(MANGLE_NAMESPACE_OUT);\n\n    private static final String MANGLE_NAMESPACE_IN_SUFFIX = \"_\";\n\n    private static final String MANGLE_NAMESPACE_IN_PREFIX = \"/_\";\n\n    private static final String SCHEME_PATTERN = \"://\";\n\n    private String mangleNamespaces(String absPath) {\n        if (absPath != null) {\n            // check for absolute urls\n            final int schemeIndex = absPath.indexOf(SCHEME_PATTERN);\n            final String manglePath;\n            final String prefix;\n            if (schemeIndex != -1) {\n                final int pathIndex = absPath.indexOf(\"/\", schemeIndex + 3);\n                if (pathIndex != -1) {\n                    prefix = absPath.substring(0, pathIndex);\n                    manglePath = absPath.substring(pathIndex);\n                } else {\n                    prefix = absPath;\n                    manglePath = \"\";\n                }\n            } else {\n                prefix = \"\";\n                manglePath = absPath;\n            }\n            if (manglePath.contains(MANGLE_NAMESPACE_OUT_SUFFIX)) {\n                final Matcher m = MANGLE_NAMESPACE_PATTERN.matcher(manglePath);\n\n                final StringBuffer buf = new StringBuffer();\n                while (m.find()) {\n                    final String replacement = MANGLE_NAMESPACE_IN_PREFIX + m.group(1) + MANGLE_NAMESPACE_IN_SUFFIX;\n                    m.appendReplacement(buf, replacement);\n                }\n\n                m.appendTail(buf);\n\n                absPath = prefix + buf.toString();\n\n            }\n        }\n\n        return absPath;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidHref(String)\n     */\n    @Override\n    @Nonnull\n    public String getValidHref(final String url) {\n        if (url != null && url.length() > 0) {\n            // Percent-encode characters that are not allowed in unquoted\n            // HTML attributes: \", ', >, <, ` and space. We don't encode =\n            // since this would break links with query parameters.\n            String encodedUrl = url.replaceAll(\"\\\"\", \"%22\")\n                    .replaceAll(\"'\", \"%27\")\n                    .replaceAll(\">\", \"%3E\")\n                    .replaceAll(\"<\", \"%3C\")\n                    .replaceAll(\"`\", \"%60\")\n                    .replaceAll(\" \", \"%20\");\n            int qMarkIx = encodedUrl.indexOf('?');\n            if (qMarkIx > 0) {\n                encodedUrl = encodedUrl.substring(0, qMarkIx) + encodedUrl.substring(qMarkIx).replaceAll(\":\", \"%3A\");\n            }\n\n            encodedUrl = mangleNamespaces(encodedUrl);\n            if (xssFilter.isValidHref(encodedUrl)) {\n                return encodedUrl;\n            }\n        }\n\n        // fall through to empty string\n        return \"\";\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidJSToken(String, String)\n     */\n    @Override\n    public String getValidJSToken(String token, String defaultValue) {\n        if (token != null && token.length() > 0) {\n            token = token.trim();\n            String q = token.substring(0, 1);\n            if (q.matches(\"['\\\"]\") && token.endsWith(q)) {\n                String literal = token.substring(1, token.length() - 1);\n                return q + encodeForJSString(literal) + q;\n            } else if (token.matches(\"[0-9a-zA-Z_$][0-9a-zA-Z_$.]*\")) {\n                return token;\n            }\n        }\n\n        // fall through to default value\n        return defaultValue;\n    }\n\n    private static final String NON_ASCII = \"\\\\x00\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\";\n    /** http://www.w3.org/TR/css-syntax-3/#number-token-diagram */\n    private static final String NUMBER = \"[+-]?[\\\\d]*[\\\\.]?[\\\\d]*(?:[e][+-]?\\\\d+)?\";\n    /** http://www.w3.org/TR/css-syntax-3/#hex-digit-diagram */\n    private static final String HEX_DIGITS = \"#[0-9a-f]*\";\n    /** http://www.w3.org/TR/css-syntax-3/#ident-token-diagram */\n    private static final String IDENTIFIER = \"-?[a-z_\" + NON_ASCII + \"][\\\\w_\\\\-\" + NON_ASCII + \"]*\";\n    /** http://www.w3.org/TR/css-syntax-3/#string-token-diagram */\n    private static final String STRING = \"\\\"(?:(?!javascript\\\\s?:)[^\\\"^\\\\\\\\^\\\\n]|(?:\\\\\\\\\\\"))*\\\"|'(?:(?!javascript\\\\s?:)[^'^\\\\\\\\^\\\\n]|(?:\\\\\\\\'))*'\";\n    /** http://www.w3.org/TR/css-syntax-3/#dimension-token-diagram */\n    private static final String DIMENSION = NUMBER + IDENTIFIER;\n    /** http://www.w3.org/TR/css-syntax-3/#percentage-token-diagram */\n    private static final String PERCENT = NUMBER + \"%\";\n    /** http://www.w3.org/TR/css-syntax-3/#function-token-diagram */\n    private static final String FUNCTION = IDENTIFIER + \"\\\\((?:(?:\" + NUMBER + \")|(?:\" + IDENTIFIER + \")|(?:[\\\\s]*)|(?:,))*\\\\)\";\n    /** http://www.w3.org/TR/css-syntax-3/#url-unquoted-diagram */\n    private static final String URL_UNQUOTED = \"[^\\\"^'^\\\\(^\\\\)^[\" + NON_ASCII + \"]]*\";\n    /** http://www.w3.org/TR/css-syntax-3/#url-token-diagram */\n    private static final String URL = \"url\\\\((?:(?:\" + URL_UNQUOTED + \")|(?:\" + STRING + \"))\\\\)\";\n    /** composite regular expression for style token validation */\n    private static final String CSS_TOKEN = \"(?i)\" // case insensitive\n            + \"(?:\" + NUMBER + \")\"\n            + \"|(?:\" + DIMENSION + \")\"\n            + \"|(?:\" + PERCENT + \")\"\n            + \"|(?:\" + HEX_DIGITS + \")\"\n            + \"|(?:\" + IDENTIFIER + \")\"\n            + \"|(?:\" + STRING + \")\"\n            + \"|(?:\" + FUNCTION + \")\"\n            + \"|(?:\" + URL + \")\";\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidStyleToken(String, String)\n     */\n    @Override\n    public String getValidStyleToken(String token, String defaultValue) {\n        if (token != null && token.length() > 0 && token.matches(CSS_TOKEN)) {\n            return token;\n        }\n\n        return defaultValue;\n   }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidCSSColor(String, String)\n     */\n    @Override\n    public String getValidCSSColor(String color, String defaultColor) {\n        if (color != null && color.length() > 0) {\n            color = color.trim();\n            /*\n             * Avoid security implications by including only the characters required to specify colors in hex\n             * or functional notation. Critical characters disallowed: x (as in expression(...)),\n             * u (as in url(...)) and semi colon (as in escaping the context of the color value).\n             */\n            if (color.matches(\"(?i)[#a-fghlrs(+0-9-.%,) \\\\t\\\\n\\\\x0B\\\\f\\\\r]+\")) {\n                return color;\n            }\n            // named color values\n            if (color.matches(\"(?i)[a-zA-Z \\\\t\\\\n\\\\x0B\\\\f\\\\r]+\")) {\n                return color;\n            }\n        }\n\n        return defaultColor;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidMultiLineComment(String, String)\n     */\n    @Override\n    public String getValidMultiLineComment(String comment, String defaultComment) {\n        if (comment != null && !comment.contains(\"*/\")) {\n            return comment;\n        }\n        return defaultComment;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidJSON(String, String)\n     */\n    @Override\n    public String getValidJSON(String json, String defaultJson) {\n        if (json == null) {\n            return getValidJSON(defaultJson, \"\");\n        }\n        json = json.trim();\n        if (\"\".equals(json)) {\n            return \"\";\n        }\n        int curlyIx = json.indexOf(\"{\");\n        int straightIx = json.indexOf(\"[\");\n        if (curlyIx >= 0 && (curlyIx < straightIx || straightIx < 0)) {\n            try {\n                JSONObject obj = new JSONObject(json);\n                return obj.toString();\n            } catch (JSONException e) {\n                LOGGER.debug(\"JSON validation failed: \" + e.getMessage(), e);\n            }\n        } else {\n            try {\n                JSONArray arr = new JSONArray(json);\n                return arr.toString();\n            } catch (JSONException e) {\n                LOGGER.debug(\"JSON validation failed: \" + e.getMessage(), e);\n            }\n        }\n        return getValidJSON(defaultJson, \"\");\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidXML(String, String)\n     */\n    @Override\n    public String getValidXML(String xml, String defaultXml) {\n        if (xml == null) {\n            return getValidXML(defaultXml, \"\");\n        }\n        xml = xml.trim();\n        if (\"\".equals(xml)) {\n            return \"\";\n        }\n\n        try {\n            SAXParser parser = factory.newSAXParser();\n            XMLReader reader = parser.getXMLReader();\n            reader.parse(new InputSource(new StringReader(xml)));\n            return xml;\n        } catch (Exception e) {\n            LOGGER.debug(\"XML validation failed: \" + e.getMessage(), e);\n        }\n        return getValidXML(defaultXml, \"\");\n    }\n\n    // =============================================================================================\n    // ENCODERS\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForHTML(String)\n     */\n    @Override\n    public String encodeForHTML(String source) {\n        return source == null ? null : Encode.forHtml(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForHTMLAttr(String)\n     */\n    @Override\n    public String encodeForHTMLAttr(String source) {\n        return source == null ? null : Encode.forHtmlAttribute(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForXML(String)\n     */\n    @Override\n    public String encodeForXML(String source) {\n        return source == null ? null : Encode.forXml(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForXMLAttr(String)\n     */\n    @Override\n    public String encodeForXMLAttr(String source) {\n        return source == null ? null : Encode.forXmlAttribute(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForJSString(String)\n     */\n    @Override\n    public String encodeForJSString(String source) {\n        return source == null ? null : Encode.forJavaScriptSource(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForCSSString(String)\n     */\n    @Override\n    public String encodeForCSSString(String source) {\n        return source == null ? null : Encode.forCssString(source);\n    }\n\n    // =============================================================================================\n    // FILTERS\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#filterHTML(String)\n     */\n    @Override\n    @Nonnull\n    public String filterHTML(String source) {\n        return xssFilter.filter(ProtectionContext.HTML_HTML_CONTENT, source);\n    }\n\n    // =============================================================================================\n    // JCR-NAMESPACE MANGLING\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getRequestSpecificAPI(org.apache.sling.api.SlingHttpServletRequest)\n     */\n    @Override\n    public XSSAPI getRequestSpecificAPI(final SlingHttpServletRequest request) {\n        return this;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getResourceResolverSpecificAPI(org.apache.sling.api.resource.ResourceResolver)\n     */\n    @Override\n    public XSSAPI getResourceResolverSpecificAPI(final ResourceResolver resourceResolver) {\n        return this;\n    }\n}\n",
        "human_patch_code": "/*******************************************************************************\n * Licensed to the Apache Software Foundation (ASF) under one or\n * more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to you under the\n * Apache License, Version 2.0 (the \"License\"); you may not use\n * this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0 Unless required by\n * applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n ******************************************************************************/\npackage org.apache.sling.xss.impl;\n\nimport java.io.StringReader;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.Nonnull;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.apache.felix.scr.annotations.Activate;\nimport org.apache.felix.scr.annotations.Component;\nimport org.apache.felix.scr.annotations.Deactivate;\nimport org.apache.felix.scr.annotations.Reference;\nimport org.apache.felix.scr.annotations.Service;\nimport org.apache.sling.api.SlingHttpServletRequest;\nimport org.apache.sling.api.resource.ResourceResolver;\nimport org.apache.sling.commons.json.JSONArray;\nimport org.apache.sling.commons.json.JSONException;\nimport org.apache.sling.commons.json.JSONObject;\nimport org.apache.sling.xss.ProtectionContext;\nimport org.apache.sling.xss.XSSAPI;\nimport org.apache.sling.xss.XSSFilter;\nimport org.owasp.encoder.Encode;\nimport org.owasp.esapi.ESAPI;\nimport org.owasp.esapi.Validator;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.XMLReader;\n\n@Component\n@Service(value = XSSAPI.class)\npublic class XSSAPIImpl implements XSSAPI {\n    private static final Logger LOGGER = LoggerFactory.getLogger(XSSAPIImpl.class);\n\n    @Reference\n    private XSSFilter xssFilter = null;\n\n    private Validator validator = ESAPI.validator();\n\n    private static final Pattern PATTERN_AUTO_DIMENSION = Pattern.compile(\"['\\\"]?auto['\\\"]?\");\n\n    private SAXParserFactory factory;\n\n    @Activate\n    @SuppressWarnings(\"unused\")\n    protected void activate() {\n        factory = SAXParserFactory.newInstance();\n        factory.setValidating(false);\n        factory.setNamespaceAware(true);\n    }\n\n    @Deactivate\n    @SuppressWarnings(\"unused\")\n    protected void deactivate() {\n        factory = null;\n    }\n\n    // =============================================================================================\n    // VALIDATORS\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidInteger(String, int)\n     */\n    @Override\n    public Integer getValidInteger(String integer, int defaultValue) {\n        if (integer != null && integer.length() > 0) {\n            try {\n                return validator.getValidInteger(\"XSS\", integer, -2000000000, 2000000000, false);\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidLong(String, long)\n     */\n    @Override\n    public Long getValidLong(String source, long defaultValue) {\n        if (source != null && source.length() > 0) {\n            try {\n                LongValidationRule ivr = new LongValidationRule( \"number\", ESAPI.encoder(), -9000000000000000000L, 9000000000000000000L );\n                ivr.setAllowNull(false);\n                return ivr.getValid(\"XSS\", source);\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidDouble(String, double)\n     */\n    @Override\n    public Double getValidDouble(String source, double defaultValue) {\n        if (source != null && source.length() > 0) {\n            try {\n                return validator.getValidDouble(\"XSS\", source, 0d, Double.MAX_VALUE, false);\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidDimension(String, String)\n     */\n    @Override\n    public String getValidDimension(String dimension, String defaultValue) {\n        if (dimension != null && dimension.length() > 0) {\n            if (PATTERN_AUTO_DIMENSION.matcher(dimension).matches()) {\n                return \"\\\"auto\\\"\";\n            }\n\n            try {\n                return validator.getValidInteger(\"XSS\", dimension, -10000, 10000, false).toString();\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    private static final String LINK_PREFIX = \"<a href=\\\"\";\n    private static final String LINK_SUFFIX = \"\\\"></a>\";\n\n    private static final String MANGLE_NAMESPACE_OUT_SUFFIX = \":\";\n\n    private static final String MANGLE_NAMESPACE_OUT = \"/([^:/]+):\";\n\n    private static final Pattern MANGLE_NAMESPACE_PATTERN = Pattern.compile(MANGLE_NAMESPACE_OUT);\n\n    private static final String MANGLE_NAMESPACE_IN_SUFFIX = \"_\";\n\n    private static final String MANGLE_NAMESPACE_IN_PREFIX = \"/_\";\n\n    private static final String SCHEME_PATTERN = \"://\";\n\n    private String mangleNamespaces(String absPath) {\n        if (absPath != null) {\n            // check for absolute urls\n            final int schemeIndex = absPath.indexOf(SCHEME_PATTERN);\n            final String manglePath;\n            final String prefix;\n            if (schemeIndex != -1) {\n                final int pathIndex = absPath.indexOf(\"/\", schemeIndex + 3);\n                if (pathIndex != -1) {\n                    prefix = absPath.substring(0, pathIndex);\n                    manglePath = absPath.substring(pathIndex);\n                } else {\n                    prefix = absPath;\n                    manglePath = \"\";\n                }\n            } else {\n                prefix = \"\";\n                manglePath = absPath;\n            }\n            if (manglePath.contains(MANGLE_NAMESPACE_OUT_SUFFIX)) {\n                final Matcher m = MANGLE_NAMESPACE_PATTERN.matcher(manglePath);\n\n                final StringBuffer buf = new StringBuffer();\n                while (m.find()) {\n                    final String replacement = MANGLE_NAMESPACE_IN_PREFIX + m.group(1) + MANGLE_NAMESPACE_IN_SUFFIX;\n                    m.appendReplacement(buf, replacement);\n                }\n\n                m.appendTail(buf);\n\n                absPath = prefix + buf.toString();\n\n            }\n        }\n\n        return absPath;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidHref(String)\n     */\n    @Override\n    @Nonnull\n    public String getValidHref(final String url) {\n        if (url != null && url.length() > 0) {\n            // Percent-encode characters that are not allowed in unquoted\n            // HTML attributes: \", ', >, <, ` and space. We don't encode =\n            // since this would break links with query parameters.\n            String encodedUrl = url.replaceAll(\"\\\"\", \"%22\")\n                    .replaceAll(\"'\", \"%27\")\n                    .replaceAll(\">\", \"%3E\")\n                    .replaceAll(\"<\", \"%3C\")\n                    .replaceAll(\"`\", \"%60\")\n                    .replaceAll(\" \", \"%20\");\n            int qMarkIx = encodedUrl.indexOf('?');\n            if (qMarkIx > 0) {\n                encodedUrl = encodedUrl.substring(0, qMarkIx) + encodedUrl.substring(qMarkIx).replaceAll(\":\", \"%3A\");\n            }\n\n            encodedUrl = mangleNamespaces(encodedUrl);\n            if (xssFilter.isValidHref(encodedUrl)) {\n                return encodedUrl;\n            }\n        }\n\n        // fall through to empty string\n        return \"\";\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidJSToken(String, String)\n     */\n    @Override\n    public String getValidJSToken(String token, String defaultValue) {\n        if (token != null && token.length() > 0) {\n            token = token.trim();\n            String q = token.substring(0, 1);\n            if (q.matches(\"['\\\"]\") && token.endsWith(q)) {\n                String literal = token.substring(1, token.length() - 1);\n                return q + encodeForJSString(literal) + q;\n            } else if (token.matches(\"[0-9a-zA-Z_$][0-9a-zA-Z_$.]*\")) {\n                return token;\n            }\n        }\n\n        // fall through to default value\n        return defaultValue;\n    }\n\n    private static final String NON_ASCII = \"\\\\x00\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\";\n    /** http://www.w3.org/TR/css-syntax-3/#number-token-diagram */\n    private static final String NUMBER = \"[+-]?[\\\\d]*[\\\\.]?[\\\\d]*(?:[e][+-]?\\\\d+)?\";\n    /** http://www.w3.org/TR/css-syntax-3/#hex-digit-diagram */\n    private static final String HEX_DIGITS = \"#[0-9a-f]*\";\n    /** http://www.w3.org/TR/css-syntax-3/#ident-token-diagram */\n    private static final String IDENTIFIER = \"-?[a-z_\" + NON_ASCII + \"][\\\\w_\\\\-\" + NON_ASCII + \"]*\";\n    /** http://www.w3.org/TR/css-syntax-3/#string-token-diagram */\n    private static final String STRING = \"\\\"(?:(?!javascript\\\\s?:)[^\\\"^\\\\\\\\^\\\\n]|(?:\\\\\\\\\\\"))*\\\"|'(?:(?!javascript\\\\s?:)[^'^\\\\\\\\^\\\\n]|(?:\\\\\\\\'))*'\";\n    /** http://www.w3.org/TR/css-syntax-3/#dimension-token-diagram */\n    private static final String DIMENSION = NUMBER + IDENTIFIER;\n    /** http://www.w3.org/TR/css-syntax-3/#percentage-token-diagram */\n    private static final String PERCENT = NUMBER + \"%\";\n    /** http://www.w3.org/TR/css-syntax-3/#function-token-diagram */\n    private static final String FUNCTION = IDENTIFIER + \"\\\\((?:(?:\" + NUMBER + \")|(?:\" + IDENTIFIER + \")|(?:[\\\\s]*)|(?:,))*\\\\)\";\n    /** http://www.w3.org/TR/css-syntax-3/#url-unquoted-diagram */\n    private static final String URL_UNQUOTED = \"[^\\\"^'^\\\\(^\\\\)^[\" + NON_ASCII + \"]]*\";\n    /** http://www.w3.org/TR/css-syntax-3/#url-token-diagram */\n    private static final String URL = \"url\\\\((?:(?:\" + URL_UNQUOTED + \")|(?:\" + STRING + \"))\\\\)\";\n    /** composite regular expression for style token validation */\n    private static final String CSS_TOKEN = \"(?i)\" // case insensitive\n            + \"(?:\" + NUMBER + \")\"\n            + \"|(?:\" + DIMENSION + \")\"\n            + \"|(?:\" + PERCENT + \")\"\n            + \"|(?:\" + HEX_DIGITS + \")\"\n            + \"|(?:\" + IDENTIFIER + \")\"\n            + \"|(?:\" + STRING + \")\"\n            + \"|(?:\" + FUNCTION + \")\"\n            + \"|(?:\" + URL + \")\";\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidStyleToken(String, String)\n     */\n    @Override\n    public String getValidStyleToken(String token, String defaultValue) {\n        if (token != null && token.length() > 0 && token.matches(CSS_TOKEN)) {\n            return token;\n        }\n\n        return defaultValue;\n   }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidCSSColor(String, String)\n     */\n    @Override\n    public String getValidCSSColor(String color, String defaultColor) {\n        if (color != null && color.length() > 0) {\n            color = color.trim();\n            /*\n             * Avoid security implications by including only the characters required to specify colors in hex\n             * or functional notation. Critical characters disallowed: x (as in expression(...)),\n             * u (as in url(...)) and semi colon (as in escaping the context of the color value).\n             */\n            if (color.matches(\"(?i)[#a-fghlrs(+0-9-.%,) \\\\t\\\\n\\\\x0B\\\\f\\\\r]+\")) {\n                return color;\n            }\n            // named color values\n            if (color.matches(\"(?i)[a-zA-Z \\\\t\\\\n\\\\x0B\\\\f\\\\r]+\")) {\n                return color;\n            }\n        }\n\n        return defaultColor;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidMultiLineComment(String, String)\n     */\n    @Override\n    public String getValidMultiLineComment(String comment, String defaultComment) {\n        if (comment != null && !comment.contains(\"*/\")) {\n            return comment;\n        }\n        return defaultComment;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidJSON(String, String)\n     */\n    @Override\n    public String getValidJSON(String json, String defaultJson) {\n        if (json == null) {\n            return getValidJSON(defaultJson, \"\");\n        }\n        json = json.trim();\n        if (\"\".equals(json)) {\n            return \"\";\n        }\n        int curlyIx = json.indexOf(\"{\");\n        int straightIx = json.indexOf(\"[\");\n        if (curlyIx >= 0 && (curlyIx < straightIx || straightIx < 0)) {\n            try {\n                JSONObject obj = new JSONObject(json);\n                return obj.toString();\n            } catch (JSONException e) {\n                LOGGER.debug(\"JSON validation failed: \" + e.getMessage(), e);\n            }\n        } else {\n            try {\n                JSONArray arr = new JSONArray(json);\n                return arr.toString();\n            } catch (JSONException e) {\n                LOGGER.debug(\"JSON validation failed: \" + e.getMessage(), e);\n            }\n        }\n        return getValidJSON(defaultJson, \"\");\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidXML(String, String)\n     */\n    @Override\n    public String getValidXML(String xml, String defaultXml) {\n        if (xml == null) {\n            return getValidXML(defaultXml, \"\");\n        }\n        xml = xml.trim();\n        if (\"\".equals(xml)) {\n            return \"\";\n        }\n\n        try {\n            SAXParser parser = factory.newSAXParser();\n            XMLReader reader = parser.getXMLReader();\n            reader.parse(new InputSource(new StringReader(xml)));\n            return xml;\n        } catch (Exception e) {\n            LOGGER.debug(\"XML validation failed: \" + e.getMessage(), e);\n        }\n        return getValidXML(defaultXml, \"\");\n    }\n\n    // =============================================================================================\n    // ENCODERS\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForHTML(String)\n     */\n    @Override\n    public String encodeForHTML(String source) {\n        return source == null ? null : Encode.forHtml(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForHTMLAttr(String)\n     */\n    @Override\n    public String encodeForHTMLAttr(String source) {\n        return source == null ? null : Encode.forHtmlAttribute(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForXML(String)\n     */\n    @Override\n    public String encodeForXML(String source) {\n        return source == null ? null : Encode.forXml(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForXMLAttr(String)\n     */\n    @Override\n    public String encodeForXMLAttr(String source) {\n        return source == null ? null : Encode.forXmlAttribute(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForJSString(String)\n     */\n    @Override\n    public String encodeForJSString(String source) {\n        return source == null ? null : Encode.forJavaScript(source).replace(\"\\\\-\", \"\\\\u002D\");\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForCSSString(String)\n     */\n    @Override\n    public String encodeForCSSString(String source) {\n        return source == null ? null : Encode.forCssString(source);\n    }\n\n    // =============================================================================================\n    // FILTERS\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#filterHTML(String)\n     */\n    @Override\n    @Nonnull\n    public String filterHTML(String source) {\n        return xssFilter.filter(ProtectionContext.HTML_HTML_CONTENT, source);\n    }\n\n    // =============================================================================================\n    // JCR-NAMESPACE MANGLING\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getRequestSpecificAPI(org.apache.sling.api.SlingHttpServletRequest)\n     */\n    @Override\n    public XSSAPI getRequestSpecificAPI(final SlingHttpServletRequest request) {\n        return this;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getResourceResolverSpecificAPI(org.apache.sling.api.resource.ResourceResolver)\n     */\n    @Override\n    public XSSAPI getResourceResolverSpecificAPI(final ResourceResolver resourceResolver) {\n        return this;\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-24": {
    "vul_id": "VUL4J-24",
    "cve_id": "CVE-2016-6798",
    "project": "apache_sling",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl bundles/extensions/xss -Dtest=org.apache.sling.xss.impl.XSSAPIImplTest#testGetValidXML",
    "test_all_cmd": "mvn test -pl bundles/extensions/xss",
    "human_patch_url": "https://github.com/apache/sling/commit/fb2719e8299fadddae62245482de112052a0e08c",
    "vulnerable_files": [
      {
        "file_path": "bundles/extensions/xss/src/main/java/org/apache/sling/xss/impl/XSSAPIImpl.java",
        "file_name": "XSSAPIImpl.java",
        "vulnerable_code": "/*******************************************************************************\n * Licensed to the Apache Software Foundation (ASF) under one or\n * more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to you under the\n * Apache License, Version 2.0 (the \"License\"); you may not use\n * this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0 Unless required by\n * applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n ******************************************************************************/\npackage org.apache.sling.xss.impl;\n\nimport java.io.StringReader;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.Nonnull;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.apache.felix.scr.annotations.Activate;\nimport org.apache.felix.scr.annotations.Component;\nimport org.apache.felix.scr.annotations.Deactivate;\nimport org.apache.felix.scr.annotations.Reference;\nimport org.apache.felix.scr.annotations.Service;\nimport org.apache.sling.api.SlingHttpServletRequest;\nimport org.apache.sling.api.resource.ResourceResolver;\nimport org.apache.sling.commons.json.JSONArray;\nimport org.apache.sling.commons.json.JSONException;\nimport org.apache.sling.commons.json.JSONObject;\nimport org.apache.sling.xss.ProtectionContext;\nimport org.apache.sling.xss.XSSAPI;\nimport org.apache.sling.xss.XSSFilter;\nimport org.owasp.encoder.Encode;\nimport org.owasp.esapi.ESAPI;\nimport org.owasp.esapi.Validator;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.XMLReader;\n\n@Component\n@Service(value = XSSAPI.class)\npublic class XSSAPIImpl implements XSSAPI {\n    private static final Logger LOGGER = LoggerFactory.getLogger(XSSAPIImpl.class);\n\n    @Reference\n    private XSSFilter xssFilter = null;\n\n    private Validator validator = ESAPI.validator();\n\n    private static final Pattern PATTERN_AUTO_DIMENSION = Pattern.compile(\"['\\\"]?auto['\\\"]?\");\n\n    private SAXParserFactory factory;\n\n    @Activate\n    @SuppressWarnings(\"unused\")\n    protected void activate() {\n        factory = SAXParserFactory.newInstance();\n        factory.setValidating(false);\n        factory.setNamespaceAware(true);\n    }\n\n    @Deactivate\n    @SuppressWarnings(\"unused\")\n    protected void deactivate() {\n        factory = null;\n    }\n\n    // =============================================================================================\n    // VALIDATORS\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidInteger(String, int)\n     */\n    @Override\n    public Integer getValidInteger(String integer, int defaultValue) {\n        if (integer != null && integer.length() > 0) {\n            try {\n                return validator.getValidInteger(\"XSS\", integer, -2000000000, 2000000000, false);\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidLong(String, long)\n     */\n    @Override\n    public Long getValidLong(String source, long defaultValue) {\n        if (source != null && source.length() > 0) {\n            try {\n                LongValidationRule ivr = new LongValidationRule( \"number\", ESAPI.encoder(), -9000000000000000000L, 9000000000000000000L );\n                ivr.setAllowNull(false);\n                return ivr.getValid(\"XSS\", source);\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidDouble(String, double)\n     */\n    @Override\n    public Double getValidDouble(String source, double defaultValue) {\n        if (source != null && source.length() > 0) {\n            try {\n                return validator.getValidDouble(\"XSS\", source, 0d, Double.MAX_VALUE, false);\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidDimension(String, String)\n     */\n    @Override\n    public String getValidDimension(String dimension, String defaultValue) {\n        if (dimension != null && dimension.length() > 0) {\n            if (PATTERN_AUTO_DIMENSION.matcher(dimension).matches()) {\n                return \"\\\"auto\\\"\";\n            }\n\n            try {\n                return validator.getValidInteger(\"XSS\", dimension, -10000, 10000, false).toString();\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    private static final String LINK_PREFIX = \"<a href=\\\"\";\n    private static final String LINK_SUFFIX = \"\\\"></a>\";\n\n    private static final String MANGLE_NAMESPACE_OUT_SUFFIX = \":\";\n\n    private static final String MANGLE_NAMESPACE_OUT = \"/([^:/]+):\";\n\n    private static final Pattern MANGLE_NAMESPACE_PATTERN = Pattern.compile(MANGLE_NAMESPACE_OUT);\n\n    private static final String MANGLE_NAMESPACE_IN_SUFFIX = \"_\";\n\n    private static final String MANGLE_NAMESPACE_IN_PREFIX = \"/_\";\n\n    private static final String SCHEME_PATTERN = \"://\";\n\n    private String mangleNamespaces(String absPath) {\n        if (absPath != null) {\n            // check for absolute urls\n            final int schemeIndex = absPath.indexOf(SCHEME_PATTERN);\n            final String manglePath;\n            final String prefix;\n            if (schemeIndex != -1) {\n                final int pathIndex = absPath.indexOf(\"/\", schemeIndex + 3);\n                if (pathIndex != -1) {\n                    prefix = absPath.substring(0, pathIndex);\n                    manglePath = absPath.substring(pathIndex);\n                } else {\n                    prefix = absPath;\n                    manglePath = \"\";\n                }\n            } else {\n                prefix = \"\";\n                manglePath = absPath;\n            }\n            if (manglePath.contains(MANGLE_NAMESPACE_OUT_SUFFIX)) {\n                final Matcher m = MANGLE_NAMESPACE_PATTERN.matcher(manglePath);\n\n                final StringBuffer buf = new StringBuffer();\n                while (m.find()) {\n                    final String replacement = MANGLE_NAMESPACE_IN_PREFIX + m.group(1) + MANGLE_NAMESPACE_IN_SUFFIX;\n                    m.appendReplacement(buf, replacement);\n                }\n\n                m.appendTail(buf);\n\n                absPath = prefix + buf.toString();\n\n            }\n        }\n\n        return absPath;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidHref(String)\n     */\n    @Override\n    @Nonnull\n    public String getValidHref(final String url) {\n        if (url != null && url.length() > 0) {\n            // Percent-encode characters that are not allowed in unquoted\n            // HTML attributes: \", ', >, <, ` and space. We don't encode =\n            // since this would break links with query parameters.\n            String encodedUrl = url.replaceAll(\"\\\"\", \"%22\")\n                    .replaceAll(\"'\", \"%27\")\n                    .replaceAll(\">\", \"%3E\")\n                    .replaceAll(\"<\", \"%3C\")\n                    .replaceAll(\"`\", \"%60\")\n                    .replaceAll(\" \", \"%20\");\n            int qMarkIx = encodedUrl.indexOf('?');\n            if (qMarkIx > 0) {\n                encodedUrl = encodedUrl.substring(0, qMarkIx) + encodedUrl.substring(qMarkIx).replaceAll(\":\", \"%3A\");\n            }\n\n            encodedUrl = mangleNamespaces(encodedUrl);\n            if (xssFilter.isValidHref(encodedUrl)) {\n                return encodedUrl;\n            }\n        }\n\n        // fall through to empty string\n        return \"\";\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidJSToken(String, String)\n     */\n    @Override\n    public String getValidJSToken(String token, String defaultValue) {\n        if (token != null && token.length() > 0) {\n            token = token.trim();\n            String q = token.substring(0, 1);\n            if (q.matches(\"['\\\"]\") && token.endsWith(q)) {\n                String literal = token.substring(1, token.length() - 1);\n                return q + encodeForJSString(literal) + q;\n            } else if (token.matches(\"[0-9a-zA-Z_$][0-9a-zA-Z_$.]*\")) {\n                return token;\n            }\n        }\n\n        // fall through to default value\n        return defaultValue;\n    }\n\n    private static final String NON_ASCII = \"\\\\x00\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\";\n    /** http://www.w3.org/TR/css-syntax-3/#number-token-diagram */\n    private static final String NUMBER = \"[+-]?[\\\\d]*[\\\\.]?[\\\\d]*(?:[e][+-]?\\\\d+)?\";\n    /** http://www.w3.org/TR/css-syntax-3/#hex-digit-diagram */\n    private static final String HEX_DIGITS = \"#[0-9a-f]*\";\n    /** http://www.w3.org/TR/css-syntax-3/#ident-token-diagram */\n    private static final String IDENTIFIER = \"-?[a-z_\" + NON_ASCII + \"][\\\\w_\\\\-\" + NON_ASCII + \"]*\";\n    /** http://www.w3.org/TR/css-syntax-3/#string-token-diagram */\n    private static final String STRING = \"\\\"(?:(?!javascript\\\\s?:)[^\\\"^\\\\\\\\^\\\\n]|(?:\\\\\\\\\\\"))*\\\"|'(?:(?!javascript\\\\s?:)[^'^\\\\\\\\^\\\\n]|(?:\\\\\\\\'))*'\";\n    /** http://www.w3.org/TR/css-syntax-3/#dimension-token-diagram */\n    private static final String DIMENSION = NUMBER + IDENTIFIER;\n    /** http://www.w3.org/TR/css-syntax-3/#percentage-token-diagram */\n    private static final String PERCENT = NUMBER + \"%\";\n    /** http://www.w3.org/TR/css-syntax-3/#function-token-diagram */\n    private static final String FUNCTION = IDENTIFIER + \"\\\\((?:(?:\" + NUMBER + \")|(?:\" + IDENTIFIER + \")|(?:[\\\\s]*)|(?:,))*\\\\)\";\n    /** http://www.w3.org/TR/css-syntax-3/#url-unquoted-diagram */\n    private static final String URL_UNQUOTED = \"[^\\\"^'^\\\\(^\\\\)^[\" + NON_ASCII + \"]]*\";\n    /** http://www.w3.org/TR/css-syntax-3/#url-token-diagram */\n    private static final String URL = \"url\\\\((?:(?:\" + URL_UNQUOTED + \")|(?:\" + STRING + \"))\\\\)\";\n    /** composite regular expression for style token validation */\n    private static final String CSS_TOKEN = \"(?i)\" // case insensitive\n            + \"(?:\" + NUMBER + \")\"\n            + \"|(?:\" + DIMENSION + \")\"\n            + \"|(?:\" + PERCENT + \")\"\n            + \"|(?:\" + HEX_DIGITS + \")\"\n            + \"|(?:\" + IDENTIFIER + \")\"\n            + \"|(?:\" + STRING + \")\"\n            + \"|(?:\" + FUNCTION + \")\"\n            + \"|(?:\" + URL + \")\";\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidStyleToken(String, String)\n     */\n    @Override\n    public String getValidStyleToken(String token, String defaultValue) {\n        if (token != null && token.length() > 0 && token.matches(CSS_TOKEN)) {\n            return token;\n        }\n\n        return defaultValue;\n   }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidCSSColor(String, String)\n     */\n    @Override\n    public String getValidCSSColor(String color, String defaultColor) {\n        if (color != null && color.length() > 0) {\n            color = color.trim();\n            /*\n             * Avoid security implications by including only the characters required to specify colors in hex\n             * or functional notation. Critical characters disallowed: x (as in expression(...)),\n             * u (as in url(...)) and semi colon (as in escaping the context of the color value).\n             */\n            if (color.matches(\"(?i)[#a-fghlrs(+0-9-.%,) \\\\t\\\\n\\\\x0B\\\\f\\\\r]+\")) {\n                return color;\n            }\n            // named color values\n            if (color.matches(\"(?i)[a-zA-Z \\\\t\\\\n\\\\x0B\\\\f\\\\r]+\")) {\n                return color;\n            }\n        }\n\n        return defaultColor;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidMultiLineComment(String, String)\n     */\n    @Override\n    public String getValidMultiLineComment(String comment, String defaultComment) {\n        if (comment != null && !comment.contains(\"*/\")) {\n            return comment;\n        }\n        return defaultComment;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidJSON(String, String)\n     */\n    @Override\n    public String getValidJSON(String json, String defaultJson) {\n        if (json == null) {\n            return getValidJSON(defaultJson, \"\");\n        }\n        json = json.trim();\n        if (\"\".equals(json)) {\n            return \"\";\n        }\n        int curlyIx = json.indexOf(\"{\");\n        int straightIx = json.indexOf(\"[\");\n        if (curlyIx >= 0 && (curlyIx < straightIx || straightIx < 0)) {\n            try {\n                JSONObject obj = new JSONObject(json);\n                return obj.toString();\n            } catch (JSONException e) {\n                LOGGER.debug(\"JSON validation failed: \" + e.getMessage(), e);\n            }\n        } else {\n            try {\n                JSONArray arr = new JSONArray(json);\n                return arr.toString();\n            } catch (JSONException e) {\n                LOGGER.debug(\"JSON validation failed: \" + e.getMessage(), e);\n            }\n        }\n        return getValidJSON(defaultJson, \"\");\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidXML(String, String)\n     */\n    @Override\n    public String getValidXML(String xml, String defaultXml) {\n        if (xml == null) {\n            return getValidXML(defaultXml, \"\");\n        }\n        xml = xml.trim();\n        if (\"\".equals(xml)) {\n            return \"\";\n        }\n\n        try {\n            SAXParser parser = factory.newSAXParser();\n            XMLReader reader = parser.getXMLReader();\n            reader.parse(new InputSource(new StringReader(xml)));\n            return xml;\n        } catch (Exception e) {\n            LOGGER.debug(\"XML validation failed: \" + e.getMessage(), e);\n        }\n        return getValidXML(defaultXml, \"\");\n    }\n\n    // =============================================================================================\n    // ENCODERS\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForHTML(String)\n     */\n    @Override\n    public String encodeForHTML(String source) {\n        return source == null ? null : Encode.forHtml(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForHTMLAttr(String)\n     */\n    @Override\n    public String encodeForHTMLAttr(String source) {\n        return source == null ? null : Encode.forHtmlAttribute(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForXML(String)\n     */\n    @Override\n    public String encodeForXML(String source) {\n        return source == null ? null : Encode.forXml(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForXMLAttr(String)\n     */\n    @Override\n    public String encodeForXMLAttr(String source) {\n        return source == null ? null : Encode.forXmlAttribute(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForJSString(String)\n     */\n    @Override\n    public String encodeForJSString(String source) {\n        return source == null ? null : Encode.forJavaScript(source).replace(\"\\\\-\", \"\\\\u002D\");\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForCSSString(String)\n     */\n    @Override\n    public String encodeForCSSString(String source) {\n        return source == null ? null : Encode.forCssString(source);\n    }\n\n    // =============================================================================================\n    // FILTERS\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#filterHTML(String)\n     */\n    @Override\n    @Nonnull\n    public String filterHTML(String source) {\n        return xssFilter.filter(ProtectionContext.HTML_HTML_CONTENT, source);\n    }\n\n    // =============================================================================================\n    // JCR-NAMESPACE MANGLING\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getRequestSpecificAPI(org.apache.sling.api.SlingHttpServletRequest)\n     */\n    @Override\n    public XSSAPI getRequestSpecificAPI(final SlingHttpServletRequest request) {\n        return this;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getResourceResolverSpecificAPI(org.apache.sling.api.resource.ResourceResolver)\n     */\n    @Override\n    public XSSAPI getResourceResolverSpecificAPI(final ResourceResolver resourceResolver) {\n        return this;\n    }\n}\n",
        "human_patch_code": "/*******************************************************************************\n * Licensed to the Apache Software Foundation (ASF) under one or\n * more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to you under the\n * Apache License, Version 2.0 (the \"License\"); you may not use\n * this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0 Unless required by\n * applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n ******************************************************************************/\npackage org.apache.sling.xss.impl;\n\nimport java.io.StringReader;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.Nonnull;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.apache.felix.scr.annotations.Activate;\nimport org.apache.felix.scr.annotations.Component;\nimport org.apache.felix.scr.annotations.Deactivate;\nimport org.apache.felix.scr.annotations.Reference;\nimport org.apache.felix.scr.annotations.Service;\nimport org.apache.sling.api.SlingHttpServletRequest;\nimport org.apache.sling.api.resource.ResourceResolver;\nimport org.apache.sling.commons.json.JSONArray;\nimport org.apache.sling.commons.json.JSONException;\nimport org.apache.sling.commons.json.JSONObject;\nimport org.apache.sling.xss.ProtectionContext;\nimport org.apache.sling.xss.XSSAPI;\nimport org.apache.sling.xss.XSSFilter;\nimport org.owasp.encoder.Encode;\nimport org.owasp.esapi.ESAPI;\nimport org.owasp.esapi.Validator;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXNotRecognizedException;\nimport org.xml.sax.SAXNotSupportedException;\nimport org.xml.sax.XMLReader;\n\n@Component\n@Service(value = XSSAPI.class)\npublic class XSSAPIImpl implements XSSAPI {\n    private static final Logger LOGGER = LoggerFactory.getLogger(XSSAPIImpl.class);\n\n    @Reference\n    private XSSFilter xssFilter = null;\n\n    private Validator validator = ESAPI.validator();\n\n    private static final Pattern PATTERN_AUTO_DIMENSION = Pattern.compile(\"['\\\"]?auto['\\\"]?\");\n\n    private SAXParserFactory factory;\n\n    @Activate\n    @SuppressWarnings(\"unused\")\n    protected void activate() {\n        factory = SAXParserFactory.newInstance();\n        factory.setValidating(false);\n        factory.setNamespaceAware(true);\n        try {\n            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        } catch (Exception e) {\n            LOGGER.error(\"SAX parser configuration error: \" + e.getMessage(), e);\n        }\n    }\n\n    @Deactivate\n    @SuppressWarnings(\"unused\")\n    protected void deactivate() {\n        factory = null;\n    }\n\n    // =============================================================================================\n    // VALIDATORS\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidInteger(String, int)\n     */\n    @Override\n    public Integer getValidInteger(String integer, int defaultValue) {\n        if (integer != null && integer.length() > 0) {\n            try {\n                return validator.getValidInteger(\"XSS\", integer, -2000000000, 2000000000, false);\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidLong(String, long)\n     */\n    @Override\n    public Long getValidLong(String source, long defaultValue) {\n        if (source != null && source.length() > 0) {\n            try {\n                LongValidationRule ivr = new LongValidationRule( \"number\", ESAPI.encoder(), -9000000000000000000L, 9000000000000000000L );\n                ivr.setAllowNull(false);\n                return ivr.getValid(\"XSS\", source);\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidDouble(String, double)\n     */\n    @Override\n    public Double getValidDouble(String source, double defaultValue) {\n        if (source != null && source.length() > 0) {\n            try {\n                return validator.getValidDouble(\"XSS\", source, 0d, Double.MAX_VALUE, false);\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidDimension(String, String)\n     */\n    @Override\n    public String getValidDimension(String dimension, String defaultValue) {\n        if (dimension != null && dimension.length() > 0) {\n            if (PATTERN_AUTO_DIMENSION.matcher(dimension).matches()) {\n                return \"\\\"auto\\\"\";\n            }\n\n            try {\n                return validator.getValidInteger(\"XSS\", dimension, -10000, 10000, false).toString();\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    private static final String LINK_PREFIX = \"<a href=\\\"\";\n    private static final String LINK_SUFFIX = \"\\\"></a>\";\n\n    private static final String MANGLE_NAMESPACE_OUT_SUFFIX = \":\";\n\n    private static final String MANGLE_NAMESPACE_OUT = \"/([^:/]+):\";\n\n    private static final Pattern MANGLE_NAMESPACE_PATTERN = Pattern.compile(MANGLE_NAMESPACE_OUT);\n\n    private static final String MANGLE_NAMESPACE_IN_SUFFIX = \"_\";\n\n    private static final String MANGLE_NAMESPACE_IN_PREFIX = \"/_\";\n\n    private static final String SCHEME_PATTERN = \"://\";\n\n    private String mangleNamespaces(String absPath) {\n        if (absPath != null) {\n            // check for absolute urls\n            final int schemeIndex = absPath.indexOf(SCHEME_PATTERN);\n            final String manglePath;\n            final String prefix;\n            if (schemeIndex != -1) {\n                final int pathIndex = absPath.indexOf(\"/\", schemeIndex + 3);\n                if (pathIndex != -1) {\n                    prefix = absPath.substring(0, pathIndex);\n                    manglePath = absPath.substring(pathIndex);\n                } else {\n                    prefix = absPath;\n                    manglePath = \"\";\n                }\n            } else {\n                prefix = \"\";\n                manglePath = absPath;\n            }\n            if (manglePath.contains(MANGLE_NAMESPACE_OUT_SUFFIX)) {\n                final Matcher m = MANGLE_NAMESPACE_PATTERN.matcher(manglePath);\n\n                final StringBuffer buf = new StringBuffer();\n                while (m.find()) {\n                    final String replacement = MANGLE_NAMESPACE_IN_PREFIX + m.group(1) + MANGLE_NAMESPACE_IN_SUFFIX;\n                    m.appendReplacement(buf, replacement);\n                }\n\n                m.appendTail(buf);\n\n                absPath = prefix + buf.toString();\n\n            }\n        }\n\n        return absPath;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidHref(String)\n     */\n    @Override\n    @Nonnull\n    public String getValidHref(final String url) {\n        if (url != null && url.length() > 0) {\n            // Percent-encode characters that are not allowed in unquoted\n            // HTML attributes: \", ', >, <, ` and space. We don't encode =\n            // since this would break links with query parameters.\n            String encodedUrl = url.replaceAll(\"\\\"\", \"%22\")\n                    .replaceAll(\"'\", \"%27\")\n                    .replaceAll(\">\", \"%3E\")\n                    .replaceAll(\"<\", \"%3C\")\n                    .replaceAll(\"`\", \"%60\")\n                    .replaceAll(\" \", \"%20\");\n            int qMarkIx = encodedUrl.indexOf('?');\n            if (qMarkIx > 0) {\n                encodedUrl = encodedUrl.substring(0, qMarkIx) + encodedUrl.substring(qMarkIx).replaceAll(\":\", \"%3A\");\n            }\n\n            encodedUrl = mangleNamespaces(encodedUrl);\n            if (xssFilter.isValidHref(encodedUrl)) {\n                return encodedUrl;\n            }\n        }\n\n        // fall through to empty string\n        return \"\";\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidJSToken(String, String)\n     */\n    @Override\n    public String getValidJSToken(String token, String defaultValue) {\n        if (token != null && token.length() > 0) {\n            token = token.trim();\n            String q = token.substring(0, 1);\n            if (q.matches(\"['\\\"]\") && token.endsWith(q)) {\n                String literal = token.substring(1, token.length() - 1);\n                return q + encodeForJSString(literal) + q;\n            } else if (token.matches(\"[0-9a-zA-Z_$][0-9a-zA-Z_$.]*\")) {\n                return token;\n            }\n        }\n\n        // fall through to default value\n        return defaultValue;\n    }\n\n    private static final String NON_ASCII = \"\\\\x00\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\";\n    /** http://www.w3.org/TR/css-syntax-3/#number-token-diagram */\n    private static final String NUMBER = \"[+-]?[\\\\d]*[\\\\.]?[\\\\d]*(?:[e][+-]?\\\\d+)?\";\n    /** http://www.w3.org/TR/css-syntax-3/#hex-digit-diagram */\n    private static final String HEX_DIGITS = \"#[0-9a-f]*\";\n    /** http://www.w3.org/TR/css-syntax-3/#ident-token-diagram */\n    private static final String IDENTIFIER = \"-?[a-z_\" + NON_ASCII + \"][\\\\w_\\\\-\" + NON_ASCII + \"]*\";\n    /** http://www.w3.org/TR/css-syntax-3/#string-token-diagram */\n    private static final String STRING = \"\\\"(?:(?!javascript\\\\s?:)[^\\\"^\\\\\\\\^\\\\n]|(?:\\\\\\\\\\\"))*\\\"|'(?:(?!javascript\\\\s?:)[^'^\\\\\\\\^\\\\n]|(?:\\\\\\\\'))*'\";\n    /** http://www.w3.org/TR/css-syntax-3/#dimension-token-diagram */\n    private static final String DIMENSION = NUMBER + IDENTIFIER;\n    /** http://www.w3.org/TR/css-syntax-3/#percentage-token-diagram */\n    private static final String PERCENT = NUMBER + \"%\";\n    /** http://www.w3.org/TR/css-syntax-3/#function-token-diagram */\n    private static final String FUNCTION = IDENTIFIER + \"\\\\((?:(?:\" + NUMBER + \")|(?:\" + IDENTIFIER + \")|(?:[\\\\s]*)|(?:,))*\\\\)\";\n    /** http://www.w3.org/TR/css-syntax-3/#url-unquoted-diagram */\n    private static final String URL_UNQUOTED = \"[^\\\"^'^\\\\(^\\\\)^[\" + NON_ASCII + \"]]*\";\n    /** http://www.w3.org/TR/css-syntax-3/#url-token-diagram */\n    private static final String URL = \"url\\\\((?:(?:\" + URL_UNQUOTED + \")|(?:\" + STRING + \"))\\\\)\";\n    /** composite regular expression for style token validation */\n    private static final String CSS_TOKEN = \"(?i)\" // case insensitive\n            + \"(?:\" + NUMBER + \")\"\n            + \"|(?:\" + DIMENSION + \")\"\n            + \"|(?:\" + PERCENT + \")\"\n            + \"|(?:\" + HEX_DIGITS + \")\"\n            + \"|(?:\" + IDENTIFIER + \")\"\n            + \"|(?:\" + STRING + \")\"\n            + \"|(?:\" + FUNCTION + \")\"\n            + \"|(?:\" + URL + \")\";\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidStyleToken(String, String)\n     */\n    @Override\n    public String getValidStyleToken(String token, String defaultValue) {\n        if (token != null && token.length() > 0 && token.matches(CSS_TOKEN)) {\n            return token;\n        }\n\n        return defaultValue;\n   }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidCSSColor(String, String)\n     */\n    @Override\n    public String getValidCSSColor(String color, String defaultColor) {\n        if (color != null && color.length() > 0) {\n            color = color.trim();\n            /*\n             * Avoid security implications by including only the characters required to specify colors in hex\n             * or functional notation. Critical characters disallowed: x (as in expression(...)),\n             * u (as in url(...)) and semi colon (as in escaping the context of the color value).\n             */\n            if (color.matches(\"(?i)[#a-fghlrs(+0-9-.%,) \\\\t\\\\n\\\\x0B\\\\f\\\\r]+\")) {\n                return color;\n            }\n            // named color values\n            if (color.matches(\"(?i)[a-zA-Z \\\\t\\\\n\\\\x0B\\\\f\\\\r]+\")) {\n                return color;\n            }\n        }\n\n        return defaultColor;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidMultiLineComment(String, String)\n     */\n    @Override\n    public String getValidMultiLineComment(String comment, String defaultComment) {\n        if (comment != null && !comment.contains(\"*/\")) {\n            return comment;\n        }\n        return defaultComment;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidJSON(String, String)\n     */\n    @Override\n    public String getValidJSON(String json, String defaultJson) {\n        if (json == null) {\n            return getValidJSON(defaultJson, \"\");\n        }\n        json = json.trim();\n        if (\"\".equals(json)) {\n            return \"\";\n        }\n        int curlyIx = json.indexOf(\"{\");\n        int straightIx = json.indexOf(\"[\");\n        if (curlyIx >= 0 && (curlyIx < straightIx || straightIx < 0)) {\n            try {\n                JSONObject obj = new JSONObject(json);\n                return obj.toString();\n            } catch (JSONException e) {\n                LOGGER.debug(\"JSON validation failed: \" + e.getMessage(), e);\n            }\n        } else {\n            try {\n                JSONArray arr = new JSONArray(json);\n                return arr.toString();\n            } catch (JSONException e) {\n                LOGGER.debug(\"JSON validation failed: \" + e.getMessage(), e);\n            }\n        }\n        return getValidJSON(defaultJson, \"\");\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidXML(String, String)\n     */\n    @Override\n    public String getValidXML(String xml, String defaultXml) {\n        if (xml == null) {\n            return getValidXML(defaultXml, \"\");\n        }\n        xml = xml.trim();\n        if (\"\".equals(xml)) {\n            return \"\";\n        }\n\n        try {\n            SAXParser parser = factory.newSAXParser();\n            XMLReader reader = parser.getXMLReader();\n            reader.parse(new InputSource(new StringReader(xml)));\n            return xml;\n        } catch (Exception e) {\n            LOGGER.debug(\"XML validation failed: \" + e.getMessage(), e);\n        }\n        return getValidXML(defaultXml, \"\");\n    }\n\n    // =============================================================================================\n    // ENCODERS\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForHTML(String)\n     */\n    @Override\n    public String encodeForHTML(String source) {\n        return source == null ? null : Encode.forHtml(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForHTMLAttr(String)\n     */\n    @Override\n    public String encodeForHTMLAttr(String source) {\n        return source == null ? null : Encode.forHtmlAttribute(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForXML(String)\n     */\n    @Override\n    public String encodeForXML(String source) {\n        return source == null ? null : Encode.forXml(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForXMLAttr(String)\n     */\n    @Override\n    public String encodeForXMLAttr(String source) {\n        return source == null ? null : Encode.forXmlAttribute(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForJSString(String)\n     */\n    @Override\n    public String encodeForJSString(String source) {\n        return source == null ? null : Encode.forJavaScript(source).replace(\"\\\\-\", \"\\\\u002D\");\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForCSSString(String)\n     */\n    @Override\n    public String encodeForCSSString(String source) {\n        return source == null ? null : Encode.forCssString(source);\n    }\n\n    // =============================================================================================\n    // FILTERS\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#filterHTML(String)\n     */\n    @Override\n    @Nonnull\n    public String filterHTML(String source) {\n        return xssFilter.filter(ProtectionContext.HTML_HTML_CONTENT, source);\n    }\n\n    // =============================================================================================\n    // JCR-NAMESPACE MANGLING\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getRequestSpecificAPI(org.apache.sling.api.SlingHttpServletRequest)\n     */\n    @Override\n    public XSSAPI getRequestSpecificAPI(final SlingHttpServletRequest request) {\n        return this;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getResourceResolverSpecificAPI(org.apache.sling.api.resource.ResourceResolver)\n     */\n    @Override\n    public XSSAPI getResourceResolverSpecificAPI(final ResourceResolver resourceResolver) {\n        return this;\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-25": {
    "vul_id": "VUL4J-25",
    "cve_id": "CVE-2017-15717",
    "project": "apache_sling-org-apache-sling-xss",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=org.apache.sling.xss.impl.XSSAPIImplTest",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/apache/sling-org-apache-sling-xss/commit/ec6764d165abc4df8cffd8439761bb2228887db9",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/org/apache/sling/xss/impl/XSSAPIImpl.java",
        "file_name": "XSSAPIImpl.java",
        "vulnerable_code": "/*******************************************************************************\n * Licensed to the Apache Software Foundation (ASF) under one or\n * more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to you under the\n * Apache License, Version 2.0 (the \"License\"); you may not use\n * this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0 Unless required by\n * applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n ******************************************************************************/\npackage org.apache.sling.xss.impl;\n\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.Nonnull;\nimport javax.json.Json;\nimport javax.json.JsonReaderFactory;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.apache.commons.lang3.StringEscapeUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.sling.xss.ProtectionContext;\nimport org.apache.sling.xss.XSSAPI;\nimport org.apache.sling.xss.XSSFilter;\nimport org.osgi.framework.Constants;\nimport org.osgi.service.component.annotations.Activate;\nimport org.osgi.service.component.annotations.Component;\nimport org.osgi.service.component.annotations.Deactivate;\nimport org.osgi.service.component.annotations.Reference;\nimport org.owasp.encoder.Encode;\nimport org.owasp.esapi.ESAPI;\nimport org.owasp.esapi.Validator;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.XMLReader;\n\n@Component(service = XSSAPI.class,\n           property = {\n                Constants.SERVICE_VENDOR + \"=The Apache Software Foundation\"\n           })\n\npublic class XSSAPIImpl implements XSSAPI {\n\n    private final Logger LOGGER = LoggerFactory.getLogger(XSSAPIImpl.class);\n\n    @Reference\n    private XSSFilter xssFilter;\n\n    private final Validator validator = ESAPI.validator();\n\n    private static final Pattern PATTERN_AUTO_DIMENSION = Pattern.compile(\"['\\\"]?auto['\\\"]?\");\n\n    private SAXParserFactory factory;\n\n    private volatile JsonReaderFactory jsonReaderFactory;\n\n    @Activate\n    protected void activate() {\n        factory = SAXParserFactory.newInstance();\n        factory.setValidating(false);\n        factory.setNamespaceAware(true);\n        try {\n            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        } catch (Exception e) {\n            LOGGER.error(\"SAX parser configuration error: \" + e.getMessage(), e);\n        }\n        Map<String, Object> config = new HashMap<>();\n        config.put(\"org.apache.johnzon.supports-comments\", true);\n        jsonReaderFactory = Json.createReaderFactory(config);\n    }\n\n    @Deactivate\n    protected void deactivate() {\n        factory = null;\n        jsonReaderFactory = null;\n    }\n\n    // =============================================================================================\n    // VALIDATORS\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidInteger(String, int)\n     */\n    @Override\n    public Integer getValidInteger(String integer, int defaultValue) {\n        if (integer != null && integer.length() > 0) {\n            try {\n                return validator.getValidInteger(\"XSS\", integer, -2000000000, 2000000000, false);\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidLong(String, long)\n     */\n    @Override\n    public Long getValidLong(String source, long defaultValue) {\n        if (source != null && source.length() > 0) {\n            try {\n                LongValidationRule ivr = new LongValidationRule( \"number\", ESAPI.encoder(), -9000000000000000000L, 9000000000000000000L );\n                ivr.setAllowNull(false);\n                return ivr.getValid(\"XSS\", source);\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidDouble(String, double)\n     */\n    @Override\n    public Double getValidDouble(String source, double defaultValue) {\n        if (source != null && source.length() > 0) {\n            try {\n                return validator.getValidDouble(\"XSS\", source, 0d, Double.MAX_VALUE, false);\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidDimension(String, String)\n     */\n    @Override\n    public String getValidDimension(String dimension, String defaultValue) {\n        if (dimension != null && dimension.length() > 0) {\n            if (PATTERN_AUTO_DIMENSION.matcher(dimension).matches()) {\n                return \"\\\"auto\\\"\";\n            }\n\n            try {\n                return validator.getValidInteger(\"XSS\", dimension, -10000, 10000, false).toString();\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    private static final String MANGLE_NAMESPACE_OUT_SUFFIX = \":\";\n\n    private static final String MANGLE_NAMESPACE_OUT = \"/([^:/]+):\";\n\n    private static final Pattern MANGLE_NAMESPACE_PATTERN = Pattern.compile(MANGLE_NAMESPACE_OUT);\n\n    private static final String MANGLE_NAMESPACE_IN_SUFFIX = \"_\";\n\n    private static final String MANGLE_NAMESPACE_IN_PREFIX = \"/_\";\n\n    private static final String SCHEME_PATTERN = \"://\";\n\n    private String mangleNamespaces(String absPath) {\n        if (absPath != null) {\n            // check for absolute urls\n            final int schemeIndex = absPath.indexOf(SCHEME_PATTERN);\n            final String manglePath;\n            final String prefix;\n            if (schemeIndex != -1) {\n                final int pathIndex = absPath.indexOf(\"/\", schemeIndex + 3);\n                if (pathIndex != -1) {\n                    prefix = absPath.substring(0, pathIndex);\n                    manglePath = absPath.substring(pathIndex);\n                } else {\n                    prefix = absPath;\n                    manglePath = \"\";\n                }\n            } else {\n                prefix = \"\";\n                manglePath = absPath;\n            }\n            if (manglePath.contains(MANGLE_NAMESPACE_OUT_SUFFIX)) {\n                final Matcher m = MANGLE_NAMESPACE_PATTERN.matcher(manglePath);\n\n                final StringBuffer buf = new StringBuffer();\n                while (m.find()) {\n                    final String replacement = MANGLE_NAMESPACE_IN_PREFIX + m.group(1) + MANGLE_NAMESPACE_IN_SUFFIX;\n                    m.appendReplacement(buf, replacement);\n                }\n\n                m.appendTail(buf);\n\n                absPath = prefix + buf.toString();\n\n            }\n        }\n\n        return absPath;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidHref(String)\n     */\n    @Override\n    @Nonnull\n    public String getValidHref(final String url) {\n        if (StringUtils.isNotEmpty(url)) {\n            try {\n                String unescapedURL = URLDecoder.decode(url, StandardCharsets.UTF_8.name());\n                /*\n                    StringEscapeUtils is deprecated starting with version 3.6 of commons-lang3, however the indicated replacement comes from\n                    commons-text, which is not an OSGi bundle\n                */\n                unescapedURL = StringEscapeUtils.unescapeXml(unescapedURL);\n                // Percent-encode characters that are not allowed in unquoted\n                // HTML attributes: \", ', >, <, ` and space. We don't encode =\n                // since this would break links with query parameters.\n                String encodedUrl = unescapedURL.replaceAll(\"\\\"\", \"%22\")\n                        .replaceAll(\"'\", \"%27\")\n                        .replaceAll(\">\", \"%3E\")\n                        .replaceAll(\"<\", \"%3C\")\n                        .replaceAll(\"`\", \"%60\")\n                        .replaceAll(\" \", \"%20\");\n                int qMarkIx = encodedUrl.indexOf('?');\n                if (qMarkIx > 0) {\n                    encodedUrl = encodedUrl.substring(0, qMarkIx) + encodedUrl.substring(qMarkIx).replaceAll(\":\", \"%3A\");\n                }\n\n                encodedUrl = mangleNamespaces(encodedUrl);\n                if (xssFilter.isValidHref(encodedUrl)) {\n                    return encodedUrl;\n                }\n            } catch (UnsupportedEncodingException e) {\n                LOGGER.error(\"Unable to decode url: {}.\", url);\n            }\n        }\n        // fall through to empty string\n        return \"\";\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidJSToken(String, String)\n     */\n    @Override\n    public String getValidJSToken(String token, String defaultValue) {\n        if (token != null && token.length() > 0) {\n            token = token.trim();\n            String q = token.substring(0, 1);\n            if (q.matches(\"['\\\"]\") && token.endsWith(q)) {\n                String literal = token.substring(1, token.length() - 1);\n                return q + encodeForJSString(literal) + q;\n            } else if (token.matches(\"[0-9a-zA-Z_$][0-9a-zA-Z_$.]*\")) {\n                return token;\n            }\n        }\n\n        // fall through to default value\n        return defaultValue;\n    }\n\n    private static final String NON_ASCII = \"\\\\x00\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\";\n    /** http://www.w3.org/TR/css-syntax-3/#number-token-diagram */\n    private static final String NUMBER = \"[+-]?[\\\\d]*[\\\\.]?[\\\\d]*(?:[e][+-]?\\\\d+)?\";\n    /** http://www.w3.org/TR/css-syntax-3/#hex-digit-diagram */\n    private static final String HEX_DIGITS = \"#[0-9a-f]*\";\n    /** http://www.w3.org/TR/css-syntax-3/#ident-token-diagram */\n    private static final String IDENTIFIER = \"-?[a-z_\" + NON_ASCII + \"][\\\\w_\\\\-\" + NON_ASCII + \"]*\";\n    /** http://www.w3.org/TR/css-syntax-3/#string-token-diagram */\n    private static final String STRING = \"\\\"(?:(?!javascript\\\\s?:)[^\\\"^\\\\\\\\^\\\\n]|(?:\\\\\\\\\\\"))*\\\"|'(?:(?!javascript\\\\s?:)[^'^\\\\\\\\^\\\\n]|(?:\\\\\\\\'))*'\";\n    /** http://www.w3.org/TR/css-syntax-3/#dimension-token-diagram */\n    private static final String DIMENSION = NUMBER + IDENTIFIER;\n    /** http://www.w3.org/TR/css-syntax-3/#percentage-token-diagram */\n    private static final String PERCENT = NUMBER + \"%\";\n    /** http://www.w3.org/TR/css-syntax-3/#function-token-diagram */\n    private static final String FUNCTION = IDENTIFIER + \"\\\\((?:(?:\" + NUMBER + \")|(?:\" + IDENTIFIER + \")|(?:[\\\\s]*)|(?:,))*\\\\)\";\n    /** http://www.w3.org/TR/css-syntax-3/#url-unquoted-diagram */\n    private static final String URL_UNQUOTED = \"[^\\\"^'^\\\\(^\\\\)^[\" + NON_ASCII + \"]]*\";\n    /** http://www.w3.org/TR/css-syntax-3/#url-token-diagram */\n    private static final String URL = \"url\\\\((?:(?:\" + URL_UNQUOTED + \")|(?:\" + STRING + \"))\\\\)\";\n    /** composite regular expression for style token validation */\n    private static final String CSS_TOKEN = \"(?i)\" // case insensitive\n            + \"(?:\" + NUMBER + \")\"\n            + \"|(?:\" + DIMENSION + \")\"\n            + \"|(?:\" + PERCENT + \")\"\n            + \"|(?:\" + HEX_DIGITS + \")\"\n            + \"|(?:\" + IDENTIFIER + \")\"\n            + \"|(?:\" + STRING + \")\"\n            + \"|(?:\" + FUNCTION + \")\"\n            + \"|(?:\" + URL + \")\";\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidStyleToken(String, String)\n     */\n    @Override\n    public String getValidStyleToken(String token, String defaultValue) {\n        if (token != null && token.length() > 0 && token.matches(CSS_TOKEN)) {\n            return token;\n        }\n\n        return defaultValue;\n   }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidCSSColor(String, String)\n     */\n    @Override\n    public String getValidCSSColor(String color, String defaultColor) {\n        if (color != null && color.length() > 0) {\n            color = color.trim();\n            /*\n             * Avoid security implications by including only the characters required to specify colors in hex\n             * or functional notation. Critical characters disallowed: x (as in expression(...)),\n             * u (as in url(...)) and semi colon (as in escaping the context of the color value).\n             */\n            if (color.matches(\"(?i)[#a-fghlrs(+0-9-.%,) \\\\t\\\\n\\\\x0B\\\\f\\\\r]+\")) {\n                return color;\n            }\n            // named color values\n            if (color.matches(\"(?i)[a-zA-Z \\\\t\\\\n\\\\x0B\\\\f\\\\r]+\")) {\n                return color;\n            }\n        }\n\n        return defaultColor;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidMultiLineComment(String, String)\n     */\n    @Override\n    public String getValidMultiLineComment(String comment, String defaultComment) {\n        if (comment != null && !comment.contains(\"*/\")) {\n            return comment;\n        }\n        return defaultComment;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidJSON(String, String)\n     */\n    @Override\n    public String getValidJSON(String json, String defaultJson) {\n        if (json == null) {\n            return getValidJSON(defaultJson, \"\");\n        }\n        json = json.trim();\n        if (\"\".equals(json)) {\n            return \"\";\n        }\n        int curlyIx = json.indexOf(\"{\");\n        int straightIx = json.indexOf(\"[\");\n        if (curlyIx >= 0 && (curlyIx < straightIx || straightIx < 0)) {\n            try {\n                StringWriter output = new StringWriter();\n                Json.createGenerator(output).write(jsonReaderFactory.createReader(new StringReader(json)).readObject()).close();\n                return output.getBuffer().toString();\n            } catch (Exception e) {\n                LOGGER.debug(\"JSON validation failed: \" + e.getMessage(), e);\n            }\n        } else {\n            try {\n                StringWriter output = new StringWriter();\n                Json.createGenerator(output).write(jsonReaderFactory.createReader(new StringReader(json)).readArray()).close();\n                return output.getBuffer().toString();\n            } catch (Exception e) {\n                LOGGER.debug(\"JSON validation failed: \" + e.getMessage(), e);\n            }\n        }\n        return getValidJSON(defaultJson, \"\");\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidXML(String, String)\n     */\n    @Override\n    public String getValidXML(String xml, String defaultXml) {\n        if (xml == null) {\n            return getValidXML(defaultXml, \"\");\n        }\n        xml = xml.trim();\n        if (\"\".equals(xml)) {\n            return \"\";\n        }\n\n        try {\n            SAXParser parser = factory.newSAXParser();\n            XMLReader reader = parser.getXMLReader();\n            reader.parse(new InputSource(new StringReader(xml)));\n            return xml;\n        } catch (Exception e) {\n            LOGGER.debug(\"XML validation failed: \" + e.getMessage(), e);\n        }\n        return getValidXML(defaultXml, \"\");\n    }\n\n    // =============================================================================================\n    // ENCODERS\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForHTML(String)\n     */\n    @Override\n    public String encodeForHTML(String source) {\n        return source == null ? null : Encode.forHtml(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForHTMLAttr(String)\n     */\n    @Override\n    public String encodeForHTMLAttr(String source) {\n        return source == null ? null : Encode.forHtmlAttribute(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForXML(String)\n     */\n    @Override\n    public String encodeForXML(String source) {\n        return source == null ? null : Encode.forXml(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForXMLAttr(String)\n     */\n    @Override\n    public String encodeForXMLAttr(String source) {\n        return source == null ? null : Encode.forXmlAttribute(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForJSString(String)\n     */\n    @Override\n    public String encodeForJSString(String source) {\n        return source == null ? null : Encode.forJavaScript(source).replace(\"\\\\-\", \"\\\\u002D\");\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForCSSString(String)\n     */\n    @Override\n    public String encodeForCSSString(String source) {\n        return source == null ? null : Encode.forCssString(source);\n    }\n\n    // =============================================================================================\n    // FILTERS\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#filterHTML(String)\n     */\n    @Override\n    @Nonnull\n    public String filterHTML(String source) {\n        return xssFilter.filter(ProtectionContext.HTML_HTML_CONTENT, source);\n    }\n}\n",
        "human_patch_code": "/*******************************************************************************\n * Licensed to the Apache Software Foundation (ASF) under one or\n * more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to you under the\n * Apache License, Version 2.0 (the \"License\"); you may not use\n * this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0 Unless required by\n * applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n ******************************************************************************/\npackage org.apache.sling.xss.impl;\n\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.Nonnull;\nimport javax.json.Json;\nimport javax.json.JsonReaderFactory;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.sling.xss.ProtectionContext;\nimport org.apache.sling.xss.XSSAPI;\nimport org.apache.sling.xss.XSSFilter;\nimport org.osgi.framework.Constants;\nimport org.osgi.service.component.annotations.Activate;\nimport org.osgi.service.component.annotations.Component;\nimport org.osgi.service.component.annotations.Deactivate;\nimport org.osgi.service.component.annotations.Reference;\nimport org.owasp.encoder.Encode;\nimport org.owasp.esapi.ESAPI;\nimport org.owasp.esapi.Validator;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.XMLReader;\n\n@Component(service = XSSAPI.class,\n           property = {\n                Constants.SERVICE_VENDOR + \"=The Apache Software Foundation\"\n           })\n\npublic class XSSAPIImpl implements XSSAPI {\n\n    private final Logger LOGGER = LoggerFactory.getLogger(XSSAPIImpl.class);\n\n    @Reference\n    private XSSFilter xssFilter;\n\n    private final Validator validator = ESAPI.validator();\n\n    private static final Pattern PATTERN_AUTO_DIMENSION = Pattern.compile(\"['\\\"]?auto['\\\"]?\");\n\n    private SAXParserFactory factory;\n\n    private volatile JsonReaderFactory jsonReaderFactory;\n\n    @Activate\n    protected void activate() {\n        factory = SAXParserFactory.newInstance();\n        factory.setValidating(false);\n        factory.setNamespaceAware(true);\n        try {\n            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        } catch (Exception e) {\n            LOGGER.error(\"SAX parser configuration error: \" + e.getMessage(), e);\n        }\n        Map<String, Object> config = new HashMap<>();\n        config.put(\"org.apache.johnzon.supports-comments\", true);\n        jsonReaderFactory = Json.createReaderFactory(config);\n    }\n\n    @Deactivate\n    protected void deactivate() {\n        factory = null;\n        jsonReaderFactory = null;\n    }\n\n    // =============================================================================================\n    // VALIDATORS\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidInteger(String, int)\n     */\n    @Override\n    public Integer getValidInteger(String integer, int defaultValue) {\n        if (integer != null && integer.length() > 0) {\n            try {\n                return validator.getValidInteger(\"XSS\", integer, -2000000000, 2000000000, false);\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidLong(String, long)\n     */\n    @Override\n    public Long getValidLong(String source, long defaultValue) {\n        if (source != null && source.length() > 0) {\n            try {\n                LongValidationRule ivr = new LongValidationRule( \"number\", ESAPI.encoder(), -9000000000000000000L, 9000000000000000000L );\n                ivr.setAllowNull(false);\n                return ivr.getValid(\"XSS\", source);\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidDouble(String, double)\n     */\n    @Override\n    public Double getValidDouble(String source, double defaultValue) {\n        if (source != null && source.length() > 0) {\n            try {\n                return validator.getValidDouble(\"XSS\", source, 0d, Double.MAX_VALUE, false);\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidDimension(String, String)\n     */\n    @Override\n    public String getValidDimension(String dimension, String defaultValue) {\n        if (dimension != null && dimension.length() > 0) {\n            if (PATTERN_AUTO_DIMENSION.matcher(dimension).matches()) {\n                return \"\\\"auto\\\"\";\n            }\n\n            try {\n                return validator.getValidInteger(\"XSS\", dimension, -10000, 10000, false).toString();\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n\n    private static final String MANGLE_NAMESPACE_OUT_SUFFIX = \":\";\n\n    private static final String MANGLE_NAMESPACE_OUT = \"/([^:/]+):\";\n\n    private static final Pattern MANGLE_NAMESPACE_PATTERN = Pattern.compile(MANGLE_NAMESPACE_OUT);\n\n    private static final String MANGLE_NAMESPACE_IN_SUFFIX = \"_\";\n\n    private static final String MANGLE_NAMESPACE_IN_PREFIX = \"/_\";\n\n    private static final String SCHEME_PATTERN = \"://\";\n\n    private String mangleNamespaces(String absPath) {\n        if (absPath != null) {\n            // check for absolute urls\n            final int schemeIndex = absPath.indexOf(SCHEME_PATTERN);\n            final String manglePath;\n            final String prefix;\n            if (schemeIndex != -1) {\n                final int pathIndex = absPath.indexOf(\"/\", schemeIndex + 3);\n                if (pathIndex != -1) {\n                    prefix = absPath.substring(0, pathIndex);\n                    manglePath = absPath.substring(pathIndex);\n                } else {\n                    prefix = absPath;\n                    manglePath = \"\";\n                }\n            } else {\n                prefix = \"\";\n                manglePath = absPath;\n            }\n            if (manglePath.contains(MANGLE_NAMESPACE_OUT_SUFFIX)) {\n                final Matcher m = MANGLE_NAMESPACE_PATTERN.matcher(manglePath);\n\n                final StringBuffer buf = new StringBuffer();\n                while (m.find()) {\n                    final String replacement = MANGLE_NAMESPACE_IN_PREFIX + m.group(1) + MANGLE_NAMESPACE_IN_SUFFIX;\n                    m.appendReplacement(buf, replacement);\n                }\n\n                m.appendTail(buf);\n\n                absPath = prefix + buf.toString();\n\n            }\n        }\n\n        return absPath;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidHref(String)\n     */\n    @Override\n    @Nonnull\n    public String getValidHref(final String url) {\n        if (StringUtils.isNotEmpty(url)) {\n            // Percent-encode characters that are not allowed in unquoted\n            // HTML attributes: \", ', >, <, ` and space. We don't encode =\n            // since this would break links with query parameters.\n            String encodedUrl = url.replaceAll(\"\\\"\", \"%22\")\n                    .replaceAll(\"'\", \"%27\")\n                    .replaceAll(\">\", \"%3E\")\n                    .replaceAll(\"<\", \"%3C\")\n                    .replaceAll(\"`\", \"%60\")\n                    .replaceAll(\" \", \"%20\");\n            int qMarkIx = encodedUrl.indexOf('?');\n            if (qMarkIx > 0) {\n                encodedUrl = encodedUrl.substring(0, qMarkIx) + encodedUrl.substring(qMarkIx).replaceAll(\":\", \"%3A\");\n            }\n            encodedUrl = mangleNamespaces(encodedUrl);\n            if (xssFilter.isValidHref(encodedUrl)) {\n                return encodedUrl;\n            }\n        }\n        // fall through to empty string\n        return \"\";\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidJSToken(String, String)\n     */\n    @Override\n    public String getValidJSToken(String token, String defaultValue) {\n        if (token != null && token.length() > 0) {\n            token = token.trim();\n            String q = token.substring(0, 1);\n            if (q.matches(\"['\\\"]\") && token.endsWith(q)) {\n                String literal = token.substring(1, token.length() - 1);\n                return q + encodeForJSString(literal) + q;\n            } else if (token.matches(\"[0-9a-zA-Z_$][0-9a-zA-Z_$.]*\")) {\n                return token;\n            }\n        }\n\n        // fall through to default value\n        return defaultValue;\n    }\n\n    private static final String NON_ASCII = \"\\\\x00\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\";\n    /** http://www.w3.org/TR/css-syntax-3/#number-token-diagram */\n    private static final String NUMBER = \"[+-]?[\\\\d]*[\\\\.]?[\\\\d]*(?:[e][+-]?\\\\d+)?\";\n    /** http://www.w3.org/TR/css-syntax-3/#hex-digit-diagram */\n    private static final String HEX_DIGITS = \"#[0-9a-f]*\";\n    /** http://www.w3.org/TR/css-syntax-3/#ident-token-diagram */\n    private static final String IDENTIFIER = \"-?[a-z_\" + NON_ASCII + \"][\\\\w_\\\\-\" + NON_ASCII + \"]*\";\n    /** http://www.w3.org/TR/css-syntax-3/#string-token-diagram */\n    private static final String STRING = \"\\\"(?:(?!javascript\\\\s?:)[^\\\"^\\\\\\\\^\\\\n]|(?:\\\\\\\\\\\"))*\\\"|'(?:(?!javascript\\\\s?:)[^'^\\\\\\\\^\\\\n]|(?:\\\\\\\\'))*'\";\n    /** http://www.w3.org/TR/css-syntax-3/#dimension-token-diagram */\n    private static final String DIMENSION = NUMBER + IDENTIFIER;\n    /** http://www.w3.org/TR/css-syntax-3/#percentage-token-diagram */\n    private static final String PERCENT = NUMBER + \"%\";\n    /** http://www.w3.org/TR/css-syntax-3/#function-token-diagram */\n    private static final String FUNCTION = IDENTIFIER + \"\\\\((?:(?:\" + NUMBER + \")|(?:\" + IDENTIFIER + \")|(?:[\\\\s]*)|(?:,))*\\\\)\";\n    /** http://www.w3.org/TR/css-syntax-3/#url-unquoted-diagram */\n    private static final String URL_UNQUOTED = \"[^\\\"^'^\\\\(^\\\\)^[\" + NON_ASCII + \"]]*\";\n    /** http://www.w3.org/TR/css-syntax-3/#url-token-diagram */\n    private static final String URL = \"url\\\\((?:(?:\" + URL_UNQUOTED + \")|(?:\" + STRING + \"))\\\\)\";\n    /** composite regular expression for style token validation */\n    private static final String CSS_TOKEN = \"(?i)\" // case insensitive\n            + \"(?:\" + NUMBER + \")\"\n            + \"|(?:\" + DIMENSION + \")\"\n            + \"|(?:\" + PERCENT + \")\"\n            + \"|(?:\" + HEX_DIGITS + \")\"\n            + \"|(?:\" + IDENTIFIER + \")\"\n            + \"|(?:\" + STRING + \")\"\n            + \"|(?:\" + FUNCTION + \")\"\n            + \"|(?:\" + URL + \")\";\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidStyleToken(String, String)\n     */\n    @Override\n    public String getValidStyleToken(String token, String defaultValue) {\n        if (token != null && token.length() > 0 && token.matches(CSS_TOKEN)) {\n            return token;\n        }\n\n        return defaultValue;\n   }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidCSSColor(String, String)\n     */\n    @Override\n    public String getValidCSSColor(String color, String defaultColor) {\n        if (color != null && color.length() > 0) {\n            color = color.trim();\n            /*\n             * Avoid security implications by including only the characters required to specify colors in hex\n             * or functional notation. Critical characters disallowed: x (as in expression(...)),\n             * u (as in url(...)) and semi colon (as in escaping the context of the color value).\n             */\n            if (color.matches(\"(?i)[#a-fghlrs(+0-9-.%,) \\\\t\\\\n\\\\x0B\\\\f\\\\r]+\")) {\n                return color;\n            }\n            // named color values\n            if (color.matches(\"(?i)[a-zA-Z \\\\t\\\\n\\\\x0B\\\\f\\\\r]+\")) {\n                return color;\n            }\n        }\n\n        return defaultColor;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidMultiLineComment(String, String)\n     */\n    @Override\n    public String getValidMultiLineComment(String comment, String defaultComment) {\n        if (comment != null && !comment.contains(\"*/\")) {\n            return comment;\n        }\n        return defaultComment;\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidJSON(String, String)\n     */\n    @Override\n    public String getValidJSON(String json, String defaultJson) {\n        if (json == null) {\n            return getValidJSON(defaultJson, \"\");\n        }\n        json = json.trim();\n        if (\"\".equals(json)) {\n            return \"\";\n        }\n        int curlyIx = json.indexOf(\"{\");\n        int straightIx = json.indexOf(\"[\");\n        if (curlyIx >= 0 && (curlyIx < straightIx || straightIx < 0)) {\n            try {\n                StringWriter output = new StringWriter();\n                Json.createGenerator(output).write(jsonReaderFactory.createReader(new StringReader(json)).readObject()).close();\n                return output.getBuffer().toString();\n            } catch (Exception e) {\n                LOGGER.debug(\"JSON validation failed: \" + e.getMessage(), e);\n            }\n        } else {\n            try {\n                StringWriter output = new StringWriter();\n                Json.createGenerator(output).write(jsonReaderFactory.createReader(new StringReader(json)).readArray()).close();\n                return output.getBuffer().toString();\n            } catch (Exception e) {\n                LOGGER.debug(\"JSON validation failed: \" + e.getMessage(), e);\n            }\n        }\n        return getValidJSON(defaultJson, \"\");\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#getValidXML(String, String)\n     */\n    @Override\n    public String getValidXML(String xml, String defaultXml) {\n        if (xml == null) {\n            return getValidXML(defaultXml, \"\");\n        }\n        xml = xml.trim();\n        if (\"\".equals(xml)) {\n            return \"\";\n        }\n\n        try {\n            SAXParser parser = factory.newSAXParser();\n            XMLReader reader = parser.getXMLReader();\n            reader.parse(new InputSource(new StringReader(xml)));\n            return xml;\n        } catch (Exception e) {\n            LOGGER.debug(\"XML validation failed: \" + e.getMessage(), e);\n        }\n        return getValidXML(defaultXml, \"\");\n    }\n\n    // =============================================================================================\n    // ENCODERS\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForHTML(String)\n     */\n    @Override\n    public String encodeForHTML(String source) {\n        return source == null ? null : Encode.forHtml(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForHTMLAttr(String)\n     */\n    @Override\n    public String encodeForHTMLAttr(String source) {\n        return source == null ? null : Encode.forHtmlAttribute(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForXML(String)\n     */\n    @Override\n    public String encodeForXML(String source) {\n        return source == null ? null : Encode.forXml(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForXMLAttr(String)\n     */\n    @Override\n    public String encodeForXMLAttr(String source) {\n        return source == null ? null : Encode.forXmlAttribute(source);\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForJSString(String)\n     */\n    @Override\n    public String encodeForJSString(String source) {\n        return source == null ? null : Encode.forJavaScript(source).replace(\"\\\\-\", \"\\\\u002D\");\n    }\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#encodeForCSSString(String)\n     */\n    @Override\n    public String encodeForCSSString(String source) {\n        return source == null ? null : Encode.forCssString(source);\n    }\n\n    // =============================================================================================\n    // FILTERS\n    //\n\n    /**\n     * @see org.apache.sling.xss.XSSAPI#filterHTML(String)\n     */\n    @Override\n    @Nonnull\n    public String filterHTML(String source) {\n        return xssFilter.filter(ProtectionContext.HTML_HTML_CONTENT, source);\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-26": {
    "vul_id": "VUL4J-26",
    "cve_id": "CVE-2016-4465",
    "project": "apache_struts",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests -DskipAssembly clean install",
    "test_cmd": "mvn test -pl core -Dtest=com.opensymphony.xwork2.validator.URLValidatorTest",
    "test_all_cmd": "mvn test -pl core",
    "human_patch_url": "https://github.com/apache/struts/commit/a0fdca138feec2c2e94eb75ca1f8b76678b4d152",
    "vulnerable_files": [
      {
        "file_path": "core/src/main/java/com/opensymphony/xwork2/validator/validators/URLValidator.java",
        "file_name": "URLValidator.java",
        "vulnerable_code": "/*\n * Copyright 2002-2006,2009 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.validator.validators;\n\nimport com.opensymphony.xwork2.validator.ValidationException;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.regex.Pattern;\n\n/**\n * URLValidator checks that a given field is a String and a valid URL\n *\n * <pre>\n * &lt;validators&gt;\n *      &lt;!-- Plain Validator Syntax --&gt;\n *      &lt;validator type=\"url\"&gt;\n *          &lt;param name=\"fieldName\"&gt;myHomePage&lt;/param&gt;\n *          &lt;message&gt;Invalid homepage url&lt;/message&gt;\n *      &lt;/validator&gt;\n *\n *      &lt;!-- Field Validator Syntax --&gt;\n *      &lt;field name=\"myHomepage\"&gt;\n *          &lt;field-validator type=\"url\"&gt;\n *              &lt;message&gt;Invalid homepage url&lt;/message&gt;\n *          &lt;/field-validator&gt;\n *      &lt;/field&gt;\n * &lt;/validators&gt;\n * </pre>\n */\npublic class URLValidator extends FieldValidatorSupport {\n\n    private String urlRegex;\n    private String urlRegexExpression;\n\n    public void validate(Object object) throws ValidationException {\n        String fieldName = getFieldName();\n        Object value = this.getFieldValue(fieldName, object);\n\n        // if there is no value - don't do comparison\n        // if a value is required, a required validator should be added to the field\n        if (value == null || value.toString().length() == 0) {\n            return;\n        }\n\n        if (!(value.getClass().equals(String.class)) || !Pattern.compile(getUrlRegex()).matcher((String) value).matches()) {\n            addFieldError(fieldName, object);\n        }\n    }\n\n    /**\n     * This is used to support client-side validation, it's based on\n     * http://stackoverflow.com/questions/161738/what-is-the-best-regular-expression-to-check-if-a-string-is-a-valid-url\n     *\n     * @return regex to validate URLs\n     */\n    public String getUrlRegex() {\n        if (StringUtils.isNotEmpty(urlRegexExpression)) {\n            return (String) parse(urlRegexExpression, String.class);\n        } else if (StringUtils.isNotEmpty(urlRegex)) {\n            return urlRegex;\n        } else {\n            return \"^(https?|ftp):\\\\/\\\\/\" +\n                    \"(([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+\" +\n                    \"(:([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+)?\" +\n                    \"@)?(#?\" +\n                    \")((([a-z0-9]\\\\.|[a-z0-9][a-z0-9-]*[a-z0-9]\\\\.)*\" +\n                    \"[a-z][a-z0-9-]*[a-z0-9]\" +\n                    \"|((\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\\\\.){3}\" +\n                    \"(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\" +\n                    \")(:\\\\d+)?\" +\n                    \")(((\\\\/+([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)*\" +\n                    \"(\\\\?([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)\" +\n                    \"?)?)?\" +\n                    \"(#([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)?\" +\n                    \"$\";\n        }\n    }\n\n    public void setUrlRegex(String urlRegex) {\n        this.urlRegex = urlRegex;\n    }\n\n    public void setUrlRegexExpression(String urlRegexExpression) {\n        this.urlRegexExpression = urlRegexExpression;\n    }\n\n}\n",
        "human_patch_code": "/*\n * Copyright 2002-2006,2009 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.validator.validators;\n\nimport com.opensymphony.xwork2.validator.ValidationException;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.regex.Pattern;\n\n/**\n * URLValidator checks that a given field is a String and a valid URL\n *\n * <pre>\n * &lt;validators&gt;\n *      &lt;!-- Plain Validator Syntax --&gt;\n *      &lt;validator type=\"url\"&gt;\n *          &lt;param name=\"fieldName\"&gt;myHomePage&lt;/param&gt;\n *          &lt;message&gt;Invalid homepage url&lt;/message&gt;\n *      &lt;/validator&gt;\n *\n *      &lt;!-- Field Validator Syntax --&gt;\n *      &lt;field name=\"myHomepage\"&gt;\n *          &lt;field-validator type=\"url\"&gt;\n *              &lt;message&gt;Invalid homepage url&lt;/message&gt;\n *          &lt;/field-validator&gt;\n *      &lt;/field&gt;\n * &lt;/validators&gt;\n * </pre>\n */\npublic class URLValidator extends FieldValidatorSupport {\n\n    private String urlRegex;\n    private String urlRegexExpression;\n\n    public void validate(Object object) throws ValidationException {\n        String fieldName = getFieldName();\n        Object value = this.getFieldValue(fieldName, object);\n\n        // if there is no value - don't do comparison\n        // if a value is required, a required validator should be added to the field\n        if (value == null || value.toString().length() == 0) {\n            return;\n        }\n\n        if (!(value.getClass().equals(String.class)) || !Pattern.compile(getUrlRegex()).matcher((String) value).matches()) {\n            addFieldError(fieldName, object);\n        }\n    }\n\n    /**\n     * This is used to support client-side validation, it's based on\n     * http://stackoverflow.com/questions/161738/what-is-the-best-regular-expression-to-check-if-a-string-is-a-valid-url\n     *\n     * @return regex to validate URLs\n     */\n    public String getUrlRegex() {\n        if (StringUtils.isNotEmpty(urlRegexExpression)) {\n            return (String) parse(urlRegexExpression, String.class);\n        } else if (StringUtils.isNotEmpty(urlRegex)) {\n            return urlRegex;\n        } else {\n            return \"^(https?|ftp):\\\\/\\\\/\" +\n                    \"(([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+\" +\n                    \"(:([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+)?\" +\n                    \"@)?(#?\" +\n                    \")((([a-z0-9]\\\\.|[a-z0-9][a-z0-9-]*[a-z0-9]\\\\.)*\" +\n                    \"[a-z][a-z0-9-]*[a-z0-9]\" +\n                    \"|((\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\\\\.){3}\" +\n                    \"(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\" +\n                    \")(:\\\\d+)?\" +\n                    \")(((\\\\/{0,1}([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)*\" +\n                    \"(\\\\?([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)\" +\n                    \"?)?)?\" +\n                    \"(#([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)?\" +\n                    \"$\";\n        }\n    }\n\n    public void setUrlRegex(String urlRegex) {\n        this.urlRegex = urlRegex;\n    }\n\n    public void setUrlRegexExpression(String urlRegexExpression) {\n        this.urlRegexExpression = urlRegexExpression;\n    }\n\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-27": {
    "vul_id": "VUL4J-27",
    "cve_id": "CVE-2014-0112",
    "project": "apache_struts",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests -DskipAssembly clean install",
    "test_cmd": "mvn test -pl xwork-core -Dtest=com.opensymphony.xwork2.interceptor.ParametersInterceptorTest",
    "test_all_cmd": "mvn test -pl xwork-core",
    "human_patch_url": "https://github.com/bqcuong/vul4j/compare/a2d0ecdcd3594c87265f483ecb3c202fec18937c..6315241719be167542962da436b38782ed730c62",
    "vulnerable_files": [
      {
        "file_path": "core/src/main/java/org/apache/struts2/interceptor/CookieInterceptor.java",
        "file_name": "CookieInterceptor.java",
        "vulnerable_code": "/*\n * $Id$\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.struts2.interceptor;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.interceptor.AbstractInterceptor;\nimport com.opensymphony.xwork2.util.TextParseUtil;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport com.opensymphony.xwork2.util.logging.Logger;\nimport com.opensymphony.xwork2.util.logging.LoggerFactory;\nimport org.apache.struts2.ServletActionContext;\n\nimport javax.servlet.http.Cookie;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\n/**\n * <!-- START SNIPPET: description -->\n *\n * The aim of this intercepter is to set values in the stack/action based on cookie name/value\n * of interest. <p/>\n *\n * If an asterisk is present in cookiesName parameter, it will be assume that\n * all cookies name are to be injected into struts' action, even though\n * cookiesName is comma-separated by other values, e.g. (cookie1,*,cookie2). <p/>\n *\n * If cookiesName is left empty it will assume that no cookie will be injected\n * into Struts' action. <p/>\n *\n * If an asterisk is present in cookiesValue parameter, it will assume that all\n * cookies name irrespective of its value will be injected into Struts' action so\n * long as the cookie name matches those specified in cookiesName parameter.<p/>\n *\n * If cookiesValue is left empty it will assume that all cookie that match the cookieName\n * parameter will be injected into Struts' action.<p/>\n *\n * The action could implement {@link CookiesAware} in order to have a {@link Map}\n * of filtered cookies set into it. <p/>\n *\n * <!-- END SNIPPET: description -->\n *\n *\n * <!-- START SNIPPET: parameters -->\n *\n * <ul>\n *      <li>cookiesName (mandatory) - Name of cookies to be injected into the action. If more\n *                                                                 than one cookie name is desired it could be comma-separated.\n *                                                                 If all cookies name is desired, it could simply be *, an asterik.\n *                                                                 When many cookies name are comma-separated either of the cookie\n *                                                        that match the name in the comma-separated list will be qualified.</li>\n *     <li>cookiesValue (mandatory) - Value of cookies that if its name matches cookieName attribute\n *                                                         and its value matched this, will be injected into Struts'\n *                                                         action. If more than one cookie name is desired it could be\n *                                                         comma-separated. If left empty, it will assume any value would\n *                                                         be ok. If more than one value is specified (comma-separated)\n *                                                         it will assume a match if either value is matched.</li>\n *     <li>acceptCookieNames (optional) - Pattern used to check if name of cookie matches the provided patter, to </li>\n * </ul>\n *\n * <!-- END SNIPPET: parameters -->\n *\n *\n * <!-- START SNIPPET: extending -->\n *\n * <ul>\n *     <li>\n *         populateCookieValueIntoStack - this method will decide if this cookie value is qualified\n *         to be populated into the value stack (hence into the action itself)\n *     </li>\n *     <li>\n *         injectIntoCookiesAwareAction - this method will inject selected cookies (as a java.util.Map)\n *         into action that implements {@link CookiesAware}.\n *     </li>\n * </ul>\n *\n * <!-- END SNIPPET: extending -->\n *\n * <pre>\n * <!-- START SNIPPET: example -->\n *\n * &lt;!--\n *   This example will inject cookies named either 'cookie1' or 'cookie2' whose\n *   value could be either 'cookie1value' or 'cookie2value' into Struts' action.\n * --&gt;\n * &lt;action ... &gt;\n *    &lt;interceptor-ref name=\"cookie\"&gt;\n *        &lt;param name=\"cookiesName\"&gt;cookie1, cookie2&lt;/param&gt;\n *        &lt;param name=\"cookiesValue\"&gt;cookie1value, cookie2value&lt;/param&gt;\n *    &lt;/interceptor-ref&gt;\n *    ....\n * &lt;/action&gt;\n *\n *\n * &lt;!--\n *      This example will inject cookies named either 'cookie1' or 'cookie2'\n *     regardless of their value into Struts' action.\n * --&gt;\n * &lt;action ... &gt;\n *   &lt;interceptor-ref name=\"cookie\"&gt;\n *      &lt;param name=\"cookiesName\"&gt;cookie1, cookie2&lt;/param&gt;\n *      &lt;param name=\"cookiesValue\"&gt;*&lt;/param&gt;\n *   &lt;interceptor-ref&gt;\n *   ...\n * &lt;/action&gt;\n *\n *\n * &lt;!--\n *      This example will inject cookies named either 'cookie1' with value\n *      'cookie1value' or 'cookie2' with value 'cookie2value' into Struts'\n *      action.\n * --&gt;\n * &lt;action ... &gt;\n *   &lt;interceptor-ref name=\"cookie\"&gt;\n *      &lt;param name=\"cookiesName\"&gt;cookie1&lt;/param&gt;\n *      &lt;param name=\"cookiesValue\"&gt;cookie1value&lt;/param&gt;\n *   &lt;/interceptor-ref&gt;\n *   &lt;interceptor-ref name=\"cookie\"&gt;\n *      &lt;param name=\"cookiesName\"&lt;cookie2&lt;/param&gt;\n *     &lt;param name=\"cookiesValue\"&gt;cookie2value&lt;/param&gt;\n *   &lt;/interceptor-ref&gt;\n *   ....\n * &lt;/action&gt;\n *\n * &lt;!--\n *    This example will inject any cookies regardless of its value into\n *    Struts' action.\n *  --&gt;\n * &lt;action ... &gt;\n *   &lt;interceptor-ref name=\"cookie\"&gt;\n *      &lt;param name=\"cookiesName\"&gt;*&lt;/param&gt;\n *      &lt;param name=\"cookiesValue\"&gt;*&lt;/param&gt;\n *   &lt;/interceptor-ref&gt;\n *    ...\n * &lt;/action&gt;\n *\n * <!-- END SNIPPET: example -->\n * </pre>\n *\n * @see CookiesAware\n */\npublic class CookieInterceptor extends AbstractInterceptor {\n\n    private static final long serialVersionUID = 4153142432948747305L;\n\n    private static final Logger LOG = LoggerFactory.getLogger(CookieInterceptor.class);\n\n    private static final String ACCEPTED_PATTERN = \"[a-zA-Z0-9\\\\.\\\\]\\\\[_'\\\\s]+\";\n\n    private Set<String> cookiesNameSet = Collections.emptySet();\n    private Set<String> cookiesValueSet = Collections.emptySet();\n\n    // Allowed names of cookies\n    private Pattern acceptedPattern = Pattern.compile(ACCEPTED_PATTERN);\n\n    /**\n     * Set the <code>cookiesName</code> which if matched will allow the cookie\n     * to be injected into action, could be comma-separated string.\n     *\n     * @param cookiesName\n     */\n    public void setCookiesName(String cookiesName) {\n        if (cookiesName != null)\n            this.cookiesNameSet = TextParseUtil.commaDelimitedStringToSet(cookiesName);\n    }\n\n    /**\n     * Set the <code>cookiesValue</code> which if matched (together with matching\n     * cookiesName) will caused the cookie to be injected into action, could be\n     * comma-separated string.\n     *\n     * @param cookiesValue\n     */\n    public void setCookiesValue(String cookiesValue) {\n        if (cookiesValue != null)\n            this.cookiesValueSet = TextParseUtil.commaDelimitedStringToSet(cookiesValue);\n    }\n\n    /**\n     * Set the <code>acceptCookieNames</code> pattern of allowed names of cookies to protect against remote command execution vulnerability\n     *\n     * @param pattern used to check cookie name against\n     */\n    public void setAcceptCookieNames(String pattern) {\n        acceptedPattern = Pattern.compile(pattern);\n    }\n\n    public String intercept(ActionInvocation invocation) throws Exception {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"start interception\");\n        }\n\n        // contains selected cookies\n        final Map<String, String> cookiesMap = new LinkedHashMap<String, String>();\n\n        Cookie[] cookies = ServletActionContext.getRequest().getCookies();\n        if (cookies != null) {\n            final ValueStack stack = ActionContext.getContext().getValueStack();\n\n            for (Cookie cookie : cookies) {\n                String name = cookie.getName();\n                String value = cookie.getValue();\n\n                if (isAcceptableName(name)) {\n                    if (cookiesNameSet.contains(\"*\")) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"contains cookie name [*] in configured cookies name set, cookie with name [\" + name + \"] with value [\" + value + \"] will be injected\");\n                        }\n                        populateCookieValueIntoStack(name, value, cookiesMap, stack);\n                    } else if (cookiesNameSet.contains(cookie.getName())) {\n                        populateCookieValueIntoStack(name, value, cookiesMap, stack);\n                    }\n                } else {\n                    LOG.warn(\"Cookie name [\" + name + \"] does not match accepted cookie names pattern [\" + acceptedPattern + \"]\");\n                }\n            }\n        }\n\n        // inject the cookiesMap, even if we don't have any cookies\n        injectIntoCookiesAwareAction(invocation.getAction(), cookiesMap);\n\n        return invocation.invoke();\n    }\n\n    protected boolean isAcceptableName(String name) {\n        // Patch: return !Pattern.compile(ExcludedPatterns.CLASS_ACCESS_PATTERN).matcher(name).matches();\n        return acceptedPattern.matcher(name).matches();\n    }\n\n    /**\n     * Hook that populate cookie value into value stack (hence the action)\n     * if the criteria is satisfied (if the cookie value matches with those configured).\n     *\n     * @param cookieName\n     * @param cookieValue\n     * @param cookiesMap\n     * @param stack\n     */\n    protected void populateCookieValueIntoStack(String cookieName, String cookieValue, Map<String, String> cookiesMap, ValueStack stack) {\n        if (cookiesValueSet.isEmpty() || cookiesValueSet.contains(\"*\")) {\n            // If the interceptor is configured to accept any cookie value\n            // OR\n            // no cookiesValue is defined, so as long as the cookie name match\n            // we'll inject it into Struts' action\n            if (LOG.isDebugEnabled()) {\n                if (cookiesValueSet.isEmpty())\n                    LOG.debug(\"no cookie value is configured, cookie with name [\"+cookieName+\"] with value [\"+cookieValue+\"] will be injected\");\n                else if (cookiesValueSet.contains(\"*\"))\n                    LOG.debug(\"interceptor is configured to accept any value, cookie with name [\"+cookieName+\"] with value [\"+cookieValue+\"] will be injected\");\n            }\n            cookiesMap.put(cookieName, cookieValue);\n            stack.setValue(cookieName, cookieValue);\n        }\n        else {\n            // if cookiesValues is specified, the cookie's value must match before we\n            // inject them into Struts' action\n            if (cookiesValueSet.contains(cookieValue)) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"both configured cookie name and value matched, cookie [\"+cookieName+\"] with value [\"+cookieValue+\"] will be injected\");\n                }\n\n                cookiesMap.put(cookieName, cookieValue);\n                stack.setValue(cookieName, cookieValue);\n            }\n        }\n    }\n\n    /**\n     * Hook that set the <code>cookiesMap</code> into action that implements\n     * {@link CookiesAware}.\n     *\n     * @param action\n     * @param cookiesMap\n     */\n    protected void injectIntoCookiesAwareAction(Object action, Map<String, String> cookiesMap) {\n        if (action instanceof CookiesAware) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"action [\"+action+\"] implements CookiesAware, injecting cookies map [\"+cookiesMap+\"]\");\n            }\n            ((CookiesAware)action).setCookiesMap(cookiesMap);\n        }\n    }\n}\n",
        "human_patch_code": "/*\n * $Id$\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.struts2.interceptor;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.interceptor.AbstractInterceptor;\nimport com.opensymphony.xwork2.ExcludedPatterns;\nimport com.opensymphony.xwork2.util.TextParseUtil;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport com.opensymphony.xwork2.util.logging.Logger;\nimport com.opensymphony.xwork2.util.logging.LoggerFactory;\nimport org.apache.struts2.ServletActionContext;\n\nimport javax.servlet.http.Cookie;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\n/**\n * <!-- START SNIPPET: description -->\n *\n * The aim of this intercepter is to set values in the stack/action based on cookie name/value\n * of interest. <p/>\n *\n * If an asterisk is present in cookiesName parameter, it will be assume that\n * all cookies name are to be injected into struts' action, even though\n * cookiesName is comma-separated by other values, e.g. (cookie1,*,cookie2). <p/>\n *\n * If cookiesName is left empty it will assume that no cookie will be injected\n * into Struts' action. <p/>\n *\n * If an asterisk is present in cookiesValue parameter, it will assume that all\n * cookies name irrespective of its value will be injected into Struts' action so\n * long as the cookie name matches those specified in cookiesName parameter.<p/>\n *\n * If cookiesValue is left empty it will assume that all cookie that match the cookieName\n * parameter will be injected into Struts' action.<p/>\n *\n * The action could implement {@link CookiesAware} in order to have a {@link Map}\n * of filtered cookies set into it. <p/>\n *\n * <!-- END SNIPPET: description -->\n *\n *\n * <!-- START SNIPPET: parameters -->\n *\n * <ul>\n *      <li>cookiesName (mandatory) - Name of cookies to be injected into the action. If more\n *                                                                 than one cookie name is desired it could be comma-separated.\n *                                                                 If all cookies name is desired, it could simply be *, an asterik.\n *                                                                 When many cookies name are comma-separated either of the cookie\n *                                                        that match the name in the comma-separated list will be qualified.</li>\n *     <li>cookiesValue (mandatory) - Value of cookies that if its name matches cookieName attribute\n *                                                         and its value matched this, will be injected into Struts'\n *                                                         action. If more than one cookie name is desired it could be\n *                                                         comma-separated. If left empty, it will assume any value would\n *                                                         be ok. If more than one value is specified (comma-separated)\n *                                                         it will assume a match if either value is matched.</li>\n *     <li>acceptCookieNames (optional) - Pattern used to check if name of cookie matches the provided patter, to </li>\n * </ul>\n *\n * <!-- END SNIPPET: parameters -->\n *\n *\n * <!-- START SNIPPET: extending -->\n *\n * <ul>\n *     <li>\n *         populateCookieValueIntoStack - this method will decide if this cookie value is qualified\n *         to be populated into the value stack (hence into the action itself)\n *     </li>\n *     <li>\n *         injectIntoCookiesAwareAction - this method will inject selected cookies (as a java.util.Map)\n *         into action that implements {@link CookiesAware}.\n *     </li>\n * </ul>\n *\n * <!-- END SNIPPET: extending -->\n *\n * <pre>\n * <!-- START SNIPPET: example -->\n *\n * &lt;!--\n *   This example will inject cookies named either 'cookie1' or 'cookie2' whose\n *   value could be either 'cookie1value' or 'cookie2value' into Struts' action.\n * --&gt;\n * &lt;action ... &gt;\n *    &lt;interceptor-ref name=\"cookie\"&gt;\n *        &lt;param name=\"cookiesName\"&gt;cookie1, cookie2&lt;/param&gt;\n *        &lt;param name=\"cookiesValue\"&gt;cookie1value, cookie2value&lt;/param&gt;\n *    &lt;/interceptor-ref&gt;\n *    ....\n * &lt;/action&gt;\n *\n *\n * &lt;!--\n *      This example will inject cookies named either 'cookie1' or 'cookie2'\n *     regardless of their value into Struts' action.\n * --&gt;\n * &lt;action ... &gt;\n *   &lt;interceptor-ref name=\"cookie\"&gt;\n *      &lt;param name=\"cookiesName\"&gt;cookie1, cookie2&lt;/param&gt;\n *      &lt;param name=\"cookiesValue\"&gt;*&lt;/param&gt;\n *   &lt;interceptor-ref&gt;\n *   ...\n * &lt;/action&gt;\n *\n *\n * &lt;!--\n *      This example will inject cookies named either 'cookie1' with value\n *      'cookie1value' or 'cookie2' with value 'cookie2value' into Struts'\n *      action.\n * --&gt;\n * &lt;action ... &gt;\n *   &lt;interceptor-ref name=\"cookie\"&gt;\n *      &lt;param name=\"cookiesName\"&gt;cookie1&lt;/param&gt;\n *      &lt;param name=\"cookiesValue\"&gt;cookie1value&lt;/param&gt;\n *   &lt;/interceptor-ref&gt;\n *   &lt;interceptor-ref name=\"cookie\"&gt;\n *      &lt;param name=\"cookiesName\"&lt;cookie2&lt;/param&gt;\n *     &lt;param name=\"cookiesValue\"&gt;cookie2value&lt;/param&gt;\n *   &lt;/interceptor-ref&gt;\n *   ....\n * &lt;/action&gt;\n *\n * &lt;!--\n *    This example will inject any cookies regardless of its value into\n *    Struts' action.\n *  --&gt;\n * &lt;action ... &gt;\n *   &lt;interceptor-ref name=\"cookie\"&gt;\n *      &lt;param name=\"cookiesName\"&gt;*&lt;/param&gt;\n *      &lt;param name=\"cookiesValue\"&gt;*&lt;/param&gt;\n *   &lt;/interceptor-ref&gt;\n *    ...\n * &lt;/action&gt;\n *\n * <!-- END SNIPPET: example -->\n * </pre>\n *\n * @see CookiesAware\n */\npublic class CookieInterceptor extends AbstractInterceptor {\n\n    private static final long serialVersionUID = 4153142432948747305L;\n\n    private static final Logger LOG = LoggerFactory.getLogger(CookieInterceptor.class);\n\n    private static final String ACCEPTED_PATTERN = \"[a-zA-Z0-9\\\\.\\\\]\\\\[_'\\\\s]+\";\n\n    private Set<String> cookiesNameSet = Collections.emptySet();\n    private Set<String> cookiesValueSet = Collections.emptySet();\n\n    // Allowed names of cookies\n    private Pattern acceptedPattern = Pattern.compile(ACCEPTED_PATTERN, Pattern.CASE_INSENSITIVE);\n    private Pattern excludedPattern = Pattern.compile(ExcludedPatterns.CLASS_ACCESS_PATTERN, Pattern.CASE_INSENSITIVE);\n\n    /**\n     * Set the <code>cookiesName</code> which if matched will allow the cookie\n     * to be injected into action, could be comma-separated string.\n     *\n     * @param cookiesName\n     */\n    public void setCookiesName(String cookiesName) {\n        if (cookiesName != null)\n            this.cookiesNameSet = TextParseUtil.commaDelimitedStringToSet(cookiesName);\n    }\n\n    /**\n     * Set the <code>cookiesValue</code> which if matched (together with matching\n     * cookiesName) will caused the cookie to be injected into action, could be\n     * comma-separated string.\n     *\n     * @param cookiesValue\n     */\n    public void setCookiesValue(String cookiesValue) {\n        if (cookiesValue != null)\n            this.cookiesValueSet = TextParseUtil.commaDelimitedStringToSet(cookiesValue);\n    }\n\n    /**\n     * Set the <code>acceptCookieNames</code> pattern of allowed names of cookies to protect against remote command execution vulnerability\n     *\n     * @param pattern used to check cookie name against\n     */\n    public void setAcceptCookieNames(String pattern) {\n        acceptedPattern = Pattern.compile(pattern);\n    }\n\n    public String intercept(ActionInvocation invocation) throws Exception {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"start interception\");\n        }\n\n        // contains selected cookies\n        final Map<String, String> cookiesMap = new LinkedHashMap<String, String>();\n\n        Cookie[] cookies = ServletActionContext.getRequest().getCookies();\n        if (cookies != null) {\n            final ValueStack stack = ActionContext.getContext().getValueStack();\n\n            for (Cookie cookie : cookies) {\n                String name = cookie.getName();\n                String value = cookie.getValue();\n\n                if (isAcceptableName(name) && isAcceptableValue(value)) {\n                    if (cookiesNameSet.contains(\"*\")) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"contains cookie name [*] in configured cookies name set, cookie with name [\" + name + \"] with value [\" + value + \"] will be injected\");\n                        }\n                        populateCookieValueIntoStack(name, value, cookiesMap, stack);\n                    } else if (cookiesNameSet.contains(cookie.getName())) {\n                        populateCookieValueIntoStack(name, value, cookiesMap, stack);\n                    }\n                } else {\n                    LOG.warn(\"Cookie name [#0] with value [#1] was rejected!\", name, value);\n                }\n            }\n        }\n\n        // inject the cookiesMap, even if we don't have any cookies\n        injectIntoCookiesAwareAction(invocation.getAction(), cookiesMap);\n\n        return invocation.invoke();\n    }\n\n    /**\n     * Checks if value of Cookie doesn't contain vulnerable code\n     *\n     * @param value of Cookie\n     * @return true|false\n     */\n    protected boolean isAcceptableValue(String value) {\n        boolean matches = !excludedPattern.matcher(value).matches();\n        if (!matches) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Cookie value [#0] matches excludedPattern [#1]\", value, ExcludedPatterns.CLASS_ACCESS_PATTERN);\n            }\n        }\n        return matches;\n    }\n\n    /**\n     * Checks if name of Cookie doesn't contain vulnerable code\n     *\n     * @param name of Cookie\n     * @return true|false\n     */\n    protected boolean isAcceptableName(String name) {\n        return !isExcluded(name) && isAccepted(name);\n    }\n\n    /**\n     * Checks if name of Cookie match {@link #acceptedPattern}\n     *\n     * @param name of Cookie\n     * @return true|false\n     */\n    protected boolean isAccepted(String name) {\n        boolean matches = acceptedPattern.matcher(name).matches();\n        if (matches) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Cookie [#0] matches acceptedPattern [#1]\", name, ACCEPTED_PATTERN);\n            }\n        } else {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Cookie [#0] doesn't match acceptedPattern [#1]\", name, ACCEPTED_PATTERN);\n            }\n        }\n        return matches;\n    }\n\n    /**\n     * Checks if name of Cookie match {@link #excludedPattern}\n     *\n     * @param name of Cookie\n     * @return true|false\n     */\n    protected boolean isExcluded(String name) {\n        boolean matches = excludedPattern.matcher(name).matches();\n        if (matches) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Cookie [#0] matches excludedPattern [#1]\", name, ExcludedPatterns.CLASS_ACCESS_PATTERN);\n            }\n        } else {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Cookie [#0] doesn't match excludedPattern [#1]\", name, ExcludedPatterns.CLASS_ACCESS_PATTERN);\n            }\n        }\n        return matches;\n    }\n\n    /**\n     * Hook that populate cookie value into value stack (hence the action)\n     * if the criteria is satisfied (if the cookie value matches with those configured).\n     *\n     * @param cookieName\n     * @param cookieValue\n     * @param cookiesMap\n     * @param stack\n     */\n    protected void populateCookieValueIntoStack(String cookieName, String cookieValue, Map<String, String> cookiesMap, ValueStack stack) {\n        if (cookiesValueSet.isEmpty() || cookiesValueSet.contains(\"*\")) {\n            // If the interceptor is configured to accept any cookie value\n            // OR\n            // no cookiesValue is defined, so as long as the cookie name match\n            // we'll inject it into Struts' action\n            if (LOG.isDebugEnabled()) {\n                if (cookiesValueSet.isEmpty())\n                    LOG.debug(\"no cookie value is configured, cookie with name [\"+cookieName+\"] with value [\"+cookieValue+\"] will be injected\");\n                else if (cookiesValueSet.contains(\"*\"))\n                    LOG.debug(\"interceptor is configured to accept any value, cookie with name [\"+cookieName+\"] with value [\"+cookieValue+\"] will be injected\");\n            }\n            cookiesMap.put(cookieName, cookieValue);\n            stack.setValue(cookieName, cookieValue);\n        }\n        else {\n            // if cookiesValues is specified, the cookie's value must match before we\n            // inject them into Struts' action\n            if (cookiesValueSet.contains(cookieValue)) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"both configured cookie name and value matched, cookie [\"+cookieName+\"] with value [\"+cookieValue+\"] will be injected\");\n                }\n\n                cookiesMap.put(cookieName, cookieValue);\n                stack.setValue(cookieName, cookieValue);\n            }\n        }\n    }\n\n    /**\n     * Hook that set the <code>cookiesMap</code> into action that implements\n     * {@link CookiesAware}.\n     *\n     * @param action\n     * @param cookiesMap\n     */\n    protected void injectIntoCookiesAwareAction(Object action, Map<String, String> cookiesMap) {\n        if (action instanceof CookiesAware) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"action [\"+action+\"] implements CookiesAware, injecting cookies map [\"+cookiesMap+\"]\");\n            }\n            ((CookiesAware)action).setCookiesMap(cookiesMap);\n        }\n    }\n}\n"
      },
      {
        "file_path": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/ParametersInterceptor.java",
        "file_name": "ParametersInterceptor.java",
        "vulnerable_code": "/*\n * Copyright 2002-2007,2009 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.interceptor;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.ValidationAware;\nimport com.opensymphony.xwork2.XWorkConstants;\nimport com.opensymphony.xwork2.conversion.impl.InstantiatingNullHandler;\nimport com.opensymphony.xwork2.conversion.impl.XWorkConverter;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.ognl.PropertiesJudge;\nimport com.opensymphony.xwork2.util.ArrayUtils;\nimport com.opensymphony.xwork2.util.ClearableValueStack;\nimport com.opensymphony.xwork2.util.LocalizedTextUtil;\nimport com.opensymphony.xwork2.util.MemberAccessValueStack;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport com.opensymphony.xwork2.util.ValueStackFactory;\nimport com.opensymphony.xwork2.util.logging.Logger;\nimport com.opensymphony.xwork2.util.logging.LoggerFactory;\nimport com.opensymphony.xwork2.util.reflection.ReflectionContextState;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\n/**\n * <!-- START SNIPPET: description -->\n * This interceptor sets all parameters on the value stack.\n *\n * This interceptor gets all parameters from {@link ActionContext#getParameters()} and sets them on the value stack by\n * calling {@link ValueStack#setValue(String, Object)}, typically resulting in the values submitted in a form\n * request being applied to an action in the value stack. Note that the parameter map must contain a String key and\n * often containers a String[] for the value.\n *\n * The interceptor takes one parameter named 'ordered'. When set to true action properties are guaranteed to be\n * set top-down which means that top action's properties are set first. Then it's subcomponents properties are set.\n * The reason for this order is to enable a 'factory' pattern. For example, let's assume that one has an action\n * that contains a property named 'modelClass' that allows to choose what is the underlying implementation of model.\n * By assuring that modelClass property is set before any model properties are set, it's possible to choose model\n * implementation during action.setModelClass() call. Similiarily it's possible to use action.setPrimaryKey()\n * property set call to actually load the model class from persistent storage. Without any assumption on parameter\n * order you have to use patterns like 'Preparable'.\n *\n * Because parameter names are effectively OGNL statements, it is important that security be taken in to account.\n * This interceptor will not apply any values in the parameters map if the expression contains an assignment (=),\n * multiple expressions (,), or references any objects in the context (#). This is all done in the {@link\n * #acceptableName(String)} method. In addition to this method, if the action being invoked implements the {@link\n * ParameterNameAware} interface, the action will be consulted to determine if the parameter should be set.\n *\n * In addition to these restrictions, a flag ({@link ReflectionContextState#DENY_METHOD_EXECUTION}) is set such that\n * no methods are allowed to be invoked. That means that any expression such as <i>person.doSomething()</i> or\n * <i>person.getName()</i> will be explicitely forbidden. This is needed to make sure that your application is not\n * exposed to attacks by malicious users.\n *\n * While this interceptor is being invoked, a flag ({@link ReflectionContextState#CREATE_NULL_OBJECTS}) is turned\n * on to ensure that any null reference is automatically created - if possible. See the type conversion documentation\n * and the {@link InstantiatingNullHandler} javadocs for more information.\n *\n * Finally, a third flag ({@link XWorkConverter#REPORT_CONVERSION_ERRORS}) is set that indicates any errors when\n * converting the the values to their final data type (String[] -&gt; int) an unrecoverable error occured. With this\n * flag set, the type conversion errors will be reported in the action context. See the type conversion documentation\n * and the {@link XWorkConverter} javadocs for more information.\n *\n * If you are looking for detailed logging information about your parameters, turn on DEBUG level logging for this\n * interceptor. A detailed log of all the parameter keys and values will be reported.\n *\n * <b>Note:</b> Since XWork 2.0.2, this interceptor extends {@link MethodFilterInterceptor}, therefore being\n * able to deal with excludeMethods / includeMethods parameters. See [Workflow Interceptor]\n * (class {@link DefaultWorkflowInterceptor}) for documentation and examples on how to use this feature.\n * <!-- END SNIPPET: description -->\n *\n * <u>Interceptor parameters:</u>\n *\n * <!-- START SNIPPET: parameters -->\n *\n * <ul>\n * <li>ordered - set to true if you want the top-down property setter behaviour</li>\n * <li>acceptParamNames - a comma delimited list of regular expressions to describe a whitelist of accepted parameter names.\n * Don't change the default unless you know what you are doing in terms of security implications</li>\n * <li>excludeParams - a comma delimited list of regular expressions to describe a blacklist of not allowed parameter names</li>\n * <li>paramNameMaxLength - the maximum length of parameter names; parameters with longer names will be ignored; the default is 100 characters</li>\n * </ul>\n *\n * <!-- END SNIPPET: parameters -->\n *\n *  <u>Extending the interceptor:</u>\n *\n * <!-- START SNIPPET: extending -->\n *\n *  The best way to add behavior to this interceptor is to utilize the {@link ParameterNameAware} interface in your\n * actions. However, if you wish to apply a global rule that isn't implemented in your action, then you could extend\n * this interceptor and override the {@link #acceptableName(String)} method.\n *\n * <!-- END SNIPPET: extending -->\n *\n *\n * <!-- START SNIPPET: extending-warning -->\n * Using {@link ParameterNameAware} could be dangerous as {@link ParameterNameAware#acceptableParameterName(String)} takes precedence\n * over ParametersInterceptor which means if ParametersInterceptor excluded given parameter name you can accept it with\n * {@link ParameterNameAware#acceptableParameterName(String)}.\n *\n * The best idea is to define very tight restrictions with ParametersInterceptor and relax them per action with\n * {@link ParameterNameAware#acceptableParameterName(String)}\n * <!-- END SNIPPET: extending-warning -->\n *\n *\n * <u>Example code:</u>\n *\n * <pre>\n * <!-- START SNIPPET: example -->\n * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n *     &lt;interceptor-ref name=\"params\"/&gt;\n *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n * &lt;/action&gt;\n * <!-- END SNIPPET: example -->\n * </pre>\n *\n * @author Patrick Lightbody\n */\npublic class ParametersInterceptor extends MethodFilterInterceptor {\n\n    private static final Logger LOG = LoggerFactory.getLogger(ParametersInterceptor.class);\n\n    public static final String ACCEPTED_PARAM_NAMES = \"\\\\w+((\\\\.\\\\w+)|(\\\\[\\\\d+\\\\])|(\\\\(\\\\d+\\\\))|(\\\\['\\\\w+'\\\\])|(\\\\('\\\\w+'\\\\)))*\";\n\n    protected static final int PARAM_NAME_MAX_LENGTH = 100;\n\n    private int paramNameMaxLength = PARAM_NAME_MAX_LENGTH;\n\n    protected boolean ordered = false;\n    protected Set<Pattern> excludeParams = Collections.emptySet();\n    protected Set<Pattern> acceptParams = Collections.emptySet();\n\n    private boolean devMode = false;\n\n    // Allowed names of parameters\n    private Pattern acceptedPattern = Pattern.compile(ACCEPTED_PARAM_NAMES);\n\n    private ValueStackFactory valueStackFactory;\n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject(XWorkConstants.DEV_MODE)\n    public void setDevMode(String mode) {\n        devMode = \"true\".equals(mode);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p/>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        Collection<String> acceptPatterns = ArrayUtils.asCollection(commaDelim);\n        if (acceptPatterns != null) {\n            acceptParams = new HashSet<Pattern>();\n            for (String pattern : acceptPatterns) {\n                acceptParams.add(Pattern.compile(pattern));\n            }\n        }\n    }\n\n    /**\n     * If the param name exceeds the configured maximum length it will not be\n     * accepted.\n     *\n     * @param paramNameMaxLength Maximum length of param names\n     */\n    public void setParamNameMaxLength(int paramNameMaxLength) {\n        this.paramNameMaxLength = paramNameMaxLength;\n    }\n\n    static private int countOGNLCharacters(String s) {\n        int count = 0;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            char c = s.charAt(i);\n            if (c == '.' || c == '[') count++;\n        }\n        return count;\n    }\n\n    /**\n     * Compares based on number of '.' and '[' characters (fewer is higher)\n     */\n    static final Comparator<String> rbCollator = new Comparator<String>() {\n        public int compare(String s1, String s2) {\n            int l1 = countOGNLCharacters(s1),\n                    l2 = countOGNLCharacters(s2);\n            return l1 < l2 ? -1 : (l2 < l1 ? 1 : s1.compareTo(s2));\n        }\n\n    };\n\n    @Override\n    public String doIntercept(ActionInvocation invocation) throws Exception {\n        Object action = invocation.getAction();\n        if (!(action instanceof NoParameters)) {\n            ActionContext ac = invocation.getInvocationContext();\n            final Map<String, Object> parameters = retrieveParameters(ac);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Setting params \" + getParameterLogMap(parameters));\n            }\n\n            if (parameters != null) {\n                Map<String, Object> contextMap = ac.getContextMap();\n                try {\n                    ReflectionContextState.setCreatingNullObjects(contextMap, true);\n                    ReflectionContextState.setDenyMethodExecution(contextMap, true);\n                    ReflectionContextState.setReportingConversionErrors(contextMap, true);\n\n                    ValueStack stack = ac.getValueStack();\n                    setParameters(action, stack, parameters);\n                } finally {\n                    ReflectionContextState.setCreatingNullObjects(contextMap, false);\n                    ReflectionContextState.setDenyMethodExecution(contextMap, false);\n                    ReflectionContextState.setReportingConversionErrors(contextMap, false);\n                }\n            }\n        }\n        return invocation.invoke();\n    }\n\n    /**\n     * Gets the parameter map to apply from wherever appropriate\n     *\n     * @param ac The action context\n     * @return The parameter map to apply\n     */\n    protected Map<String, Object> retrieveParameters(ActionContext ac) {\n        return ac.getParameters();\n    }\n\n\n    /**\n     * Adds the parameters into context's ParameterMap\n     *\n     * @param ac        The action context\n     * @param newParams The parameter map to apply\n     *                  <p/>\n     *                  In this class this is a no-op, since the parameters were fetched from the same location.\n     *                  In subclasses both retrieveParameters() and addParametersToContext() should be overridden.\n     */\n    protected void addParametersToContext(ActionContext ac, Map<String, Object> newParams) {\n    }\n\n    protected void setParameters(final Object action, ValueStack stack, final Map<String, Object> parameters) {\n        Map<String, Object> params;\n        Map<String, Object> acceptableParameters;\n        if (ordered) {\n            params = new TreeMap<String, Object>(getOrderedComparator());\n            acceptableParameters = new TreeMap<String, Object>(getOrderedComparator());\n            params.putAll(parameters);\n        } else {\n            params = new TreeMap<String, Object>(parameters);\n            acceptableParameters = new TreeMap<String, Object>();\n        }\n\n        for (Map.Entry<String, Object> entry : params.entrySet()) {\n            String name = entry.getKey();\n            if (isAcceptableParameter(name, action)) {\n                acceptableParameters.put(name, entry.getValue());\n            }\n        }\n\n        ValueStack newStack = valueStackFactory.createValueStack(stack);\n        boolean clearableStack = newStack instanceof ClearableValueStack;\n        if (clearableStack) {\n            //if the stack's context can be cleared, do that to prevent OGNL\n            //from having access to objects in the stack, see XW-641\n            ((ClearableValueStack)newStack).clearContextValues();\n            Map<String, Object> context = newStack.getContext();\n            ReflectionContextState.setCreatingNullObjects(context, true);\n            ReflectionContextState.setDenyMethodExecution(context, true);\n            ReflectionContextState.setReportingConversionErrors(context, true);\n\n            //keep locale from original context\n            context.put(ActionContext.LOCALE, stack.getContext().get(ActionContext.LOCALE));\n        }\n\n        boolean memberAccessStack = newStack instanceof MemberAccessValueStack;\n        if (memberAccessStack) {\n            //block or allow access to properties\n            //see WW-2761 for more details\n            MemberAccessValueStack accessValueStack = (MemberAccessValueStack) newStack;\n            accessValueStack.setAcceptProperties(acceptParams);\n            accessValueStack.setExcludeProperties(excludeParams);\n            if (action instanceof ParameterNameAware) {\n                accessValueStack.setPropertiesJudge(new PropertiesJudge() {\n                    public boolean acceptProperty(String propertyName) {\n                        return ((ParameterNameAware) action).acceptableParameterName(propertyName);\n                    }\n                });\n            }\n        }\n\n        for (Map.Entry<String, Object> entry : acceptableParameters.entrySet()) {\n            String name = entry.getKey();\n            Object value = entry.getValue();\n            try {\n                newStack.setParameter(name, value);\n            } catch (RuntimeException e) {\n                if (devMode) {\n                    notifyDeveloper(action, name, e.getMessage());\n                }\n            }\n        }\n\n        if (clearableStack && (stack.getContext() != null) && (newStack.getContext() != null))\n            stack.getContext().put(ActionContext.CONVERSION_ERRORS, newStack.getContext().get(ActionContext.CONVERSION_ERRORS));\n\n        addParametersToContext(ActionContext.getContext(), acceptableParameters);\n    }\n\n    protected void notifyDeveloper(Object action, String property, String message) {\n        String developerNotification = LocalizedTextUtil.findText(ParametersInterceptor.class, \"devmode.notification\",\n                ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\",\n                new Object[]{\n                        \"Unexpected Exception caught setting '\" + property + \"' on '\" + action.getClass() + \": \" + message\n                }\n        );\n        LOG.error(developerNotification);\n        // see https://issues.apache.org/jira/browse/WW-4066\n        if (action instanceof ValidationAware) {\n            Collection<String> messages = ((ValidationAware) action).getActionMessages();\n            messages.add(message);\n            ((ValidationAware) action).setActionMessages(messages);\n        }\n    }\n\n    /**\n     * Checks if name of parameter can be accepted or thrown away\n     *\n     * @param name parameter name\n     * @param action current action\n     * @return true if parameter is accepted\n     */\n    protected boolean isAcceptableParameter(String name, Object action) {\n        ParameterNameAware parameterNameAware = (action instanceof ParameterNameAware) ? (ParameterNameAware) action : null;\n        return acceptableName(name) && (parameterNameAware == null || parameterNameAware.acceptableParameterName(name));\n    }\n\n    /**\n     * Gets an instance of the comparator to use for the ordered sorting.  Override this\n     * method to customize the ordering of the parameters as they are set to the\n     * action.\n     *\n     * @return A comparator to sort the parameters\n     */\n    protected Comparator<String> getOrderedComparator() {\n        return rbCollator;\n    }\n\n    protected String getParameterLogMap(Map<String, Object> parameters) {\n        if (parameters == null) {\n            return \"NONE\";\n        }\n\n        StringBuilder logEntry = new StringBuilder();\n        for (Map.Entry entry : parameters.entrySet()) {\n            logEntry.append(String.valueOf(entry.getKey()));\n            logEntry.append(\" => \");\n            if (entry.getValue() instanceof Object[]) {\n                Object[] valueArray = (Object[]) entry.getValue();\n                logEntry.append(\"[ \");\n                if (valueArray.length > 0 ) {\n                    for (int indexA = 0; indexA < (valueArray.length - 1); indexA++) {\n                        Object valueAtIndex = valueArray[indexA];\n                        logEntry.append(String.valueOf(valueAtIndex));\n                        logEntry.append(\", \");\n                    }\n                    logEntry.append(String.valueOf(valueArray[valueArray.length - 1]));\n                }\n                logEntry.append(\" ] \");\n            } else {\n                logEntry.append(String.valueOf(entry.getValue()));\n            }\n        }\n\n        return logEntry.toString();\n    }\n\n    protected boolean acceptableName(String name) {\n        boolean accepted = isWithinLengthLimit(name) && !isExcluded(name) && isAccepted(name);\n        if (devMode && accepted) { // notify only when in devMode\n            LOG.debug(\"Parameter [#0] was accepted and will be appended to action!\", name);\n        }\n        return accepted;\n    }\n\n    protected boolean isWithinLengthLimit( String name ) {\n        boolean matchLength = name.length() <= paramNameMaxLength;\n        if (!matchLength) {\n            notifyDeveloper(\"Parameter [#0] is too long, allowed length is [#1]\", name, String.valueOf(paramNameMaxLength));\n        }\n        return matchLength;\n    }\n\n    protected boolean isAccepted(String paramName) {\n        if (!this.acceptParams.isEmpty()) {\n            for (Pattern pattern : acceptParams) {\n                Matcher matcher = pattern.matcher(paramName);\n                if (matcher.matches()) {\n                    return true;\n                }\n            }\n            notifyDeveloper(\"Parameter [#0] didn't match acceptParams list of patterns!\", paramName);\n            return false;\n        } else {\n            boolean matches = acceptedPattern.matcher(paramName).matches();\n            if (!matches) {\n                notifyDeveloper(\"Parameter [#0] didn't match acceptedPattern pattern!\", paramName);\n            }\n            return matches;\n        }\n    }\n\n    protected boolean isExcluded(String paramName) {\n        if (!this.excludeParams.isEmpty()) {\n            for (Pattern pattern : excludeParams) {\n                Matcher matcher = pattern.matcher(paramName);\n                if (matcher.matches()) {\n                    notifyDeveloper(\"Parameter [#0] is on the excludeParams list of patterns!\", paramName);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private void notifyDeveloper(String message, String... parameters) {\n        if (devMode) {\n            LOG.warn(message, parameters);\n        } else {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(message, parameters);\n            }\n        }\n    }\n\n    /**\n     * Whether to order the parameters or not\n     *\n     * @return True to order\n     */\n    public boolean isOrdered() {\n        return ordered;\n    }\n\n    /**\n     * Set whether to order the parameters by object depth or not\n     *\n     * @param ordered True to order them\n     */\n    public void setOrdered(boolean ordered) {\n        this.ordered = ordered;\n    }\n\n    /**\n     * Gets a set of regular expressions of parameters to remove\n     * from the parameter map\n     *\n     * @return A set of compiled regular expression patterns\n     */\n    protected Set getExcludeParamsSet() {\n        return excludeParams;\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        Collection<String> excludePatterns = ArrayUtils.asCollection(commaDelim);\n        if (excludePatterns != null) {\n            excludeParams = new HashSet<Pattern>();\n            for (String pattern : excludePatterns) {\n                excludeParams.add(Pattern.compile(pattern));\n            }\n            // Patch: Add excludeParams.add(Pattern.compile(\"(.*\\\\.|^|.*|\\\\[('|\\\"))class(\\\\.|('|\\\")]|\\\\[).*\"));\n//            excludeParams.add(Pattern.compile(\"(.*\\\\.|^|.*|\\\\[('|\\\"))class(\\\\.|('|\\\")]|\\\\[).*\"));\n        }\n    }\n\n}\n",
        "human_patch_code": "/*\n * Copyright 2002-2007,2009 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.interceptor;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.ExcludedPatterns;\nimport com.opensymphony.xwork2.ValidationAware;\nimport com.opensymphony.xwork2.XWorkConstants;\nimport com.opensymphony.xwork2.conversion.impl.InstantiatingNullHandler;\nimport com.opensymphony.xwork2.conversion.impl.XWorkConverter;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.ognl.PropertiesJudge;\nimport com.opensymphony.xwork2.util.ArrayUtils;\nimport com.opensymphony.xwork2.util.ClearableValueStack;\nimport com.opensymphony.xwork2.util.LocalizedTextUtil;\nimport com.opensymphony.xwork2.util.MemberAccessValueStack;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport com.opensymphony.xwork2.util.ValueStackFactory;\nimport com.opensymphony.xwork2.util.logging.Logger;\nimport com.opensymphony.xwork2.util.logging.LoggerFactory;\nimport com.opensymphony.xwork2.util.reflection.ReflectionContextState;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\n/**\n * <!-- START SNIPPET: description -->\n * This interceptor sets all parameters on the value stack.\n *\n * This interceptor gets all parameters from {@link ActionContext#getParameters()} and sets them on the value stack by\n * calling {@link ValueStack#setValue(String, Object)}, typically resulting in the values submitted in a form\n * request being applied to an action in the value stack. Note that the parameter map must contain a String key and\n * often containers a String[] for the value.\n *\n * The interceptor takes one parameter named 'ordered'. When set to true action properties are guaranteed to be\n * set top-down which means that top action's properties are set first. Then it's subcomponents properties are set.\n * The reason for this order is to enable a 'factory' pattern. For example, let's assume that one has an action\n * that contains a property named 'modelClass' that allows to choose what is the underlying implementation of model.\n * By assuring that modelClass property is set before any model properties are set, it's possible to choose model\n * implementation during action.setModelClass() call. Similiarily it's possible to use action.setPrimaryKey()\n * property set call to actually load the model class from persistent storage. Without any assumption on parameter\n * order you have to use patterns like 'Preparable'.\n *\n * Because parameter names are effectively OGNL statements, it is important that security be taken in to account.\n * This interceptor will not apply any values in the parameters map if the expression contains an assignment (=),\n * multiple expressions (,), or references any objects in the context (#). This is all done in the {@link\n * #acceptableName(String)} method. In addition to this method, if the action being invoked implements the {@link\n * ParameterNameAware} interface, the action will be consulted to determine if the parameter should be set.\n *\n * In addition to these restrictions, a flag ({@link ReflectionContextState#DENY_METHOD_EXECUTION}) is set such that\n * no methods are allowed to be invoked. That means that any expression such as <i>person.doSomething()</i> or\n * <i>person.getName()</i> will be explicitely forbidden. This is needed to make sure that your application is not\n * exposed to attacks by malicious users.\n *\n * While this interceptor is being invoked, a flag ({@link ReflectionContextState#CREATE_NULL_OBJECTS}) is turned\n * on to ensure that any null reference is automatically created - if possible. See the type conversion documentation\n * and the {@link InstantiatingNullHandler} javadocs for more information.\n *\n * Finally, a third flag ({@link XWorkConverter#REPORT_CONVERSION_ERRORS}) is set that indicates any errors when\n * converting the the values to their final data type (String[] -&gt; int) an unrecoverable error occured. With this\n * flag set, the type conversion errors will be reported in the action context. See the type conversion documentation\n * and the {@link XWorkConverter} javadocs for more information.\n *\n * If you are looking for detailed logging information about your parameters, turn on DEBUG level logging for this\n * interceptor. A detailed log of all the parameter keys and values will be reported.\n *\n * <b>Note:</b> Since XWork 2.0.2, this interceptor extends {@link MethodFilterInterceptor}, therefore being\n * able to deal with excludeMethods / includeMethods parameters. See [Workflow Interceptor]\n * (class {@link DefaultWorkflowInterceptor}) for documentation and examples on how to use this feature.\n * <!-- END SNIPPET: description -->\n *\n * <u>Interceptor parameters:</u>\n *\n * <!-- START SNIPPET: parameters -->\n *\n * <ul>\n * <li>ordered - set to true if you want the top-down property setter behaviour</li>\n * <li>acceptParamNames - a comma delimited list of regular expressions to describe a whitelist of accepted parameter names.\n * Don't change the default unless you know what you are doing in terms of security implications</li>\n * <li>excludeParams - a comma delimited list of regular expressions to describe a blacklist of not allowed parameter names</li>\n * <li>paramNameMaxLength - the maximum length of parameter names; parameters with longer names will be ignored; the default is 100 characters</li>\n * </ul>\n *\n * <!-- END SNIPPET: parameters -->\n *\n *  <u>Extending the interceptor:</u>\n *\n * <!-- START SNIPPET: extending -->\n *\n *  The best way to add behavior to this interceptor is to utilize the {@link ParameterNameAware} interface in your\n * actions. However, if you wish to apply a global rule that isn't implemented in your action, then you could extend\n * this interceptor and override the {@link #acceptableName(String)} method.\n *\n * <!-- END SNIPPET: extending -->\n *\n *\n * <!-- START SNIPPET: extending-warning -->\n * Using {@link ParameterNameAware} could be dangerous as {@link ParameterNameAware#acceptableParameterName(String)} takes precedence\n * over ParametersInterceptor which means if ParametersInterceptor excluded given parameter name you can accept it with\n * {@link ParameterNameAware#acceptableParameterName(String)}.\n *\n * The best idea is to define very tight restrictions with ParametersInterceptor and relax them per action with\n * {@link ParameterNameAware#acceptableParameterName(String)}\n * <!-- END SNIPPET: extending-warning -->\n *\n *\n * <u>Example code:</u>\n *\n * <pre>\n * <!-- START SNIPPET: example -->\n * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n *     &lt;interceptor-ref name=\"params\"/&gt;\n *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n * &lt;/action&gt;\n * <!-- END SNIPPET: example -->\n * </pre>\n *\n * @author Patrick Lightbody\n */\npublic class ParametersInterceptor extends MethodFilterInterceptor {\n\n    private static final Logger LOG = LoggerFactory.getLogger(ParametersInterceptor.class);\n\n    public static final String ACCEPTED_PARAM_NAMES = \"\\\\w+((\\\\.\\\\w+)|(\\\\[\\\\d+\\\\])|(\\\\(\\\\d+\\\\))|(\\\\['\\\\w+'\\\\])|(\\\\('\\\\w+'\\\\)))*\";\n\n    protected static final int PARAM_NAME_MAX_LENGTH = 100;\n\n    private int paramNameMaxLength = PARAM_NAME_MAX_LENGTH;\n\n    protected boolean ordered = false;\n    protected Set<Pattern> excludeParams;\n    protected Set<Pattern> acceptParams = Collections.emptySet();\n\n    private boolean devMode = false;\n\n    // Allowed names of parameters\n    private Pattern acceptedPattern = Pattern.compile(ACCEPTED_PARAM_NAMES, Pattern.CASE_INSENSITIVE);\n\n    private ValueStackFactory valueStackFactory;\n\n    public ParametersInterceptor() {\n        initializeHardCodedExcludePatterns();\n    }\n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject(XWorkConstants.DEV_MODE)\n    public void setDevMode(String mode) {\n        devMode = \"true\".equals(mode);\n    }\n\n\t/**\n\t * Sets a comma-delimited list of regular expressions to match\n\t * parameters that are allowed in the parameter map (aka whitelist).\n\t * <p/>\n\t * Don't change the default unless you know what you are doing in terms\n\t * of security implications.\n\t *\n\t * @param commaDelim A comma-delimited list of regular expressions\n\t */\n\tpublic void setAcceptParamNames(String commaDelim) {\n        Collection<String> acceptPatterns = ArrayUtils.asCollection(commaDelim);\n        if (acceptPatterns != null) {\n            acceptParams = new HashSet<Pattern>();\n            for (String pattern : acceptPatterns) {\n                acceptParams.add(Pattern.compile(pattern));\n            }\n        }\n    }\n\n    /**\n     * If the param name exceeds the configured maximum length it will not be\n     * accepted.\n     *\n     * @param paramNameMaxLength Maximum length of param names\n     */\n    public void setParamNameMaxLength(int paramNameMaxLength) {\n        this.paramNameMaxLength = paramNameMaxLength;\n    }\n\n    static private int countOGNLCharacters(String s) {\n        int count = 0;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            char c = s.charAt(i);\n            if (c == '.' || c == '[') count++;\n        }\n        return count;\n    }\n\n    /**\n     * Compares based on number of '.' and '[' characters (fewer is higher)\n     */\n    static final Comparator<String> rbCollator = new Comparator<String>() {\n        public int compare(String s1, String s2) {\n            int l1 = countOGNLCharacters(s1),\n                l2 = countOGNLCharacters(s2);\n            return l1 < l2 ? -1 : (l2 < l1 ? 1 : s1.compareTo(s2));\n        }\n\n    };\n\n    @Override\n    public String doIntercept(ActionInvocation invocation) throws Exception {\n        Object action = invocation.getAction();\n        if (!(action instanceof NoParameters)) {\n            ActionContext ac = invocation.getInvocationContext();\n            final Map<String, Object> parameters = retrieveParameters(ac);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Setting params \" + getParameterLogMap(parameters));\n            }\n\n            if (parameters != null) {\n                Map<String, Object> contextMap = ac.getContextMap();\n                try {\n                    ReflectionContextState.setCreatingNullObjects(contextMap, true);\n                    ReflectionContextState.setDenyMethodExecution(contextMap, true);\n                    ReflectionContextState.setReportingConversionErrors(contextMap, true);\n\n                    ValueStack stack = ac.getValueStack();\n                    setParameters(action, stack, parameters);\n                } finally {\n                    ReflectionContextState.setCreatingNullObjects(contextMap, false);\n                    ReflectionContextState.setDenyMethodExecution(contextMap, false);\n                    ReflectionContextState.setReportingConversionErrors(contextMap, false);\n                }\n            }\n        }\n        return invocation.invoke();\n    }\n\n    /**\n     * Gets the parameter map to apply from wherever appropriate\n     *\n     * @param ac The action context\n     * @return The parameter map to apply\n     */\n    protected Map<String, Object> retrieveParameters(ActionContext ac) {\n        return ac.getParameters();\n    }\n\n\n    /**\n     * Adds the parameters into context's ParameterMap\n     *\n     * @param ac        The action context\n     * @param newParams The parameter map to apply\n     *                  <p/>\n     *                  In this class this is a no-op, since the parameters were fetched from the same location.\n     *                  In subclasses both retrieveParameters() and addParametersToContext() should be overridden.\n     */\n    protected void addParametersToContext(ActionContext ac, Map<String, Object> newParams) {\n    }\n\n    protected void setParameters(final Object action, ValueStack stack, final Map<String, Object> parameters) {\n        Map<String, Object> params;\n        Map<String, Object> acceptableParameters;\n        if (ordered) {\n            params = new TreeMap<String, Object>(getOrderedComparator());\n            acceptableParameters = new TreeMap<String, Object>(getOrderedComparator());\n            params.putAll(parameters);\n        } else {\n            params = new TreeMap<String, Object>(parameters);\n            acceptableParameters = new TreeMap<String, Object>();\n        }\n\n        for (Map.Entry<String, Object> entry : params.entrySet()) {\n            String name = entry.getKey();\n            if (isAcceptableParameter(name, action)) {\n                acceptableParameters.put(name, entry.getValue());\n            }\n        }\n\n        ValueStack newStack = valueStackFactory.createValueStack(stack);\n        boolean clearableStack = newStack instanceof ClearableValueStack;\n        if (clearableStack) {\n            //if the stack's context can be cleared, do that to prevent OGNL\n            //from having access to objects in the stack, see XW-641\n            ((ClearableValueStack)newStack).clearContextValues();\n            Map<String, Object> context = newStack.getContext();\n            ReflectionContextState.setCreatingNullObjects(context, true);\n            ReflectionContextState.setDenyMethodExecution(context, true);\n            ReflectionContextState.setReportingConversionErrors(context, true);\n\n            //keep locale from original context\n            context.put(ActionContext.LOCALE, stack.getContext().get(ActionContext.LOCALE));\n        }\n\n        boolean memberAccessStack = newStack instanceof MemberAccessValueStack;\n        if (memberAccessStack) {\n            //block or allow access to properties\n            //see WW-2761 for more details\n            MemberAccessValueStack accessValueStack = (MemberAccessValueStack) newStack;\n            accessValueStack.setAcceptProperties(acceptParams);\n            accessValueStack.setExcludeProperties(excludeParams);\n            if (action instanceof ParameterNameAware) {\n                accessValueStack.setPropertiesJudge(new PropertiesJudge() {\n                    public boolean acceptProperty(String propertyName) {\n                        return ((ParameterNameAware) action).acceptableParameterName(propertyName);\n                    }\n                });\n            }\n        }\n\n        for (Map.Entry<String, Object> entry : acceptableParameters.entrySet()) {\n            String name = entry.getKey();\n            Object value = entry.getValue();\n            try {\n                newStack.setParameter(name, value);\n            } catch (RuntimeException e) {\n                if (devMode) {\n                    notifyDeveloper(action, name, e.getMessage());\n                }\n            }\n        }\n\n        if (clearableStack && (stack.getContext() != null) && (newStack.getContext() != null))\n            stack.getContext().put(ActionContext.CONVERSION_ERRORS, newStack.getContext().get(ActionContext.CONVERSION_ERRORS));\n\n        addParametersToContext(ActionContext.getContext(), acceptableParameters);\n    }\n\n    protected void notifyDeveloper(Object action, String property, String message) {\n        String developerNotification = LocalizedTextUtil.findText(ParametersInterceptor.class, \"devmode.notification\",\n                ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\",\n                new Object[]{\n                        \"Unexpected Exception caught setting '\" + property + \"' on '\" + action.getClass() + \": \" + message\n                }\n        );\n        LOG.error(developerNotification);\n        // see https://issues.apache.org/jira/browse/WW-4066\n        if (action instanceof ValidationAware) {\n            Collection<String> messages = ((ValidationAware) action).getActionMessages();\n            messages.add(message);\n            ((ValidationAware) action).setActionMessages(messages);\n        }\n    }\n\n    /**\n     * Checks if name of parameter can be accepted or thrown away\n     *\n     * @param name parameter name\n     * @param action current action\n     * @return true if parameter is accepted\n     */\n    protected boolean isAcceptableParameter(String name, Object action) {\n        ParameterNameAware parameterNameAware = (action instanceof ParameterNameAware) ? (ParameterNameAware) action : null;\n        return acceptableName(name) && (parameterNameAware == null || parameterNameAware.acceptableParameterName(name));\n    }\n\n    /**\n     * Gets an instance of the comparator to use for the ordered sorting.  Override this\n     * method to customize the ordering of the parameters as they are set to the\n     * action.\n     *\n     * @return A comparator to sort the parameters\n     */\n    protected Comparator<String> getOrderedComparator() {\n        return rbCollator;\n    }\n\n    protected String getParameterLogMap(Map<String, Object> parameters) {\n        if (parameters == null) {\n            return \"NONE\";\n        }\n\n        StringBuilder logEntry = new StringBuilder();\n        for (Map.Entry entry : parameters.entrySet()) {\n            logEntry.append(String.valueOf(entry.getKey()));\n            logEntry.append(\" => \");\n            if (entry.getValue() instanceof Object[]) {\n                Object[] valueArray = (Object[]) entry.getValue();\n                logEntry.append(\"[ \");\n                if (valueArray.length > 0 ) {\n                    for (int indexA = 0; indexA < (valueArray.length - 1); indexA++) {\n                        Object valueAtIndex = valueArray[indexA];\n                        logEntry.append(String.valueOf(valueAtIndex));\n                        logEntry.append(\", \");\n                    }\n                    logEntry.append(String.valueOf(valueArray[valueArray.length - 1]));\n                }\n                logEntry.append(\" ] \");\n            } else {\n                logEntry.append(String.valueOf(entry.getValue()));\n            }\n        }\n\n        return logEntry.toString();\n    }\n\n    protected boolean acceptableName(String name) {\n        boolean accepted = isWithinLengthLimit(name) && !isExcluded(name) && isAccepted(name);\n        if (devMode && accepted) { // notify only when in devMode\n            LOG.debug(\"Parameter [#0] was accepted and will be appended to action!\", name);\n        }\n        return accepted;\n    }\n\n\tprotected boolean isWithinLengthLimit( String name ) {\n        boolean matchLength = name.length() <= paramNameMaxLength;\n        if (!matchLength) {\n            notifyDeveloper(\"Parameter [#0] is too long, allowed length is [#1]\", name, String.valueOf(paramNameMaxLength));\n        }\n        return matchLength;\n\t}\n\n    protected boolean isAccepted(String paramName) {\n        if (!this.acceptParams.isEmpty()) {\n            for (Pattern pattern : acceptParams) {\n                Matcher matcher = pattern.matcher(paramName);\n                if (matcher.matches()) {\n                    return true;\n                }\n            }\n            notifyDeveloper(\"Parameter [#0] didn't match acceptParams list of patterns!\", paramName);\n            return false;\n        } else {\n            boolean matches = acceptedPattern.matcher(paramName).matches();\n            if (!matches) {\n                notifyDeveloper(\"Parameter [#0] didn't match acceptedPattern pattern!\", paramName);\n            }\n            return matches;\n        }\n    }\n\n    protected boolean isExcluded(String paramName) {\n        if (!this.excludeParams.isEmpty()) {\n            for (Pattern pattern : excludeParams) {\n                Matcher matcher = pattern.matcher(paramName);\n                if (matcher.matches()) {\n                    notifyDeveloper(\"Parameter [#0] is on the excludeParams list of patterns!\", paramName);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private void notifyDeveloper(String message, String... parameters) {\n        if (devMode) {\n            LOG.warn(message, parameters);\n        } else {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(message, parameters);\n            }\n        }\n    }\n\n    /**\n     * Whether to order the parameters or not\n     *\n     * @return True to order\n     */\n    public boolean isOrdered() {\n        return ordered;\n    }\n\n    /**\n     * Set whether to order the parameters by object depth or not\n     *\n     * @param ordered True to order them\n     */\n    public void setOrdered(boolean ordered) {\n        this.ordered = ordered;\n    }\n\n    /**\n     * Gets a set of regular expressions of parameters to remove\n     * from the parameter map\n     *\n     * @return A set of compiled regular expression patterns\n     */\n    protected Set getExcludeParamsSet() {\n        return excludeParams;\n    }\n\n    protected void initializeHardCodedExcludePatterns() {\n        excludeParams = new HashSet<Pattern>();\n        for (String pattern : ExcludedPatterns.EXCLUDED_PATTERNS) {\n            excludeParams.add(Pattern.compile(pattern, Pattern.CASE_INSENSITIVE));\n        }\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        Collection<String> excludePatterns = ArrayUtils.asCollection(commaDelim);\n        if (excludePatterns != null) {\n            for (String pattern : excludePatterns) {\n                excludeParams.add(Pattern.compile(pattern, Pattern.CASE_INSENSITIVE));\n            }\n        }\n    }\n\n}\n"
      }
    ],
    "file_count": 2
  },
  "VUL4J-29": {
    "vul_id": "VUL4J-29",
    "cve_id": "CVE-2014-0116",
    "project": "apache_struts",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests -DskipAssembly clean install",
    "test_cmd": "mvn test -pl core -Dtest=org.apache.struts2.interceptor.CookieInterceptorTest",
    "test_all_cmd": "mvn test -pl core",
    "human_patch_url": "https://github.com/bqcuong/vul4j/commit/1a668af7f1ffccea4a3b46d8d8c1fe1c7331ff02",
    "vulnerable_files": [
      {
        "file_path": "core/src/main/java/org/apache/struts2/interceptor/CookieInterceptor.java",
        "file_name": "CookieInterceptor.java",
        "vulnerable_code": "/*\n * $Id$\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.struts2.interceptor;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.interceptor.AbstractInterceptor;\nimport com.opensymphony.xwork2.ExcludedPatterns;\nimport com.opensymphony.xwork2.util.TextParseUtil;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport com.opensymphony.xwork2.util.logging.Logger;\nimport com.opensymphony.xwork2.util.logging.LoggerFactory;\nimport org.apache.struts2.ServletActionContext;\n\nimport javax.servlet.http.Cookie;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\n/**\n * <!-- START SNIPPET: description -->\n *\n * The aim of this intercepter is to set values in the stack/action based on cookie name/value\n * of interest. <p/>\n *\n * If an asterisk is present in cookiesName parameter, it will be assume that\n * all cookies name are to be injected into struts' action, even though\n * cookiesName is comma-separated by other values, e.g. (cookie1,*,cookie2). <p/>\n *\n * If cookiesName is left empty it will assume that no cookie will be injected\n * into Struts' action. <p/>\n *\n * If an asterisk is present in cookiesValue parameter, it will assume that all\n * cookies name irrespective of its value will be injected into Struts' action so\n * long as the cookie name matches those specified in cookiesName parameter.<p/>\n *\n * If cookiesValue is left empty it will assume that all cookie that match the cookieName\n * parameter will be injected into Struts' action.<p/>\n *\n * The action could implement {@link CookiesAware} in order to have a {@link Map}\n * of filtered cookies set into it. <p/>\n *\n * <!-- END SNIPPET: description -->\n *\n *\n * <!-- START SNIPPET: parameters -->\n *\n * <ul>\n *      <li>cookiesName (mandatory) - Name of cookies to be injected into the action. If more\n *                                                                 than one cookie name is desired it could be comma-separated.\n *                                                                 If all cookies name is desired, it could simply be *, an asterik.\n *                                                                 When many cookies name are comma-separated either of the cookie\n *                                                        that match the name in the comma-separated list will be qualified.</li>\n *     <li>cookiesValue (mandatory) - Value of cookies that if its name matches cookieName attribute\n *                                                         and its value matched this, will be injected into Struts'\n *                                                         action. If more than one cookie name is desired it could be\n *                                                         comma-separated. If left empty, it will assume any value would\n *                                                         be ok. If more than one value is specified (comma-separated)\n *                                                         it will assume a match if either value is matched.</li>\n *     <li>acceptCookieNames (optional) - Pattern used to check if name of cookie matches the provided patter, to </li>\n * </ul>\n *\n * <!-- END SNIPPET: parameters -->\n *\n *\n * <!-- START SNIPPET: extending -->\n *\n * <ul>\n *     <li>\n *         populateCookieValueIntoStack - this method will decide if this cookie value is qualified\n *         to be populated into the value stack (hence into the action itself)\n *     </li>\n *     <li>\n *         injectIntoCookiesAwareAction - this method will inject selected cookies (as a java.util.Map)\n *         into action that implements {@link CookiesAware}.\n *     </li>\n * </ul>\n *\n * <!-- END SNIPPET: extending -->\n *\n * <pre>\n * <!-- START SNIPPET: example -->\n *\n * &lt;!--\n *   This example will inject cookies named either 'cookie1' or 'cookie2' whose\n *   value could be either 'cookie1value' or 'cookie2value' into Struts' action.\n * --&gt;\n * &lt;action ... &gt;\n *    &lt;interceptor-ref name=\"cookie\"&gt;\n *        &lt;param name=\"cookiesName\"&gt;cookie1, cookie2&lt;/param&gt;\n *        &lt;param name=\"cookiesValue\"&gt;cookie1value, cookie2value&lt;/param&gt;\n *    &lt;/interceptor-ref&gt;\n *    ....\n * &lt;/action&gt;\n *\n *\n * &lt;!--\n *      This example will inject cookies named either 'cookie1' or 'cookie2'\n *     regardless of their value into Struts' action.\n * --&gt;\n * &lt;action ... &gt;\n *   &lt;interceptor-ref name=\"cookie\"&gt;\n *      &lt;param name=\"cookiesName\"&gt;cookie1, cookie2&lt;/param&gt;\n *      &lt;param name=\"cookiesValue\"&gt;*&lt;/param&gt;\n *   &lt;interceptor-ref&gt;\n *   ...\n * &lt;/action&gt;\n *\n *\n * &lt;!--\n *      This example will inject cookies named either 'cookie1' with value\n *      'cookie1value' or 'cookie2' with value 'cookie2value' into Struts'\n *      action.\n * --&gt;\n * &lt;action ... &gt;\n *   &lt;interceptor-ref name=\"cookie\"&gt;\n *      &lt;param name=\"cookiesName\"&gt;cookie1&lt;/param&gt;\n *      &lt;param name=\"cookiesValue\"&gt;cookie1value&lt;/param&gt;\n *   &lt;/interceptor-ref&gt;\n *   &lt;interceptor-ref name=\"cookie\"&gt;\n *      &lt;param name=\"cookiesName\"&lt;cookie2&lt;/param&gt;\n *     &lt;param name=\"cookiesValue\"&gt;cookie2value&lt;/param&gt;\n *   &lt;/interceptor-ref&gt;\n *   ....\n * &lt;/action&gt;\n *\n * &lt;!--\n *    This example will inject any cookies regardless of its value into\n *    Struts' action.\n *  --&gt;\n * &lt;action ... &gt;\n *   &lt;interceptor-ref name=\"cookie\"&gt;\n *      &lt;param name=\"cookiesName\"&gt;*&lt;/param&gt;\n *      &lt;param name=\"cookiesValue\"&gt;*&lt;/param&gt;\n *   &lt;/interceptor-ref&gt;\n *    ...\n * &lt;/action&gt;\n *\n * <!-- END SNIPPET: example -->\n * </pre>\n *\n * @see CookiesAware\n */\npublic class CookieInterceptor extends AbstractInterceptor {\n\n    private static final long serialVersionUID = 4153142432948747305L;\n\n    private static final Logger LOG = LoggerFactory.getLogger(CookieInterceptor.class);\n\n    private static final String ACCEPTED_PATTERN = \"[a-zA-Z0-9\\\\.\\\\]\\\\[_'\\\\s]+\";\n\n    private Set<String> cookiesNameSet = Collections.emptySet();\n    private Set<String> cookiesValueSet = Collections.emptySet();\n\n    // Allowed names of cookies\n    private Pattern acceptedPattern = Pattern.compile(ACCEPTED_PATTERN, Pattern.CASE_INSENSITIVE);\n    private Pattern excludedPattern = Pattern.compile(ExcludedPatterns.CLASS_ACCESS_PATTERN, Pattern.CASE_INSENSITIVE);\n\n    /**\n     * Set the <code>cookiesName</code> which if matched will allow the cookie\n     * to be injected into action, could be comma-separated string.\n     *\n     * @param cookiesName\n     */\n    public void setCookiesName(String cookiesName) {\n        if (cookiesName != null)\n            this.cookiesNameSet = TextParseUtil.commaDelimitedStringToSet(cookiesName);\n    }\n\n    /**\n     * Set the <code>cookiesValue</code> which if matched (together with matching\n     * cookiesName) will caused the cookie to be injected into action, could be\n     * comma-separated string.\n     *\n     * @param cookiesValue\n     */\n    public void setCookiesValue(String cookiesValue) {\n        if (cookiesValue != null)\n            this.cookiesValueSet = TextParseUtil.commaDelimitedStringToSet(cookiesValue);\n    }\n\n    /**\n     * Set the <code>acceptCookieNames</code> pattern of allowed names of cookies to protect against remote command execution vulnerability\n     *\n     * @param pattern used to check cookie name against\n     */\n    public void setAcceptCookieNames(String pattern) {\n        acceptedPattern = Pattern.compile(pattern);\n    }\n\n    public String intercept(ActionInvocation invocation) throws Exception {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"start interception\");\n        }\n\n        // contains selected cookies\n        final Map<String, String> cookiesMap = new LinkedHashMap<String, String>();\n\n        Cookie[] cookies = ServletActionContext.getRequest().getCookies();\n        if (cookies != null) {\n            final ValueStack stack = ActionContext.getContext().getValueStack();\n\n            for (Cookie cookie : cookies) {\n                String name = cookie.getName();\n                String value = cookie.getValue();\n\n                if (isAcceptableName(name) && isAcceptableValue(value)) {\n                    if (cookiesNameSet.contains(\"*\")) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"contains cookie name [*] in configured cookies name set, cookie with name [\" + name + \"] with value [\" + value + \"] will be injected\");\n                        }\n                        populateCookieValueIntoStack(name, value, cookiesMap, stack);\n                    } else if (cookiesNameSet.contains(cookie.getName())) {\n                        populateCookieValueIntoStack(name, value, cookiesMap, stack);\n                    }\n                } else {\n                    LOG.warn(\"Cookie name [#0] with value [#1] was rejected!\", name, value);\n                }\n            }\n        }\n\n        // inject the cookiesMap, even if we don't have any cookies\n        injectIntoCookiesAwareAction(invocation.getAction(), cookiesMap);\n\n        return invocation.invoke();\n    }\n\n    /**\n     * Checks if value of Cookie doesn't contain vulnerable code\n     *\n     * @param value of Cookie\n     * @return true|false\n     */\n    protected boolean isAcceptableValue(String value) {\n        boolean matches = !excludedPattern.matcher(value).matches();\n        if (!matches) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Cookie value [#0] matches excludedPattern [#1]\", value, ExcludedPatterns.CLASS_ACCESS_PATTERN);\n            }\n        }\n        return matches;\n    }\n\n    /**\n     * Checks if name of Cookie doesn't contain vulnerable code\n     *\n     * @param name of Cookie\n     * @return true|false\n     */\n    protected boolean isAcceptableName(String name) {\n        return !isExcluded(name) && isAccepted(name);\n    }\n\n    /**\n     * Checks if name of Cookie match {@link #acceptedPattern}\n     *\n     * @param name of Cookie\n     * @return true|false\n     */\n    protected boolean isAccepted(String name) {\n        boolean matches = acceptedPattern.matcher(name).matches();\n        if (matches) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Cookie [#0] matches acceptedPattern [#1]\", name, ACCEPTED_PATTERN);\n            }\n        } else {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Cookie [#0] doesn't match acceptedPattern [#1]\", name, ACCEPTED_PATTERN);\n            }\n        }\n        return matches;\n    }\n\n    /**\n     * Checks if name of Cookie match {@link #excludedPattern}\n     *\n     * @param name of Cookie\n     * @return true|false\n     */\n    protected boolean isExcluded(String name) {\n        boolean matches = excludedPattern.matcher(name).matches();\n        if (matches) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Cookie [#0] matches excludedPattern [#1]\", name, ExcludedPatterns.CLASS_ACCESS_PATTERN);\n            }\n        } else {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Cookie [#0] doesn't match excludedPattern [#1]\", name, ExcludedPatterns.CLASS_ACCESS_PATTERN);\n            }\n        }\n        return matches;\n    }\n\n    /**\n     * Hook that populate cookie value into value stack (hence the action)\n     * if the criteria is satisfied (if the cookie value matches with those configured).\n     *\n     * @param cookieName\n     * @param cookieValue\n     * @param cookiesMap\n     * @param stack\n     */\n    protected void populateCookieValueIntoStack(String cookieName, String cookieValue, Map<String, String> cookiesMap, ValueStack stack) {\n        if (cookiesValueSet.isEmpty() || cookiesValueSet.contains(\"*\")) {\n            // If the interceptor is configured to accept any cookie value\n            // OR\n            // no cookiesValue is defined, so as long as the cookie name match\n            // we'll inject it into Struts' action\n            if (LOG.isDebugEnabled()) {\n                if (cookiesValueSet.isEmpty())\n                    LOG.debug(\"no cookie value is configured, cookie with name [\"+cookieName+\"] with value [\"+cookieValue+\"] will be injected\");\n                else if (cookiesValueSet.contains(\"*\"))\n                    LOG.debug(\"interceptor is configured to accept any value, cookie with name [\"+cookieName+\"] with value [\"+cookieValue+\"] will be injected\");\n            }\n            cookiesMap.put(cookieName, cookieValue);\n            stack.setValue(cookieName, cookieValue);\n        }\n        else {\n            // if cookiesValues is specified, the cookie's value must match before we\n            // inject them into Struts' action\n            if (cookiesValueSet.contains(cookieValue)) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"both configured cookie name and value matched, cookie [\"+cookieName+\"] with value [\"+cookieValue+\"] will be injected\");\n                }\n\n                cookiesMap.put(cookieName, cookieValue);\n                stack.setValue(cookieName, cookieValue);\n            }\n        }\n    }\n\n    /**\n     * Hook that set the <code>cookiesMap</code> into action that implements\n     * {@link CookiesAware}.\n     *\n     * @param action\n     * @param cookiesMap\n     */\n    protected void injectIntoCookiesAwareAction(Object action, Map<String, String> cookiesMap) {\n        if (action instanceof CookiesAware) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"action [\"+action+\"] implements CookiesAware, injecting cookies map [\"+cookiesMap+\"]\");\n            }\n            ((CookiesAware)action).setCookiesMap(cookiesMap);\n        }\n    }\n}\n",
        "human_patch_code": "/*\n * $Id$\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.struts2.interceptor;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.interceptor.AbstractInterceptor;\nimport com.opensymphony.xwork2.ExcludedPatterns;\nimport com.opensymphony.xwork2.util.TextParseUtil;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport com.opensymphony.xwork2.util.logging.Logger;\nimport com.opensymphony.xwork2.util.logging.LoggerFactory;\nimport org.apache.struts2.ServletActionContext;\n\nimport javax.servlet.http.Cookie;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\n/**\n * <!-- START SNIPPET: description -->\n *\n * The aim of this intercepter is to set values in the stack/action based on cookie name/value\n * of interest. <p/>\n *\n * If an asterisk is present in cookiesName parameter, it will be assume that\n * all cookies name are to be injected into struts' action, even though\n * cookiesName is comma-separated by other values, e.g. (cookie1,*,cookie2). <p/>\n *\n * If cookiesName is left empty it will assume that no cookie will be injected\n * into Struts' action. <p/>\n *\n * If an asterisk is present in cookiesValue parameter, it will assume that all\n * cookies name irrespective of its value will be injected into Struts' action so\n * long as the cookie name matches those specified in cookiesName parameter.<p/>\n *\n * If cookiesValue is left empty it will assume that all cookie that match the cookieName\n * parameter will be injected into Struts' action.<p/>\n *\n * The action could implement {@link CookiesAware} in order to have a {@link Map}\n * of filtered cookies set into it. <p/>\n *\n * <!-- END SNIPPET: description -->\n *\n *\n * <!-- START SNIPPET: parameters -->\n *\n * <ul>\n *      <li>cookiesName (mandatory) - Name of cookies to be injected into the action. If more\n *                                                                 than one cookie name is desired it could be comma-separated.\n *                                                                 If all cookies name is desired, it could simply be *, an asterik.\n *                                                                 When many cookies name are comma-separated either of the cookie\n *                                                        that match the name in the comma-separated list will be qualified.</li>\n *     <li>cookiesValue (mandatory) - Value of cookies that if its name matches cookieName attribute\n *                                                         and its value matched this, will be injected into Struts'\n *                                                         action. If more than one cookie name is desired it could be\n *                                                         comma-separated. If left empty, it will assume any value would\n *                                                         be ok. If more than one value is specified (comma-separated)\n *                                                         it will assume a match if either value is matched.</li>\n *     <li>acceptCookieNames (optional) - Pattern used to check if name of cookie matches the provided patter, to </li>\n * </ul>\n *\n * <!-- END SNIPPET: parameters -->\n *\n *\n * <!-- START SNIPPET: extending -->\n *\n * <ul>\n *     <li>\n *         populateCookieValueIntoStack - this method will decide if this cookie value is qualified\n *         to be populated into the value stack (hence into the action itself)\n *     </li>\n *     <li>\n *         injectIntoCookiesAwareAction - this method will inject selected cookies (as a java.util.Map)\n *         into action that implements {@link CookiesAware}.\n *     </li>\n * </ul>\n *\n * <!-- END SNIPPET: extending -->\n *\n * <pre>\n * <!-- START SNIPPET: example -->\n *\n * &lt;!--\n *   This example will inject cookies named either 'cookie1' or 'cookie2' whose\n *   value could be either 'cookie1value' or 'cookie2value' into Struts' action.\n * --&gt;\n * &lt;action ... &gt;\n *    &lt;interceptor-ref name=\"cookie\"&gt;\n *        &lt;param name=\"cookiesName\"&gt;cookie1, cookie2&lt;/param&gt;\n *        &lt;param name=\"cookiesValue\"&gt;cookie1value, cookie2value&lt;/param&gt;\n *    &lt;/interceptor-ref&gt;\n *    ....\n * &lt;/action&gt;\n *\n *\n * &lt;!--\n *      This example will inject cookies named either 'cookie1' or 'cookie2'\n *     regardless of their value into Struts' action.\n * --&gt;\n * &lt;action ... &gt;\n *   &lt;interceptor-ref name=\"cookie\"&gt;\n *      &lt;param name=\"cookiesName\"&gt;cookie1, cookie2&lt;/param&gt;\n *      &lt;param name=\"cookiesValue\"&gt;*&lt;/param&gt;\n *   &lt;interceptor-ref&gt;\n *   ...\n * &lt;/action&gt;\n *\n *\n * &lt;!--\n *      This example will inject cookies named either 'cookie1' with value\n *      'cookie1value' or 'cookie2' with value 'cookie2value' into Struts'\n *      action.\n * --&gt;\n * &lt;action ... &gt;\n *   &lt;interceptor-ref name=\"cookie\"&gt;\n *      &lt;param name=\"cookiesName\"&gt;cookie1&lt;/param&gt;\n *      &lt;param name=\"cookiesValue\"&gt;cookie1value&lt;/param&gt;\n *   &lt;/interceptor-ref&gt;\n *   &lt;interceptor-ref name=\"cookie\"&gt;\n *      &lt;param name=\"cookiesName\"&lt;cookie2&lt;/param&gt;\n *     &lt;param name=\"cookiesValue\"&gt;cookie2value&lt;/param&gt;\n *   &lt;/interceptor-ref&gt;\n *   ....\n * &lt;/action&gt;\n *\n * &lt;!--\n *    This example will inject any cookies regardless of its value into\n *    Struts' action.\n *  --&gt;\n * &lt;action ... &gt;\n *   &lt;interceptor-ref name=\"cookie\"&gt;\n *      &lt;param name=\"cookiesName\"&gt;*&lt;/param&gt;\n *      &lt;param name=\"cookiesValue\"&gt;*&lt;/param&gt;\n *   &lt;/interceptor-ref&gt;\n *    ...\n * &lt;/action&gt;\n *\n * <!-- END SNIPPET: example -->\n * </pre>\n *\n * @see CookiesAware\n */\npublic class CookieInterceptor extends AbstractInterceptor {\n\n    private static final long serialVersionUID = 4153142432948747305L;\n\n    private static final Logger LOG = LoggerFactory.getLogger(CookieInterceptor.class);\n\n    private static final String ACCEPTED_PATTERN = \"[a-zA-Z0-9\\\\.\\\\]\\\\[_'\\\\s]+\";\n\n    private Set<String> cookiesNameSet = Collections.emptySet();\n    private Set<String> cookiesValueSet = Collections.emptySet();\n\n    // Allowed names of cookies\n    private Pattern acceptedPattern = Pattern.compile(ACCEPTED_PATTERN, Pattern.CASE_INSENSITIVE);\n    private Set<Pattern> excludedPatterns = new HashSet<Pattern>();\n\n    public CookieInterceptor() {\n        for (String pattern : ExcludedPatterns.EXCLUDED_PATTERNS) {\n            excludedPatterns.add(Pattern.compile(pattern, Pattern.CASE_INSENSITIVE));\n        }\n    }\n\n    /**\n     * Set the <code>cookiesName</code> which if matched will allow the cookie\n     * to be injected into action, could be comma-separated string.\n     *\n     * @param cookiesName\n     */\n    public void setCookiesName(String cookiesName) {\n        if (cookiesName != null)\n            this.cookiesNameSet = TextParseUtil.commaDelimitedStringToSet(cookiesName);\n    }\n\n    /**\n     * Set the <code>cookiesValue</code> which if matched (together with matching\n     * cookiesName) will caused the cookie to be injected into action, could be\n     * comma-separated string.\n     *\n     * @param cookiesValue\n     */\n    public void setCookiesValue(String cookiesValue) {\n        if (cookiesValue != null)\n            this.cookiesValueSet = TextParseUtil.commaDelimitedStringToSet(cookiesValue);\n    }\n\n    /**\n     * Set the <code>acceptCookieNames</code> pattern of allowed names of cookies to protect against remote command execution vulnerability\n     *\n     * @param pattern used to check cookie name against\n     */\n    public void setAcceptCookieNames(String pattern) {\n        acceptedPattern = Pattern.compile(pattern);\n    }\n\n    public String intercept(ActionInvocation invocation) throws Exception {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"start interception\");\n        }\n\n        // contains selected cookies\n        final Map<String, String> cookiesMap = new LinkedHashMap<String, String>();\n\n        Cookie[] cookies = ServletActionContext.getRequest().getCookies();\n        if (cookies != null) {\n            final ValueStack stack = ActionContext.getContext().getValueStack();\n\n            for (Cookie cookie : cookies) {\n                String name = cookie.getName();\n                String value = cookie.getValue();\n\n                if (isAcceptableName(name) && isAcceptableValue(value)) {\n                    if (cookiesNameSet.contains(\"*\")) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"contains cookie name [*] in configured cookies name set, cookie with name [\" + name + \"] with value [\" + value + \"] will be injected\");\n                        }\n                        populateCookieValueIntoStack(name, value, cookiesMap, stack);\n                    } else if (cookiesNameSet.contains(cookie.getName())) {\n                        populateCookieValueIntoStack(name, value, cookiesMap, stack);\n                    }\n                } else {\n                    LOG.warn(\"Cookie name [#0] with value [#1] was rejected!\", name, value);\n                }\n            }\n        }\n\n        // inject the cookiesMap, even if we don't have any cookies\n        injectIntoCookiesAwareAction(invocation.getAction(), cookiesMap);\n\n        return invocation.invoke();\n    }\n\n    /**\n     * Checks if value of Cookie doesn't contain vulnerable code\n     *\n     * @param value of Cookie\n     * @return true|false\n     */\n    protected boolean isAcceptableValue(String value) {\n        for (Pattern excludedPattern : excludedPatterns) {\n            boolean matches = !excludedPattern.matcher(value).matches();\n            if (!matches) {\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Cookie value [#0] matches excludedPattern [#1]\", value, excludedPattern.toString());\n                }\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Checks if name of Cookie doesn't contain vulnerable code\n     *\n     * @param name of Cookie\n     * @return true|false\n     */\n    protected boolean isAcceptableName(String name) {\n        return !isExcluded(name) && isAccepted(name);\n    }\n\n    /**\n     * Checks if name of Cookie match {@link #acceptedPattern}\n     *\n     * @param name of Cookie\n     * @return true|false\n     */\n    protected boolean isAccepted(String name) {\n        boolean matches = acceptedPattern.matcher(name).matches();\n        if (matches) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Cookie [#0] matches acceptedPattern [#1]\", name, ACCEPTED_PATTERN);\n            }\n        } else {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Cookie [#0] doesn't match acceptedPattern [#1]\", name, ACCEPTED_PATTERN);\n            }\n        }\n        return matches;\n    }\n\n    /**\n     * Checks if name of Cookie match {@link #excludedPatterns}\n     *\n     * @param name of Cookie\n     * @return true|false\n     */\n    protected boolean isExcluded(String name) {\n        for (Pattern excludedPattern : excludedPatterns) {\n            boolean matches = excludedPattern.matcher(name).matches();\n            if (matches) {\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Cookie [#0] matches excludedPattern [#1]\", name, excludedPattern.toString());\n                }\n                return true;\n            } else {\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Cookie [#0] doesn't match excludedPattern [#1]\", name, excludedPattern.toString());\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Hook that populate cookie value into value stack (hence the action)\n     * if the criteria is satisfied (if the cookie value matches with those configured).\n     *\n     * @param cookieName\n     * @param cookieValue\n     * @param cookiesMap\n     * @param stack\n     */\n    protected void populateCookieValueIntoStack(String cookieName, String cookieValue, Map<String, String> cookiesMap, ValueStack stack) {\n        if (cookiesValueSet.isEmpty() || cookiesValueSet.contains(\"*\")) {\n            // If the interceptor is configured to accept any cookie value\n            // OR\n            // no cookiesValue is defined, so as long as the cookie name match\n            // we'll inject it into Struts' action\n            if (LOG.isDebugEnabled()) {\n                if (cookiesValueSet.isEmpty())\n                    LOG.debug(\"no cookie value is configured, cookie with name [\"+cookieName+\"] with value [\"+cookieValue+\"] will be injected\");\n                else if (cookiesValueSet.contains(\"*\"))\n                    LOG.debug(\"interceptor is configured to accept any value, cookie with name [\"+cookieName+\"] with value [\"+cookieValue+\"] will be injected\");\n            }\n            cookiesMap.put(cookieName, cookieValue);\n            stack.setValue(cookieName, cookieValue);\n        }\n        else {\n            // if cookiesValues is specified, the cookie's value must match before we\n            // inject them into Struts' action\n            if (cookiesValueSet.contains(cookieValue)) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"both configured cookie name and value matched, cookie [\"+cookieName+\"] with value [\"+cookieValue+\"] will be injected\");\n                }\n\n                cookiesMap.put(cookieName, cookieValue);\n                stack.setValue(cookieName, cookieValue);\n            }\n        }\n    }\n\n    /**\n     * Hook that set the <code>cookiesMap</code> into action that implements\n     * {@link CookiesAware}.\n     *\n     * @param action\n     * @param cookiesMap\n     */\n    protected void injectIntoCookiesAwareAction(Object action, Map<String, String> cookiesMap) {\n        if (action instanceof CookiesAware) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"action [\"+action+\"] implements CookiesAware, injecting cookies map [\"+cookiesMap+\"]\");\n            }\n            ((CookiesAware)action).setCookiesMap(cookiesMap);\n        }\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-30": {
    "vul_id": "VUL4J-30",
    "cve_id": "CVE-2016-8738",
    "project": "apache_struts",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests -DskipAssembly clean install",
    "test_cmd": "mvn test -pl core -Dtest=com.opensymphony.xwork2.validator.URLValidatorTest",
    "test_all_cmd": "mvn test -pl core",
    "human_patch_url": "https://github.com/apache/struts/commit/554b9dddb0fbd1e581ef577dd62a7c22955ad0f6",
    "vulnerable_files": [
      {
        "file_path": "core/src/main/java/com/opensymphony/xwork2/validator/validators/URLValidator.java",
        "file_name": "URLValidator.java",
        "vulnerable_code": "/*\n * Copyright 2002-2006,2009 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.validator.validators;\n\nimport com.opensymphony.xwork2.validator.ValidationException;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.regex.Pattern;\n\n/**\n * URLValidator checks that a given field is a String and a valid URL\n *\n * <pre>\n * &lt;validators&gt;\n *      &lt;!-- Plain Validator Syntax --&gt;\n *      &lt;validator type=\"url\"&gt;\n *          &lt;param name=\"fieldName\"&gt;myHomePage&lt;/param&gt;\n *          &lt;message&gt;Invalid homepage url&lt;/message&gt;\n *      &lt;/validator&gt;\n *\n *      &lt;!-- Field Validator Syntax --&gt;\n *      &lt;field name=\"myHomepage\"&gt;\n *          &lt;field-validator type=\"url\"&gt;\n *              &lt;message&gt;Invalid homepage url&lt;/message&gt;\n *          &lt;/field-validator&gt;\n *      &lt;/field&gt;\n * &lt;/validators&gt;\n * </pre>\n */\npublic class URLValidator extends FieldValidatorSupport {\n\n    private String urlRegex;\n    private String urlRegexExpression;\n\n    public void validate(Object object) throws ValidationException {\n        String fieldName = getFieldName();\n        Object value = this.getFieldValue(fieldName, object);\n\n        // if there is no value - don't do comparison\n        // if a value is required, a required validator should be added to the field\n        if (value == null || value.toString().length() == 0) {\n            return;\n        }\n\n        if (!(value.getClass().equals(String.class)) || !Pattern.compile(getUrlRegex(), Pattern.CASE_INSENSITIVE).matcher(String.valueOf(value)).matches()) {\n            addFieldError(fieldName, object);\n        }\n    }\n\n    /**\n     * This is used to support client-side validation, it's based on\n     * http://stackoverflow.com/questions/161738/what-is-the-best-regular-expression-to-check-if-a-string-is-a-valid-url\n     *\n     * @return regex to validate URLs\n     */\n    public String getUrlRegex() {\n        if (StringUtils.isNotEmpty(urlRegexExpression)) {\n            return (String) parse(urlRegexExpression, String.class);\n        } else if (StringUtils.isNotEmpty(urlRegex)) {\n            return urlRegex;\n        } else {\n            return \"^(https?|ftp):\\\\/\\\\/\" +\n                    \"(([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+\" +\n                    \"(:([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+)?\" +\n                    \"@)?(#?\" +\n                    \")((([a-z0-9]\\\\.|[a-z0-9][a-z0-9-]*[a-z0-9]\\\\.)*\" +\n                    \"[a-z][a-z0-9-]*[a-z0-9]\" +\n                    \"|((\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\\\\.){3}\" +\n                    \"(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\" +\n                    \")(:\\\\d+)?\" +\n                    \")(((\\\\/{0,1}([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)*\" +\n                    \"(\\\\?([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)\" +\n                    \"?)?)?\" +\n                    \"(#([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)?\" +\n                    \"$\";\n        }\n    }\n\n    public void setUrlRegex(String urlRegex) {\n        this.urlRegex = urlRegex;\n    }\n\n    public void setUrlRegexExpression(String urlRegexExpression) {\n        this.urlRegexExpression = urlRegexExpression;\n    }\n\n}\n",
        "human_patch_code": "/*\n * Copyright 2002-2006,2009 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.validator.validators;\n\nimport com.opensymphony.xwork2.validator.ValidationException;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.regex.Pattern;\n\n/**\n * URLValidator checks that a given field is a String and a valid URL\n *\n * <pre>\n * &lt;validators&gt;\n *      &lt;!-- Plain Validator Syntax --&gt;\n *      &lt;validator type=\"url\"&gt;\n *          &lt;param name=\"fieldName\"&gt;myHomePage&lt;/param&gt;\n *          &lt;message&gt;Invalid homepage url&lt;/message&gt;\n *      &lt;/validator&gt;\n *\n *      &lt;!-- Field Validator Syntax --&gt;\n *      &lt;field name=\"myHomepage\"&gt;\n *          &lt;field-validator type=\"url\"&gt;\n *              &lt;message&gt;Invalid homepage url&lt;/message&gt;\n *          &lt;/field-validator&gt;\n *      &lt;/field&gt;\n * &lt;/validators&gt;\n * </pre>\n */\npublic class URLValidator extends FieldValidatorSupport {\n\n    private String urlRegex;\n    private String urlRegexExpression;\n\n    public void validate(Object object) throws ValidationException {\n        String fieldName = getFieldName();\n        Object value = this.getFieldValue(fieldName, object);\n\n        // if there is no value - don't do comparison\n        // if a value is required, a required validator should be added to the field\n        if (value == null || value.toString().length() == 0) {\n            return;\n        }\n\n        if (!(value.getClass().equals(String.class)) || !Pattern.compile(getUrlRegex(), Pattern.CASE_INSENSITIVE).matcher(String.valueOf(value).trim()).matches()) {\n            addFieldError(fieldName, object);\n        }\n    }\n\n    /**\n     * This is used to support client-side validation, it's based on\n     * http://stackoverflow.com/questions/161738/what-is-the-best-regular-expression-to-check-if-a-string-is-a-valid-url\n     *\n     * @return regex to validate URLs\n     */\n    public String getUrlRegex() {\n        if (StringUtils.isNotEmpty(urlRegexExpression)) {\n            return (String) parse(urlRegexExpression, String.class);\n        } else if (StringUtils.isNotEmpty(urlRegex)) {\n            return urlRegex;\n        } else {\n            return \"^(https?|ftp):\\\\/\\\\/\" +\n                    \"(([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+\" +\n                    \"(:([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+)?\" +\n                    \"@)?(#?\" +\n                    \")((([a-z0-9]\\\\.|[a-z0-9][a-z0-9-]*[a-z0-9]\\\\.)*\" +\n                    \"[a-z][a-z0-9-]*[a-z0-9]\" +\n                    \"|((\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\\\\.){3}\" +\n                    \"(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\" +\n                    \")(:\\\\d+)?\" +\n                    \")(((\\\\/{0,1}([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)*\" +\n                    \"(\\\\?([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)\" +\n                    \"?)?)?\" +\n                    \"(#([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)?\" +\n                    \"$\";\n        }\n    }\n\n    public void setUrlRegex(String urlRegex) {\n        this.urlRegex = urlRegex;\n    }\n\n    public void setUrlRegexExpression(String urlRegexExpression) {\n        this.urlRegexExpression = urlRegexExpression;\n    }\n\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-32": {
    "vul_id": "VUL4J-32",
    "cve_id": "CVE-2015-1831",
    "project": "apache_struts",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests -DskipAssembly clean install",
    "test_cmd": "mvn test -pl xwork-core -Dtest=com.opensymphony.xwork2.security.DefaultExcludedPatternsCheckerTest test",
    "test_all_cmd": "mvn test -pl xwork-core",
    "human_patch_url": "https://github.com/apache/struts/commit/d832747d647df343ed07a58b1b5e540a05a4d51b",
    "vulnerable_files": [
      {
        "file_path": "xwork-core/src/main/java/com/opensymphony/xwork2/security/DefaultExcludedPatternsChecker.java",
        "file_name": "DefaultExcludedPatternsChecker.java",
        "vulnerable_code": "package com.opensymphony.xwork2.security;\n\nimport com.opensymphony.xwork2.*;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.util.TextParseUtil;\nimport com.opensymphony.xwork2.util.logging.Logger;\nimport com.opensymphony.xwork2.util.logging.LoggerFactory;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\npublic class DefaultExcludedPatternsChecker implements ExcludedPatternsChecker {\n\n    private static final Logger LOG = LoggerFactory.getLogger(DefaultExcludedPatternsChecker.class);\n\n    public static final String[] EXCLUDED_PATTERNS = {\n            \"(.*\\\\.|^|.*|\\\\[('|\\\"))\\\\bclass(\\\\.|('|\\\")]|\\\\[).*\",\n            \"(^|.*#)dojo(\\\\.|\\\\[).*\",\n            \"(^|.*#)struts(\\\\.|\\\\[).*\",\n            \"(^|.*#)session(\\\\.|\\\\[).*\",\n            \"(^|.*#)request(\\\\.|\\\\[).*\",\n            \"(^|.*#)application(\\\\.|\\\\[).*\",\n            \"(^|.*#)servlet(Request|Response)(\\\\.|\\\\[).*\",\n            \"(^|.*#)parameters(\\\\.|\\\\[).*\",\n            \"(^|.*#)context(\\\\.|\\\\[).*\",\n            \"(^|.*#)_memberAccess(\\\\.|\\\\[).*\"\n    };\n\n    private Set<Pattern> excludedPatterns;\n\n    public DefaultExcludedPatternsChecker() {\n        setExcludedPatterns(EXCLUDED_PATTERNS);\n    }\n\n    @Inject(value = XWorkConstants.OVERRIDE_EXCLUDED_PATTERNS, required = false)\n    public void setOverrideExcludePatterns(String excludePatterns) {\n        if (LOG.isWarnEnabled()) {\n            LOG.warn(\"Overriding excluded patterns [#0] with [#1], be aware that this affects all instances and safety of your application!\",\n                    XWorkConstants.OVERRIDE_EXCLUDED_PATTERNS, excludePatterns);\n        }\n        excludedPatterns = new HashSet<Pattern>();\n        for (String pattern : TextParseUtil.commaDelimitedStringToSet(excludePatterns)) {\n            excludedPatterns.add(Pattern.compile(pattern, Pattern.CASE_INSENSITIVE));\n        }\n    }\n\n    @Inject(value = XWorkConstants.ADDITIONAL_EXCLUDED_PATTERNS, required = false)\n    public void setAdditionalExcludePatterns(String excludePatterns) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Adding additional global patterns [#0] to excluded patterns!\", excludePatterns);\n        }\n        for (String pattern : TextParseUtil.commaDelimitedStringToSet(excludePatterns)) {\n            excludedPatterns.add(Pattern.compile(pattern, Pattern.CASE_INSENSITIVE));\n        }\n    }\n\n    public void setExcludedPatterns(String commaDelimitedPatterns) {\n        setExcludedPatterns(TextParseUtil.commaDelimitedStringToSet(commaDelimitedPatterns));\n    }\n\n    public void setExcludedPatterns(String[] patterns) {\n        setExcludedPatterns(new HashSet<String>(Arrays.asList(patterns)));\n    }\n\n    public void setExcludedPatterns(Set<String> patterns) {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Sets excluded patterns [#0]\", patterns);\n        }\n        excludedPatterns = new HashSet<Pattern>(patterns.size());\n        for (String pattern : patterns) {\n            excludedPatterns.add(Pattern.compile(pattern, Pattern.CASE_INSENSITIVE));\n        }\n    }\n\n    public IsExcluded isExcluded(String value) {\n        for (Pattern excludedPattern : excludedPatterns) {\n            if (excludedPattern.matcher(value).matches()) {\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"[#0] matches excluded pattern [#1]\", value, excludedPattern);\n                }\n                return IsExcluded.yes(excludedPattern);\n            }\n        }\n        return IsExcluded.no(excludedPatterns);\n    }\n\n    public Set<Pattern> getExcludedPatterns() {\n        return excludedPatterns;\n    }\n\n}\n",
        "human_patch_code": "package com.opensymphony.xwork2.security;\n\nimport com.opensymphony.xwork2.*;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.util.TextParseUtil;\nimport com.opensymphony.xwork2.util.logging.Logger;\nimport com.opensymphony.xwork2.util.logging.LoggerFactory;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\npublic class DefaultExcludedPatternsChecker implements ExcludedPatternsChecker {\n\n    private static final Logger LOG = LoggerFactory.getLogger(DefaultExcludedPatternsChecker.class);\n\n    public static final String[] EXCLUDED_PATTERNS = {\n        \"(^|.*#)(dojo|struts|session|request|application|servlet(Request|Response)|parameters|context|_memberAccess)(\\\\.|\\\\[).*\",\n        \"^(action|method):.*\"\n    };\n\n    private Set<Pattern> excludedPatterns;\n\n    public DefaultExcludedPatternsChecker() {\n        setExcludedPatterns(EXCLUDED_PATTERNS);\n    }\n\n    @Inject(value = XWorkConstants.OVERRIDE_EXCLUDED_PATTERNS, required = false)\n    public void setOverrideExcludePatterns(String excludePatterns) {\n        if (LOG.isWarnEnabled()) {\n            LOG.warn(\"Overriding excluded patterns [#0] with [#1], be aware that this affects all instances and safety of your application!\",\n                    XWorkConstants.OVERRIDE_EXCLUDED_PATTERNS, excludePatterns);\n        }\n        excludedPatterns = new HashSet<Pattern>();\n        for (String pattern : TextParseUtil.commaDelimitedStringToSet(excludePatterns)) {\n            excludedPatterns.add(Pattern.compile(pattern, Pattern.CASE_INSENSITIVE));\n        }\n    }\n\n    @Inject(value = XWorkConstants.ADDITIONAL_EXCLUDED_PATTERNS, required = false)\n    public void setAdditionalExcludePatterns(String excludePatterns) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Adding additional global patterns [#0] to excluded patterns!\", excludePatterns);\n        }\n        for (String pattern : TextParseUtil.commaDelimitedStringToSet(excludePatterns)) {\n            excludedPatterns.add(Pattern.compile(pattern, Pattern.CASE_INSENSITIVE));\n        }\n    }\n\n    public void setExcludedPatterns(String commaDelimitedPatterns) {\n        setExcludedPatterns(TextParseUtil.commaDelimitedStringToSet(commaDelimitedPatterns));\n    }\n\n    public void setExcludedPatterns(String[] patterns) {\n        setExcludedPatterns(new HashSet<String>(Arrays.asList(patterns)));\n    }\n\n    public void setExcludedPatterns(Set<String> patterns) {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Sets excluded patterns [#0]\", patterns);\n        }\n        excludedPatterns = new HashSet<Pattern>(patterns.size());\n        for (String pattern : patterns) {\n            excludedPatterns.add(Pattern.compile(pattern, Pattern.CASE_INSENSITIVE));\n        }\n    }\n\n    public IsExcluded isExcluded(String value) {\n        for (Pattern excludedPattern : excludedPatterns) {\n            if (excludedPattern.matcher(value).matches()) {\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"[#0] matches excluded pattern [#1]\", value, excludedPattern);\n                }\n                return IsExcluded.yes(excludedPattern);\n            }\n        }\n        return IsExcluded.no(excludedPatterns);\n    }\n\n    public Set<Pattern> getExcludedPatterns() {\n        return excludedPatterns;\n    }\n\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-33": {
    "vul_id": "VUL4J-33",
    "cve_id": "CVE-2016-3081",
    "project": "apache_struts",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests -DskipAssembly clean install",
    "test_cmd": "mvn test -pl core -Dtest=com.opensymphony.xwork2.ognl.OgnlUtilTest",
    "test_all_cmd": "mvn test -pl core",
    "human_patch_url": "https://github.com/apache/struts/commit/f238cf4f1091be19fbcfd086b042c86a1bcaa7fc",
    "vulnerable_files": [
      {
        "file_path": "core/src/main/java/com/opensymphony/xwork2/ognl/OgnlUtil.java",
        "file_name": "OgnlUtil.java",
        "vulnerable_code": "/*\n * Copyright 2002-2006,2009 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.ognl;\n\nimport com.opensymphony.xwork2.XWorkConstants;\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.conversion.impl.XWorkConverter;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.ognl.accessor.CompoundRootAccessor;\nimport com.opensymphony.xwork2.util.CompoundRoot;\nimport com.opensymphony.xwork2.util.TextParseUtil;\nimport com.opensymphony.xwork2.util.reflection.ReflectionException;\nimport ognl.*;\nimport org.apache.commons.lang3.BooleanUtils;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.regex.Pattern;\n\n\n/**\n * Utility class that provides common access to the Ognl APIs for\n * setting and getting properties from objects (usually Actions).\n *\n * @author Jason Carreira\n */\npublic class OgnlUtil {\n\n    private static final Logger LOG = LogManager.getLogger(OgnlUtil.class);\n    private ConcurrentMap<String, Object> expressions = new ConcurrentHashMap<>();\n    private final ConcurrentMap<Class, BeanInfo> beanInfoCache = new ConcurrentHashMap<>();\n    private TypeConverter defaultConverter;\n\n    private boolean devMode = false;\n    private boolean enableExpressionCache = true;\n    private boolean enableEvalExpression;\n\n    private Set<Class<?>> excludedClasses = new HashSet<>();\n    private Set<Pattern> excludedPackageNamePatterns = new HashSet<>();\n    private Set<String> excludedPackageNames = new HashSet<>();\n\n    private Container container;\n    private boolean allowStaticMethodAccess;\n\n    @Inject\n    public void setXWorkConverter(XWorkConverter conv) {\n        this.defaultConverter = new OgnlTypeConverterWrapper(conv);\n    }\n\n    @Inject(XWorkConstants.DEV_MODE)\n    public void setDevMode(String mode) {\n        this.devMode = BooleanUtils.toBoolean(mode);\n    }\n\n    @Inject(XWorkConstants.ENABLE_OGNL_EXPRESSION_CACHE)\n    public void setEnableExpressionCache(String cache) {\n        enableExpressionCache = BooleanUtils.toBoolean(cache);\n    }\n\n    @Inject(value = XWorkConstants.ENABLE_OGNL_EVAL_EXPRESSION, required = false)\n    public void setEnableEvalExpression(String evalExpression) {\n        enableEvalExpression = \"true\".equals(evalExpression);\n        if(enableEvalExpression){\n            LOG.warn(\"Enabling OGNL expression evaluation may introduce security risks \" +\n                    \"(see http://struts.apache.org/release/2.3.x/docs/s2-013.html for further details)\");\n        }\n    }\n\n    @Inject(value = XWorkConstants.OGNL_EXCLUDED_CLASSES, required = false)\n    public void setExcludedClasses(String commaDelimitedClasses) {\n        Set<String> classes = TextParseUtil.commaDelimitedStringToSet(commaDelimitedClasses);\n        for (String className : classes) {\n            try {\n                excludedClasses.add(Class.forName(className));\n            } catch (ClassNotFoundException e) {\n                throw new ConfigurationException(\"Cannot load excluded class: \" + className, e);\n            }\n        }\n    }\n\n    @Inject(value = XWorkConstants.OGNL_EXCLUDED_PACKAGE_NAME_PATTERNS, required = false)\n    public void setExcludedPackageNamePatterns(String commaDelimitedPackagePatterns) {\n        Set<String> packagePatterns = TextParseUtil.commaDelimitedStringToSet(commaDelimitedPackagePatterns);\n        for (String pattern : packagePatterns) {\n            excludedPackageNamePatterns.add(Pattern.compile(pattern));\n        }\n    }\n\n    @Inject(value = XWorkConstants.OGNL_EXCLUDED_PACKAGE_NAMES, required = false)\n    public void setExcludedPackageNames(String commaDelimitedPackageNames) {\n        excludedPackageNames = TextParseUtil.commaDelimitedStringToSet(commaDelimitedPackageNames);\n    }\n\n    public Set<Class<?>> getExcludedClasses() {\n        return excludedClasses;\n    }\n\n    public Set<Pattern> getExcludedPackageNamePatterns() {\n        return excludedPackageNamePatterns;\n    }\n\n    public Set<String> getExcludedPackageNames() {\n        return excludedPackageNames;\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value = XWorkConstants.ALLOW_STATIC_METHOD_ACCESS, required = false)\n    public void setAllowStaticMethodAccess(String allowStaticMethodAccess) {\n        this.allowStaticMethodAccess = Boolean.parseBoolean(allowStaticMethodAccess);\n    }\n\n    /**\n     * Sets the object's properties using the default type converter, defaulting to not throw\n     * exceptions for problems setting the properties.\n     *\n     * @param props   the properties being set\n     * @param o       the object\n     * @param context the action context\n     */\n    public void setProperties(Map<String, ?> props, Object o, Map<String, Object> context) {\n        setProperties(props, o, context, false);\n    }\n\n    /**\n     * Sets the object's properties using the default type converter.\n     *\n     * @param props                   the properties being set\n     * @param o                       the object\n     * @param context                 the action context\n     * @param throwPropertyExceptions boolean which tells whether it should throw exceptions for\n     *                                problems setting the properties\n     */\n    public void setProperties(Map<String, ?> props, Object o, Map<String, Object> context, boolean throwPropertyExceptions) throws ReflectionException{\n        if (props == null) {\n            return;\n        }\n\n        Ognl.setTypeConverter(context, getTypeConverterFromContext(context));\n\n        Object oldRoot = Ognl.getRoot(context);\n        Ognl.setRoot(context, o);\n\n        for (Map.Entry<String, ?> entry : props.entrySet()) {\n            String expression = entry.getKey();\n            internalSetProperty(expression, entry.getValue(), o, context, throwPropertyExceptions);\n        }\n\n        Ognl.setRoot(context, oldRoot);\n    }\n\n    /**\n     * Sets the properties on the object using the default context, defaulting to not throwing\n     * exceptions for problems setting the properties.\n     *\n     * @param properties map of properties\n     * @param o object\n     */\n    public void setProperties(Map<String, ?> properties, Object o) {\n        setProperties(properties, o, false);\n    }\n\n    /**\n     * Sets the properties on the object using the default context.\n     *\n     * @param properties              the property map to set on the object\n     * @param o                       the object to set the properties into\n     * @param throwPropertyExceptions boolean which tells whether it should throw exceptions for\n     *                                problems setting the properties\n     */\n    public void setProperties(Map<String, ?> properties, Object o, boolean throwPropertyExceptions) {\n        Map context = createDefaultContext(o, null);\n        setProperties(properties, o, context, throwPropertyExceptions);\n    }\n\n    /**\n     * Sets the named property to the supplied value on the Object, defaults to not throwing\n     * property exceptions.\n     *\n     * @param name    the name of the property to be set\n     * @param value   the value to set into the named property\n     * @param o       the object upon which to set the property\n     * @param context the context which may include the TypeConverter\n     */\n    public void setProperty(String name, Object value, Object o, Map<String, Object> context) {\n        setProperty(name, value, o, context, false);\n    }\n\n    /**\n     * Sets the named property to the supplied value on the Object.\n     *\n     * @param name                    the name of the property to be set\n     * @param value                   the value to set into the named property\n     * @param o                       the object upon which to set the property\n     * @param context                 the context which may include the TypeConverter\n     * @param throwPropertyExceptions boolean which tells whether it should throw exceptions for\n     *                                problems setting the property\n     */\n    public void setProperty(String name, Object value, Object o, Map<String, Object> context, boolean throwPropertyExceptions) {\n        Ognl.setTypeConverter(context, getTypeConverterFromContext(context));\n\n        Object oldRoot = Ognl.getRoot(context);\n        Ognl.setRoot(context, o);\n\n        internalSetProperty(name, value, o, context, throwPropertyExceptions);\n\n        Ognl.setRoot(context, oldRoot);\n    }\n\n    /**\n     * Looks for the real target with the specified property given a root Object which may be a\n     * CompoundRoot.\n     *\n     * @param property  the property\n     * @param context context map\n     * @param root compound root\n     *\n     * @return the real target or null if no object can be found with the specified property\n     * @throws OgnlException in case of ognl errors\n     */\n    public Object getRealTarget(String property, Map<String, Object> context, Object root) throws OgnlException {\n        //special keyword, they must be cutting the stack\n        if (\"top\".equals(property)) {\n            return root;\n        }\n\n        if (root instanceof CompoundRoot) {\n            // find real target\n            CompoundRoot cr = (CompoundRoot) root;\n\n            try {\n                for (Object target : cr) {\n                    if (OgnlRuntime.hasSetProperty((OgnlContext) context, target, property)\n                            || OgnlRuntime.hasGetProperty((OgnlContext) context, target, property)\n                            || OgnlRuntime.getIndexedPropertyType((OgnlContext) context, target.getClass(), property) != OgnlRuntime.INDEXED_PROPERTY_NONE\n                            ) {\n                        return target;\n                    }\n                }\n            } catch (IntrospectionException ex) {\n                throw new ReflectionException(\"Cannot figure out real target class\", ex);\n            }\n\n            return null;\n        }\n\n        return root;\n    }\n\n    /**\n     * Wrapper around Ognl.setValue() to handle type conversion for collection elements.\n     * Ideally, this should be handled by OGNL directly.\n     *\n     * @param name  the name\n     * @param context context map\n     * @param root root\n     * @param value value\n     *\n     * @throws OgnlException in case of ognl errors\n     */\n    public void setValue(final String name, final Map<String, Object> context, final Object root, final Object value) throws OgnlException {\n        compileAndExecute(name, context, new OgnlTask<Void>() {\n            public Void execute(Object tree) throws OgnlException {\n                if (isEvalExpression(tree, context)) {\n                    throw new OgnlException(\"Eval expression cannot be used as parameter name\");\n                }\n                Ognl.setValue(tree, context, root, value);\n                return null;\n            }\n        });\n    }\n\n    private boolean isEvalExpression(Object tree, Map<String, Object> context) throws OgnlException {\n        if (tree instanceof SimpleNode) {\n            SimpleNode node = (SimpleNode) tree;\n            OgnlContext ognlContext = null;\n\n            if (context!=null && context instanceof OgnlContext) {\n                ognlContext = (OgnlContext) context;\n            }\n            return node.isEvalChain(ognlContext);\n        }\n        return false;\n    }\n\n    public Object getValue(final String name, final Map<String, Object> context, final Object root) throws OgnlException {\n        return compileAndExecute(name, context, new OgnlTask<Object>() {\n            public Object execute(Object tree) throws OgnlException {\n                return Ognl.getValue(tree, context, root);\n            }\n        });\n    }\n\n    public Object getValue(final String name, final Map<String, Object> context, final Object root, final Class resultType) throws OgnlException {\n        return compileAndExecute(name, context, new OgnlTask<Object>() {\n            public Object execute(Object tree) throws OgnlException {\n                return Ognl.getValue(tree, context, root, resultType);\n            }\n        });\n    }\n\n\n    public Object compile(String expression) throws OgnlException {\n        return compile(expression, null);\n    }\n\n    private <T> Object compileAndExecute(String expression, Map<String, Object> context, OgnlTask<T> task) throws OgnlException {\n        Object tree;\n        if (enableExpressionCache) {\n            tree = expressions.get(expression);\n            if (tree == null) {\n                tree = Ognl.parseExpression(expression);\n                checkEnableEvalExpression(tree, context);\n            }\n        } else {\n            tree = Ognl.parseExpression(expression);\n            checkEnableEvalExpression(tree, context);\n        }\n\n        final T exec = task.execute(tree);\n        // if cache is enabled and it's a valid expression, puts it in\n        if(enableExpressionCache) {\n            expressions.putIfAbsent(expression, tree);\n        }\n        return exec;\n    }\n\n    public Object compile(String expression, Map<String, Object> context) throws OgnlException {\n        return compileAndExecute(expression,context,new OgnlTask<Object>() {\n            public Object execute(Object tree) throws OgnlException {\n                return tree;\n            }\n        });\n    }\n    \n    private void checkEnableEvalExpression(Object tree, Map<String, Object> context) throws OgnlException {\n        if (!enableEvalExpression && isEvalExpression(tree, context)) {\n            throw new OgnlException(\"Eval expressions/chained expressions have been disabled!\");\n        }\n    }\n\n    /**\n     * Copies the properties in the object \"from\" and sets them in the object \"to\"\n     * using specified type converter, or {@link com.opensymphony.xwork2.conversion.impl.XWorkConverter} if none\n     * is specified.\n     *\n     * @param from       the source object\n     * @param to         the target object\n     * @param context    the action context we're running under\n     * @param exclusions collection of method names to excluded from copying ( can be null)\n     * @param inclusions collection of method names to included copying  (can be null)\n     *                   note if exclusions AND inclusions are supplied and not null nothing will get copied.\n     */\n    public void copy(final Object from, final Object to, final Map<String, Object> context, Collection<String> exclusions, Collection<String> inclusions) {\n        if (from == null || to == null) {\n            LOG.warn(\"Attempting to copy from or to a null source. This is illegal and is bein skipped. This may be due to an error in an OGNL expression, action chaining, or some other event.\");\n            return;\n        }\n\n        TypeConverter converter = getTypeConverterFromContext(context);\n        final Map contextFrom = createDefaultContext(from, null);\n        Ognl.setTypeConverter(contextFrom, converter);\n        final Map contextTo = createDefaultContext(to, null);\n        Ognl.setTypeConverter(contextTo, converter);\n\n        PropertyDescriptor[] fromPds;\n        PropertyDescriptor[] toPds;\n\n        try {\n            fromPds = getPropertyDescriptors(from);\n            toPds = getPropertyDescriptors(to);\n        } catch (IntrospectionException e) {\n            LOG.error(\"An error occurred\", e);\n            return;\n        }\n\n        Map<String, PropertyDescriptor> toPdHash = new HashMap<>();\n\n        for (PropertyDescriptor toPd : toPds) {\n            toPdHash.put(toPd.getName(), toPd);\n        }\n\n        for (PropertyDescriptor fromPd : fromPds) {\n            if (fromPd.getReadMethod() != null) {\n                boolean copy = true;\n                if (exclusions != null && exclusions.contains(fromPd.getName())) {\n                    copy = false;\n                } else if (inclusions != null && !inclusions.contains(fromPd.getName())) {\n                    copy = false;\n                }\n\n                if (copy) {\n                    PropertyDescriptor toPd = toPdHash.get(fromPd.getName());\n                    if ((toPd != null) && (toPd.getWriteMethod() != null)) {\n                        try {\n                            compileAndExecute(fromPd.getName(), context, new OgnlTask<Object>() {\n                                public Void execute(Object expr) throws OgnlException {\n                                    Object value = Ognl.getValue(expr, contextFrom, from);\n                                    Ognl.setValue(expr, contextTo, to, value);\n                                    return null;\n                                }\n                            });\n\n                        } catch (OgnlException e) {\n                            LOG.debug(\"Got OGNL exception\", e);\n                        }\n                    }\n\n                }\n\n            }\n\n        }\n    }\n\n\n    /**\n     * Copies the properties in the object \"from\" and sets them in the object \"to\"\n     * using specified type converter, or {@link com.opensymphony.xwork2.conversion.impl.XWorkConverter} if none\n     * is specified.\n     *\n     * @param from    the source object\n     * @param to      the target object\n     * @param context the action context we're running under\n     */\n    public void copy(Object from, Object to, Map<String, Object> context) {\n        copy(from, to, context, null, null);\n    }\n\n    /**\n     * Get's the java beans property descriptors for the given source.\n     *\n     * @param source the source object.\n     * @return property descriptors.\n     * @throws IntrospectionException is thrown if an exception occurs during introspection.\n     */\n    public PropertyDescriptor[] getPropertyDescriptors(Object source) throws IntrospectionException {\n        BeanInfo beanInfo = getBeanInfo(source);\n        return beanInfo.getPropertyDescriptors();\n    }\n\n\n    /**\n     * Get's the java beans property descriptors for the given class.\n     *\n     * @param clazz the source object.\n     * @return property descriptors.\n     * @throws IntrospectionException is thrown if an exception occurs during introspection.\n     */\n    public PropertyDescriptor[] getPropertyDescriptors(Class clazz) throws IntrospectionException {\n        BeanInfo beanInfo = getBeanInfo(clazz);\n        return beanInfo.getPropertyDescriptors();\n    }\n\n    /**\n     * Creates a Map with read properties for the given source object.\n     * <p>\n     * If the source object does not have a read property (i.e. write-only) then\n     * the property is added to the map with the value <code>here is no read method for property-name</code>.\n     * </p>\n     *\n     * @param source the source object.\n     * @return a Map with (key = read property name, value = value of read property).\n     * @throws IntrospectionException is thrown if an exception occurs during introspection.\n     * @throws OgnlException          is thrown by OGNL if the property value could not be retrieved\n     */\n    public Map<String, Object> getBeanMap(final Object source) throws IntrospectionException, OgnlException {\n        Map<String, Object> beanMap = new HashMap<>();\n        final Map sourceMap = createDefaultContext(source, null);\n        PropertyDescriptor[] propertyDescriptors = getPropertyDescriptors(source);\n        for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {\n            final String propertyName = propertyDescriptor.getDisplayName();\n            Method readMethod = propertyDescriptor.getReadMethod();\n            if (readMethod != null) {\n                final Object value = compileAndExecute(propertyName, null, new OgnlTask<Object>() {\n                    public Object execute(Object expr) throws OgnlException {\n                        return Ognl.getValue(expr, sourceMap, source);\n                    }\n                });\n                beanMap.put(propertyName, value);\n            } else {\n                beanMap.put(propertyName, \"There is no read method for \" + propertyName);\n            }\n        }\n        return beanMap;\n    }\n\n    /**\n     * Get's the java bean info for the given source object. Calls getBeanInfo(Class c).\n     *\n     * @param from the source object.\n     * @return java bean info.\n     * @throws IntrospectionException is thrown if an exception occurs during introspection.\n     */\n    public BeanInfo getBeanInfo(Object from) throws IntrospectionException {\n        return getBeanInfo(from.getClass());\n    }\n\n\n    /**\n     * Get's the java bean info for the given source.\n     *\n     * @param clazz the source class.\n     * @return java bean info.\n     * @throws IntrospectionException is thrown if an exception occurs during introspection.\n     */\n    public BeanInfo getBeanInfo(Class clazz) throws IntrospectionException {\n        synchronized (beanInfoCache) {\n            BeanInfo beanInfo;\n            beanInfo = beanInfoCache.get(clazz);\n            if (beanInfo == null) {\n                beanInfo = Introspector.getBeanInfo(clazz, Object.class);\n                beanInfoCache.putIfAbsent(clazz, beanInfo);\n            }\n            return beanInfo;\n        }\n    }\n\n    void internalSetProperty(String name, Object value, Object o, Map<String, Object> context, boolean throwPropertyExceptions) throws ReflectionException{\n        try {\n            setValue(name, context, o, value);\n        } catch (OgnlException e) {\n            Throwable reason = e.getReason();\n            String msg = \"Caught OgnlException while setting property '\" + name + \"' on type '\" + o.getClass().getName() + \"'.\";\n            Throwable exception = (reason == null) ? e : reason;\n\n            if (throwPropertyExceptions) {\n                throw new ReflectionException(msg, exception);\n            } else if (devMode) {\n                LOG.warn(msg, exception);\n            }\n        }\n    }\n\n    TypeConverter getTypeConverterFromContext(Map<String, Object> context) {\n        /*ValueStack stack = (ValueStack) context.get(ActionContext.VALUE_STACK);\n        Container cont = (Container)stack.getContext().get(ActionContext.CONTAINER);\n        if (cont != null) {\n            return new OgnlTypeConverterWrapper(cont.getInstance(XWorkConverter.class));\n        } else {\n            throw new IllegalArgumentException(\"Cannot find type converter in context map\");\n        }\n        */\n        return defaultConverter;\n    }\n\n    protected Map createDefaultContext(Object root) {\n        return createDefaultContext(root, null);\n    }\n\n    protected Map createDefaultContext(Object root, ClassResolver classResolver) {\n        ClassResolver resolver = classResolver;\n        if (resolver == null) {\n            resolver = container.getInstance(CompoundRootAccessor.class);\n        }\n\n        SecurityMemberAccess memberAccess = new SecurityMemberAccess(allowStaticMethodAccess);\n        memberAccess.setExcludedClasses(excludedClasses);\n        memberAccess.setExcludedPackageNamePatterns(excludedPackageNamePatterns);\n        memberAccess.setExcludedPackageNames(excludedPackageNames);\n\n        return Ognl.createDefaultContext(root, resolver, defaultConverter, memberAccess);\n    }\n\n    private interface OgnlTask<T> {\n        T execute(Object tree) throws OgnlException;\n    }\n\n}\n",
        "human_patch_code": "/*\n * Copyright 2002-2006,2009 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.ognl;\n\nimport com.opensymphony.xwork2.XWorkConstants;\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.conversion.impl.XWorkConverter;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.ognl.accessor.CompoundRootAccessor;\nimport com.opensymphony.xwork2.util.CompoundRoot;\nimport com.opensymphony.xwork2.util.TextParseUtil;\nimport com.opensymphony.xwork2.util.reflection.ReflectionException;\nimport ognl.*;\nimport org.apache.commons.lang3.BooleanUtils;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.regex.Pattern;\n\n\n/**\n * Utility class that provides common access to the Ognl APIs for\n * setting and getting properties from objects (usually Actions).\n *\n * @author Jason Carreira\n */\npublic class OgnlUtil {\n\n    private static final Logger LOG = LogManager.getLogger(OgnlUtil.class);\n    private ConcurrentMap<String, Object> expressions = new ConcurrentHashMap<>();\n    private final ConcurrentMap<Class, BeanInfo> beanInfoCache = new ConcurrentHashMap<>();\n    private TypeConverter defaultConverter;\n\n    private boolean devMode = false;\n    private boolean enableExpressionCache = true;\n    private boolean enableEvalExpression;\n\n    private Set<Class<?>> excludedClasses = new HashSet<>();\n    private Set<Pattern> excludedPackageNamePatterns = new HashSet<>();\n    private Set<String> excludedPackageNames = new HashSet<>();\n\n    private Container container;\n    private boolean allowStaticMethodAccess;\n\n    @Inject\n    public void setXWorkConverter(XWorkConverter conv) {\n        this.defaultConverter = new OgnlTypeConverterWrapper(conv);\n    }\n\n    @Inject(XWorkConstants.DEV_MODE)\n    public void setDevMode(String mode) {\n        this.devMode = BooleanUtils.toBoolean(mode);\n    }\n\n    @Inject(XWorkConstants.ENABLE_OGNL_EXPRESSION_CACHE)\n    public void setEnableExpressionCache(String cache) {\n        enableExpressionCache = BooleanUtils.toBoolean(cache);\n    }\n\n    @Inject(value = XWorkConstants.ENABLE_OGNL_EVAL_EXPRESSION, required = false)\n    public void setEnableEvalExpression(String evalExpression) {\n        enableEvalExpression = \"true\".equals(evalExpression);\n        if(enableEvalExpression){\n            LOG.warn(\"Enabling OGNL expression evaluation may introduce security risks \" +\n                    \"(see http://struts.apache.org/release/2.3.x/docs/s2-013.html for further details)\");\n        }\n    }\n\n    @Inject(value = XWorkConstants.OGNL_EXCLUDED_CLASSES, required = false)\n    public void setExcludedClasses(String commaDelimitedClasses) {\n        Set<String> classes = TextParseUtil.commaDelimitedStringToSet(commaDelimitedClasses);\n        for (String className : classes) {\n            try {\n                excludedClasses.add(Class.forName(className));\n            } catch (ClassNotFoundException e) {\n                throw new ConfigurationException(\"Cannot load excluded class: \" + className, e);\n            }\n        }\n    }\n\n    @Inject(value = XWorkConstants.OGNL_EXCLUDED_PACKAGE_NAME_PATTERNS, required = false)\n    public void setExcludedPackageNamePatterns(String commaDelimitedPackagePatterns) {\n        Set<String> packagePatterns = TextParseUtil.commaDelimitedStringToSet(commaDelimitedPackagePatterns);\n        for (String pattern : packagePatterns) {\n            excludedPackageNamePatterns.add(Pattern.compile(pattern));\n        }\n    }\n\n    @Inject(value = XWorkConstants.OGNL_EXCLUDED_PACKAGE_NAMES, required = false)\n    public void setExcludedPackageNames(String commaDelimitedPackageNames) {\n        excludedPackageNames = TextParseUtil.commaDelimitedStringToSet(commaDelimitedPackageNames);\n    }\n\n    public Set<Class<?>> getExcludedClasses() {\n        return excludedClasses;\n    }\n\n    public Set<Pattern> getExcludedPackageNamePatterns() {\n        return excludedPackageNamePatterns;\n    }\n\n    public Set<String> getExcludedPackageNames() {\n        return excludedPackageNames;\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value = XWorkConstants.ALLOW_STATIC_METHOD_ACCESS, required = false)\n    public void setAllowStaticMethodAccess(String allowStaticMethodAccess) {\n        this.allowStaticMethodAccess = Boolean.parseBoolean(allowStaticMethodAccess);\n    }\n\n    /**\n     * Sets the object's properties using the default type converter, defaulting to not throw\n     * exceptions for problems setting the properties.\n     *\n     * @param props   the properties being set\n     * @param o       the object\n     * @param context the action context\n     */\n    public void setProperties(Map<String, ?> props, Object o, Map<String, Object> context) {\n        setProperties(props, o, context, false);\n    }\n\n    /**\n     * Sets the object's properties using the default type converter.\n     *\n     * @param props                   the properties being set\n     * @param o                       the object\n     * @param context                 the action context\n     * @param throwPropertyExceptions boolean which tells whether it should throw exceptions for\n     *                                problems setting the properties\n     */\n    public void setProperties(Map<String, ?> props, Object o, Map<String, Object> context, boolean throwPropertyExceptions) throws ReflectionException{\n        if (props == null) {\n            return;\n        }\n\n        Ognl.setTypeConverter(context, getTypeConverterFromContext(context));\n\n        Object oldRoot = Ognl.getRoot(context);\n        Ognl.setRoot(context, o);\n\n        for (Map.Entry<String, ?> entry : props.entrySet()) {\n            String expression = entry.getKey();\n            internalSetProperty(expression, entry.getValue(), o, context, throwPropertyExceptions);\n        }\n\n        Ognl.setRoot(context, oldRoot);\n    }\n\n    /**\n     * Sets the properties on the object using the default context, defaulting to not throwing\n     * exceptions for problems setting the properties.\n     *\n     * @param properties map of properties\n     * @param o object\n     */\n    public void setProperties(Map<String, ?> properties, Object o) {\n        setProperties(properties, o, false);\n    }\n\n    /**\n     * Sets the properties on the object using the default context.\n     *\n     * @param properties              the property map to set on the object\n     * @param o                       the object to set the properties into\n     * @param throwPropertyExceptions boolean which tells whether it should throw exceptions for\n     *                                problems setting the properties\n     */\n    public void setProperties(Map<String, ?> properties, Object o, boolean throwPropertyExceptions) {\n        Map context = createDefaultContext(o, null);\n        setProperties(properties, o, context, throwPropertyExceptions);\n    }\n\n    /**\n     * Sets the named property to the supplied value on the Object, defaults to not throwing\n     * property exceptions.\n     *\n     * @param name    the name of the property to be set\n     * @param value   the value to set into the named property\n     * @param o       the object upon which to set the property\n     * @param context the context which may include the TypeConverter\n     */\n    public void setProperty(String name, Object value, Object o, Map<String, Object> context) {\n        setProperty(name, value, o, context, false);\n    }\n\n    /**\n     * Sets the named property to the supplied value on the Object.\n     *\n     * @param name                    the name of the property to be set\n     * @param value                   the value to set into the named property\n     * @param o                       the object upon which to set the property\n     * @param context                 the context which may include the TypeConverter\n     * @param throwPropertyExceptions boolean which tells whether it should throw exceptions for\n     *                                problems setting the property\n     */\n    public void setProperty(String name, Object value, Object o, Map<String, Object> context, boolean throwPropertyExceptions) {\n        Ognl.setTypeConverter(context, getTypeConverterFromContext(context));\n\n        Object oldRoot = Ognl.getRoot(context);\n        Ognl.setRoot(context, o);\n\n        internalSetProperty(name, value, o, context, throwPropertyExceptions);\n\n        Ognl.setRoot(context, oldRoot);\n    }\n\n    /**\n     * Looks for the real target with the specified property given a root Object which may be a\n     * CompoundRoot.\n     *\n     * @param property  the property\n     * @param context context map\n     * @param root compound root\n     *\n     * @return the real target or null if no object can be found with the specified property\n     * @throws OgnlException in case of ognl errors\n     */\n    public Object getRealTarget(String property, Map<String, Object> context, Object root) throws OgnlException {\n        //special keyword, they must be cutting the stack\n        if (\"top\".equals(property)) {\n            return root;\n        }\n\n        if (root instanceof CompoundRoot) {\n            // find real target\n            CompoundRoot cr = (CompoundRoot) root;\n\n            try {\n                for (Object target : cr) {\n                    if (OgnlRuntime.hasSetProperty((OgnlContext) context, target, property)\n                            || OgnlRuntime.hasGetProperty((OgnlContext) context, target, property)\n                            || OgnlRuntime.getIndexedPropertyType((OgnlContext) context, target.getClass(), property) != OgnlRuntime.INDEXED_PROPERTY_NONE\n                            ) {\n                        return target;\n                    }\n                }\n            } catch (IntrospectionException ex) {\n                throw new ReflectionException(\"Cannot figure out real target class\", ex);\n            }\n\n            return null;\n        }\n\n        return root;\n    }\n\n    /**\n     * Wrapper around Ognl.setValue() to handle type conversion for collection elements.\n     * Ideally, this should be handled by OGNL directly.\n     *\n     * @param name  the name\n     * @param context context map\n     * @param root root\n     * @param value value\n     *\n     * @throws OgnlException in case of ognl errors\n     */\n    public void setValue(final String name, final Map<String, Object> context, final Object root, final Object value) throws OgnlException {\n        compileAndExecute(name, context, new OgnlTask<Void>() {\n            public Void execute(Object tree) throws OgnlException {\n                if (isEvalExpression(tree, context)) {\n                    throw new OgnlException(\"Eval expression/chained expressions cannot be used as parameter name\");\n                }\n                Ognl.setValue(tree, context, root, value);\n                return null;\n            }\n        });\n    }\n\n    private boolean isEvalExpression(Object tree, Map<String, Object> context) throws OgnlException {\n        if (tree instanceof SimpleNode) {\n            SimpleNode node = (SimpleNode) tree;\n            OgnlContext ognlContext = null;\n\n            if (context!=null && context instanceof OgnlContext) {\n                ognlContext = (OgnlContext) context;\n            }\n            return node.isEvalChain(ognlContext) || node.isSequence(ognlContext);\n        }\n        return false;\n    }\n\n    public Object getValue(final String name, final Map<String, Object> context, final Object root) throws OgnlException {\n        return compileAndExecute(name, context, new OgnlTask<Object>() {\n            public Object execute(Object tree) throws OgnlException {\n                return Ognl.getValue(tree, context, root);\n            }\n        });\n    }\n\n    public Object getValue(final String name, final Map<String, Object> context, final Object root, final Class resultType) throws OgnlException {\n        return compileAndExecute(name, context, new OgnlTask<Object>() {\n            public Object execute(Object tree) throws OgnlException {\n                return Ognl.getValue(tree, context, root, resultType);\n            }\n        });\n    }\n\n\n    public Object compile(String expression) throws OgnlException {\n        return compile(expression, null);\n    }\n\n    private <T> Object compileAndExecute(String expression, Map<String, Object> context, OgnlTask<T> task) throws OgnlException {\n        Object tree;\n        if (enableExpressionCache) {\n            tree = expressions.get(expression);\n            if (tree == null) {\n                tree = Ognl.parseExpression(expression);\n                checkEnableEvalExpression(tree, context);\n            }\n        } else {\n            tree = Ognl.parseExpression(expression);\n            checkEnableEvalExpression(tree, context);\n        }\n\n        final T exec = task.execute(tree);\n        // if cache is enabled and it's a valid expression, puts it in\n        if(enableExpressionCache) {\n            expressions.putIfAbsent(expression, tree);\n        }\n        return exec;\n    }\n\n    public Object compile(String expression, Map<String, Object> context) throws OgnlException {\n        return compileAndExecute(expression,context,new OgnlTask<Object>() {\n            public Object execute(Object tree) throws OgnlException {\n                return tree;\n            }\n        });\n    }\n    \n    private void checkEnableEvalExpression(Object tree, Map<String, Object> context) throws OgnlException {\n        if (!enableEvalExpression && isEvalExpression(tree, context)) {\n            throw new OgnlException(\"Eval expressions/chained expressions have been disabled!\");\n        }\n    }\n\n    /**\n     * Copies the properties in the object \"from\" and sets them in the object \"to\"\n     * using specified type converter, or {@link com.opensymphony.xwork2.conversion.impl.XWorkConverter} if none\n     * is specified.\n     *\n     * @param from       the source object\n     * @param to         the target object\n     * @param context    the action context we're running under\n     * @param exclusions collection of method names to excluded from copying ( can be null)\n     * @param inclusions collection of method names to included copying  (can be null)\n     *                   note if exclusions AND inclusions are supplied and not null nothing will get copied.\n     */\n    public void copy(final Object from, final Object to, final Map<String, Object> context, Collection<String> exclusions, Collection<String> inclusions) {\n        if (from == null || to == null) {\n            LOG.warn(\"Attempting to copy from or to a null source. This is illegal and is bein skipped. This may be due to an error in an OGNL expression, action chaining, or some other event.\");\n            return;\n        }\n\n        TypeConverter converter = getTypeConverterFromContext(context);\n        final Map contextFrom = createDefaultContext(from, null);\n        Ognl.setTypeConverter(contextFrom, converter);\n        final Map contextTo = createDefaultContext(to, null);\n        Ognl.setTypeConverter(contextTo, converter);\n\n        PropertyDescriptor[] fromPds;\n        PropertyDescriptor[] toPds;\n\n        try {\n            fromPds = getPropertyDescriptors(from);\n            toPds = getPropertyDescriptors(to);\n        } catch (IntrospectionException e) {\n            LOG.error(\"An error occurred\", e);\n            return;\n        }\n\n        Map<String, PropertyDescriptor> toPdHash = new HashMap<>();\n\n        for (PropertyDescriptor toPd : toPds) {\n            toPdHash.put(toPd.getName(), toPd);\n        }\n\n        for (PropertyDescriptor fromPd : fromPds) {\n            if (fromPd.getReadMethod() != null) {\n                boolean copy = true;\n                if (exclusions != null && exclusions.contains(fromPd.getName())) {\n                    copy = false;\n                } else if (inclusions != null && !inclusions.contains(fromPd.getName())) {\n                    copy = false;\n                }\n\n                if (copy) {\n                    PropertyDescriptor toPd = toPdHash.get(fromPd.getName());\n                    if ((toPd != null) && (toPd.getWriteMethod() != null)) {\n                        try {\n                            compileAndExecute(fromPd.getName(), context, new OgnlTask<Object>() {\n                                public Void execute(Object expr) throws OgnlException {\n                                    Object value = Ognl.getValue(expr, contextFrom, from);\n                                    Ognl.setValue(expr, contextTo, to, value);\n                                    return null;\n                                }\n                            });\n\n                        } catch (OgnlException e) {\n                            LOG.debug(\"Got OGNL exception\", e);\n                        }\n                    }\n\n                }\n\n            }\n\n        }\n    }\n\n\n    /**\n     * Copies the properties in the object \"from\" and sets them in the object \"to\"\n     * using specified type converter, or {@link com.opensymphony.xwork2.conversion.impl.XWorkConverter} if none\n     * is specified.\n     *\n     * @param from    the source object\n     * @param to      the target object\n     * @param context the action context we're running under\n     */\n    public void copy(Object from, Object to, Map<String, Object> context) {\n        copy(from, to, context, null, null);\n    }\n\n    /**\n     * Get's the java beans property descriptors for the given source.\n     *\n     * @param source the source object.\n     * @return property descriptors.\n     * @throws IntrospectionException is thrown if an exception occurs during introspection.\n     */\n    public PropertyDescriptor[] getPropertyDescriptors(Object source) throws IntrospectionException {\n        BeanInfo beanInfo = getBeanInfo(source);\n        return beanInfo.getPropertyDescriptors();\n    }\n\n\n    /**\n     * Get's the java beans property descriptors for the given class.\n     *\n     * @param clazz the source object.\n     * @return property descriptors.\n     * @throws IntrospectionException is thrown if an exception occurs during introspection.\n     */\n    public PropertyDescriptor[] getPropertyDescriptors(Class clazz) throws IntrospectionException {\n        BeanInfo beanInfo = getBeanInfo(clazz);\n        return beanInfo.getPropertyDescriptors();\n    }\n\n    /**\n     * Creates a Map with read properties for the given source object.\n     * <p>\n     * If the source object does not have a read property (i.e. write-only) then\n     * the property is added to the map with the value <code>here is no read method for property-name</code>.\n     * </p>\n     *\n     * @param source the source object.\n     * @return a Map with (key = read property name, value = value of read property).\n     * @throws IntrospectionException is thrown if an exception occurs during introspection.\n     * @throws OgnlException          is thrown by OGNL if the property value could not be retrieved\n     */\n    public Map<String, Object> getBeanMap(final Object source) throws IntrospectionException, OgnlException {\n        Map<String, Object> beanMap = new HashMap<>();\n        final Map sourceMap = createDefaultContext(source, null);\n        PropertyDescriptor[] propertyDescriptors = getPropertyDescriptors(source);\n        for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {\n            final String propertyName = propertyDescriptor.getDisplayName();\n            Method readMethod = propertyDescriptor.getReadMethod();\n            if (readMethod != null) {\n                final Object value = compileAndExecute(propertyName, null, new OgnlTask<Object>() {\n                    public Object execute(Object expr) throws OgnlException {\n                        return Ognl.getValue(expr, sourceMap, source);\n                    }\n                });\n                beanMap.put(propertyName, value);\n            } else {\n                beanMap.put(propertyName, \"There is no read method for \" + propertyName);\n            }\n        }\n        return beanMap;\n    }\n\n    /**\n     * Get's the java bean info for the given source object. Calls getBeanInfo(Class c).\n     *\n     * @param from the source object.\n     * @return java bean info.\n     * @throws IntrospectionException is thrown if an exception occurs during introspection.\n     */\n    public BeanInfo getBeanInfo(Object from) throws IntrospectionException {\n        return getBeanInfo(from.getClass());\n    }\n\n\n    /**\n     * Get's the java bean info for the given source.\n     *\n     * @param clazz the source class.\n     * @return java bean info.\n     * @throws IntrospectionException is thrown if an exception occurs during introspection.\n     */\n    public BeanInfo getBeanInfo(Class clazz) throws IntrospectionException {\n        synchronized (beanInfoCache) {\n            BeanInfo beanInfo;\n            beanInfo = beanInfoCache.get(clazz);\n            if (beanInfo == null) {\n                beanInfo = Introspector.getBeanInfo(clazz, Object.class);\n                beanInfoCache.putIfAbsent(clazz, beanInfo);\n            }\n            return beanInfo;\n        }\n    }\n\n    void internalSetProperty(String name, Object value, Object o, Map<String, Object> context, boolean throwPropertyExceptions) throws ReflectionException{\n        try {\n            setValue(name, context, o, value);\n        } catch (OgnlException e) {\n            Throwable reason = e.getReason();\n            String msg = \"Caught OgnlException while setting property '\" + name + \"' on type '\" + o.getClass().getName() + \"'.\";\n            Throwable exception = (reason == null) ? e : reason;\n\n            if (throwPropertyExceptions) {\n                throw new ReflectionException(msg, exception);\n            } else if (devMode) {\n                LOG.warn(msg, exception);\n            }\n        }\n    }\n\n    TypeConverter getTypeConverterFromContext(Map<String, Object> context) {\n        /*ValueStack stack = (ValueStack) context.get(ActionContext.VALUE_STACK);\n        Container cont = (Container)stack.getContext().get(ActionContext.CONTAINER);\n        if (cont != null) {\n            return new OgnlTypeConverterWrapper(cont.getInstance(XWorkConverter.class));\n        } else {\n            throw new IllegalArgumentException(\"Cannot find type converter in context map\");\n        }\n        */\n        return defaultConverter;\n    }\n\n    protected Map createDefaultContext(Object root) {\n        return createDefaultContext(root, null);\n    }\n\n    protected Map createDefaultContext(Object root, ClassResolver classResolver) {\n        ClassResolver resolver = classResolver;\n        if (resolver == null) {\n            resolver = container.getInstance(CompoundRootAccessor.class);\n        }\n\n        SecurityMemberAccess memberAccess = new SecurityMemberAccess(allowStaticMethodAccess);\n        memberAccess.setExcludedClasses(excludedClasses);\n        memberAccess.setExcludedPackageNamePatterns(excludedPackageNamePatterns);\n        memberAccess.setExcludedPackageNames(excludedPackageNames);\n\n        return Ognl.createDefaultContext(root, resolver, defaultConverter, memberAccess);\n    }\n\n    private interface OgnlTask<T> {\n        T execute(Object tree) throws OgnlException;\n    }\n\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-34": {
    "vul_id": "VUL4J-34",
    "cve_id": "CVE-2016-2162",
    "project": "apache_struts",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests -DskipAssembly clean install",
    "test_cmd": "mvn test -pl core -Dtest=com.opensymphony.xwork2.interceptor.I18nInterceptorTest",
    "test_all_cmd": "mvn test -pl core",
    "human_patch_url": "https://github.com/apache/struts/commit/fc2179cf1ac9fbfb61e3430fa88b641d87253327",
    "vulnerable_files": [
      {
        "file_path": "core/src/main/java/com/opensymphony/xwork2/interceptor/I18nInterceptor.java",
        "file_name": "I18nInterceptor.java",
        "vulnerable_code": "/*\n * Copyright 2002-2006,2009 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.opensymphony.xwork2.interceptor;\n\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.util.LocalizedTextUtil;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport java.util.Locale;\nimport java.util.Map;\n\n/**\n * <!-- START SNIPPET: description -->\n * <p>\n * An interceptor that handles setting the locale specified in a session as the locale for the current action request.\n * In addition, this interceptor will look for a specific HTTP request parameter and set the locale to whatever value is\n * provided. This means that this interceptor can be used to allow for your application to dynamically change the locale\n * for the user's session or, alternatively, only for the current request (since XWork 2.1.3).\n * This is very useful for applications that require multi-lingual support and want the user to\n * be able to set his or her language preference at any point. The locale parameter is removed during the execution of\n * this interceptor, ensuring that properties aren't set on an action (such as request_locale) that have no typical\n * corresponding setter in your action.\n * </p>\n *\n * <p>\n * For example, using the default parameter name, a request to <b>foo.action?request_locale=en_US</b>, then the\n * locale for US English is saved in the user's session and will be used for all future requests.\n * If there is no locale set (for example with the first visit), the interceptor uses the browser locale.\n * </p>\n *\n * <!-- END SNIPPET: description -->\n * <p><u>Interceptor parameters:</u></p>\n * <!-- START SNIPPET: parameters -->\n *\n * <ul>\n * <li>parameterName (optional) - the name of the HTTP request parameter that dictates the locale to switch to and save\n * in the session. By default this is <b>request_locale</b></li>\n * <li>requestOnlyParameterName (optional) - the name of the HTTP request parameter that dictates the locale to switch to\n * for the current request only, without saving it in the session. By default this is <b>request_only_locale</b></li>\n * <li>attributeName (optional) - the name of the session key to store the selected locale. By default this is\n * <b>WW_TRANS_I18N_LOCALE</b></li>\n * </ul>\n * <!-- END SNIPPET: parameters -->\n *\n * <p><u>Extending the interceptor:</u></p>\n *\n * <!-- START SNIPPET: extending -->\n * <p>\n * There are no known extensions points for this interceptor.\n * </p>\n * <!-- END SNIPPET: extending -->\n *\n * <p><u>Example code:</u></p>\n *\n * <pre>\n * <!-- START SNIPPET: example -->\n * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n *     &lt;interceptor-ref name=\"i18n\"/&gt;\n *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n * &lt;/action&gt;\n * <!-- END SNIPPET: example -->\n * </pre>\n *\n * @author Aleksei Gopachenko\n */\npublic class I18nInterceptor extends AbstractInterceptor {\n    private static final long serialVersionUID = 2496830135246700300L;\n\n    protected static final Logger LOG = LogManager.getLogger(I18nInterceptor.class);\n\n    public static final String DEFAULT_SESSION_ATTRIBUTE = \"WW_TRANS_I18N_LOCALE\";\n    public static final String DEFAULT_PARAMETER = \"request_locale\";\n    public static final String DEFAULT_REQUESTONLY_PARAMETER = \"request_only_locale\";\n\n    protected String parameterName = DEFAULT_PARAMETER;\n    protected String requestOnlyParameterName = DEFAULT_REQUESTONLY_PARAMETER;\n    protected String attributeName = DEFAULT_SESSION_ATTRIBUTE;\n\n    // Request-Only = None\n    protected enum Storage { SESSION, NONE }\n\n    public I18nInterceptor() {\n        LOG.debug(\"new I18nInterceptor()\");\n    }\n\n    public void setParameterName(String parameterName) {\n        this.parameterName = parameterName;\n    }\n\n    public void setRequestOnlyParameterName(String requestOnlyParameterName) {\n        this.requestOnlyParameterName = requestOnlyParameterName;\n    }\n\n    public void setAttributeName(String attributeName) {\n        this.attributeName = attributeName;\n    }\n\n    @Override\n    public String intercept(ActionInvocation invocation) throws Exception {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Intercept '{}/{}' {\", invocation.getProxy().getNamespace(), invocation.getProxy().getActionName());\n        }\n\n        LocaleFinder localeFinder = new LocaleFinder(invocation);\n        Locale locale = getLocaleFromParam(localeFinder.getRequestedLocale());\n        locale = storeLocale(invocation, locale, localeFinder.getStorage());\n        saveLocale(invocation, locale);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"before Locale: {}\", invocation.getStack().findValue(\"locale\"));\n        }\n\n        final String result = invocation.invoke();\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"after Locale {}\", invocation.getStack().findValue(\"locale\"));\n            LOG.debug(\"intercept } \");\n        }\n\n        return result;\n    }\n\n    /**\n     * Store the locale to the chosen storage, like f. e. the session\n     *\n     * @param invocation the action invocation\n     * @param locale the locale to store\n     * @param storage the place to store this locale (like Storage.SESSSION.toString())\n     *\n     * @return the locale\n     */\n    protected Locale storeLocale(ActionInvocation invocation, Locale locale, String storage) {\n        //save it in session\n        Map<String, Object> session = invocation.getInvocationContext().getSession();\n\n        if (session != null) {\n            synchronized (session) {\n                if (locale == null) {\n                    storage = Storage.NONE.toString();\n                    locale = readStoredLocale(invocation, session);\n                }\n\n                if (Storage.SESSION.toString().equals(storage)) {\n                    session.put(attributeName, locale);\n                }\n            }\n        }\n        return locale;\n    }\n\n    protected class LocaleFinder {\n        protected String storage = Storage.SESSION.toString();\n        protected Object requestedLocale = null;\n\n        protected ActionInvocation actionInvocation = null;\n\n        protected LocaleFinder(ActionInvocation invocation) {\n            actionInvocation = invocation;\n            find();\n        }\n\n        protected void find() {\n            //get requested locale\n            Map<String, Object> params = actionInvocation.getInvocationContext().getParameters();\n\n            storage = Storage.SESSION.toString();\n\n            requestedLocale = findLocaleParameter(params, parameterName);\n            if (requestedLocale != null) {\n                return;\n            }\n\n            requestedLocale = findLocaleParameter(params, requestOnlyParameterName);\n            if (requestedLocale != null) {\n                storage = Storage.NONE.toString();\n            }\n        }\n\n        public String getStorage() {\n            return storage;\n        }\n\n        public Object getRequestedLocale() {\n            return requestedLocale;\n        }\n    }\n\n    /**\n     * Creates a Locale object from the request param, which might\n     * be already a Local or a String\n     *\n     * @param requestedLocale the parameter from the request\n     * @return the Locale\n     */\n    protected Locale getLocaleFromParam(Object requestedLocale) {\n        Locale locale = null;\n        if (requestedLocale != null) {\n            locale = (requestedLocale instanceof Locale) ?\n                    (Locale) requestedLocale :\n                    LocalizedTextUtil.localeFromString(requestedLocale.toString(), null);\n            if (locale != null) {\n                LOG.debug(\"Applied request locale: {}\", locale);\n            }\n        }\n\n        return locale;\n    }\n\n    /**\n     * Reads the locale from the session, and if not found from the\n     * current invocation (=browser)\n     *\n     * @param invocation the current invocation\n     * @param session the current session\n     * @return the read locale\n     */\n    protected Locale readStoredLocale(ActionInvocation invocation, Map<String, Object> session) {\n        Locale locale = this.readStoredLocalFromSession(invocation, session);\n\n        if (locale != null) {\n            return locale;\n        }\n\n        return this.readStoredLocalFromCurrentInvocation(invocation);\n    }\n\n    protected Locale readStoredLocalFromSession(ActionInvocation invocation, Map<String, Object> session) {\n         // check session for saved locale\n        Object sessionLocale = session.get(attributeName);\n        if (sessionLocale != null && sessionLocale instanceof Locale) {\n            Locale locale = (Locale) sessionLocale;\n            LOG.debug(\"Applied session locale: {}\", locale);\n            return locale;\n        }\n        return null;\n    }\n\n    protected Locale readStoredLocalFromCurrentInvocation(ActionInvocation invocation) {\n        // no overriding locale definition found, stay with current invocation (=browser) locale\n        Locale locale = invocation.getInvocationContext().getLocale();\n        if (locale != null) {\n            LOG.debug(\"Applied invocation context locale: {}\", locale);\n        }\n        return locale;\n    }\n\n    protected Object findLocaleParameter(Map<String, Object> params, String parameterName) {\n        Object requestedLocale = params.remove(parameterName);\n        if (requestedLocale != null && requestedLocale.getClass().isArray()\n                && ((Object[]) requestedLocale).length > 0) {\n            requestedLocale = ((Object[]) requestedLocale)[0];\n\n            LOG.debug(\"Requested locale: {}\", requestedLocale);\n        }\n        return requestedLocale;\n    }\n\n    /**\n     * Save the given locale to the ActionInvocation.\n     *\n     * @param invocation The ActionInvocation.\n     * @param locale     The locale to save.\n     */\n    protected void saveLocale(ActionInvocation invocation, Locale locale) {\n        invocation.getInvocationContext().setLocale(locale);\n    }\n\n}\n",
        "human_patch_code": "/*\n * Copyright 2002-2006,2009 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.opensymphony.xwork2.interceptor;\n\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.util.LocalizedTextUtil;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport java.util.Arrays;\nimport java.util.Locale;\nimport java.util.Map;\n\n/**\n * <!-- START SNIPPET: description -->\n * <p>\n * An interceptor that handles setting the locale specified in a session as the locale for the current action request.\n * In addition, this interceptor will look for a specific HTTP request parameter and set the locale to whatever value is\n * provided. This means that this interceptor can be used to allow for your application to dynamically change the locale\n * for the user's session or, alternatively, only for the current request (since XWork 2.1.3).\n * This is very useful for applications that require multi-lingual support and want the user to\n * be able to set his or her language preference at any point. The locale parameter is removed during the execution of\n * this interceptor, ensuring that properties aren't set on an action (such as request_locale) that have no typical\n * corresponding setter in your action.\n * </p>\n *\n * <p>\n * For example, using the default parameter name, a request to <b>foo.action?request_locale=en_US</b>, then the\n * locale for US English is saved in the user's session and will be used for all future requests.\n * If there is no locale set (for example with the first visit), the interceptor uses the browser locale.\n * </p>\n *\n * <!-- END SNIPPET: description -->\n * <p><u>Interceptor parameters:</u></p>\n * <!-- START SNIPPET: parameters -->\n *\n * <ul>\n * <li>parameterName (optional) - the name of the HTTP request parameter that dictates the locale to switch to and save\n * in the session. By default this is <b>request_locale</b></li>\n * <li>requestOnlyParameterName (optional) - the name of the HTTP request parameter that dictates the locale to switch to\n * for the current request only, without saving it in the session. By default this is <b>request_only_locale</b></li>\n * <li>attributeName (optional) - the name of the session key to store the selected locale. By default this is\n * <b>WW_TRANS_I18N_LOCALE</b></li>\n * </ul>\n * <!-- END SNIPPET: parameters -->\n *\n * <p><u>Extending the interceptor:</u></p>\n *\n * <!-- START SNIPPET: extending -->\n * <p>\n * There are no known extensions points for this interceptor.\n * </p>\n * <!-- END SNIPPET: extending -->\n *\n * <p><u>Example code:</u></p>\n *\n * <pre>\n * <!-- START SNIPPET: example -->\n * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n *     &lt;interceptor-ref name=\"i18n\"/&gt;\n *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n * &lt;/action&gt;\n * <!-- END SNIPPET: example -->\n * </pre>\n *\n * @author Aleksei Gopachenko\n */\npublic class I18nInterceptor extends AbstractInterceptor {\n    private static final long serialVersionUID = 2496830135246700300L;\n\n    protected static final Logger LOG = LogManager.getLogger(I18nInterceptor.class);\n\n    public static final String DEFAULT_SESSION_ATTRIBUTE = \"WW_TRANS_I18N_LOCALE\";\n    public static final String DEFAULT_PARAMETER = \"request_locale\";\n    public static final String DEFAULT_REQUESTONLY_PARAMETER = \"request_only_locale\";\n\n    protected String parameterName = DEFAULT_PARAMETER;\n    protected String requestOnlyParameterName = DEFAULT_REQUESTONLY_PARAMETER;\n    protected String attributeName = DEFAULT_SESSION_ATTRIBUTE;\n\n    // Request-Only = None\n    protected enum Storage { SESSION, NONE }\n\n    public I18nInterceptor() {\n        LOG.debug(\"new I18nInterceptor()\");\n    }\n\n    public void setParameterName(String parameterName) {\n        this.parameterName = parameterName;\n    }\n\n    public void setRequestOnlyParameterName(String requestOnlyParameterName) {\n        this.requestOnlyParameterName = requestOnlyParameterName;\n    }\n\n    public void setAttributeName(String attributeName) {\n        this.attributeName = attributeName;\n    }\n\n    @Override\n    public String intercept(ActionInvocation invocation) throws Exception {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Intercept '{}/{}' {\", invocation.getProxy().getNamespace(), invocation.getProxy().getActionName());\n        }\n\n        LocaleFinder localeFinder = new LocaleFinder(invocation);\n        Locale locale = getLocaleFromParam(localeFinder.getRequestedLocale());\n        locale = storeLocale(invocation, locale, localeFinder.getStorage());\n        saveLocale(invocation, locale);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"before Locale: {}\", invocation.getStack().findValue(\"locale\"));\n        }\n\n        final String result = invocation.invoke();\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"after Locale {}\", invocation.getStack().findValue(\"locale\"));\n            LOG.debug(\"intercept } \");\n        }\n\n        return result;\n    }\n\n    /**\n     * Store the locale to the chosen storage, like f. e. the session\n     *\n     * @param invocation the action invocation\n     * @param locale the locale to store\n     * @param storage the place to store this locale (like Storage.SESSSION.toString())\n     *\n     * @return the locale\n     */\n    protected Locale storeLocale(ActionInvocation invocation, Locale locale, String storage) {\n        //save it in session\n        Map<String, Object> session = invocation.getInvocationContext().getSession();\n\n        if (session != null) {\n            synchronized (session) {\n                if (locale == null) {\n                    storage = Storage.NONE.toString();\n                    locale = readStoredLocale(invocation, session);\n                }\n\n                if (Storage.SESSION.toString().equals(storage)) {\n                    session.put(attributeName, locale);\n                }\n            }\n        }\n        return locale;\n    }\n\n    protected class LocaleFinder {\n        protected String storage = Storage.SESSION.toString();\n        protected Object requestedLocale = null;\n\n        protected ActionInvocation actionInvocation = null;\n\n        protected LocaleFinder(ActionInvocation invocation) {\n            actionInvocation = invocation;\n            find();\n        }\n\n        protected void find() {\n            //get requested locale\n            Map<String, Object> params = actionInvocation.getInvocationContext().getParameters();\n\n            storage = Storage.SESSION.toString();\n\n            requestedLocale = findLocaleParameter(params, parameterName);\n            if (requestedLocale != null) {\n                return;\n            }\n\n            requestedLocale = findLocaleParameter(params, requestOnlyParameterName);\n            if (requestedLocale != null) {\n                storage = Storage.NONE.toString();\n            }\n        }\n\n        public String getStorage() {\n            return storage;\n        }\n\n        public Object getRequestedLocale() {\n            return requestedLocale;\n        }\n    }\n\n    /**\n     * Creates a Locale object from the request param, which might\n     * be already a Local or a String\n     *\n     * @param requestedLocale the parameter from the request\n     * @return the Locale\n     */\n    protected Locale getLocaleFromParam(Object requestedLocale) {\n        Locale locale = null;\n        if (requestedLocale != null) {\n            locale = (requestedLocale instanceof Locale) ?\n                    (Locale) requestedLocale :\n                    LocalizedTextUtil.localeFromString(requestedLocale.toString(), null);\n            if (locale != null) {\n                LOG.debug(\"Applied request locale: {}\", locale);\n            }\n        }\n\n        if (locale != null && !Arrays.asList(Locale.getAvailableLocales()).contains(locale)) {\n            locale = Locale.getDefault();\n        }\n        return locale;\n    }\n\n    /**\n     * Reads the locale from the session, and if not found from the\n     * current invocation (=browser)\n     *\n     * @param invocation the current invocation\n     * @param session the current session\n     * @return the read locale\n     */\n    protected Locale readStoredLocale(ActionInvocation invocation, Map<String, Object> session) {\n        Locale locale = this.readStoredLocalFromSession(invocation, session);\n\n        if (locale != null) {\n            return locale;\n        }\n\n        return this.readStoredLocalFromCurrentInvocation(invocation);\n    }\n\n    protected Locale readStoredLocalFromSession(ActionInvocation invocation, Map<String, Object> session) {\n         // check session for saved locale\n        Object sessionLocale = session.get(attributeName);\n        if (sessionLocale != null && sessionLocale instanceof Locale) {\n            Locale locale = (Locale) sessionLocale;\n            LOG.debug(\"Applied session locale: {}\", locale);\n            return locale;\n        }\n        return null;\n    }\n\n    protected Locale readStoredLocalFromCurrentInvocation(ActionInvocation invocation) {\n        // no overriding locale definition found, stay with current invocation (=browser) locale\n        Locale locale = invocation.getInvocationContext().getLocale();\n        if (locale != null) {\n            LOG.debug(\"Applied invocation context locale: {}\", locale);\n        }\n        return locale;\n    }\n\n    protected Object findLocaleParameter(Map<String, Object> params, String parameterName) {\n        Object requestedLocale = params.remove(parameterName);\n        if (requestedLocale != null && requestedLocale.getClass().isArray()\n                && ((Object[]) requestedLocale).length > 0) {\n            requestedLocale = ((Object[]) requestedLocale)[0];\n\n            LOG.debug(\"Requested locale: {}\", requestedLocale);\n        }\n        return requestedLocale;\n    }\n\n    /**\n     * Save the given locale to the ActionInvocation.\n     *\n     * @param invocation The ActionInvocation.\n     * @param locale     The locale to save.\n     */\n    protected void saveLocale(ActionInvocation invocation, Locale locale) {\n        invocation.getInvocationContext().setLocale(locale);\n    }\n\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-35": {
    "vul_id": "VUL4J-35",
    "cve_id": "CVE-2014-7809",
    "project": "apache_struts",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests -DskipAssembly clean install",
    "test_cmd": "mvn test -pl core -Dtest=org.apache.struts2.util.TokenHelperTest",
    "test_all_cmd": "mvn test -pl core",
    "human_patch_url": "https://github.com/apache/struts/commit/1f301038a751bf16e525607c3db513db835b2999",
    "vulnerable_files": [
      {
        "file_path": "core/src/main/java/org/apache/struts2/util/TokenHelper.java",
        "file_name": "TokenHelper.java",
        "vulnerable_code": "/*\n * $Id$\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.struts2.util;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.util.LocalizedTextUtil;\nimport com.opensymphony.xwork2.util.logging.Logger;\nimport com.opensymphony.xwork2.util.logging.LoggerFactory;\n\nimport java.math.BigInteger;\nimport java.util.Map;\nimport java.util.Random;\n\n/**\n * TokenHelper\n *\n */\npublic class TokenHelper {\n\n\t/**\n\t * The default namespace for storing token session values\n\t */\n\tpublic static final String TOKEN_NAMESPACE = \"struts.tokens\";\n\n\t/**\n     * The default name to map the token value\n     */\n    public static final String DEFAULT_TOKEN_NAME = \"token\";\n\n    /**\n     * The name of the field which will hold the token name\n     */\n    public static final String TOKEN_NAME_FIELD = \"struts.token.name\";\n    private static final Logger LOG = LoggerFactory.getLogger(TokenHelper.class);\n    private static final Random RANDOM = new Random();\n\n\n    /**\n     * Sets a transaction token into the session using the default token name.\n     *\n     * @return the token string\n     */\n    public static String setToken() {\n        return setToken(DEFAULT_TOKEN_NAME);\n    }\n\n\t/**\n\t * Sets a transaction token into the session based on the provided token name.\n\t *\n\t * @param tokenName the token name based on which a generated token value is stored into session; for actual session\n\t *                  store, this name will be prefixed by a namespace.\n\t *\n\t * @return the token string\n\t */\n\tpublic static String setToken( String tokenName ) {\n\t\tString token = generateGUID();\n\t\tsetSessionToken(tokenName, token);\n\t\treturn token;\n\t}\n\n\t/**\n\t * Put a given named token into the session map. The token will be stored with a namespace prefix prepended.\n\t *\n\t * @param tokenName the token name based on which given token value is stored into session; for actual session store,\n\t *                  this name will be prefixed by a namespace.\n\t * @param token     the token value to store\n\t */\n\tpublic static void setSessionToken( String tokenName, String token ) {\n\t\tMap<String, Object> session = ActionContext.getContext().getSession();\n\t\ttry {\n\t\t\tsession.put(buildTokenSessionAttributeName(tokenName), token);\n\t\t} catch ( IllegalStateException e ) {\n\t\t\t// WW-1182 explain to user what the problem is\n            String msg = \"Error creating HttpSession due response is commited to client. You can use the CreateSessionInterceptor or create the HttpSession from your action before the result is rendered to the client: \" + e.getMessage();\n            if (LOG.isErrorEnabled()) {\n                LOG.error(msg, e);\n            }\n\t\t\tthrow new IllegalArgumentException(msg);\n\t\t}\n\t}\n\n\n\t/**\n\t * Build a name-spaced token session attribute name based on the given token name.\n\t *\n\t * @param tokenName the token name to prefix\n\t *\n\t * @return the name space prefixed session token name\n\t */\n\tpublic static String buildTokenSessionAttributeName( String tokenName ) {\n\t\treturn TOKEN_NAMESPACE + \".\" + tokenName;\n\t}\n\n\t/**\n     * Gets a transaction token from the params in the ServletActionContext using the default token name.\n     *\n     * @return token\n     */\n    public static String getToken() {\n        return getToken(DEFAULT_TOKEN_NAME);\n    }\n\n    /**\n     * Gets the Token value from the params in the ServletActionContext using the given name\n     *\n     * @param tokenName the name of the parameter which holds the token value\n     * @return the token String or null, if the token could not be found\n     */\n    public static String getToken(String tokenName) {\n        if (tokenName == null ) {\n            return null;\n        }\n        Map params = ActionContext.getContext().getParameters();\n        String[] tokens = (String[]) params.get(tokenName);\n        String token;\n\n        if ((tokens == null) || (tokens.length < 1)) {\n            if (LOG.isWarnEnabled()) {\n        \tLOG.warn(\"Could not find token mapped to token name \" + tokenName);\n            }\n\n            return null;\n        }\n\n        token = tokens[0];\n\n        return token;\n    }\n\n    /**\n     * Gets the token name from the Parameters in the ServletActionContext\n     *\n     * @return the token name found in the params, or null if it could not be found\n     */\n    public static String getTokenName() {\n        Map params = ActionContext.getContext().getParameters();\n\n        if (!params.containsKey(TOKEN_NAME_FIELD)) {\n            if (LOG.isWarnEnabled()) {\n        \tLOG.warn(\"Could not find token name in params.\");\n            }\n\n            return null;\n        }\n\n        String[] tokenNames = (String[]) params.get(TOKEN_NAME_FIELD);\n        String tokenName;\n\n        if ((tokenNames == null) || (tokenNames.length < 1)) {\n            if (LOG.isWarnEnabled()) {\n        \tLOG.warn(\"Got a null or empty token name.\");\n            }\n\n            return null;\n        }\n\n        tokenName = tokenNames[0];\n\n        return tokenName;\n    }\n\n    /**\n     * Checks for a valid transaction token in the current request params. If a valid token is found, it is\n     * removed so the it is not valid again.\n     *\n     * @return false if there was no token set into the params (check by looking for {@link #TOKEN_NAME_FIELD}), true if a valid token is found\n     */\n    public static boolean validToken() {\n        String tokenName = getTokenName();\n\n        if (tokenName == null) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"no token name found -> Invalid token \");\n            }\n            return false;\n        }\n\n        String token = getToken(tokenName);\n\n        if (token == null) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"no token found for token name \"+tokenName+\" -> Invalid token \");\n            }\n            return false;\n        }\n\n        Map session = ActionContext.getContext().getSession();\n\t\tString tokenSessionName = buildTokenSessionAttributeName(tokenName);\n        String sessionToken = (String) session.get(tokenSessionName);\n\n        if (!token.equals(sessionToken)) {\n            if (LOG.isWarnEnabled()) {\n                LOG.warn(LocalizedTextUtil.findText(TokenHelper.class, \"struts.internal.invalid.token\", ActionContext.getContext().getLocale(), \"Form token {0} does not match the session token {1}.\", new Object[]{\n                        token, sessionToken\n                }));\n            }\n\n            return false;\n        }\n\n        // remove the token so it won't be used again\n        session.remove(tokenSessionName);\n\n        return true;\n    }\n\n    public static String generateGUID() {\n        return new BigInteger(165, RANDOM).toString(36).toUpperCase();\n    }\n\n    public static Random getRANDOM() { return RANDOM; }\n}\n",
        "human_patch_code": "/*\n * $Id$\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.struts2.util;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.util.LocalizedTextUtil;\nimport com.opensymphony.xwork2.util.logging.Logger;\nimport com.opensymphony.xwork2.util.logging.LoggerFactory;\n\nimport java.math.BigInteger;\nimport java.security.SecureRandom;\nimport java.util.Map;\nimport java.util.Random;\n\n/**\n * TokenHelper\n *\n */\npublic class TokenHelper {\n\n\t/**\n\t * The default namespace for storing token session values\n\t */\n\tpublic static final String TOKEN_NAMESPACE = \"struts.tokens\";\n\n\t/**\n     * The default name to map the token value\n     */\n    public static final String DEFAULT_TOKEN_NAME = \"token\";\n\n    /**\n     * The name of the field which will hold the token name\n     */\n    public static final String TOKEN_NAME_FIELD = \"struts.token.name\";\n    private static final Logger LOG = LoggerFactory.getLogger(TokenHelper.class);\n    private static final Random RANDOM = new SecureRandom();\n\n\n    /**\n     * Sets a transaction token into the session using the default token name.\n     *\n     * @return the token string\n     */\n    public static String setToken() {\n        return setToken(DEFAULT_TOKEN_NAME);\n    }\n\n\t/**\n\t * Sets a transaction token into the session based on the provided token name.\n\t *\n\t * @param tokenName the token name based on which a generated token value is stored into session; for actual session\n\t *                  store, this name will be prefixed by a namespace.\n\t *\n\t * @return the token string\n\t */\n\tpublic static String setToken( String tokenName ) {\n\t\tString token = generateGUID();\n\t\tsetSessionToken(tokenName, token);\n\t\treturn token;\n\t}\n\n\t/**\n\t * Put a given named token into the session map. The token will be stored with a namespace prefix prepended.\n\t *\n\t * @param tokenName the token name based on which given token value is stored into session; for actual session store,\n\t *                  this name will be prefixed by a namespace.\n\t * @param token     the token value to store\n\t */\n\tpublic static void setSessionToken( String tokenName, String token ) {\n\t\tMap<String, Object> session = ActionContext.getContext().getSession();\n\t\ttry {\n\t\t\tsession.put(buildTokenSessionAttributeName(tokenName), token);\n\t\t} catch ( IllegalStateException e ) {\n\t\t\t// WW-1182 explain to user what the problem is\n            String msg = \"Error creating HttpSession due response is commited to client. You can use the CreateSessionInterceptor or create the HttpSession from your action before the result is rendered to the client: \" + e.getMessage();\n            if (LOG.isErrorEnabled()) {\n                LOG.error(msg, e);\n            }\n\t\t\tthrow new IllegalArgumentException(msg);\n\t\t}\n\t}\n\n\n\t/**\n\t * Build a name-spaced token session attribute name based on the given token name.\n\t *\n\t * @param tokenName the token name to prefix\n\t *\n\t * @return the name space prefixed session token name\n\t */\n\tpublic static String buildTokenSessionAttributeName( String tokenName ) {\n\t\treturn TOKEN_NAMESPACE + \".\" + tokenName;\n\t}\n\n\t/**\n     * Gets a transaction token from the params in the ServletActionContext using the default token name.\n     *\n     * @return token\n     */\n    public static String getToken() {\n        return getToken(DEFAULT_TOKEN_NAME);\n    }\n\n    /**\n     * Gets the Token value from the params in the ServletActionContext using the given name\n     *\n     * @param tokenName the name of the parameter which holds the token value\n     * @return the token String or null, if the token could not be found\n     */\n    public static String getToken(String tokenName) {\n        if (tokenName == null ) {\n            return null;\n        }\n        Map params = ActionContext.getContext().getParameters();\n        String[] tokens = (String[]) params.get(tokenName);\n        String token;\n\n        if ((tokens == null) || (tokens.length < 1)) {\n            if (LOG.isWarnEnabled()) {\n        \tLOG.warn(\"Could not find token mapped to token name \" + tokenName);\n            }\n\n            return null;\n        }\n\n        token = tokens[0];\n\n        return token;\n    }\n\n    /**\n     * Gets the token name from the Parameters in the ServletActionContext\n     *\n     * @return the token name found in the params, or null if it could not be found\n     */\n    public static String getTokenName() {\n        Map params = ActionContext.getContext().getParameters();\n\n        if (!params.containsKey(TOKEN_NAME_FIELD)) {\n            if (LOG.isWarnEnabled()) {\n        \tLOG.warn(\"Could not find token name in params.\");\n            }\n\n            return null;\n        }\n\n        String[] tokenNames = (String[]) params.get(TOKEN_NAME_FIELD);\n        String tokenName;\n\n        if ((tokenNames == null) || (tokenNames.length < 1)) {\n            if (LOG.isWarnEnabled()) {\n        \tLOG.warn(\"Got a null or empty token name.\");\n            }\n\n            return null;\n        }\n\n        tokenName = tokenNames[0];\n\n        return tokenName;\n    }\n\n    /**\n     * Checks for a valid transaction token in the current request params. If a valid token is found, it is\n     * removed so the it is not valid again.\n     *\n     * @return false if there was no token set into the params (check by looking for {@link #TOKEN_NAME_FIELD}), true if a valid token is found\n     */\n    public static boolean validToken() {\n        String tokenName = getTokenName();\n\n        if (tokenName == null) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"no token name found -> Invalid token \");\n            }\n            return false;\n        }\n\n        String token = getToken(tokenName);\n\n        if (token == null) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"no token found for token name \"+tokenName+\" -> Invalid token \");\n            }\n            return false;\n        }\n\n        Map session = ActionContext.getContext().getSession();\n\t\tString tokenSessionName = buildTokenSessionAttributeName(tokenName);\n        String sessionToken = (String) session.get(tokenSessionName);\n\n        if (!token.equals(sessionToken)) {\n            if (LOG.isWarnEnabled()) {\n                LOG.warn(LocalizedTextUtil.findText(TokenHelper.class, \"struts.internal.invalid.token\", ActionContext.getContext().getLocale(), \"Form token {0} does not match the session token {1}.\", new Object[]{\n                        token, sessionToken\n                }));\n            }\n\n            return false;\n        }\n\n        // remove the token so it won't be used again\n        session.remove(tokenSessionName);\n\n        return true;\n    }\n\n    public static String generateGUID() {\n        return new BigInteger(165, RANDOM).toString(36).toUpperCase();\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-36": {
    "vul_id": "VUL4J-36",
    "cve_id": "CVE-2018-8017",
    "project": "apache_tika",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl tika-parsers -Dtest=org.apache.tika.parser.iptc.IptcParserTest#testCVE_2018_8017",
    "test_all_cmd": "mvn test -pl tika-parsers",
    "human_patch_url": "https://github.com/apache/tika/commit/8a6a9e1344f5b10ebfa1a189dc3c30d0da2b9d4",
    "vulnerable_files": [
      {
        "file_path": "tika-parsers/src/main/java/org/apache/tika/parser/iptc/IptcAnpaParser.java",
        "file_name": "IptcAnpaParser.java",
        "vulnerable_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.tika.parser.iptc;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.apache.tika.exception.TikaException;\nimport org.apache.tika.metadata.Metadata;\nimport org.apache.tika.metadata.TikaCoreProperties;\nimport org.apache.tika.mime.MediaType;\nimport org.apache.tika.parser.ParseContext;\nimport org.apache.tika.parser.Parser;\nimport org.apache.tika.sax.XHTMLContentHandler;\nimport org.xml.sax.ContentHandler;\nimport org.xml.sax.SAXException;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * Parser for IPTC ANPA New Wire Feeds\n */\npublic class IptcAnpaParser implements Parser {\n    /** Serial version UID */\n    private static final long serialVersionUID = -6062820170212879115L;\n\n    private static final MediaType TYPE =\n        MediaType.text(\"vnd.iptc.anpa\");\n\n    private static final Set<MediaType> SUPPORTED_TYPES =\n        Collections.singleton(TYPE);\n\n    public Set<MediaType> getSupportedTypes(ParseContext context) {\n        return SUPPORTED_TYPES;\n    }\n\n    public void parse(\n           InputStream stream, ContentHandler handler,\n           Metadata metadata, ParseContext context)\n           throws IOException, SAXException, TikaException {\n\n        HashMap<String,String> properties = this.loadProperties(stream);\n        this.setMetadata(metadata, properties);\n\n        XHTMLContentHandler xhtml = new XHTMLContentHandler(handler, metadata);\n        xhtml.startDocument();\n        // TODO: put body content here\n        xhtml.startElement(\"p\");\n        String body = clean(properties.get(\"body\"));\n        if (body != null)\n           xhtml.characters(body);\n        xhtml.endElement(\"p\");\n        xhtml.endDocument();\n    }\n\n    /**\n     * @deprecated This method will be removed in Apache Tika 1.0.\n     */\n    public void parse(\n            InputStream stream, ContentHandler handler, Metadata metadata)\n            throws IOException, SAXException, TikaException {\n        parse(stream, handler, metadata, new ParseContext());\n    }\n\n\n   private int FMT_ANPA_1312    = 0x00;   // \"NAA 89-3 (ANPA 1312)\"\n   private int FMT_ANPA_UPI     = 0x01;   // \"United Press International ANPA 1312 variant\"\n   private int FMT_ANPA_UPI_DL  = 0x02;   // \"United Press International Down-Load Message\"\n   private int FMT_IPTC_7901    = 0x03;   // \"IPTC7901 Recommended Message Format\"\n   private int FMT_IPTC_PHOTO   = 0x04;   // \"IPTC-NAA Digital Newsphoto Parameter Record\"\n   private int FMT_IPTC_CHAR    = 0x05;   // \"IPTC Unstructured Character Oriented File Format (UCOFF)\"\n   private int FMT_NITF         = 0x06;   // \"News Industry Text Format (NITF)\"\n   private int FMT_NITF_TT      = 0x07;   // \"Tidningarnas Telegrambyra NITF version (TTNITF DTD)\"\n   private int FMT_NITF_RB      = 0x08;   // \"Ritzaus Bureau NITF version (RBNITF DTD)\"\n   private int FMT_IPTC_AP      = 0x09;   // \"Associated Press news wire format\"\n   private int FMT_IPTC_BLM     = 0x0A;   // \"Bloomberg News news wire format\"\n   private int FMT_IPTC_NYT     = 0x0B;   // \"New York Times news wire format\"\n   private int FMT_IPTC_RTR     = 0x0C;   // \"Reuters news wire format\"\n\n   private int FORMAT = FMT_ANPA_1312;    // assume the default format to be ANPA-1312\n\n   private final static char SOH = 0x01;    // start of header (ctrl-a)\n   private final static char STX = 0x02;    // start of text (ctrl-b)\n   private final static char ETX = 0x03;    // end of text (ctrl-c)\n   private final static char EOT = 0x04;    // the tab character (ctrl-d)\n   private final static char SYN = 0x16;    // synchronous idle (ctrl-v)\n\n   private final static char BS = 0x08;    // the backspace character (used for diacriticals)\n   private final static char TB = 0x09;    // the tab character\n   private final static char LF = 0x0A;    // line feed\n   private final static char FF = 0x0C;    // form feed\n   private final static char CR = 0x0D;    // carriage return\n   private final static char XQ = 0x11;    // device control (ctrl-q)\n   private final static char XS = 0x13;    // device control (ctrl-s)\n   private final static char FS = 0x1F;    // a field delimiter\n\n   private final static char HY = 0x2D;    // hyphen\n   private final static char SP = 0x20;    // the blank space\n   private final static char LT = 0x3C;    // less than\n   private final static char EQ = 0x3D;    // less than\n   private final static char CT = 0x5E;    // carat\n\n   private final static char SL = 0x91;    // single-quote left\n   private final static char SR = 0x92;    // single-quote right\n   private final static char DL = 0x93;    // double-quote left\n   private final static char DR = 0x94;    // double-quote right\n\n\n   /**\n    * scan the news messsage and store the metadata and data into a map\n    */\n   private HashMap<String,String> loadProperties(InputStream is) {\n      \n      HashMap<String,String> properties = new HashMap<String,String>();\n\n      FORMAT = this.scanFormat(is);\n\n      byte[] residual = this.getSection(is,\"residual\");\n\n      byte[] header = this.getSection(is,\"header\");\n      parseHeader(header, properties);\n\n      byte[] body = this.getSection(is,\"body\");\n      parseBody(body, properties);\n\n      byte[] footer = this.getSection(is,\"footer\");\n      parseFooter(footer, properties);\n       \n      return (properties);\n   }\n\n\n   private int scanFormat(InputStream is) {\n      int format    = this.FORMAT;\n      int  maxsize  = 524288;     //  512K\n\n      byte[] buf = new byte[maxsize];\n      try {\n         if (is.markSupported()) {\n            is.mark(maxsize);\n         }\n         int msgsize = is.read(buf);                // read in at least the full data\n\n         String message = (new String(buf, UTF_8)).toLowerCase(Locale.ROOT);\n         // these are not if-then-else, because we want to go from most common\n         // and fall through to least.  this is imperfect, as these tags could\n         // show up in other agency stories, but i can't find a spec or any\n         // explicit codes to identify the wire source in the message itself\n\n         if (message.contains(\"ap-wf\")) {\n            format = this.FMT_IPTC_AP;\n         }\n         if (message.contains(\"reuters\")) {\n            format = this.FMT_IPTC_RTR;\n         }\n         if (message.contains(\"new york times\")) {\n            format = this.FMT_IPTC_NYT;\n         }\n         if (message.contains(\"bloomberg news\")) {\n            format = this.FMT_IPTC_BLM;\n         }\n      }\n      catch (IOException eio) {\n         // we are in an unstable state\n      }\n\n      try {\n         if (is.markSupported()) {\n            is.reset();\n         }\n      }\n      catch (IOException eio) {\n         // we are in an unstable state\n      }\n      return (format);\n   }\n\n\n   private void setFormat(int format) {\n      this.FORMAT = format;\n   }\n\n\n   private String getFormatName() {\n      \n      String name = \"\";\n      \n      if (FORMAT == this.FMT_IPTC_AP) {\n         name = \"Associated Press\";\n      }\n      \n      else if(FORMAT == this.FMT_IPTC_BLM) {\n         name = \"Bloomberg\";\n      }\n\n      else if(FORMAT == this.FMT_IPTC_NYT) {\n         name = \"New York Times\";\n      }\n\n      else if(FORMAT == this.FMT_IPTC_RTR) {\n         name = \"Reuters\";\n      }\n\n      return (name);\n   }\n\n\n   private byte[] getSection(InputStream is, String name) {\n\n      byte[] value = new byte[0];\n\n      if (name.equals(\"residual\")) {\n         // the header shouldn't be more than 1k, but just being generous here\n         int  maxsize  = 8192;     //  8K\n         byte bstart   = SYN;     // check for SYN [0x16 : ctrl-v] (may have leftover residue from preceding message)\n         byte bfinish  = SOH;     // check for SOH [0x01 : ctrl-a] (typically follows a pair of SYN [0x16 : ctrl-v])\n         value = getSection(is, maxsize, bstart, bfinish, true);\n      }\n\n      else if(name.equals(\"header\")) {\n         // the header shouldn't be more than 1k, but just being generous here\n         int  maxsize  = 8192;     //  8K\n         byte bstart   = SOH;     // check for SOH [0x01 : ctrl-a] (typically follows a pair of SYN [0x16 : ctrl-v])\n         byte bfinish  = STX;     // check for STX [0x02 : ctrl-b] (marks end of header, beginning of message)\n         value = getSection(is, maxsize, bstart, bfinish, true);\n      }\n\n      else if (name.equals(\"body\")) {\n         // the message shouldn't be more than 16k (?), leaving plenty of space\n         int  maxsize  = 524288;     //  512K\n         byte bstart   = STX;     // check for STX [0x02 : ctrl-b] (marks end of header, beginning of message)\n         byte bfinish  = ETX;     // check for ETX [0x03 : ctrl-c] (marks end of message, beginning of footer)\n         value = getSection(is, maxsize, bstart, bfinish, true);\n      }\n\n      else if (name.equals(\"footer\")) {\n         // the footer shouldn't be more than 1k , leaving plenty of space\n         int maxsize   = 8192;     //  8K\n         byte bstart   = ETX;     // check for ETX [0x03 : ctrl-c] (marks end of message, beginning of footer)\n         byte bfinish  = EOT;     // check for EOT [0x04 : ctrl-d] (marks end of transmission)\n         value = getSection(is, maxsize, bstart, bfinish, true);\n      }\n\n      return (value);\n   }\n\n\n   private byte[] getSection(InputStream is, int maxsize, byte bstart, byte bfinish, boolean ifincomplete) {\n      byte[] value  = new byte[0];\n\n      try {\n         boolean started = false;                   // check if we have found the start flag\n         boolean finished = false;                  // check if we have found the finish flag\n         int read = 0;                              // the number of bytes we read\n         int start = 0;                             // the position after the start flag\n\n         // TODO: this only pulls back 8K of data on a read, regardless of buffer size\n         //       more nefariously, it caps at a total 8K, through all sections\n         int streammax = is.available();\n         maxsize = Math.min(maxsize, streammax);\n\n         is.mark(maxsize);\n         byte[] buf = new byte[maxsize];\n         int totsize = 0;\n         int remainder = maxsize - totsize;\n         while (remainder > 0) {\n            int msgsize = is.read(buf, maxsize-remainder, maxsize);    // read in at least the full data\n            if (msgsize == -1) {\n               remainder = msgsize = 0;\n            }\n            remainder -= msgsize;\n            totsize   += msgsize;\n         }\n\n         // scan through the provided input stream\n         for (read=0; read < totsize; read++) {\n            byte b = buf[read];\n\n            if (!started) {\n               started = (b == bstart);\n               start = read + 1;\n               continue;\n            }\n\n            if (finished = (b == bfinish)) {\n/*\n               is.reset();\n               long skipped = is.skip((long)read);\n               if (skipped != read) {\n                  // we are in an unstable state\n               }\n               is.mark(1);\n */\n               break;\n            }\n\n            // load from the stream until we run out of characters, or hit the termination byte\n            continue;\n         }\n\n         // move the input stream back to where it was initially\n         is.reset();\n\n         if (finished) {\n            // now, we want to reset the stream to be sitting right on top of the finish marker\n            is.skip(read);\n            value = new byte[read-start];\n            System.arraycopy(buf, start, value, 0, read-start);\n         }\n         else {\n            if (ifincomplete && started) {\n               // the caller wants anything that was read, and we finished the stream or buffer\n               value = new byte[read-start];\n               System.arraycopy(buf, start, value, 0, read-start);\n            }\n         }\n      }\n      catch (IOException eio) {\n         // something invalid occurred, return an empty string\n      }\n\n      return (value);\n   }\n\n\n   private boolean parseHeader(byte[] value, HashMap<String,String> properties) {\n      boolean added = false;\n\n      String env_serviceid = \"\";\n      String env_category = \"\";\n      String env_urgency = \"\";\n      String hdr_edcode = \"\";\n      String hdr_subject = \"\";\n      String hdr_date = \"\";\n      String hdr_time = \"\";\n\n      int read = 0;\n\n      while (read < value.length) {\n\n         // pull apart the envelope, getting the service id  (....\\x1f)\n         while (read < value.length) {\n            byte val_next = value[read++];\n            if (val_next != FS) {\n               env_serviceid += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n            }\n            else {\n               break;\n            }\n         }\n\n         // pull apart the envelope, getting the category  (....\\x13\\x11)\n         while (read < value.length) {\n            byte val_next = value[read++];\n            if (val_next != XS) {   // the end of the envelope is marked (\\x13)\n               env_category += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n            }\n            else {\n               val_next = value[read];  // get the remaining byte (\\x11)\n               if (val_next == XQ) {\n                  read++;\n               }\n               break;\n            }\n         }\n\n         // pull apart the envelope, getting the subject heading\n         while (read < value.length) {\n            boolean subject = true;\n            byte val_next = value[read++];\n            while ((subject) && (val_next != SP) && (val_next != 0x00)) {  // ignore the envelope subject\n               hdr_subject += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n               val_next =  (read < value.length) ? value[read++] : 0x00;\n               while (val_next == SP) {  // consume all the spaces\n                  subject = false;\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (val_next != SP) {\n                     --read;  // otherwise we eat into the next section\n                  }\n               }\n            }\n            if (!subject) {\n               break;\n            }\n         }\n\n         // pull apart the envelope, getting the date and time\n         while (read < value.length) {\n            byte val_next = value[read++];\n            if (hdr_date.length() == 0) {\n               while (((val_next >= (byte)0x30) && (val_next <= (byte)0x39))  // consume all numerics and hyphens\n                  ||   (val_next == HY)) {\n                  hdr_date += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n            }\n            else if (val_next == SP) {\n               while (val_next == SP) {  // consume all the spaces\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n               continue;\n            }\n            else {\n               while (((val_next >= (byte)0x30) && (val_next <= (byte)0x39))  // consume all numerics and hyphens\n                  ||   (val_next == HY)) {\n                  hdr_time += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n            }\n         }\n         break; // don't let this run back through and start thrashing metadata\n      }\n\n      // if we were saving any of these values, we would set the properties map here\n\n      added = (env_serviceid.length() + env_category.length() + hdr_subject.length() + \n               hdr_date.length() + hdr_time.length()) > 0; \n      return added;\n   }\n\n   private boolean parseBody(byte[] value, HashMap<String,String> properties) {\n      boolean added = false;\n\n      String bdy_heading = \"\";\n      String bdy_title = \"\";\n      String bdy_source = \"\";\n      String bdy_author = \"\";\n      String bdy_body = \"\";\n\n      int read = 0;\n      boolean done = false;\n\n      while (!done && (read < value.length)) {\n\n         // pull apart the body, getting the heading (^....\\x0d\\x0a)\n         while (read < value.length) {\n            byte val_next = value[read++];\n            if (val_next == CT) {      //  start of a new section , first is the heading\n               val_next =  (read < value.length) ? value[read++] : 0x00;\n               // AP, NYT, and Bloomberg end with < , Reuters with EOL\n               while ((val_next != LT) && (val_next != CR) && (val_next != LF)) {   // less than delimiter (\\x3c) and not EOL\n                  bdy_heading += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (read > value.length) { break; }  // shouldn't ever hit this, but save a NPE\n               }\n               if (val_next == LT) {\n                  // hit the delimiter, carry on\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n               while (bdy_heading.length() > 0 && ((val_next == CR) || (val_next == LF))) {\n                  val_next =  (read < value.length) ? value[read++] : 0x00;  // skip the new lines\n                  if ((val_next != CR) && (val_next != LF)) {\n                     --read;\n                  }\n               }\n            }\n            else {\n               // this will only be hit on poorly-formed files\n\n               // for reuters, the heading does not start with the ^, so we push one back into the stream\n               if (FORMAT == this.FMT_IPTC_RTR) {\n                  if (val_next != CT) {\n                     // for any non-whitespace, we need to go back an additional step to non destroy the data\n                     if ((val_next != SP) && (val_next != TB) && (val_next != CR) && (val_next != LF)) {\n                        // if the very first byte is data, we have to shift the whole array, and stuff in a carat\n                        if (read == 1) {\n                           byte[] resize = new byte[value.length + 1];\n                           System.arraycopy(value, 0, resize, 1, value.length);\n                           value = resize;\n                        }\n                     }\n                     value[--read] = CT;\n                     continue;\n                  }\n               }\n            }\n            break;\n         }\n\n         // pull apart the body, getting the title (^....\\x0d\\x0a)\n         while (read < value.length) {\n            byte val_next = value[read++];\n            if (val_next == CT) {      //  start of a new section , first is the heading\n               val_next =  (read < value.length) ? value[read++] : 0x00;\n               // AP, NYT, and Bloomberg end with < , Reuters with EOL\n               while ((val_next != LT) && (val_next != CT) && (val_next != CR) && (val_next != LF)) {   // less than delimiter (\\x3c), or carat (\\x5e) and not EOL\n                  bdy_title += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (read > value.length) { break; }  // shouldn't ever hit this, but save a NPE\n               }\n\n               if (val_next == CT) {      //  start of a new section , when first didn't finish cleanly\n                   --read;\n               }\n\n               if (val_next == LT) {\n                  // hit the delimiter, carry on\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n\n               while (bdy_title.length() > 0 && ((val_next == CR) || (val_next == LF))) {\n                  val_next =  (read < value.length) ? value[read++] : 0x00;  // skip the new lines\n                  if ((val_next != CR) && (val_next != LF)) {\n                     --read;\n                  }\n               }\n            }\n            else {\n               // this will only be hit on poorly-formed files\n\n               // for bloomberg, the title does not start with the ^, so we push one back into the stream\n               if (FORMAT == this.FMT_IPTC_BLM) {\n                  if (val_next == TB) {\n                     value[--read] = CT;\n                     continue;\n                  }\n               }\n\n               // for reuters, the title does not start with the ^, so we push one back into the stream\n               if (FORMAT == this.FMT_IPTC_RTR) {\n                  if (val_next != CT) {\n                     // for any non-whitespace, we need to go back an additional step to non destroy the data\n                     if ((val_next != SP) && (val_next != TB) && (val_next != CR) && (val_next != LF)) {\n                        --read;\n                     }\n                     value[--read] = CT;\n                     continue;\n                  }\n               }\n            }\n            break;\n         }\n\n\n         // at this point, we have a variable number of metadata lines, with various orders\n         // we scan the start of each line for the special character, and run to the end character\n         // pull apart the body, getting the title (^....\\x0d\\x0a)\n         boolean metastarted = false;\n         String longline = \"\";\n         String longkey = \"\";\n         while (read < value.length) {\n            byte val_next = value[read++];\n\n            // eat up whitespace before committing to the next section\n            if ((val_next == SP) || (val_next == TB) || (val_next == CR) || (val_next == LF)) {\n               continue;\n            }\n\n            if (val_next == CT) {      //  start of a new section , could be authors, sources, etc\n               val_next =  (read < value.length) ? value[read++] : 0x00;\n               String tmp_line = \"\";\n               while ((val_next != LT) && (val_next != CT) && (val_next != CR) && (val_next != LF) && (val_next != 0))  {\n                  // less than delimiter (\\x3c), maybe also badly formed with just new line\n                  tmp_line += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (read > value.length) { break; }  // shouldn't ever hit this, but save a NPE\n               }\n\n               if (val_next == CT) {      //  start of a new section , when first didn't finish cleanly\n                   --read;\n               }\n\n               if (val_next == LT) {\n                  // hit the delimiter, carry on\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n\n               while ((val_next == CR) || (val_next == LF)) {\n                  val_next =  (read < value.length) ? value[read++] : 0x00;  // skip the new lines\n                  if ((val_next != CR) && (val_next != LF)) {\n                     --read;\n                  }\n               }\n               if (tmp_line.toLowerCase(Locale.ROOT).startsWith(\"by\") || longline.equals(\"bdy_author\")) {\n                  longkey = \"bdy_author\";\n\n                  // prepend a space to subsequent line, so it gets parsed consistent with the lead line\n                  tmp_line = (longline.equals(longkey) ? \" \" : \"\") + tmp_line;\n\n                  // we have an author candidate\n                  int term = tmp_line.length();\n                  term = Math.min(term, (tmp_line.contains(\"<\") ? tmp_line.indexOf(\"<\")  : term));\n                  term = Math.min(term, (tmp_line.contains(\"=\") ? tmp_line.indexOf(\"=\")  : term));\n                  term = Math.min(term, (tmp_line.contains(\"\\n\") ? tmp_line.indexOf(\"\\n\") : term));\n                  term = (term > 0 ) ? term : tmp_line.length();\n                  bdy_author += tmp_line.substring(tmp_line.indexOf(\" \"), term);\n                  metastarted = true;\n                  longline = ((tmp_line.contains(\"=\")) && (!longline.equals(longkey)) ? longkey : \"\");\n               }\n               else if (FORMAT == this.FMT_IPTC_BLM) {\n                  String byline = \"   by \";\n                  if (tmp_line.toLowerCase(Locale.ROOT).contains(byline)) {\n                     longkey = \"bdy_author\";\n\n                     int term = tmp_line.length();\n                     term = Math.min(term, (tmp_line.contains(\"<\") ? tmp_line.indexOf(\"<\")  : term));\n                     term = Math.min(term, (tmp_line.contains(\"=\") ? tmp_line.indexOf(\"=\")  : term));\n                     term = Math.min(term, (tmp_line.contains(\"\\n\") ? tmp_line.indexOf(\"\\n\") : term));\n                     term = (term > 0 ) ? term : tmp_line.length();\n                     // for bloomberg, the author line sits below their copyright statement\n                     bdy_author += tmp_line.substring(tmp_line.toLowerCase(Locale.ROOT).indexOf(byline) + byline.length(), term) + \" \";\n                     metastarted = true;\n                     longline = ((tmp_line.contains(\"=\")) && (!longline.equals(longkey)) ? longkey : \"\");\n                  }\n                  else if(tmp_line.toLowerCase(Locale.ROOT).startsWith(\"c.\")) {\n                     // the author line for bloomberg is a multiline starting with c.2011 Bloomberg News\n                     // then containing the author info on the next line\n                     if (val_next == TB) {\n                        value[--read] = CT;\n                        continue;\n                     }\n                  }\n                  else if(tmp_line.toLowerCase(Locale.ROOT).trim().startsWith(\"(\") && tmp_line.toLowerCase(Locale.ROOT).trim().endsWith(\")\")) {\n                     // the author line may have one or more comment lines between the copyright\n                     // statement, and the By AUTHORNAME line\n                     if (val_next == TB) {\n                        value[--read] = CT;\n                        continue;\n                     }\n                  }\n               }\n\n               else if (tmp_line.toLowerCase(Locale.ROOT).startsWith(\"eds\") || longline.equals(\"bdy_source\")) {\n                  longkey = \"bdy_source\";\n                  // prepend a space to subsequent line, so it gets parsed consistent with the lead line\n                  tmp_line = (longline.equals(longkey) ? \" \" : \"\") + tmp_line;\n\n                  // we have a source candidate\n                  int term = tmp_line.length();\n                  term = Math.min(term, (tmp_line.contains(\"<\") ? tmp_line.indexOf(\"<\")  : term));\n                  term = Math.min(term, (tmp_line.contains(\"=\") ? tmp_line.indexOf(\"=\")  : term));\n//                  term = Math.min(term, (tmp_line.indexOf(\"\\n\") > -1 ? tmp_line.indexOf(\"\\n\") : term));\n                  term = (term > 0 ) ? term : tmp_line.length();\n                  bdy_source += tmp_line.substring(tmp_line.indexOf(\" \") + 1, term) + \" \";\n                  metastarted = true;\n                  longline = (!longline.equals(longkey) ? longkey  : \"\");\n               }\n               else {\n                  // this has fallen all the way through.  trap it as part of the subject,\n                  // rather than just losing it\n                  if (!metastarted) {\n                     bdy_title += \" , \" + tmp_line;     //  not sure where else to put this but in the title\n                  }\n                  else {\n                     // what to do with stuff that is metadata, which falls after metadata lines started?\n                     bdy_body += \" \" + tmp_line + \" , \";     //  not sure where else to put this but in the title\n                  }\n               }\n            }\n            else {  // we're on to the main body\n               while ((read < value.length) && (val_next != 0))  {\n                  // read until the train runs out of tracks\n                  bdy_body += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (read > value.length) { break; }  // shouldn't ever hit this, but save a NPE\n               }\n\n            }\n            // we would normally break here, but just let this read out to the end\n         }\n         done = true; // don't let this run back through and start thrashing metadata\n      }\n      properties.put(\"body\", bdy_body);\n      properties.put(\"title\", bdy_title);\n      properties.put(\"subject\", bdy_heading);\n      properties.put(\"author\", bdy_author);\n      properties.put(\"source\", bdy_source);\n\n      added = (bdy_body.length() + bdy_title.length() + bdy_heading.length() + bdy_author.length() +\n               bdy_source.length()) > 0;\n      return added;\n   }\n\n\n   private boolean parseFooter(byte[] value, HashMap<String,String> properties) {\n      boolean added = false;\n\n      String ftr_source = \"\";\n      String ftr_datetime = \"\";\n\n      int read = 0;\n      boolean done = false;\n\n      while (!done && (read < value.length)) {\n\n         // pull apart the footer, getting the news feed source (^....\\x0d\\x0a)\n         byte val_next = value[read++];\n         byte val_peek =  (read < value.length) ? value[read+1] : 0x00;  // skip the new lines\n\n         while (((val_next < (byte)0x30) || (val_next > (byte)0x39)) && (val_next != 0)) {  // consume all non-numerics first\n            ftr_source += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n            val_next =  (read < value.length) ? value[read] : 0x00;  // attempt to read until end of stream\n            read++;\n            if (read > value.length) { break; }  // shouldn't ever hit this, but save a NPE\n         }\n\n         while ((val_next != LT) && (val_next != CR) && (val_next != LF) && (val_next != 0))  {  // get as much timedate as possible\n            // this is an american format, so arrives as mm-dd-yy HHiizzz\n            ftr_datetime += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n            val_next =  (read < value.length) ? value[read++] : 0x00;  // skip the new lines\n            if (read > value.length) { break; }  // shouldn't ever hit this, but save a NPE\n         }\n         if (val_next == LT) {\n            // hit the delimiter, carry on\n            val_next =  (read < value.length) ? value[read++] : 0x00;\n         }\n\n         if (ftr_datetime.length() > 0) {\n            // we want to pass this back in a more friendly format\n            String format_out = \"yyyy-MM-dd'T'HH:mm:ss'Z'\";\n            Date dateunix = new Date();\n            try {\n               // standard ap format\n               String format_in = \"MM-dd-yy HHmmzzz\";\n\n               if (FORMAT == this.FMT_IPTC_RTR) {\n                  // standard reuters format\n                  format_in = \"HH:mm MM-dd-yy\";\n               }\n               SimpleDateFormat dfi = new SimpleDateFormat(format_in, Locale.ROOT);\n               dfi.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n               dateunix = dfi.parse(ftr_datetime);\n            }\n            catch (ParseException ep) {\n               // failed, but this will just fall through to setting the date to now\n            }\n            SimpleDateFormat dfo = new SimpleDateFormat(format_out, Locale.ROOT);\n            dfo.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n            ftr_datetime = dfo.format(dateunix);\n         }\n         while ((val_next == CR) || (val_next == LF)) {\n            val_next =  (read < value.length) ? value[read++] : 0x00;  // skip the new lines\n            if ((val_next != CR) && (val_next != LF)) {\n               --read;\n            }\n         }\n         done = true; // don't let this run back through and start thrashing metadata\n      }\n\n      properties.put(\"publisher\", ftr_source);\n      properties.put(\"created\", ftr_datetime);\n      properties.put(\"modified\", ftr_datetime);\n\n      added = (ftr_source.length() + ftr_datetime.length()) > 0; \n      return added;\n   }\n\n\n   private void setMetadata(Metadata metadata, HashMap<String,String> properties) {\n\n      // every property that gets set must be non-null, or it will cause NPE\n      // in other consuming applications, like Lucene\n      metadata.set(Metadata.CONTENT_TYPE,  clean(\"text/anpa-1312\"));\n      metadata.set(TikaCoreProperties.TITLE,         clean(properties.get(\"title\")));\n      metadata.set(TikaCoreProperties.SUBJECT,       clean(properties.get(\"subject\")));\n      metadata.set(TikaCoreProperties.CREATOR,        clean(properties.get(\"author\")));\n      metadata.set(TikaCoreProperties.CREATED, clean(properties.get(\"created\")));\n      metadata.set(TikaCoreProperties.MODIFIED,      clean(properties.get(\"modified\")));\n      metadata.set(TikaCoreProperties.SOURCE,      clean(properties.get(\"source\")));\n//      metadata.set(TikaCoreProperties.PUBLISHER,     clean(properties.get(\"publisher\")));\n      metadata.set(TikaCoreProperties.PUBLISHER,     clean(this.getFormatName()));\n\n/*\n        metadata.set(TikaCoreProperties.DATE, font.getHeader().getCreated().getTime());\n        metadata.set(\n                Property.internalDate(TikaCoreProperties.MODIFIED),\n                font.getHeader().getModified().getTime());\n*/\n   }\n\n   private String clean(String value) {\n      if (value == null) {\n         value = \"\";\n      }\n\n      value = value.replaceAll(\"``\", \"`\");\n      value = value.replaceAll(\"''\", \"'\");\n      value = value.replaceAll(new String(new char[] {SL}), \"'\");\n      value = value.replaceAll(new String(new char[] {SR}), \"'\");\n      value = value.replaceAll(new String(new char[] {DL}), \"\\\"\");\n      value = value.replaceAll(new String(new char[] {DR}), \"\\\"\");\n      value = value.trim();\n\n      return (value);\n   }\n}\n",
        "human_patch_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.tika.parser.iptc;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.apache.tika.exception.TikaException;\nimport org.apache.tika.metadata.Metadata;\nimport org.apache.tika.metadata.TikaCoreProperties;\nimport org.apache.tika.mime.MediaType;\nimport org.apache.tika.parser.ParseContext;\nimport org.apache.tika.parser.Parser;\nimport org.apache.tika.sax.XHTMLContentHandler;\nimport org.xml.sax.ContentHandler;\nimport org.xml.sax.SAXException;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * Parser for IPTC ANPA New Wire Feeds\n */\npublic class IptcAnpaParser implements Parser {\n    /** Serial version UID */\n    private static final long serialVersionUID = -6062820170212879115L;\n\n    private static final MediaType TYPE =\n        MediaType.text(\"vnd.iptc.anpa\");\n\n    private static final Set<MediaType> SUPPORTED_TYPES =\n        Collections.singleton(TYPE);\n\n    public Set<MediaType> getSupportedTypes(ParseContext context) {\n        return SUPPORTED_TYPES;\n    }\n\n    public void parse(\n           InputStream stream, ContentHandler handler,\n           Metadata metadata, ParseContext context)\n           throws IOException, SAXException, TikaException {\n\n        HashMap<String,String> properties = this.loadProperties(stream);\n        this.setMetadata(metadata, properties);\n\n        XHTMLContentHandler xhtml = new XHTMLContentHandler(handler, metadata);\n        xhtml.startDocument();\n        // TODO: put body content here\n        xhtml.startElement(\"p\");\n        String body = clean(properties.get(\"body\"));\n        if (body != null)\n           xhtml.characters(body);\n        xhtml.endElement(\"p\");\n        xhtml.endDocument();\n    }\n\n    /**\n     * @deprecated This method will be removed in Apache Tika 1.0.\n     */\n    public void parse(\n            InputStream stream, ContentHandler handler, Metadata metadata)\n            throws IOException, SAXException, TikaException {\n        parse(stream, handler, metadata, new ParseContext());\n    }\n\n\n   private int FMT_ANPA_1312    = 0x00;   // \"NAA 89-3 (ANPA 1312)\"\n   private int FMT_ANPA_UPI     = 0x01;   // \"United Press International ANPA 1312 variant\"\n   private int FMT_ANPA_UPI_DL  = 0x02;   // \"United Press International Down-Load Message\"\n   private int FMT_IPTC_7901    = 0x03;   // \"IPTC7901 Recommended Message Format\"\n   private int FMT_IPTC_PHOTO   = 0x04;   // \"IPTC-NAA Digital Newsphoto Parameter Record\"\n   private int FMT_IPTC_CHAR    = 0x05;   // \"IPTC Unstructured Character Oriented File Format (UCOFF)\"\n   private int FMT_NITF         = 0x06;   // \"News Industry Text Format (NITF)\"\n   private int FMT_NITF_TT      = 0x07;   // \"Tidningarnas Telegrambyra NITF version (TTNITF DTD)\"\n   private int FMT_NITF_RB      = 0x08;   // \"Ritzaus Bureau NITF version (RBNITF DTD)\"\n   private int FMT_IPTC_AP      = 0x09;   // \"Associated Press news wire format\"\n   private int FMT_IPTC_BLM     = 0x0A;   // \"Bloomberg News news wire format\"\n   private int FMT_IPTC_NYT     = 0x0B;   // \"New York Times news wire format\"\n   private int FMT_IPTC_RTR     = 0x0C;   // \"Reuters news wire format\"\n\n   private int FORMAT = FMT_ANPA_1312;    // assume the default format to be ANPA-1312\n\n   private final static char SOH = 0x01;    // start of header (ctrl-a)\n   private final static char STX = 0x02;    // start of text (ctrl-b)\n   private final static char ETX = 0x03;    // end of text (ctrl-c)\n   private final static char EOT = 0x04;    // the tab character (ctrl-d)\n   private final static char SYN = 0x16;    // synchronous idle (ctrl-v)\n\n   private final static char BS = 0x08;    // the backspace character (used for diacriticals)\n   private final static char TB = 0x09;    // the tab character\n   private final static char LF = 0x0A;    // line feed\n   private final static char FF = 0x0C;    // form feed\n   private final static char CR = 0x0D;    // carriage return\n   private final static char XQ = 0x11;    // device control (ctrl-q)\n   private final static char XS = 0x13;    // device control (ctrl-s)\n   private final static char FS = 0x1F;    // a field delimiter\n\n   private final static char HY = 0x2D;    // hyphen\n   private final static char SP = 0x20;    // the blank space\n   private final static char LT = 0x3C;    // less than\n   private final static char EQ = 0x3D;    // less than\n   private final static char CT = 0x5E;    // carat\n\n   private final static char SL = 0x91;    // single-quote left\n   private final static char SR = 0x92;    // single-quote right\n   private final static char DL = 0x93;    // double-quote left\n   private final static char DR = 0x94;    // double-quote right\n\n\n   /**\n    * scan the news messsage and store the metadata and data into a map\n    */\n   private HashMap<String,String> loadProperties(InputStream is) {\n      \n      HashMap<String,String> properties = new HashMap<String,String>();\n\n      FORMAT = this.scanFormat(is);\n\n      byte[] residual = this.getSection(is,\"residual\");\n\n      byte[] header = this.getSection(is,\"header\");\n      parseHeader(header, properties);\n\n      byte[] body = this.getSection(is,\"body\");\n      parseBody(body, properties);\n\n      byte[] footer = this.getSection(is,\"footer\");\n      parseFooter(footer, properties);\n       \n      return (properties);\n   }\n\n\n   private int scanFormat(InputStream is) {\n      int format    = this.FORMAT;\n      int  maxsize  = 524288;     //  512K\n\n      byte[] buf = new byte[maxsize];\n      try {\n         if (is.markSupported()) {\n            is.mark(maxsize);\n         }\n         int msgsize = is.read(buf);                // read in at least the full data\n\n         String message = (new String(buf, UTF_8)).toLowerCase(Locale.ROOT);\n         // these are not if-then-else, because we want to go from most common\n         // and fall through to least.  this is imperfect, as these tags could\n         // show up in other agency stories, but i can't find a spec or any\n         // explicit codes to identify the wire source in the message itself\n\n         if (message.contains(\"ap-wf\")) {\n            format = this.FMT_IPTC_AP;\n         }\n         if (message.contains(\"reuters\")) {\n            format = this.FMT_IPTC_RTR;\n         }\n         if (message.contains(\"new york times\")) {\n            format = this.FMT_IPTC_NYT;\n         }\n         if (message.contains(\"bloomberg news\")) {\n            format = this.FMT_IPTC_BLM;\n         }\n      }\n      catch (IOException eio) {\n         // we are in an unstable state\n      }\n\n      try {\n         if (is.markSupported()) {\n            is.reset();\n         }\n      }\n      catch (IOException eio) {\n         // we are in an unstable state\n      }\n      return (format);\n   }\n\n\n   private void setFormat(int format) {\n      this.FORMAT = format;\n   }\n\n\n   private String getFormatName() {\n      \n      String name = \"\";\n      \n      if (FORMAT == this.FMT_IPTC_AP) {\n         name = \"Associated Press\";\n      }\n      \n      else if(FORMAT == this.FMT_IPTC_BLM) {\n         name = \"Bloomberg\";\n      }\n\n      else if(FORMAT == this.FMT_IPTC_NYT) {\n         name = \"New York Times\";\n      }\n\n      else if(FORMAT == this.FMT_IPTC_RTR) {\n         name = \"Reuters\";\n      }\n\n      return (name);\n   }\n\n\n   private byte[] getSection(InputStream is, String name) {\n\n      byte[] value = new byte[0];\n\n      if (name.equals(\"residual\")) {\n         // the header shouldn't be more than 1k, but just being generous here\n         int  maxsize  = 8192;     //  8K\n         byte bstart   = SYN;     // check for SYN [0x16 : ctrl-v] (may have leftover residue from preceding message)\n         byte bfinish  = SOH;     // check for SOH [0x01 : ctrl-a] (typically follows a pair of SYN [0x16 : ctrl-v])\n         value = getSection(is, maxsize, bstart, bfinish, true);\n      }\n\n      else if(name.equals(\"header\")) {\n         // the header shouldn't be more than 1k, but just being generous here\n         int  maxsize  = 8192;     //  8K\n         byte bstart   = SOH;     // check for SOH [0x01 : ctrl-a] (typically follows a pair of SYN [0x16 : ctrl-v])\n         byte bfinish  = STX;     // check for STX [0x02 : ctrl-b] (marks end of header, beginning of message)\n         value = getSection(is, maxsize, bstart, bfinish, true);\n      }\n\n      else if (name.equals(\"body\")) {\n         // the message shouldn't be more than 16k (?), leaving plenty of space\n         int  maxsize  = 524288;     //  512K\n         byte bstart   = STX;     // check for STX [0x02 : ctrl-b] (marks end of header, beginning of message)\n         byte bfinish  = ETX;     // check for ETX [0x03 : ctrl-c] (marks end of message, beginning of footer)\n         value = getSection(is, maxsize, bstart, bfinish, true);\n      }\n\n      else if (name.equals(\"footer\")) {\n         // the footer shouldn't be more than 1k , leaving plenty of space\n         int maxsize   = 8192;     //  8K\n         byte bstart   = ETX;     // check for ETX [0x03 : ctrl-c] (marks end of message, beginning of footer)\n         byte bfinish  = EOT;     // check for EOT [0x04 : ctrl-d] (marks end of transmission)\n         value = getSection(is, maxsize, bstart, bfinish, true);\n      }\n\n      return (value);\n   }\n\n\n   private byte[] getSection(InputStream is, int maxsize, byte bstart, byte bfinish, boolean ifincomplete) {\n      byte[] value  = new byte[0];\n\n      try {\n         boolean started = false;                   // check if we have found the start flag\n         boolean finished = false;                  // check if we have found the finish flag\n         int read = 0;                              // the number of bytes we read\n         int start = 0;                             // the position after the start flag\n\n         // TODO: this only pulls back 8K of data on a read, regardless of buffer size\n         //       more nefariously, it caps at a total 8K, through all sections\n         int streammax = is.available();\n         maxsize = Math.min(maxsize, streammax);\n\n         is.mark(maxsize);\n         byte[] buf = new byte[maxsize];\n         int totsize = 0;\n         int remainder = maxsize - totsize;\n         while (remainder > 0) {\n            int msgsize = is.read(buf, maxsize-remainder, maxsize);    // read in at least the full data\n            if (msgsize == -1) {\n               remainder = msgsize = 0;\n            }\n            remainder -= msgsize;\n            totsize   += msgsize;\n         }\n\n         // scan through the provided input stream\n         for (read=0; read < totsize; read++) {\n            byte b = buf[read];\n\n            if (!started) {\n               started = (b == bstart);\n               start = read + 1;\n               continue;\n            }\n\n            if (finished = (b == bfinish)) {\n/*\n               is.reset();\n               long skipped = is.skip((long)read);\n               if (skipped != read) {\n                  // we are in an unstable state\n               }\n               is.mark(1);\n */\n               break;\n            }\n\n            // load from the stream until we run out of characters, or hit the termination byte\n            continue;\n         }\n\n         // move the input stream back to where it was initially\n         is.reset();\n\n         if (finished) {\n            // now, we want to reset the stream to be sitting right on top of the finish marker\n            is.skip(read);\n            value = new byte[read-start];\n            System.arraycopy(buf, start, value, 0, read-start);\n         }\n         else {\n            if (ifincomplete && started) {\n               // the caller wants anything that was read, and we finished the stream or buffer\n               value = new byte[read-start];\n               System.arraycopy(buf, start, value, 0, read-start);\n            }\n         }\n      }\n      catch (IOException eio) {\n         // something invalid occurred, return an empty string\n      }\n\n      return (value);\n   }\n\n\n   private boolean parseHeader(byte[] value, HashMap<String,String> properties) {\n      boolean added = false;\n\n      String env_serviceid = \"\";\n      String env_category = \"\";\n      String env_urgency = \"\";\n      String hdr_edcode = \"\";\n      String hdr_subject = \"\";\n      String hdr_date = \"\";\n      String hdr_time = \"\";\n\n      int read = 0;\n\n      while (read < value.length) {\n\n         // pull apart the envelope, getting the service id  (....\\x1f)\n         while (read < value.length) {\n            byte val_next = value[read++];\n            if (val_next != FS) {\n               env_serviceid += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n            }\n            else {\n               break;\n            }\n         }\n\n         // pull apart the envelope, getting the category  (....\\x13\\x11)\n         while (read < value.length) {\n            byte val_next = value[read++];\n            if (val_next != XS) {   // the end of the envelope is marked (\\x13)\n               env_category += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n            }\n            else {\n               val_next = value[read];  // get the remaining byte (\\x11)\n               if (val_next == XQ) {\n                  read++;\n               }\n               break;\n            }\n         }\n\n         // pull apart the envelope, getting the subject heading\n         while (read < value.length) {\n            boolean subject = true;\n            byte val_next = value[read++];\n            while ((subject) && (val_next != SP) && (val_next != 0x00)) {  // ignore the envelope subject\n               hdr_subject += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n               val_next =  (read < value.length) ? value[read++] : 0x00;\n               while (val_next == SP) {  // consume all the spaces\n                  subject = false;\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (val_next != SP) {\n                     --read;  // otherwise we eat into the next section\n                  }\n               }\n            }\n            if (!subject) {\n               break;\n            }\n         }\n\n         // pull apart the envelope, getting the date and time\n         while (read < value.length) {\n            byte val_next = value[read++];\n            if (hdr_date.length() == 0) {\n               while (((val_next >= (byte)0x30) && (val_next <= (byte)0x39))  // consume all numerics and hyphens\n                  ||   (val_next == HY)) {\n                  hdr_date += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n            }\n            else if (val_next == SP) {\n               while (val_next == SP) {  // consume all the spaces\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n               continue;\n            }\n            else {\n               while (((val_next >= (byte)0x30) && (val_next <= (byte)0x39))  // consume all numerics and hyphens\n                  ||   (val_next == HY)) {\n                  hdr_time += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n            }\n         }\n         break; // don't let this run back through and start thrashing metadata\n      }\n\n      // if we were saving any of these values, we would set the properties map here\n\n      added = (env_serviceid.length() + env_category.length() + hdr_subject.length() + \n               hdr_date.length() + hdr_time.length()) > 0; \n      return added;\n   }\n\n   private boolean parseBody(byte[] value, HashMap<String,String> properties) {\n      boolean added = false;\n\n      String bdy_heading = \"\";\n      String bdy_title = \"\";\n      String bdy_source = \"\";\n      String bdy_author = \"\";\n      String bdy_body = \"\";\n\n      int read = 0;\n      boolean done = false;\n\n      while (!done && (read < value.length)) {\n\n         // pull apart the body, getting the heading (^....\\x0d\\x0a)\n         while (read < value.length) {\n            byte val_next = value[read++];\n            if (val_next == CT) {      //  start of a new section , first is the heading\n               val_next =  (read < value.length) ? value[read++] : 0x00;\n               // AP, NYT, and Bloomberg end with < , Reuters with EOL\n               while ((val_next != LT) && (val_next != CR) && (val_next != LF)) {   // less than delimiter (\\x3c) and not EOL\n                  bdy_heading += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (read >= value.length) { break; }  // shouldn't ever hit this, but save a NPE\n               }\n               if (val_next == LT) {\n                  // hit the delimiter, carry on\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n               while (bdy_heading.length() > 0 && ((val_next == CR) || (val_next == LF))) {\n                  val_next =  (read < value.length) ? value[read++] : 0x00;  // skip the new lines\n                  if ((val_next != CR) && (val_next != LF)) {\n                     --read;\n                  }\n               }\n            }\n            else {\n               // this will only be hit on poorly-formed files\n\n               // for reuters, the heading does not start with the ^, so we push one back into the stream\n               if (FORMAT == this.FMT_IPTC_RTR) {\n                  if (val_next != CT) {\n                     // for any non-whitespace, we need to go back an additional step to non destroy the data\n                     if ((val_next != SP) && (val_next != TB) && (val_next != CR) && (val_next != LF)) {\n                        // if the very first byte is data, we have to shift the whole array, and stuff in a carat\n                        if (read == 1) {\n                           byte[] resize = new byte[value.length + 1];\n                           System.arraycopy(value, 0, resize, 1, value.length);\n                           value = resize;\n                        }\n                     }\n                     value[--read] = CT;\n                     continue;\n                  }\n               }\n            }\n            break;\n         }\n\n         // pull apart the body, getting the title (^....\\x0d\\x0a)\n         while (read < value.length) {\n            byte val_next = value[read++];\n            if (val_next == CT) {      //  start of a new section , first is the heading\n               val_next =  (read < value.length) ? value[read++] : 0x00;\n               // AP, NYT, and Bloomberg end with < , Reuters with EOL\n               while ((val_next != LT) && (val_next != CT) && (val_next != CR) && (val_next != LF)) {   // less than delimiter (\\x3c), or carat (\\x5e) and not EOL\n                  bdy_title += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (read >= value.length) { break; }  // shouldn't ever hit this, but save a NPE\n               }\n\n               if (val_next == CT) {      //  start of a new section , when first didn't finish cleanly\n                   --read;\n               }\n\n               if (val_next == LT) {\n                  // hit the delimiter, carry on\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n\n               while (bdy_title.length() > 0 && ((val_next == CR) || (val_next == LF))) {\n                  val_next =  (read < value.length) ? value[read++] : 0x00;  // skip the new lines\n                  if ((val_next != CR) && (val_next != LF)) {\n                     --read;\n                  }\n               }\n            }\n            else {\n               // this will only be hit on poorly-formed files\n\n               // for bloomberg, the title does not start with the ^, so we push one back into the stream\n               if (FORMAT == this.FMT_IPTC_BLM) {\n                  if (val_next == TB) {\n                     value[--read] = CT;\n                     continue;\n                  }\n               }\n\n               // for reuters, the title does not start with the ^, so we push one back into the stream\n               if (FORMAT == this.FMT_IPTC_RTR) {\n                  if (val_next != CT) {\n                     // for any non-whitespace, we need to go back an additional step to non destroy the data\n                     if ((val_next != SP) && (val_next != TB) && (val_next != CR) && (val_next != LF)) {\n                        --read;\n                     }\n                     value[--read] = CT;\n                     continue;\n                  }\n               }\n            }\n            break;\n         }\n\n\n         // at this point, we have a variable number of metadata lines, with various orders\n         // we scan the start of each line for the special character, and run to the end character\n         // pull apart the body, getting the title (^....\\x0d\\x0a)\n         boolean metastarted = false;\n         String longline = \"\";\n         String longkey = \"\";\n         while (read < value.length) {\n            byte val_next = value[read++];\n\n            // eat up whitespace before committing to the next section\n            if ((val_next == SP) || (val_next == TB) || (val_next == CR) || (val_next == LF)) {\n               continue;\n            }\n\n            if (val_next == CT) {      //  start of a new section , could be authors, sources, etc\n               val_next =  (read < value.length) ? value[read++] : 0x00;\n               String tmp_line = \"\";\n               while ((val_next != LT) && (val_next != CT) && (val_next != CR) && (val_next != LF) && (val_next != 0))  {\n                  // less than delimiter (\\x3c), maybe also badly formed with just new line\n                  tmp_line += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (read >= value.length) { break; }  // shouldn't ever hit this, but save a NPE\n               }\n\n               if (val_next == CT) {      //  start of a new section , when first didn't finish cleanly\n                   --read;\n               }\n\n               if (val_next == LT) {\n                  // hit the delimiter, carry on\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n\n               while ((val_next == CR) || (val_next == LF)) {\n                  val_next =  (read < value.length) ? value[read++] : 0x00;  // skip the new lines\n                  if ((val_next != CR) && (val_next != LF)) {\n                     --read;\n                  }\n               }\n               if (tmp_line.toLowerCase(Locale.ROOT).startsWith(\"by\") || longline.equals(\"bdy_author\")) {\n                  longkey = \"bdy_author\";\n\n                  // prepend a space to subsequent line, so it gets parsed consistent with the lead line\n                  tmp_line = (longline.equals(longkey) ? \" \" : \"\") + tmp_line;\n\n                  // we have an author candidate\n                  int term = tmp_line.length();\n                  term = Math.min(term, (tmp_line.contains(\"<\") ? tmp_line.indexOf(\"<\")  : term));\n                  term = Math.min(term, (tmp_line.contains(\"=\") ? tmp_line.indexOf(\"=\")  : term));\n                  term = Math.min(term, (tmp_line.contains(\"\\n\") ? tmp_line.indexOf(\"\\n\") : term));\n                  term = (term > 0 ) ? term : tmp_line.length();\n                  bdy_author += tmp_line.substring(tmp_line.indexOf(\" \"), term);\n                  metastarted = true;\n                  longline = ((tmp_line.contains(\"=\")) && (!longline.equals(longkey)) ? longkey : \"\");\n               }\n               else if (FORMAT == this.FMT_IPTC_BLM) {\n                  String byline = \"   by \";\n                  if (tmp_line.toLowerCase(Locale.ROOT).contains(byline)) {\n                     longkey = \"bdy_author\";\n\n                     int term = tmp_line.length();\n                     term = Math.min(term, (tmp_line.contains(\"<\") ? tmp_line.indexOf(\"<\")  : term));\n                     term = Math.min(term, (tmp_line.contains(\"=\") ? tmp_line.indexOf(\"=\")  : term));\n                     term = Math.min(term, (tmp_line.contains(\"\\n\") ? tmp_line.indexOf(\"\\n\") : term));\n                     term = (term > 0 ) ? term : tmp_line.length();\n                     // for bloomberg, the author line sits below their copyright statement\n                     bdy_author += tmp_line.substring(tmp_line.toLowerCase(Locale.ROOT).indexOf(byline) + byline.length(), term) + \" \";\n                     metastarted = true;\n                     longline = ((tmp_line.contains(\"=\")) && (!longline.equals(longkey)) ? longkey : \"\");\n                  }\n                  else if(tmp_line.toLowerCase(Locale.ROOT).startsWith(\"c.\")) {\n                     // the author line for bloomberg is a multiline starting with c.2011 Bloomberg News\n                     // then containing the author info on the next line\n                     if (val_next == TB) {\n                        value[--read] = CT;\n                        continue;\n                     }\n                  }\n                  else if(tmp_line.toLowerCase(Locale.ROOT).trim().startsWith(\"(\") && tmp_line.toLowerCase(Locale.ROOT).trim().endsWith(\")\")) {\n                     // the author line may have one or more comment lines between the copyright\n                     // statement, and the By AUTHORNAME line\n                     if (val_next == TB) {\n                        value[--read] = CT;\n                        continue;\n                     }\n                  }\n               }\n\n               else if (tmp_line.toLowerCase(Locale.ROOT).startsWith(\"eds\") || longline.equals(\"bdy_source\")) {\n                  longkey = \"bdy_source\";\n                  // prepend a space to subsequent line, so it gets parsed consistent with the lead line\n                  tmp_line = (longline.equals(longkey) ? \" \" : \"\") + tmp_line;\n\n                  // we have a source candidate\n                  int term = tmp_line.length();\n                  term = Math.min(term, (tmp_line.contains(\"<\") ? tmp_line.indexOf(\"<\")  : term));\n                  term = Math.min(term, (tmp_line.contains(\"=\") ? tmp_line.indexOf(\"=\")  : term));\n//                  term = Math.min(term, (tmp_line.indexOf(\"\\n\") > -1 ? tmp_line.indexOf(\"\\n\") : term));\n                  term = (term > 0 ) ? term : tmp_line.length();\n                  bdy_source += tmp_line.substring(tmp_line.indexOf(\" \") + 1, term) + \" \";\n                  metastarted = true;\n                  longline = (!longline.equals(longkey) ? longkey  : \"\");\n               }\n               else {\n                  // this has fallen all the way through.  trap it as part of the subject,\n                  // rather than just losing it\n                  if (!metastarted) {\n                     bdy_title += \" , \" + tmp_line;     //  not sure where else to put this but in the title\n                  }\n                  else {\n                     // what to do with stuff that is metadata, which falls after metadata lines started?\n                     bdy_body += \" \" + tmp_line + \" , \";     //  not sure where else to put this but in the title\n                  }\n               }\n            }\n            else {  // we're on to the main body\n               while ((read < value.length) && (val_next != 0))  {\n                  // read until the train runs out of tracks\n                  bdy_body += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (read >= value.length) { break; }  // shouldn't ever hit this, but save a NPE\n               }\n\n            }\n            // we would normally break here, but just let this read out to the end\n         }\n         done = true; // don't let this run back through and start thrashing metadata\n      }\n      properties.put(\"body\", bdy_body);\n      properties.put(\"title\", bdy_title);\n      properties.put(\"subject\", bdy_heading);\n      properties.put(\"author\", bdy_author);\n      properties.put(\"source\", bdy_source);\n\n      added = (bdy_body.length() + bdy_title.length() + bdy_heading.length() + bdy_author.length() +\n               bdy_source.length()) > 0;\n      return added;\n   }\n\n\n   private boolean parseFooter(byte[] value, HashMap<String,String> properties) {\n      boolean added = false;\n\n      String ftr_source = \"\";\n      String ftr_datetime = \"\";\n\n      int read = 0;\n      boolean done = false;\n\n      while (!done && (read < value.length)) {\n\n         // pull apart the footer, getting the news feed source (^....\\x0d\\x0a)\n         byte val_next = value[read++];\n         byte val_peek =  (read < value.length) ? value[read+1] : 0x00;  // skip the new lines\n\n         while (((val_next < (byte)0x30) || (val_next > (byte)0x39)) && (val_next != 0)) {  // consume all non-numerics first\n            ftr_source += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n            val_next =  (read < value.length) ? value[read] : 0x00;  // attempt to read until end of stream\n            read++;\n            if (read >= value.length) { break; }  // shouldn't ever hit this, but save a NPE\n         }\n\n         while ((val_next != LT) && (val_next != CR) && (val_next != LF) && (val_next != 0))  {  // get as much timedate as possible\n            // this is an american format, so arrives as mm-dd-yy HHiizzz\n            ftr_datetime += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n            val_next =  (read < value.length) ? value[read++] : 0x00;  // skip the new lines\n            if (read >= value.length) { break; }  // shouldn't ever hit this, but save a NPE\n         }\n         if (val_next == LT) {\n            // hit the delimiter, carry on\n            val_next =  (read < value.length) ? value[read++] : 0x00;\n         }\n\n         if (ftr_datetime.length() > 0) {\n            // we want to pass this back in a more friendly format\n            String format_out = \"yyyy-MM-dd'T'HH:mm:ss'Z'\";\n            Date dateunix = new Date();\n            try {\n               // standard ap format\n               String format_in = \"MM-dd-yy HHmmzzz\";\n\n               if (FORMAT == this.FMT_IPTC_RTR) {\n                  // standard reuters format\n                  format_in = \"HH:mm MM-dd-yy\";\n               }\n               SimpleDateFormat dfi = new SimpleDateFormat(format_in, Locale.ROOT);\n               dfi.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n               dateunix = dfi.parse(ftr_datetime);\n            }\n            catch (ParseException ep) {\n               // failed, but this will just fall through to setting the date to now\n            }\n            SimpleDateFormat dfo = new SimpleDateFormat(format_out, Locale.ROOT);\n            dfo.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n            ftr_datetime = dfo.format(dateunix);\n         }\n         while ((val_next == CR) || (val_next == LF)) {\n            val_next =  (read < value.length) ? value[read++] : 0x00;  // skip the new lines\n            if ((val_next != CR) && (val_next != LF)) {\n               --read;\n            }\n         }\n         done = true; // don't let this run back through and start thrashing metadata\n      }\n\n      properties.put(\"publisher\", ftr_source);\n      properties.put(\"created\", ftr_datetime);\n      properties.put(\"modified\", ftr_datetime);\n\n      added = (ftr_source.length() + ftr_datetime.length()) > 0; \n      return added;\n   }\n\n\n   private void setMetadata(Metadata metadata, HashMap<String,String> properties) {\n\n      // every property that gets set must be non-null, or it will cause NPE\n      // in other consuming applications, like Lucene\n      metadata.set(Metadata.CONTENT_TYPE,  clean(\"text/anpa-1312\"));\n      metadata.set(TikaCoreProperties.TITLE,         clean(properties.get(\"title\")));\n      metadata.set(TikaCoreProperties.SUBJECT,       clean(properties.get(\"subject\")));\n      metadata.set(TikaCoreProperties.CREATOR,        clean(properties.get(\"author\")));\n      metadata.set(TikaCoreProperties.CREATED, clean(properties.get(\"created\")));\n      metadata.set(TikaCoreProperties.MODIFIED,      clean(properties.get(\"modified\")));\n      metadata.set(TikaCoreProperties.SOURCE,      clean(properties.get(\"source\")));\n//      metadata.set(TikaCoreProperties.PUBLISHER,     clean(properties.get(\"publisher\")));\n      metadata.set(TikaCoreProperties.PUBLISHER,     clean(this.getFormatName()));\n\n/*\n        metadata.set(TikaCoreProperties.DATE, font.getHeader().getCreated().getTime());\n        metadata.set(\n                Property.internalDate(TikaCoreProperties.MODIFIED),\n                font.getHeader().getModified().getTime());\n*/\n   }\n\n   private String clean(String value) {\n      if (value == null) {\n         value = \"\";\n      }\n\n      value = value.replaceAll(\"``\", \"`\");\n      value = value.replaceAll(\"''\", \"'\");\n      value = value.replaceAll(new String(new char[] {SL}), \"'\");\n      value = value.replaceAll(new String(new char[] {SR}), \"'\");\n      value = value.replaceAll(new String(new char[] {DL}), \"\\\"\");\n      value = value.replaceAll(new String(new char[] {DR}), \"\\\"\");\n      value = value.trim();\n\n      return (value);\n   }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-37": {
    "vul_id": "VUL4J-37",
    "cve_id": "CVE-2015-8581",
    "project": "apache_tomee",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl container/openejb-core -Dtest=org.apache.openejb.core.rmi.BlacklistClassResolverTest#wildcard",
    "test_all_cmd": "mvn test -pl container/openejb-core",
    "human_patch_url": "https://github.com/apache/tomee/commit/58cdbbef9c77ab2b44870f9d606593b49cde76d9",
    "vulnerable_files": [
      {
        "file_path": "arquillian/arquillian-tomee-common/src/main/java/org/apache/openejb/arquillian/common/Setup.java",
        "file_name": "Setup.java",
        "vulnerable_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.openejb.arquillian.common;\n\nimport org.apache.openejb.loader.ProvisioningUtil;\nimport org.apache.openejb.loader.SystemInstance;\nimport org.apache.openejb.loader.provisining.ProvisioningResolver;\nimport org.apache.tomee.util.QuickServerXmlParser;\nimport org.codehaus.swizzle.stream.ReplaceStringsInputStream;\nimport org.jboss.arquillian.container.spi.client.container.LifecycleException;\nimport org.jboss.shrinkwrap.api.ArchivePaths;\nimport org.jboss.shrinkwrap.api.ShrinkWrap;\nimport org.jboss.shrinkwrap.api.asset.StringAsset;\nimport org.jboss.shrinkwrap.api.exporter.ZipExporter;\nimport org.jboss.shrinkwrap.api.spec.JavaArchive;\n\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Method;\nimport java.net.Socket;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport static java.util.Collections.emptyMap;\n\n/**\n * @version $Rev$ $Date$\n */\npublic class Setup {\n    private static final Logger LOGGER = Logger.getLogger(Setup.class.getName()); // JUL is used by arquillian so that's fine\n    public static final String TOMEE_BEAN_DISCOVERER_JAR = \"lib\" + File.separator + \"xx-arquillian-tomee-bean-discoverer.jar\"; // starts with xx to not be filtered\n    private static final String DEFAULT_MEM_CONFIG = (javaVersion() >= 1.8 ? \"\" : \"-XX:PermSize=64m -XX:MaxPermSize=256m \")\n                                                            + \"-Xmx512m -Xms256m -XX:ReservedCodeCacheSize=64m\";\n\n    private static double javaVersion() {\n        try {\n            return Double.parseDouble(System.getProperty(\"java.version\", \"1.7\").substring(0, 3));\n        } catch (final Exception nfe) {\n            return 1.6;\n        }\n    }\n\n    public static void exportProperties(final File tomeeHome, final TomEEConfiguration c, final boolean defaultMem) {\n        final int httpPort = c.getHttpPort();\n        System.setProperty(\"java.naming.provider.url\", \"http://\" + c.getHost() + \":\" + httpPort + \"/tomee/ejb\");\n        System.setProperty(\"connect.tries\", \"90\");\n        System.setProperty(\"server.http.port\", String.valueOf(httpPort));\n        System.setProperty(\"server.shutdown.port\", String.valueOf(c.getStopPort()));\n        if (defaultMem) {\n            System.setProperty(\"java.opts\", DEFAULT_MEM_CONFIG + \" -Dtomee.httpPort=\" + httpPort);\n        } else {\n            System.setProperty(\"java.opts\", \"-Dtomee.httpPort=\" + httpPort);\n        }\n        System.setProperty(\"openejb.home\", tomeeHome.getAbsolutePath());\n        System.setProperty(\"tomee.home\", tomeeHome.getAbsolutePath());\n    }\n\n    public static void updateServerXml(final File tomeeHome, final TomEEConfiguration configuration) throws IOException {\n        final File serverXml = Files.path(new File(tomeeHome.getAbsolutePath()), \"conf\", \"server.xml\");\n        if (!serverXml.exists()) {\n            return;\n        }\n\n        final QuickServerXmlParser ports = QuickServerXmlParser.parse(serverXml);\n        if (configuration.getKeepServerXmlAsThis()) {\n            // force ports to be able to stop the server and get @ArquillianResource\n            configuration.setHttpPort(Integer.parseInt(ports.http()));\n            configuration.setStopPort(Integer.parseInt(ports.stop()));\n            return; // in this case we don't want to override the conf\n        }\n\n        final Map<String, String> replacements = new HashMap<>();\n        replacements.put(ports.http(), String.valueOf(configuration.getHttpPort()));\n        replacements.put(ports.https(), String.valueOf(configuration.getHttpsPort()));\n        replacements.put(ports.stop(), String.valueOf(configuration.getStopPort()));\n        replacements.put(ports.ajp(), String.valueOf(ajpPort(configuration)));\n\n        if (configuration.isUnpackWars()) {\n            replacements.put(\"unpackWARs=\\\"false\\\"\", \"unpackWARs=\\\"true\\\"\");\n        } else {\n            replacements.put(\"unpackWARs=\\\"true\\\"\", \"unpackWARs=\\\"false\\\"\");\n        }\n\n        replace(replacements, serverXml, true);\n    }\n\n    public static File findHome(File directory) {\n\n        directory = directory.getAbsoluteFile();\n\n        final File f = findHomeImpl(directory);\n\n        if (null == f) {\n            LOGGER.log(Level.INFO, \"Unable to find home in: \" + directory);\n        }\n\n        return f;\n    }\n\n    public static File findHomeImpl(final File directory) {\n        final File conf = new File(directory, \"conf\").getAbsoluteFile();\n        final File webapps = new File(directory, \"webapps\").getAbsoluteFile();\n\n        if (conf.exists() && conf.isDirectory() && webapps.exists() && webapps.isDirectory()) {\n            return directory;\n        }\n\n        final File[] files = directory.listFiles();\n        if (null != files) {\n\n            for (final File file : files) {\n                if (\".\".equals(file.getName()) || \"..\".equals(file.getName())) {\n                    continue;\n                }\n\n                final File found = findHome(file);\n\n                if (found != null) {\n                    return found;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    public static File downloadAndUnpack(final File dir, final String artifactID, final String defaultTempDir) throws LifecycleException {\n\n        final File zipFile = downloadFile(artifactID, null, defaultTempDir);\n\n        Zips.unzip(zipFile, dir);\n\n        return findHome(dir);\n    }\n\n    public static File downloadFile(final String artifactName, final String altUrl, final String defaultTempDir) {\n        final String cache = SystemInstance.isInitialized() ?\n            SystemInstance.get().getOptions().get(ProvisioningResolver.OPENEJB_DEPLOYER_CACHE_FOLDER, (String) null) :\n            System.getProperty(ProvisioningResolver.OPENEJB_DEPLOYER_CACHE_FOLDER);\n        if (cache == null && defaultTempDir != null) { // let the user override it\n            System.setProperty(ProvisioningResolver.OPENEJB_DEPLOYER_CACHE_FOLDER, defaultTempDir);\n        }\n\n        try {\n            final File artifact = MavenCache.getArtifact(artifactName, altUrl);\n            if (artifact == null) {\n                throw new NullPointerException(String.format(\"No such artifact: %s\", artifactName));\n            }\n            return artifact.getAbsoluteFile();\n        } finally {\n            if (cache == null) {\n                System.clearProperty(ProvisioningResolver.OPENEJB_DEPLOYER_CACHE_FOLDER);\n            }\n        }\n    }\n\n    public static boolean isRunning(final String host, final int port) {\n        Socket socket = null;\n        try {\n            socket = new Socket(host, port);\n            socket.getOutputStream().close();\n            return true;\n        } catch (final Exception e) {\n            return false;\n        } finally {\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (final IOException ignored) {\n                    // no-op\n                }\n            }\n        }\n    }\n\n    public static void replace(final Map<String, String> replacements, final File file, final boolean escape) throws IOException {\n\n        InputStream in = IO.read(file);\n\n        if (escape) {\n            final Map<String, String> escaped = new HashMap<>();\n            for (final Map.Entry<String, String> entry : replacements.entrySet()) {\n                final String key = entry.getKey();\n                final String value = entry.getValue();\n                if (key.startsWith(\"\\\"\") && key.endsWith(\"\\\"\")) {\n                    escaped.put(key, value);\n                } else {\n                    escaped.put(\"\\\"\" + key + \"\\\"\", \"\\\"\" + value + \"\\\"\");\n                }\n            }\n\n            replacements.clear();\n            replacements.putAll(escaped);\n        }\n\n        in = new ReplaceStringsInputStream(in, replacements);\n\n        final String data = IO.slurp(in);\n\n        IO.copy(data.getBytes(), file);\n\n        if (LOGGER.isLoggable(Level.FINE)) {\n            IO.copy(data.getBytes(), System.out);\n        }\n    }\n\n    public static void removeUselessWebapps(final File tomeeHome, final String... exceptions) {\n        final File webapps = new File(tomeeHome, \"webapps\");\n        if (webapps.isDirectory()) {\n            final File[] files = webapps.listFiles();\n            if (files != null) {\n                for (final File webapp : files) {\n                    boolean delete = true;\n                    if (exceptions != null) {\n                        for (final String ignore : exceptions) {\n                            if (webapp.getName().equals(ignore)) {\n                                delete = false;\n                                break;\n                            }\n                        }\n                    }\n                    if (delete) {\n                        org.apache.openejb.loader.Files.delete(webapp);\n                    }\n                }\n            }\n        }\n    }\n\n    public static void configureServerXml(final File tomeeHome, final TomEEConfiguration configuration) throws IOException {\n\n        if (configuration.getServerXml() != null) {\n\n            final File serverXml = new File(configuration.getServerXml());\n\n            if (!serverXml.exists()) {\n                LOGGER.severe(\"Provided server.xml doesn't exist: '\" + serverXml.getPath() + \"'\");\n            } else {\n\n                // Read in the contents to memory so we can avoid re-reading for parsing\n                final String data = IO.slurp(serverXml);\n\n                IO.copy(data.getBytes(), Files.path(tomeeHome, \"conf\", \"server.xml\"));\n            }\n        }\n        updateServerXml(tomeeHome, configuration);\n    }\n\n    private static int ajpPort(final TomEEConfiguration config) {\n        try {\n            final Method ajbPort = config.getClass().getMethod(\"getAjpPort\");\n            return (Integer) ajbPort.invoke(config);\n        } catch (final Exception e) {\n            return Integer.parseInt(QuickServerXmlParser.DEFAULT_AJP_PORT);\n        }\n    }\n\n    public static void configureSystemProperties(final File tomeeHome, final TomEEConfiguration configuration) {\n        final File file = Files.path(tomeeHome, \"conf\", \"system.properties\");\n\n        // Must use an actual properties object to avoid duplicate keys\n        final Properties properties = new Properties();\n\n        if (file.exists()) {\n            try {\n                IO.readProperties(file, properties);\n            } catch (final IOException e) {\n                LOGGER.log(Level.SEVERE, \"Can't read \" + file.getAbsolutePath(), e);\n            }\n        }\n\n        if (configuration.getProperties() != null) {\n            try {\n                final InputStream bytes = IO.read(configuration.getProperties().getBytes());\n                IO.readProperties(bytes, properties);\n            } catch (final IOException e) {\n                LOGGER.log(Level.SEVERE, \"Can't parse <property name=\\\"properties\\\"> value '\" + configuration.getProperties() + \"'\", e);\n            }\n        }\n\n        if (configuration.isQuickSession()) {\n            properties.put(\"openejb.session.manager\", \"org.apache.tomee.catalina.session.QuickSessionManager\");\n        }\n\n        try {\n            IO.writeProperties(file, properties);\n        } catch (final IOException e) {\n            LOGGER.log(Level.SEVERE, \"Can't save system properties \" + file.getAbsolutePath(), e);\n        }\n    }\n\n\n    public static void synchronizeFolder(final File tomeeHome, final String src, final String dir) {\n        if (src != null && !src.isEmpty()) {\n            final File confSrc = new File(src);\n            if (confSrc.exists()) {\n                final File conf = new File(tomeeHome, dir);\n                final Collection<File> files = org.apache.openejb.loader.Files.collect(confSrc, TrueFilter.INSTANCE);\n                files.remove(confSrc);\n                for (final File f : files) {\n                    if (f.equals(confSrc) || f.getName().startsWith(\".\")) {\n                        continue;\n                    }\n\n                    final String relativize = relativize(f, confSrc);\n                    if (f.isDirectory()) {\n                        final String path = dir + '/' + relativize;\n                        Files.mkdir(new File(tomeeHome, path));\n                        synchronizeFolder(tomeeHome, f.getAbsolutePath(), path);\n                    } else {\n                        try {\n                            final File to = new File(conf, relativize);\n                            Files.mkdir(to.getParentFile());\n                            org.apache.openejb.loader.IO.copy(f, to);\n                        } catch (final Exception e) {\n                            LOGGER.log(Level.WARNING, \"Ignoring copy of \" + f.getAbsolutePath(), e);\n                        }\n                    }\n                }\n            } else {\n                LOGGER.warning(\"Can't find \" + confSrc.getAbsolutePath());\n            }\n        }\n    }\n\n    private static String relativize(final File f, final File base) {\n        return f.getAbsolutePath().substring(base.getAbsolutePath().length() + 1);\n    }\n\n    public static void installArquillianBeanDiscoverer(final File home) {\n        final File destination = new File(home, TOMEE_BEAN_DISCOVERER_JAR);\n        ShrinkWrap.create(JavaArchive.class, destination.getName())\n                .addClasses(BeanDicovererInstaller.class, TestClassDiscoverer.class, ArquillianFilterRunner.class, Discover.class)\n                .addAsManifestResource(new StringAsset(BeanDicovererInstaller.class.getName()), ArchivePaths.create(\"org.apache.openejb.extension\"))\n                .as(ZipExporter.class).exportTo(destination, false);\n    }\n\n    public static void removeArquillianBeanDiscoverer(final File home) {\n        final File destination = new File(home, TOMEE_BEAN_DISCOVERER_JAR);\n        Files.delete(destination);\n    }\n\n    public static Map<File, String> addTomEELibraries(final File libFolder, final String additionalLibs, final boolean parseArgs) {\n        if (additionalLibs == null) {\n            return emptyMap();\n        }\n        final String libs = additionalLibs.trim();\n        if (libs.isEmpty()) {\n            return emptyMap();\n        }\n\n        try { // initializing the SystemInstance because we'll need it for configuration\n            if (!SystemInstance.isInitialized()) {\n                SystemInstance.init(new Properties());\n            }\n        } catch (final Exception e) {\n            // no-op\n        }\n\n        final Map<File, String> configs = new HashMap<>();\n        for (final String lib : libs.split(\"\\n\")) {\n            final String trim = lib.trim();\n            if (trim.isEmpty() || trim.startsWith(\"#\")) {\n                continue;\n            }\n\n            final String args;\n            if (parseArgs) { // javaagent friendly\n                int argsIdx = trim.indexOf('=');\n                if (argsIdx < 0) {\n                    argsIdx = trim.indexOf('?');\n                }\n                if (argsIdx > 0) {\n                    args = trim.substring(argsIdx);\n                } else {\n                    args = \"\";\n                }\n            } else {\n                args = null;\n            }\n\n            final Set<String> locations = ProvisioningUtil.realLocation(trim);\n            for (final String location : locations) {\n                final File from = new File(location);\n                try {\n                    final File to = new File(libFolder, from.getName());\n                    org.apache.openejb.loader.IO.copy(from, to);\n                    if (args != null) {\n                        configs.put(to, args);\n                    }\n                } catch (final IOException e) {\n                    throw new IllegalArgumentException(e);\n                }\n            }\n        }\n        return configs;\n    }\n\n    private static class TrueFilter implements FileFilter {\n        private static final TrueFilter INSTANCE = new TrueFilter();\n\n        @Override\n        public boolean accept(final File pathname) {\n            return true;\n        }\n    }\n}\n",
        "human_patch_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.openejb.arquillian.common;\n\nimport org.apache.openejb.loader.ProvisioningUtil;\nimport org.apache.openejb.loader.SystemInstance;\nimport org.apache.openejb.loader.provisining.ProvisioningResolver;\nimport org.apache.tomee.util.QuickServerXmlParser;\nimport org.codehaus.swizzle.stream.ReplaceStringsInputStream;\nimport org.jboss.arquillian.container.spi.client.container.LifecycleException;\nimport org.jboss.shrinkwrap.api.ArchivePaths;\nimport org.jboss.shrinkwrap.api.ShrinkWrap;\nimport org.jboss.shrinkwrap.api.asset.StringAsset;\nimport org.jboss.shrinkwrap.api.exporter.ZipExporter;\nimport org.jboss.shrinkwrap.api.spec.JavaArchive;\n\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Method;\nimport java.net.Socket;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport static java.util.Collections.emptyMap;\n\n/**\n * @version $Rev$ $Date$\n */\npublic class Setup {\n    private static final Logger LOGGER = Logger.getLogger(Setup.class.getName()); // JUL is used by arquillian so that's fine\n    public static final String TOMEE_BEAN_DISCOVERER_JAR = \"lib\" + File.separator + \"xx-arquillian-tomee-bean-discoverer.jar\"; // starts with xx to not be filtered\n    private static final String DEFAULT_MEM_CONFIG = (javaVersion() >= 1.8 ? \"\" : \"-XX:PermSize=64m -XX:MaxPermSize=256m \")\n                                                            + \"-Xmx512m -Xms256m -XX:ReservedCodeCacheSize=64m\";\n\n    private static double javaVersion() {\n        try {\n            return Double.parseDouble(System.getProperty(\"java.version\", \"1.7\").substring(0, 3));\n        } catch (final Exception nfe) {\n            return 1.6;\n        }\n    }\n\n    public static void exportProperties(final File tomeeHome, final TomEEConfiguration c, final boolean defaultMem) {\n        final int httpPort = c.getHttpPort();\n        System.setProperty(\"java.naming.provider.url\", \"http://\" + c.getHost() + \":\" + httpPort + \"/tomee/ejb\");\n        System.setProperty(\"connect.tries\", \"90\");\n        System.setProperty(\"server.http.port\", String.valueOf(httpPort));\n        System.setProperty(\"server.shutdown.port\", String.valueOf(c.getStopPort()));\n        if (defaultMem) {\n            System.setProperty(\"java.opts\", DEFAULT_MEM_CONFIG + \" -Dtomee.httpPort=\" + httpPort);\n        } else {\n            System.setProperty(\"java.opts\", \"-Dtomee.httpPort=\" + httpPort);\n        }\n        System.setProperty(\"openejb.home\", tomeeHome.getAbsolutePath());\n        System.setProperty(\"tomee.home\", tomeeHome.getAbsolutePath());\n    }\n\n    public static void updateServerXml(final File tomeeHome, final TomEEConfiguration configuration) throws IOException {\n        final File serverXml = Files.path(new File(tomeeHome.getAbsolutePath()), \"conf\", \"server.xml\");\n        if (!serverXml.exists()) {\n            return;\n        }\n\n        final QuickServerXmlParser ports = QuickServerXmlParser.parse(serverXml);\n        if (configuration.getKeepServerXmlAsThis()) {\n            // force ports to be able to stop the server and get @ArquillianResource\n            configuration.setHttpPort(Integer.parseInt(ports.http()));\n            configuration.setStopPort(Integer.parseInt(ports.stop()));\n            return; // in this case we don't want to override the conf\n        }\n\n        final Map<String, String> replacements = new HashMap<>();\n        replacements.put(ports.http(), String.valueOf(configuration.getHttpPort()));\n        replacements.put(ports.https(), String.valueOf(configuration.getHttpsPort()));\n        replacements.put(ports.stop(), String.valueOf(configuration.getStopPort()));\n        replacements.put(ports.ajp(), String.valueOf(ajpPort(configuration)));\n\n        if (configuration.isUnpackWars()) {\n            replacements.put(\"unpackWARs=\\\"false\\\"\", \"unpackWARs=\\\"true\\\"\");\n        } else {\n            replacements.put(\"unpackWARs=\\\"true\\\"\", \"unpackWARs=\\\"false\\\"\");\n        }\n\n        replace(replacements, serverXml, true);\n    }\n\n    public static File findHome(File directory) {\n\n        directory = directory.getAbsoluteFile();\n\n        final File f = findHomeImpl(directory);\n\n        if (null == f) {\n            LOGGER.log(Level.INFO, \"Unable to find home in: \" + directory);\n        }\n\n        return f;\n    }\n\n    public static File findHomeImpl(final File directory) {\n        final File conf = new File(directory, \"conf\").getAbsoluteFile();\n        final File webapps = new File(directory, \"webapps\").getAbsoluteFile();\n\n        if (conf.exists() && conf.isDirectory() && webapps.exists() && webapps.isDirectory()) {\n            return directory;\n        }\n\n        final File[] files = directory.listFiles();\n        if (null != files) {\n\n            for (final File file : files) {\n                if (\".\".equals(file.getName()) || \"..\".equals(file.getName())) {\n                    continue;\n                }\n\n                final File found = findHome(file);\n\n                if (found != null) {\n                    return found;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    public static File downloadAndUnpack(final File dir, final String artifactID, final String defaultTempDir) throws LifecycleException {\n\n        final File zipFile = downloadFile(artifactID, null, defaultTempDir);\n\n        Zips.unzip(zipFile, dir);\n\n        return findHome(dir);\n    }\n\n    public static File downloadFile(final String artifactName, final String altUrl, final String defaultTempDir) {\n        final String cache = SystemInstance.isInitialized() ?\n            SystemInstance.get().getOptions().get(ProvisioningResolver.OPENEJB_DEPLOYER_CACHE_FOLDER, (String) null) :\n            System.getProperty(ProvisioningResolver.OPENEJB_DEPLOYER_CACHE_FOLDER);\n        if (cache == null && defaultTempDir != null) { // let the user override it\n            System.setProperty(ProvisioningResolver.OPENEJB_DEPLOYER_CACHE_FOLDER, defaultTempDir);\n        }\n\n        try {\n            final File artifact = MavenCache.getArtifact(artifactName, altUrl);\n            if (artifact == null) {\n                throw new NullPointerException(String.format(\"No such artifact: %s\", artifactName));\n            }\n            return artifact.getAbsoluteFile();\n        } finally {\n            if (cache == null) {\n                System.clearProperty(ProvisioningResolver.OPENEJB_DEPLOYER_CACHE_FOLDER);\n            }\n        }\n    }\n\n    public static boolean isRunning(final String host, final int port) {\n        Socket socket = null;\n        try {\n            socket = new Socket(host, port);\n            socket.getOutputStream().close();\n            return true;\n        } catch (final Exception e) {\n            return false;\n        } finally {\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (final IOException ignored) {\n                    // no-op\n                }\n            }\n        }\n    }\n\n    public static void replace(final Map<String, String> replacements, final File file, final boolean escape) throws IOException {\n\n        InputStream in = IO.read(file);\n\n        if (escape) {\n            final Map<String, String> escaped = new HashMap<>();\n            for (final Map.Entry<String, String> entry : replacements.entrySet()) {\n                final String key = entry.getKey();\n                final String value = entry.getValue();\n                if (key.startsWith(\"\\\"\") && key.endsWith(\"\\\"\")) {\n                    escaped.put(key, value);\n                } else {\n                    escaped.put(\"\\\"\" + key + \"\\\"\", \"\\\"\" + value + \"\\\"\");\n                }\n            }\n\n            replacements.clear();\n            replacements.putAll(escaped);\n        }\n\n        in = new ReplaceStringsInputStream(in, replacements);\n\n        final String data = IO.slurp(in);\n\n        IO.copy(data.getBytes(), file);\n\n        if (LOGGER.isLoggable(Level.FINE)) {\n            IO.copy(data.getBytes(), System.out);\n        }\n    }\n\n    public static void removeUselessWebapps(final File tomeeHome, final String... exceptions) {\n        final File webapps = new File(tomeeHome, \"webapps\");\n        if (webapps.isDirectory()) {\n            final File[] files = webapps.listFiles();\n            if (files != null) {\n                for (final File webapp : files) {\n                    boolean delete = true;\n                    if (exceptions != null) {\n                        for (final String ignore : exceptions) {\n                            if (webapp.getName().equals(ignore)) {\n                                delete = false;\n                                break;\n                            }\n                        }\n                    }\n                    if (delete) {\n                        org.apache.openejb.loader.Files.delete(webapp);\n                    }\n                }\n            }\n        }\n    }\n\n    public static void configureServerXml(final File tomeeHome, final TomEEConfiguration configuration) throws IOException {\n\n        if (configuration.getServerXml() != null) {\n\n            final File serverXml = new File(configuration.getServerXml());\n\n            if (!serverXml.exists()) {\n                LOGGER.severe(\"Provided server.xml doesn't exist: '\" + serverXml.getPath() + \"'\");\n            } else {\n\n                // Read in the contents to memory so we can avoid re-reading for parsing\n                final String data = IO.slurp(serverXml);\n\n                IO.copy(data.getBytes(), Files.path(tomeeHome, \"conf\", \"server.xml\"));\n            }\n        }\n        updateServerXml(tomeeHome, configuration);\n    }\n\n    private static int ajpPort(final TomEEConfiguration config) {\n        try {\n            final Method ajbPort = config.getClass().getMethod(\"getAjpPort\");\n            return (Integer) ajbPort.invoke(config);\n        } catch (final Exception e) {\n            return Integer.parseInt(QuickServerXmlParser.DEFAULT_AJP_PORT);\n        }\n    }\n\n    public static void configureSystemProperties(final File tomeeHome, final TomEEConfiguration configuration) {\n        final File file = Files.path(tomeeHome, \"conf\", \"system.properties\");\n\n        // Must use an actual properties object to avoid duplicate keys\n        final Properties properties = new Properties();\n\n        if (file.exists()) {\n            try {\n                IO.readProperties(file, properties);\n            } catch (final IOException e) {\n                LOGGER.log(Level.SEVERE, \"Can't read \" + file.getAbsolutePath(), e);\n            }\n        }\n\n        if (configuration.getProperties() != null) {\n            try {\n                final InputStream bytes = IO.read(configuration.getProperties().getBytes());\n                IO.readProperties(bytes, properties);\n            } catch (final IOException e) {\n                LOGGER.log(Level.SEVERE, \"Can't parse <property name=\\\"properties\\\"> value '\" + configuration.getProperties() + \"'\", e);\n            }\n        }\n\n        if (configuration.isQuickSession()) {\n            properties.put(\"openejb.session.manager\", \"org.apache.tomee.catalina.session.QuickSessionManager\");\n        }\n\n        if (configuration.isUnsafeEjbd() && \"*\".equals(properties.getProperty(\"tomee.serialization.class.blacklist\", \"-\").trim())) {\n            properties.remove(\"tomee.serialization.class.blacklist\");\n            properties.put(\"tomee.serialization.class.whitelist\", \"*\");\n        }\n\n        try {\n            IO.writeProperties(file, properties);\n        } catch (final IOException e) {\n            LOGGER.log(Level.SEVERE, \"Can't save system properties \" + file.getAbsolutePath(), e);\n        }\n    }\n\n\n    public static void synchronizeFolder(final File tomeeHome, final String src, final String dir) {\n        if (src != null && !src.isEmpty()) {\n            final File confSrc = new File(src);\n            if (confSrc.exists()) {\n                final File conf = new File(tomeeHome, dir);\n                final Collection<File> files = org.apache.openejb.loader.Files.collect(confSrc, TrueFilter.INSTANCE);\n                files.remove(confSrc);\n                for (final File f : files) {\n                    if (f.equals(confSrc) || f.getName().startsWith(\".\")) {\n                        continue;\n                    }\n\n                    final String relativize = relativize(f, confSrc);\n                    if (f.isDirectory()) {\n                        final String path = dir + '/' + relativize;\n                        Files.mkdir(new File(tomeeHome, path));\n                        synchronizeFolder(tomeeHome, f.getAbsolutePath(), path);\n                    } else {\n                        try {\n                            final File to = new File(conf, relativize);\n                            Files.mkdir(to.getParentFile());\n                            org.apache.openejb.loader.IO.copy(f, to);\n                        } catch (final Exception e) {\n                            LOGGER.log(Level.WARNING, \"Ignoring copy of \" + f.getAbsolutePath(), e);\n                        }\n                    }\n                }\n            } else {\n                LOGGER.warning(\"Can't find \" + confSrc.getAbsolutePath());\n            }\n        }\n    }\n\n    private static String relativize(final File f, final File base) {\n        return f.getAbsolutePath().substring(base.getAbsolutePath().length() + 1);\n    }\n\n    public static void installArquillianBeanDiscoverer(final File home) {\n        final File destination = new File(home, TOMEE_BEAN_DISCOVERER_JAR);\n        ShrinkWrap.create(JavaArchive.class, destination.getName())\n                .addClasses(BeanDicovererInstaller.class, TestClassDiscoverer.class, ArquillianFilterRunner.class, Discover.class)\n                .addAsManifestResource(new StringAsset(BeanDicovererInstaller.class.getName()), ArchivePaths.create(\"org.apache.openejb.extension\"))\n                .as(ZipExporter.class).exportTo(destination, false);\n    }\n\n    public static void removeArquillianBeanDiscoverer(final File home) {\n        final File destination = new File(home, TOMEE_BEAN_DISCOVERER_JAR);\n        Files.delete(destination);\n    }\n\n    public static Map<File, String> addTomEELibraries(final File libFolder, final String additionalLibs, final boolean parseArgs) {\n        if (additionalLibs == null) {\n            return emptyMap();\n        }\n        final String libs = additionalLibs.trim();\n        if (libs.isEmpty()) {\n            return emptyMap();\n        }\n\n        try { // initializing the SystemInstance because we'll need it for configuration\n            if (!SystemInstance.isInitialized()) {\n                SystemInstance.init(new Properties());\n            }\n        } catch (final Exception e) {\n            // no-op\n        }\n\n        final Map<File, String> configs = new HashMap<>();\n        for (final String lib : libs.split(\"\\n\")) {\n            final String trim = lib.trim();\n            if (trim.isEmpty() || trim.startsWith(\"#\")) {\n                continue;\n            }\n\n            final String args;\n            if (parseArgs) { // javaagent friendly\n                int argsIdx = trim.indexOf('=');\n                if (argsIdx < 0) {\n                    argsIdx = trim.indexOf('?');\n                }\n                if (argsIdx > 0) {\n                    args = trim.substring(argsIdx);\n                } else {\n                    args = \"\";\n                }\n            } else {\n                args = null;\n            }\n\n            final Set<String> locations = ProvisioningUtil.realLocation(trim);\n            for (final String location : locations) {\n                final File from = new File(location);\n                try {\n                    final File to = new File(libFolder, from.getName());\n                    org.apache.openejb.loader.IO.copy(from, to);\n                    if (args != null) {\n                        configs.put(to, args);\n                    }\n                } catch (final IOException e) {\n                    throw new IllegalArgumentException(e);\n                }\n            }\n        }\n        return configs;\n    }\n\n    private static class TrueFilter implements FileFilter {\n        private static final TrueFilter INSTANCE = new TrueFilter();\n\n        @Override\n        public boolean accept(final File pathname) {\n            return true;\n        }\n    }\n}\n"
      },
      {
        "file_path": "arquillian/arquillian-tomee-common/src/main/java/org/apache/openejb/arquillian/common/TomEEConfiguration.java",
        "file_name": "TomEEConfiguration.java",
        "vulnerable_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.openejb.arquillian.common;\n\n\nimport org.jboss.arquillian.config.descriptor.api.Multiline;\nimport org.jboss.arquillian.container.spi.ConfigurationException;\nimport org.jboss.arquillian.container.spi.client.container.ContainerConfiguration;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\n\nimport static java.util.Arrays.asList;\n\n@SuppressWarnings(\"UnusedDeclaration\")\npublic class TomEEConfiguration implements ContainerConfiguration {\n\n    protected boolean exportConfAsSystemProperty;\n    protected int httpsPort = 8443;\n    protected int httpPort = 8080;\n    protected int stopPort = 8005;\n    protected String dir = System.getProperty(\"java.io.tmpdir\") + \"/arquillian-apache-tomee\";\n    protected String appWorkingDir = System.getProperty(\"java.io.tmpdir\") + \"/arquillian-tomee-app-working-dir\";\n    protected String host = \"localhost\";\n    protected String stopHost = \"localhost\"; // generally localhost but host (http) can be different\n    protected String stopCommand = \"SHUTDOWN\"; // default one - can be overriden in server.xml\n    protected String serverXml;\n    protected String portRange = \"\"; // only used if port < 0, empty means whatever, can be \"1024-65535\"\n    protected String preloadClasses; // just a client classloader.loadClass(), value is comma separated qualified names. Useful with maven resolver for instance\n    protected boolean quickSession = true;\n    protected boolean unpackWars = true;\n\n    protected String properties = \"\";\n    protected String webContextToUseWithEars;\n    protected boolean keepServerXmlAsThis;\n    protected boolean singleDumpByArchiveName;\n    protected Collection<String> singleDeploymentByArchiveName = Collections.emptyList();\n\n    public boolean isUnpackWars() {\n        return unpackWars;\n    }\n\n    public void setUnpackWars(final boolean unpackWars) {\n        this.unpackWars = unpackWars;\n    }\n\n    public int getHttpsPort() {\n        return httpsPort;\n    }\n\n    public void setHttpsPort(final int httpsPort) {\n        this.httpsPort = httpsPort;\n    }\n\n    public int getHttpPort() {\n        return httpPort;\n    }\n\n    public void setHttpPort(final int httpPort) {\n        this.httpPort = httpPort;\n    }\n\n    public int getStopPort() {\n        return stopPort;\n    }\n\n    public void setStopPort(final int stopPort) {\n        this.stopPort = stopPort;\n    }\n\n    public String getDir() {\n        return dir;\n    }\n\n    public void setDir(final String dir) {\n        this.dir = dir;\n    }\n\n    public String getAppWorkingDir() {\n        return appWorkingDir;\n    }\n\n    public void setAppWorkingDir(final String appWorkingDir) {\n        this.appWorkingDir = appWorkingDir;\n    }\n\n    public void validate() throws ConfigurationException {\n    }\n\n    public boolean getExportConfAsSystemProperty() {\n        return exportConfAsSystemProperty;\n    }\n\n    public void setExportConfAsSystemProperty(final boolean exportConfAsSystemProperty) {\n        this.exportConfAsSystemProperty = exportConfAsSystemProperty;\n    }\n\n    public String getHost() {\n        return host;\n    }\n\n    public void setHost(final String host) {\n        this.host = host;\n    }\n\n    public String getServerXml() {\n        return serverXml;\n    }\n\n    public void setServerXml(final String serverXml) {\n        this.serverXml = serverXml;\n    }\n\n    public String getProperties() {\n        return properties;\n    }\n\n    @Multiline\n    public void setProperties(final String properties) {\n        this.properties = properties;\n    }\n\n    public String systemProperties() {\n        return properties.replaceAll(\"\\n *\", \"\\n\");\n    }\n\n    public String getPortRange() {\n        return portRange;\n    }\n\n    public void setPortRange(final String portRange) {\n        this.portRange = portRange;\n    }\n\n    public boolean isQuickSession() {\n        return quickSession;\n    }\n\n    public void setQuickSession(final boolean quickSession) {\n        this.quickSession = quickSession;\n    }\n\n    public int[] portsAlreadySet() {\n        final List<Integer> value = new ArrayList<Integer>();\n        if (stopPort > 0) {\n            value.add(stopPort);\n        }\n        if (httpPort > 0) {\n            value.add(httpPort);\n        }\n        if (httpsPort > 0) {\n            value.add(httpsPort);\n        }\n        return toInts(value);\n    }\n\n    protected int[] toInts(final List<Integer> values) {\n        final int[] array = new int[values.size()];\n        for (int i = 0; i < array.length; i++) {\n            array[i] = values.get(i);\n        }\n        return array;\n    }\n\n    public String getStopHost() {\n        return stopHost;\n    }\n\n    public void setStopHost(final String stopHost) {\n        this.stopHost = stopHost;\n    }\n\n    public String getStopCommand() {\n        return stopCommand + Character.toString((char) 0); // last char to avoid warning/error log message\n    }\n\n    public void setStopCommand(final String stopCommand) {\n        this.stopCommand = stopCommand;\n    }\n\n    public String getPreloadClasses() {\n        return preloadClasses;\n    }\n\n    public void setPreloadClasses(final String preloadClasses) {\n        this.preloadClasses = preloadClasses;\n    }\n\n    public String getWebContextToUseWithEars() {\n        return webContextToUseWithEars;\n    }\n\n    public void setWebContextToUseWithEars(final String webContextToUseWithEars) {\n        this.webContextToUseWithEars = webContextToUseWithEars;\n    }\n\n    public boolean getKeepServerXmlAsThis() {\n        return keepServerXmlAsThis;\n    }\n\n    public void setKeepServerXmlAsThis(final boolean keepServerXmlAsThis) {\n        this.keepServerXmlAsThis = keepServerXmlAsThis;\n    }\n\n    public boolean isSingleDumpByArchiveName() {\n        return singleDumpByArchiveName;\n    }\n\n    public void setSingleDumpByArchiveName(final boolean singleDumpByArchiveName) {\n        this.singleDumpByArchiveName = singleDumpByArchiveName;\n    }\n\n    public boolean isSingleDeploymentByArchiveName(final String name) {\n        return singleDeploymentByArchiveName.contains(name) || singleDeploymentByArchiveName.contains(\"*\") || singleDeploymentByArchiveName.contains(\"true\");\n    }\n\n    public void setSingleDeploymentByArchiveName(final String singleDeploymentByArchiveName) {\n        this.singleDeploymentByArchiveName = singleDeploymentByArchiveName == null || singleDeploymentByArchiveName.trim().isEmpty() ?\n                Collections.<String>emptyList() : new HashSet<String>(asList(singleDeploymentByArchiveName.split(\" *, *\")));\n        this.singleDumpByArchiveName = true; // implied otherwise what would be the sense?\n    }\n}\n",
        "human_patch_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.openejb.arquillian.common;\n\n\nimport org.jboss.arquillian.config.descriptor.api.Multiline;\nimport org.jboss.arquillian.container.spi.ConfigurationException;\nimport org.jboss.arquillian.container.spi.client.container.ContainerConfiguration;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\n\nimport static java.util.Arrays.asList;\n\n@SuppressWarnings(\"UnusedDeclaration\")\npublic class TomEEConfiguration implements ContainerConfiguration {\n\n    protected boolean exportConfAsSystemProperty;\n    protected int httpsPort = 8443;\n    protected int httpPort = 8080;\n    protected int stopPort = 8005;\n    protected String dir = System.getProperty(\"java.io.tmpdir\") + \"/arquillian-apache-tomee\";\n    protected String appWorkingDir = System.getProperty(\"java.io.tmpdir\") + \"/arquillian-tomee-app-working-dir\";\n    protected String host = \"localhost\";\n    protected String stopHost = \"localhost\"; // generally localhost but host (http) can be different\n    protected String stopCommand = \"SHUTDOWN\"; // default one - can be overriden in server.xml\n    protected String serverXml;\n    protected String portRange = \"\"; // only used if port < 0, empty means whatever, can be \"1024-65535\"\n    protected String preloadClasses; // just a client classloader.loadClass(), value is comma separated qualified names. Useful with maven resolver for instance\n    protected boolean quickSession = true;\n    protected boolean unsafeEjbd = true;\n    protected boolean unpackWars = true;\n\n    protected String properties = \"\";\n    protected String webContextToUseWithEars;\n    protected boolean keepServerXmlAsThis;\n    protected boolean singleDumpByArchiveName;\n    protected Collection<String> singleDeploymentByArchiveName = Collections.emptyList();\n\n    public boolean isUnsafeEjbd() {\n        return unsafeEjbd;\n    }\n\n    public void setUnsafeEjbd(final boolean unsafeEjbd) {\n        this.unsafeEjbd = unsafeEjbd;\n    }\n\n    public boolean isUnpackWars() {\n        return unpackWars;\n    }\n\n    public void setUnpackWars(final boolean unpackWars) {\n        this.unpackWars = unpackWars;\n    }\n\n    public int getHttpsPort() {\n        return httpsPort;\n    }\n\n    public void setHttpsPort(final int httpsPort) {\n        this.httpsPort = httpsPort;\n    }\n\n    public int getHttpPort() {\n        return httpPort;\n    }\n\n    public void setHttpPort(final int httpPort) {\n        this.httpPort = httpPort;\n    }\n\n    public int getStopPort() {\n        return stopPort;\n    }\n\n    public void setStopPort(final int stopPort) {\n        this.stopPort = stopPort;\n    }\n\n    public String getDir() {\n        return dir;\n    }\n\n    public void setDir(final String dir) {\n        this.dir = dir;\n    }\n\n    public String getAppWorkingDir() {\n        return appWorkingDir;\n    }\n\n    public void setAppWorkingDir(final String appWorkingDir) {\n        this.appWorkingDir = appWorkingDir;\n    }\n\n    public void validate() throws ConfigurationException {\n    }\n\n    public boolean getExportConfAsSystemProperty() {\n        return exportConfAsSystemProperty;\n    }\n\n    public void setExportConfAsSystemProperty(final boolean exportConfAsSystemProperty) {\n        this.exportConfAsSystemProperty = exportConfAsSystemProperty;\n    }\n\n    public String getHost() {\n        return host;\n    }\n\n    public void setHost(final String host) {\n        this.host = host;\n    }\n\n    public String getServerXml() {\n        return serverXml;\n    }\n\n    public void setServerXml(final String serverXml) {\n        this.serverXml = serverXml;\n    }\n\n    public String getProperties() {\n        return properties;\n    }\n\n    @Multiline\n    public void setProperties(final String properties) {\n        this.properties = properties;\n    }\n\n    public String systemProperties() {\n        return properties.replaceAll(\"\\n *\", \"\\n\");\n    }\n\n    public String getPortRange() {\n        return portRange;\n    }\n\n    public void setPortRange(final String portRange) {\n        this.portRange = portRange;\n    }\n\n    public boolean isQuickSession() {\n        return quickSession;\n    }\n\n    public void setQuickSession(final boolean quickSession) {\n        this.quickSession = quickSession;\n    }\n\n    public int[] portsAlreadySet() {\n        final List<Integer> value = new ArrayList<Integer>();\n        if (stopPort > 0) {\n            value.add(stopPort);\n        }\n        if (httpPort > 0) {\n            value.add(httpPort);\n        }\n        if (httpsPort > 0) {\n            value.add(httpsPort);\n        }\n        return toInts(value);\n    }\n\n    protected int[] toInts(final List<Integer> values) {\n        final int[] array = new int[values.size()];\n        for (int i = 0; i < array.length; i++) {\n            array[i] = values.get(i);\n        }\n        return array;\n    }\n\n    public String getStopHost() {\n        return stopHost;\n    }\n\n    public void setStopHost(final String stopHost) {\n        this.stopHost = stopHost;\n    }\n\n    public String getStopCommand() {\n        return stopCommand + Character.toString((char) 0); // last char to avoid warning/error log message\n    }\n\n    public void setStopCommand(final String stopCommand) {\n        this.stopCommand = stopCommand;\n    }\n\n    public String getPreloadClasses() {\n        return preloadClasses;\n    }\n\n    public void setPreloadClasses(final String preloadClasses) {\n        this.preloadClasses = preloadClasses;\n    }\n\n    public String getWebContextToUseWithEars() {\n        return webContextToUseWithEars;\n    }\n\n    public void setWebContextToUseWithEars(final String webContextToUseWithEars) {\n        this.webContextToUseWithEars = webContextToUseWithEars;\n    }\n\n    public boolean getKeepServerXmlAsThis() {\n        return keepServerXmlAsThis;\n    }\n\n    public void setKeepServerXmlAsThis(final boolean keepServerXmlAsThis) {\n        this.keepServerXmlAsThis = keepServerXmlAsThis;\n    }\n\n    public boolean isSingleDumpByArchiveName() {\n        return singleDumpByArchiveName;\n    }\n\n    public void setSingleDumpByArchiveName(final boolean singleDumpByArchiveName) {\n        this.singleDumpByArchiveName = singleDumpByArchiveName;\n    }\n\n    public boolean isSingleDeploymentByArchiveName(final String name) {\n        return singleDeploymentByArchiveName.contains(name) || singleDeploymentByArchiveName.contains(\"*\") || singleDeploymentByArchiveName.contains(\"true\");\n    }\n\n    public void setSingleDeploymentByArchiveName(final String singleDeploymentByArchiveName) {\n        this.singleDeploymentByArchiveName = singleDeploymentByArchiveName == null || singleDeploymentByArchiveName.trim().isEmpty() ?\n                Collections.<String>emptyList() : new HashSet<String>(asList(singleDeploymentByArchiveName.split(\" *, *\")));\n        this.singleDumpByArchiveName = true; // implied otherwise what would be the sense?\n    }\n}\n"
      },
      {
        "file_path": "arquillian/arquillian-tomee-embedded/src/main/java/org/apache/openejb/arquillian/embedded/EmbeddedTomEEConfiguration.java",
        "file_name": "EmbeddedTomEEConfiguration.java",
        "vulnerable_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.openejb.arquillian.embedded;\n\nimport org.apache.openejb.OpenEJBRuntimeException;\nimport org.apache.openejb.arquillian.common.IO;\nimport org.apache.openejb.arquillian.common.Prefixes;\nimport org.apache.openejb.arquillian.common.TomEEConfiguration;\nimport org.jboss.arquillian.config.descriptor.api.Multiline;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * @version $Rev$ $Date$\n */\n@Prefixes({\"tomee\", \"tomee.embedded\"})\npublic class EmbeddedTomEEConfiguration extends TomEEConfiguration {\n    private int httpsPort = 8443;\n    private boolean ssl;\n    private boolean withEjbRemote;\n    private String keystoreFile;\n    private String keystorePass;\n    private String keystoreType = \"JKS\";\n    private String clientAuth;\n    private String keyAlias;\n    private String sslProtocol;\n    private String users;\n    private String roles;\n    private boolean webResourcesCached = true;\n\n    public boolean isWebResourcesCached() {\n        return webResourcesCached;\n    }\n\n    public void setWebResourcesCached(final boolean webResourcesCached) {\n        this.webResourcesCached = webResourcesCached;\n    }\n\n    public boolean isWithEjbRemote() {\n        return withEjbRemote;\n    }\n\n    public void setWithEjbRemote(final boolean withEjbRemote) {\n        this.withEjbRemote = withEjbRemote;\n    }\n\n    public int getHttpsPort() {\n        return httpsPort;\n    }\n\n    public void setHttpsPort(final int httpsPort) {\n        this.httpsPort = httpsPort;\n    }\n\n    public boolean isSsl() {\n        return ssl;\n    }\n\n    public void setSsl(final boolean ssl) {\n        this.ssl = ssl;\n    }\n\n    public String getKeystoreFile() {\n        return keystoreFile;\n    }\n\n    public void setKeystoreFile(final String keystoreFile) {\n        this.keystoreFile = keystoreFile;\n    }\n\n    public String getKeystorePass() {\n        return keystorePass;\n    }\n\n    public void setKeystorePass(final String keystorePass) {\n        this.keystorePass = keystorePass;\n    }\n\n    public String getKeystoreType() {\n        return keystoreType;\n    }\n\n    public void setKeystoreType(final String keystoreType) {\n        this.keystoreType = keystoreType;\n    }\n\n    public String getClientAuth() {\n        return clientAuth;\n    }\n\n    public void setClientAuth(final String clientAuth) {\n        this.clientAuth = clientAuth;\n    }\n\n    public String getKeyAlias() {\n        return keyAlias;\n    }\n\n    public void setKeyAlias(final String keyAlias) {\n        this.keyAlias = keyAlias;\n    }\n\n    public String getSslProtocol() {\n        return sslProtocol;\n    }\n\n    public void setSslProtocol(final String sslProtocol) {\n        this.sslProtocol = sslProtocol;\n    }\n\n    public String getUsers() {\n        return users;\n    }\n\n    public Properties getUsersAsProperties() {\n        return toProperties(users);\n    }\n\n    @Multiline\n    public void setUsers(final String users) {\n        this.users = users;\n    }\n\n    public String getRoles() {\n        return roles;\n    }\n\n    public Properties getRolesAsProperties() {\n        return toProperties(roles);\n    }\n\n    @Multiline\n    public void setRoles(final String roles) {\n        this.roles = roles;\n    }\n\n    @Override\n    public int[] portsAlreadySet() {\n        final List<Integer> value = new ArrayList<Integer>();\n        if (getStopPort() > 0) {\n            value.add(getStopPort());\n        }\n        if (getHttpPort() > 0) {\n            value.add(getHttpPort());\n        }\n        if (getHttpsPort() > 0) {\n            value.add(getHttpsPort());\n        }\n        return toInts(value);\n    }\n\n    public Properties systemPropertiesAsProperties() {\n        if (properties == null || properties.isEmpty()) {\n            return new Properties();\n        }\n\n        return toProperties(properties);\n    }\n\n    private static Properties toProperties(final String value) {\n        if (value == null || value.isEmpty()) {\n            return null;\n        }\n\n        final Properties properties = new Properties();\n        final ByteArrayInputStream bais = new ByteArrayInputStream(value.getBytes());\n        try {\n            properties.load(bais);\n        } catch (final IOException e) {\n            throw new OpenEJBRuntimeException(e);\n        } finally {\n            try {\n                IO.close(bais);\n            } catch (final IOException ignored) {\n                // no-op\n            }\n        }\n        return properties;\n    }\n}\n",
        "human_patch_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.openejb.arquillian.embedded;\n\nimport org.apache.openejb.OpenEJBRuntimeException;\nimport org.apache.openejb.arquillian.common.IO;\nimport org.apache.openejb.arquillian.common.Prefixes;\nimport org.apache.openejb.arquillian.common.TomEEConfiguration;\nimport org.jboss.arquillian.config.descriptor.api.Multiline;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * @version $Rev$ $Date$\n */\n@Prefixes({\"tomee\", \"tomee.embedded\"})\npublic class EmbeddedTomEEConfiguration extends TomEEConfiguration {\n    private int httpsPort = 8443;\n    private boolean ssl;\n    private boolean withEjbRemote;\n    private String keystoreFile;\n    private String keystorePass;\n    private String keystoreType = \"JKS\";\n    private String clientAuth;\n    private String keyAlias;\n    private String sslProtocol;\n    private String users;\n    private String roles;\n    private boolean webResourcesCached = true;\n\n    public boolean isWebResourcesCached() {\n        return webResourcesCached;\n    }\n\n    public void setWebResourcesCached(final boolean webResourcesCached) {\n        this.webResourcesCached = webResourcesCached;\n    }\n\n    public boolean isWithEjbRemote() {\n        return withEjbRemote;\n    }\n\n    public void setWithEjbRemote(final boolean withEjbRemote) {\n        this.withEjbRemote = withEjbRemote;\n    }\n\n    public int getHttpsPort() {\n        return httpsPort;\n    }\n\n    public void setHttpsPort(final int httpsPort) {\n        this.httpsPort = httpsPort;\n    }\n\n    public boolean isSsl() {\n        return ssl;\n    }\n\n    public void setSsl(final boolean ssl) {\n        this.ssl = ssl;\n    }\n\n    public String getKeystoreFile() {\n        return keystoreFile;\n    }\n\n    public void setKeystoreFile(final String keystoreFile) {\n        this.keystoreFile = keystoreFile;\n    }\n\n    public String getKeystorePass() {\n        return keystorePass;\n    }\n\n    public void setKeystorePass(final String keystorePass) {\n        this.keystorePass = keystorePass;\n    }\n\n    public String getKeystoreType() {\n        return keystoreType;\n    }\n\n    public void setKeystoreType(final String keystoreType) {\n        this.keystoreType = keystoreType;\n    }\n\n    public String getClientAuth() {\n        return clientAuth;\n    }\n\n    public void setClientAuth(final String clientAuth) {\n        this.clientAuth = clientAuth;\n    }\n\n    public String getKeyAlias() {\n        return keyAlias;\n    }\n\n    public void setKeyAlias(final String keyAlias) {\n        this.keyAlias = keyAlias;\n    }\n\n    public String getSslProtocol() {\n        return sslProtocol;\n    }\n\n    public void setSslProtocol(final String sslProtocol) {\n        this.sslProtocol = sslProtocol;\n    }\n\n    public String getUsers() {\n        return users;\n    }\n\n    public Properties getUsersAsProperties() {\n        return toProperties(users);\n    }\n\n    @Multiline\n    public void setUsers(final String users) {\n        this.users = users;\n    }\n\n    public String getRoles() {\n        return roles;\n    }\n\n    public Properties getRolesAsProperties() {\n        return toProperties(roles);\n    }\n\n    @Multiline\n    public void setRoles(final String roles) {\n        this.roles = roles;\n    }\n\n    @Override\n    public int[] portsAlreadySet() {\n        final List<Integer> value = new ArrayList<Integer>();\n        if (getStopPort() > 0) {\n            value.add(getStopPort());\n        }\n        if (getHttpPort() > 0) {\n            value.add(getHttpPort());\n        }\n        if (getHttpsPort() > 0) {\n            value.add(getHttpsPort());\n        }\n        return toInts(value);\n    }\n\n    public Properties systemPropertiesAsProperties() {\n        if (properties == null || properties.isEmpty()) {\n            return new Properties();\n        }\n\n        final Properties properties = toProperties(this.properties);\n        if (properties != null && isUnsafeEjbd() &&\n            \"*\".equals(properties.getProperty(\"tomee.serialization.class.blacklist\", \"-\").trim())) {\n\n            properties.remove(\"tomee.serialization.class.blacklist\");\n            properties.put(\"tomee.serialization.class.whitelist\", \"*\");\n        }\n\n        return properties;\n    }\n\n    private static Properties toProperties(final String value) {\n        if (value == null || value.isEmpty()) {\n            return null;\n        }\n\n        final Properties properties = new Properties();\n        final ByteArrayInputStream bais = new ByteArrayInputStream(value.getBytes());\n        try {\n            properties.load(bais);\n        } catch (final IOException e) {\n            throw new OpenEJBRuntimeException(e);\n        } finally {\n            try {\n                IO.close(bais);\n            } catch (final IOException ignored) {\n                // no-op\n            }\n        }\n        return properties;\n    }\n}\n"
      },
      {
        "file_path": "container/openejb-core/src/main/java/org/apache/openejb/core/rmi/BlacklistClassResolver.java",
        "file_name": "BlacklistClassResolver.java",
        "vulnerable_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.openejb.core.rmi;\n\nimport java.io.ObjectStreamClass;\n\npublic class BlacklistClassResolver {\n    public static final BlacklistClassResolver DEFAULT = new BlacklistClassResolver(\n        toArray(System.getProperty(\n            \"tomee.serialization.class.blacklist\",\n            \"org.codehaus.groovy.runtime.,org.apache.commons.collections.functors.,org.apache.xalan,java.lang.Process\")),\n        toArray(System.getProperty(\"tomee.serialization.class.whitelist\")));\n\n    private final String[] blacklist;\n    private final String[] whitelist;\n\n    protected BlacklistClassResolver(final String[] blacklist, final String[] whitelist) {\n        this.whitelist = whitelist;\n        this.blacklist = blacklist;\n    }\n\n    protected boolean isBlacklisted(final String name) {\n        return (whitelist != null && !contains(whitelist, name)) || contains(blacklist, name);\n    }\n\n    public final ObjectStreamClass check(final ObjectStreamClass classDesc) {\n        check(classDesc.getName());\n        return classDesc;\n    }\n\n    public final String check(final String name) {\n        if (isBlacklisted(name)) {\n            throw new SecurityException(name + \" is not whitelisted as deserialisable, prevented before loading.\");\n        }\n        return name;\n    }\n\n    private static String[] toArray(final String property) {\n        return property == null ? null : property.split(\" *, *\");\n    }\n\n    private static boolean contains(final String[] list, final String name) {\n        if (list != null) {\n            for (final String white : list) {\n                if (name.startsWith(white)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n",
        "human_patch_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.openejb.core.rmi;\n\nimport java.io.ObjectStreamClass;\n\npublic class BlacklistClassResolver {\n    public static final BlacklistClassResolver DEFAULT = new BlacklistClassResolver(\n        toArray(System.getProperty(\n            \"tomee.serialization.class.blacklist\",\n            \"org.codehaus.groovy.runtime.,org.apache.commons.collections.functors.,org.apache.xalan,java.lang.Process\")),\n        toArray(System.getProperty(\"tomee.serialization.class.whitelist\")));\n\n    private final String[] blacklist;\n    private final String[] whitelist;\n\n    protected BlacklistClassResolver(final String[] blacklist, final String[] whitelist) {\n        this.whitelist = whitelist;\n        this.blacklist = blacklist;\n    }\n\n    protected boolean isBlacklisted(final String name) {\n        return (whitelist != null && !contains(whitelist, name)) || contains(blacklist, name);\n    }\n\n    public final ObjectStreamClass check(final ObjectStreamClass classDesc) {\n        check(classDesc.getName());\n        return classDesc;\n    }\n\n    public final String check(final String name) {\n        if (isBlacklisted(name)) {\n            throw new SecurityException(name + \" is not whitelisted as deserialisable, prevented before loading.\");\n        }\n        return name;\n    }\n\n    private static String[] toArray(final String property) {\n        return property == null ? null : property.split(\" *, *\");\n    }\n\n    private static boolean contains(final String[] list, final String name) {\n        if (list != null) {\n            for (final String white : list) {\n                if (\"*\".equals(white) || name.startsWith(white)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n"
      },
      {
        "file_path": "server/openejb-client/src/main/java/org/apache/openejb/client/EjbObjectInputStream.java",
        "file_name": "EjbObjectInputStream.java",
        "vulnerable_code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.openejb.client;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectStreamClass;\nimport java.lang.reflect.Proxy;\n\n/**\n * @version $Rev$ $Date$\n */\npublic class EjbObjectInputStream extends ObjectInputStream {\n    private static final BlacklistClassResolver DEFAULT = new BlacklistClassResolver();\n\n    public EjbObjectInputStream(final InputStream in) throws IOException {\n        super(in);\n    }\n\n    @Override\n    protected Class<?> resolveClass(final ObjectStreamClass classDesc) throws IOException, ClassNotFoundException {\n        final String n = DEFAULT.check(classDesc.getName());\n        final ClassLoader classloader = getClassloader();\n        try {\n            return Class.forName(n, false, classloader);\n        } catch (ClassNotFoundException e) {\n\n            if (n.equals(\"boolean\")) {\n                return boolean.class;\n            }\n            if (n.equals(\"byte\")) {\n                return byte.class;\n            }\n            if (n.equals(\"char\")) {\n                return char.class;\n            }\n            if (n.equals(\"short\")) {\n                return short.class;\n            }\n            if (n.equals(\"int\")) {\n                return int.class;\n            }\n            if (n.equals(\"long\")) {\n                return long.class;\n            }\n            if (n.equals(\"float\")) {\n                return float.class;\n            }\n            if (n.equals(\"double\")) {\n                return double.class;\n            }\n\n            //Last try - Let runtime try and find it.\n            return Class.forName(n, false, null);\n        }\n    }\n\n    @Override\n    protected Class resolveProxyClass(final String[] interfaces) throws IOException, ClassNotFoundException {\n        final Class[] cinterfaces = new Class[interfaces.length];\n        for (int i = 0; i < interfaces.length; i++) {\n            cinterfaces[i] = getClassloader().loadClass(interfaces[i]);\n        }\n\n        try {\n            return Proxy.getProxyClass(getClassloader(), cinterfaces);\n        } catch (IllegalArgumentException e) {\n            throw new ClassNotFoundException(null, e);\n        }\n    }\n\n    ClassLoader getClassloader() {\n        return Thread.currentThread().getContextClassLoader();\n    }\n\n    public static class BlacklistClassResolver {\n        private static final String[] WHITELIST = toArray(System.getProperty(\"tomee.serialization.class.whitelist\"));\n        private static final String[] BLACKLIST = toArray(System.getProperty(\n            \"tomee.serialization.class.blacklist\", \"org.codehaus.groovy.runtime.,org.apache.commons.collections.functors.,org.apache.xalan,java.lang.Process\"));\n\n        private final String[] blacklist;\n        private final String[] whitelist;\n\n        protected BlacklistClassResolver() {\n            this(BLACKLIST, WHITELIST);\n        }\n\n        protected BlacklistClassResolver(final String[] blacklist, final String[] whitelist) {\n            this.whitelist = whitelist;\n            this.blacklist = blacklist;\n        }\n\n        protected boolean isBlacklisted(final String name) {\n            return (whitelist != null && !contains(whitelist, name)) || contains(blacklist, name);\n        }\n\n        public final String check(final String name) {\n            if (isBlacklisted(name)) {\n                throw new SecurityException(name + \" is not whitelisted as deserialisable, prevented before loading.\");\n            }\n            return name;\n        }\n\n        private static String[] toArray(final String property) {\n            return property == null ? null : property.split(\" *, *\");\n        }\n\n        private static boolean contains(final String[] list, String name) {\n            if (list != null) {\n                for (final String white : list) {\n                    if (name.startsWith(white)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n    }\n}\n",
        "human_patch_code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.openejb.client;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectStreamClass;\nimport java.lang.reflect.Proxy;\n\n/**\n * @version $Rev$ $Date$\n */\npublic class EjbObjectInputStream extends ObjectInputStream {\n    private static final BlacklistClassResolver DEFAULT = new BlacklistClassResolver();\n\n    public EjbObjectInputStream(final InputStream in) throws IOException {\n        super(in);\n    }\n\n    @Override\n    protected Class<?> resolveClass(final ObjectStreamClass classDesc) throws IOException, ClassNotFoundException {\n        final String n = DEFAULT.check(classDesc.getName());\n        final ClassLoader classloader = getClassloader();\n        try {\n            return Class.forName(n, false, classloader);\n        } catch (ClassNotFoundException e) {\n\n            if (n.equals(\"boolean\")) {\n                return boolean.class;\n            }\n            if (n.equals(\"byte\")) {\n                return byte.class;\n            }\n            if (n.equals(\"char\")) {\n                return char.class;\n            }\n            if (n.equals(\"short\")) {\n                return short.class;\n            }\n            if (n.equals(\"int\")) {\n                return int.class;\n            }\n            if (n.equals(\"long\")) {\n                return long.class;\n            }\n            if (n.equals(\"float\")) {\n                return float.class;\n            }\n            if (n.equals(\"double\")) {\n                return double.class;\n            }\n\n            //Last try - Let runtime try and find it.\n            return Class.forName(n, false, null);\n        }\n    }\n\n    @Override\n    protected Class resolveProxyClass(final String[] interfaces) throws IOException, ClassNotFoundException {\n        final Class[] cinterfaces = new Class[interfaces.length];\n        for (int i = 0; i < interfaces.length; i++) {\n            cinterfaces[i] = getClassloader().loadClass(interfaces[i]);\n        }\n\n        try {\n            return Proxy.getProxyClass(getClassloader(), cinterfaces);\n        } catch (IllegalArgumentException e) {\n            throw new ClassNotFoundException(null, e);\n        }\n    }\n\n    ClassLoader getClassloader() {\n        return Thread.currentThread().getContextClassLoader();\n    }\n\n    public static class BlacklistClassResolver {\n        private static final String[] WHITELIST = toArray(System.getProperty(\"tomee.serialization.class.whitelist\"));\n        private static final String[] BLACKLIST = toArray(System.getProperty(\n            \"tomee.serialization.class.blacklist\", \"org.codehaus.groovy.runtime.,org.apache.commons.collections.functors.,org.apache.xalan,java.lang.Process\"));\n\n        private final String[] blacklist;\n        private final String[] whitelist;\n\n        protected BlacklistClassResolver() {\n            this(BLACKLIST, WHITELIST);\n        }\n\n        protected BlacklistClassResolver(final String[] blacklist, final String[] whitelist) {\n            this.whitelist = whitelist;\n            this.blacklist = blacklist;\n        }\n\n        protected boolean isBlacklisted(final String name) {\n            return (whitelist != null && !contains(whitelist, name)) || contains(blacklist, name);\n        }\n\n        public final String check(final String name) {\n            if (isBlacklisted(name)) {\n                throw new SecurityException(name + \" is not whitelisted as deserialisable, prevented before loading.\");\n            }\n            return name;\n        }\n\n        private static String[] toArray(final String property) {\n            return property == null ? null : property.split(\" *, *\");\n        }\n\n        private static boolean contains(final String[] list, String name) {\n            if (list != null) {\n                for (final String white : list) {\n                    if (\"*\".equals(white) || name.startsWith(white)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n    }\n}\n"
      },
      {
        "file_path": "tomee/tomee-common/src/main/java/org/apache/tomee/installer/Installer.java",
        "file_name": "Installer.java",
        "vulnerable_code": "/**\n *\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.tomee.installer;\n\nimport org.apache.openejb.loader.Options;\nimport org.apache.openejb.loader.SystemInstance;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.jar.JarFile;\n\npublic class Installer implements InstallerInterface {\n    private final Alerts alerts = new Alerts();\n\n    private final Paths paths;\n    private Status status = Status.NONE;\n    private boolean force;\n\n    private static final boolean listenerInstalled;\n    private static final boolean agentInstalled;\n    static {\n        final Options opts = SystemInstance.get().getOptions();\n        // is the OpenEJB listener installed\n        listenerInstalled = \"OpenEJBListener\".equals(opts.get(\"openejb.embedder.source\", \"\"))\n                || \"ServerListener\".equals(opts.get(\"openejb.embedder.source\", \"\"));\n\n        // is the OpenEJB javaagent installed\n        agentInstalled = InstallerTools.invokeStaticNoArgMethod(\n                \"org.apache.openejb.javaagent.Agent\", \"getInstrumentation\") != null;\n    }\n\n    public static boolean isListenerInstalled() {\n        return listenerInstalled;\n    }\n\n    public static boolean isAgentInstalled() {\n        return agentInstalled;\n    }\n\n    public Installer(final Paths paths) {\n        this.paths = paths;\n\n        if (listenerInstalled && agentInstalled) {\n            status = Status.INSTALLED;\n        }\n    }\n\n    public Installer(final Paths paths, final boolean force) {\n        this(paths);\n        this.force = force;\n    }\n\n    @Override\n    public PathsInterface getPaths() {\n        return paths;\n    }\n\n    @Override\n    public Alerts getAlerts() {\n        return alerts;\n    }\n\n    @Override\n    public void reset() {\n        alerts.reset();\n    }\n\n    @Override\n    public Status getStatus() {\n        return status;\n    }\n\n    @Override\n    public void installAll() {\n        installListener();\n        installJavaagent();\n        installConfigFiles(false);\n\n        removeTomcatLibJar(\"annotations-api.jar\");\n        // addJavaeeInEndorsed();\n        addTomEEJuli();\n\n        addTomEEAdminConfInTomcatUsers();\n        addTomEELinkToTomcatHome();\n\n        workaroundOnBat();\n\n        if (!alerts.hasErrors()) {\n            status = Status.REBOOT_REQUIRED;\n        }\n    }\n\n    // switch tomcat-juli with tomee-juli\n    // we keep the same name to let all tomcat tooling work as expected\n    private void addTomEEJuli() {\n        final File original = new File(paths.getCatalinaBinDir(), \"tomcat-juli.jar\");\n\n        final File juli = paths.findOpenEJBJar(\"tomee-juli\");\n        try {\n            Installers.copyFile(juli, new File(original.getAbsolutePath()));\n            if (!juli.delete()) { // remove original\n                juli.deleteOnExit();\n            }\n        } catch (final IOException e) {\n            alerts.addInfo(\"Add tomee user to tomcat-users.xml\");\n        }\n    }\n\n    public void addTomEEAdminConfInTomcatUsers() {\n        addTomEEAdminConfInTomcatUsers(false);\n    }\n\n    public void addTomEEAdminConfInTomcatUsers(final boolean securityActivated) {\n        // read server.xml\n        final String tomcatUsersXml = Installers.readAll(paths.getTomcatUsersXml(), alerts);\n\n        // server xml will be null if we couldn't read the file\n        if (tomcatUsersXml == null) {\n            return;\n        }\n\n        if (tomcatUsersXml.contains(\"tomee-admin\")) {\n            alerts.addWarning(\"Can't add tomee user to tomcat-users.xml\");\n            return;\n        }\n\n        // if we can't backup the file, do not modify it\n        if (!Installers.backup(paths.getTomcatUsersXml(), alerts)) {\n            return;\n        }\n\n        // add our listener\n        final String roleUserTags =\n                \"  <role rolename=\\\"tomee-admin\\\" />\\n\" +\n                        \"  <user username=\\\"tomee\\\" password=\\\"tomee\\\" roles=\\\"tomee-admin,manager-gui\\\" />\\n\";\n        final String content;\n        if (!securityActivated) {\n            content =\n                    \"  <!-- Activate those lines to get access to TomEE GUI -->\\n\" +\n                            \"  <!--\\n\" +\n                            roleUserTags +\n                            \"  -->\\n\" +\n                            \"</tomcat-users>\\n\";\n        } else {\n            content =\n                    \"  <!-- Activate those lines to get access to TomEE GUI\\n -->\" +\n                            roleUserTags +\n                            \"</tomcat-users>\\n\";\n\n        }\n        final String newTomcatUsers = tomcatUsersXml.replace(\"</tomcat-users>\", content);\n\n        // overwrite server.xml\n        if (Installers.writeAll(paths.getTomcatUsersXml(), newTomcatUsers, alerts)) {\n            alerts.addInfo(\"Add tomee user to tomcat-users.xml\");\n        }\n    }\n\n    public void installFull() {\n        installListener(\"org.apache.tomee.catalina.ServerListener\");\n        installJavaagent();\n\n        commentDeploymentDir();\n        installConfigFiles(true);\n\n        removeTomcatLibJar(\"annotations-api.jar\");\n        // addJavaeeInEndorsed();\n        addTomEEJuli(); // before moveLibs\n        moveLibs();\n\n        addTomEEAdminConfInTomcatUsers();\n        addTomEELinkToTomcatHome();\n\n        workaroundOnBat();\n\n        if (!alerts.hasErrors()) {\n            status = Status.REBOOT_REQUIRED;\n        }\n    }\n\n    private void workaroundOnBat() {\n        final File setclasspath = new File(paths.getCatalinaBinDir(), \"setclasspath.bat\");\n        String bat = Installers.readAll(setclasspath, alerts);\n        if (bat == null || bat.contains(\" NOT DEFINED \") /* already done, tomcat doesnt use yet this new Windows NT 4 syntax */) {\n            return;\n        }\n\n        // add our magic bits to the catalina bat file\n        bat = bat // could be regex but here the diff is explicit which is better IMO\n                .replace(\"not \\\"%JRE_HOME%\\\" == \\\"\\\"\", \"DEFINED JRE_HOME\")\n                .replace(\"not \\\"%JAVA_HOME%\\\" == \\\"\\\"\", \"DEFINED JAVA_HOME\")\n                .replace(\"not \\\"%_RUNJAVA%\\\" == \\\"\\\"\", \"DEFINED _RUNJAVA\")\n                .replace(\"not \\\"%_RUNJDB%\\\" == \\\"\\\"\", \"DEFINED _RUNJDB\")\n                .replace(\"\\\"%JAVA_HOME%\\\" == \\\"\\\"\", \"NOT DEFINED JAVA_HOME\");\n\n        // overwrite the catalina.bat file\n        if (!Installers.writeAll(setclasspath, bat, alerts)) {\n            alerts.addInfo(\"Can't add workarounds for setclasspath.bat\");\n        }\n    }\n\n    private void removeTomcatLibJar(final String name) {\n        final File jar = new File(paths.getCatalinaLibDir(), name);\n        removeJar(jar);\n    }\n\n    private void commentDeploymentDir() {\n        final File tomeeXml = new File(paths.getCatalinaConfDir(), \"tomee.xml\");\n        if (!tomeeXml.exists()) {\n            Installers.writeAll(tomeeXml,\n                    \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                            \"<tomee>\\n\" +\n                            \"  <!-- see http://tomee.apache.org/containers-and-resources.html -->\\n\\n\" +\n                            \"  <!-- activate next line to be able to deploy applications in apps -->\\n\" +\n                            \"  <!-- <Deployments dir=\\\"apps\\\" /> -->\\n\" +\n                            \"</tomee>\\n\", alerts);\n        }\n    }\n\n    private void addTomEELinkToTomcatHome() {\n        final File home = paths.getHome();\n        if(!home.exists()) {\n            return;\n        }\n        final String indeJsp = Installers.readAll(home, alerts);\n        if (indeJsp == null) {\n            return;\n        }\n\n        if (!indeJsp.contains(\"tomcatUrl\")) { // check the user didn't replaced the file, can be improved\n            alerts.addWarning(\"webapps/ROOT/index.jsp was modified\");\n            return;\n        }\n\n        final String newIndeJsp = indeJsp.replaceFirst(\"<div id=\\\"actions\\\">\",\n                \"<div id=\\\"actions\\\">\\n\" +\n                        \"                    <div class=\\\"button\\\">\\n\" +\n                        \"                        <a class=\\\"container shadow\\\" href=\\\"/tomee\\\"><span>TomEE Gui</span></a>\\n\" +\n                        \"                    </div>\");\n        Installers.writeAll(home, newIndeJsp, alerts);\n    }\n\n    private void moveLibs() {\n        final File libs = paths.getCatalinaLibDir();\n        final File[] files = paths.getOpenEJBLibDir().listFiles();\n        if (files != null) {\n            for (final File file : files) {\n                if (file.isDirectory()) {\n                    continue;\n                }\n                if (!file.getName().endsWith(\".jar\")) {\n                    continue;\n                }\n\n                try {\n                    Installers.copyFile(file, new File(libs, file.getName()));\n                    if (!file.delete()) {\n                        file.deleteOnExit();\n                    }\n                    alerts.addInfo(\"Copy \" + file.getName() + \" to lib\");\n                } catch (final IOException e) {\n                    alerts.addError(\"Unable to \" + file.getName() + \" to Tomcat lib directory.  This will need to be \" +\n                            \"performed manually.\", e);\n                }\n            }\n        }\n    }\n\n    /*\n    private void addJavaeeInEndorsed() {\n        final File endorsed = new File(paths.getCatalinaHomeDir(), \"endorsed\");\n        if (!endorsed.mkdir()) {\n            alerts.addWarning(\"can't create endorsed directory\");\n        }\n\n        final File jaxbApi = paths.findOpenEJBJar(\"geronimo-jaxb_2.2_spec\");\n        copyClasses(paths.getJavaEEAPIJar(), jaxbApi, new File(endorsed, \"jaxb-api.jar\"), \"javax/xml/bind/.*\",\n                Arrays.asList(\"javax/xml/bind/ContextFinder.class\", \"javax/xml/bind/DatatypeConverter.class\"));\n        removeJar(jaxbApi);\n\n        // don't put jaxb-impl in endorsed since it relies on the jvm itself\n        final File jaxbImpl = new File(paths.getCatalinaLibDir(), \"jaxb-impl.jar\");\n        if (!jaxbImpl.exists()) {\n            try {\n                Installers.copyFile(paths.getJAXBImpl(), jaxbImpl);\n            } catch (final IOException e) {\n                alerts.addError(\"can't copy \" + paths.getJAXBImpl().getPath() + \" to \" + endorsed.getPath() + \"/jaxb-impl.jar\");\n            }\n        }\n    }\n\n\n    private void copyClasses(final File javaEEAPIJar, final File sourceJar, final File destinationJar,\n                             final String pattern, final List<String> exceptions) {\n        if (javaEEAPIJar == null) {\n            throw new NullPointerException(\"javaEEAPIJar\");\n        }\n        if (sourceJar == null) {\n            throw new NullPointerException(\"sourceJar\");\n        }\n        if (destinationJar == null) {\n            throw new NullPointerException(\"destinationJar\");\n        }\n        if (pattern == null) {\n            throw new NullPointerException(\"pattern\");\n        }\n        if (exceptions == null) {\n            throw new NullPointerException(\"exceptions\");\n        }\n\n        if (destinationJar.exists()) {\n            return;\n        }\n\n        try {\n            final ByteArrayOutputStream destinationBuffer = new ByteArrayOutputStream(524288);\n            final ZipOutputStream destination = new ZipOutputStream(destinationBuffer);\n            final ZipInputStream source = new ZipInputStream(IO.read(sourceJar));\n            for (ZipEntry entry; (entry = source.getNextEntry()) != null; ) {\n                final String entryName = entry.getName();\n                if (!entryName.matches(pattern) || exceptions.contains(entryName)) {\n                    continue;\n                }\n                destination.putNextEntry(new ZipEntry(entryName));\n                IO.copy(source, destination);\n            }\n            IO.close(source);\n            final ZipInputStream source2 = new ZipInputStream(IO.read(javaEEAPIJar));\n            for (ZipEntry entry; (entry = source2.getNextEntry()) != null; ) {\n                final String entryName = entry.getName();\n                if (!entryName.matches(pattern) || !exceptions.contains(entryName)) {\n                    continue;\n                }\n\n                destination.putNextEntry(new ZipEntry(entryName));\n\n                IO.copy(source2, destination);\n            }\n            IO.close(source2);\n            IO.close(destination);\n            IO.copy(destinationBuffer.toByteArray(), destinationJar);\n        } catch (final IOException e) {\n            alerts.addError(e.getMessage());\n        }\n    }\n    */\n\n    private void removeJar(final File jar) {\n        if (jar.exists()) {\n            if (!jar.delete()) {\n                jar.deleteOnExit();\n            }\n            alerts.addInfo(\"Please restart the server or delete manually \" + jar.getName());\n        }\n    }\n\n    public void installListener() {\n        installListener(\"org.apache.tomee.loader.OpenEJBListener\");\n    }\n\n    public void installListener(final String listener) {\n        if (listenerInstalled && !force) {\n            // OpenEJB Listener already installed\n            return;\n        }\n        boolean copyOpenEJBLoader = true;\n\n        // copy loader jar to lib\n        final File destination = new File(paths.getCatalinaLibDir(), paths.getOpenEJBTomcatLoaderJar().getName());\n        if (destination.exists()) {\n            if (paths.getOpenEJBTomcatLoaderJar().length() == destination.length()) {\n                copyOpenEJBLoader = false;\n            }\n        }\n        if (copyOpenEJBLoader) {\n            try {\n                Installers.copyFile(paths.getOpenEJBTomcatLoaderJar(), destination);\n                alerts.addInfo(\"Copy \" + paths.getOpenEJBTomcatLoaderJar().getName() + \" to lib\");\n            } catch (final IOException e) {\n                alerts.addError(\"Unable to copy OpenEJB Tomcat loader jar to Tomcat lib directory.  This will need to be performed manually.\", e);\n            }\n        }\n\n        // read server.xml\n        final String serverXmlOriginal = Installers.readAll(paths.getServerXmlFile(), alerts);\n\n        // server xml will be null if we couldn't read the file\n        if (serverXmlOriginal == null) {\n            return;\n        }\n\n        // does the server.xml contain our listener name... it is possible that they commented out our listener, but that would be a PITA to detect\n        if (serverXmlOriginal.contains(listener)) {\n            alerts.addWarning(\"OpenEJB Listener already declared in Tomcat server.xml file.\");\n            return;\n        }\n\n        // if we can't backup the file, do not modify it\n        if (!Installers.backup(paths.getServerXmlFile(), alerts)) {\n            return;\n        }\n\n        // add our listener\n        String newServerXml = null;\n        try {\n            newServerXml = Installers.replace(serverXmlOriginal,\n                    \"<Server\",\n                    \"<Server\",\n                    \">\",\n                    \">\\r\\n\" +\n                            \"  <!-- TomEE plugin for Tomcat -->\\r\\n\" +\n                            \"  <Listener className=\\\"\" + listener + \"\\\" />\");\n        } catch (final IOException e) {\n            alerts.addError(\"Error while adding listener to server.xml file\", e);\n        }\n\n        //Add TomEE header\n        try {\n            newServerXml = Installers.replace(newServerXml,\n                    \"<Connector port=\\\"8080\\\"\",\n                    \"<Connector port=\\\"8080\\\"\",\n                    \"/>\",\n                    \"xpoweredBy=\\\"false\\\" server=\\\"Apache TomEE\\\" />\");\n\n            newServerXml = Installers.replace(newServerXml,\n                    \"<Connector port=\\\"8443\\\"\",\n                    \"<Connector port=\\\"8443\\\"\",\n                    \"/>\",\n                    \"xpoweredBy=\\\"false\\\" server=\\\"Apache TomEE\\\" />\");\n        } catch (final IOException e) {\n            alerts.addError(\"Error adding server attribute to server.xml file\", e);\n        }\n\n        // overwrite server.xml\n        if (Installers.writeAll(paths.getServerXmlFile(), newServerXml, alerts)) {\n            alerts.addInfo(\"Add OpenEJB listener to server.xml\");\n        }\n    }\n\n    // NOTE: we specify the jaxbcontext implementation because\n    //       we are using geronimo jaxb API and we don't want to go to\n    //       the geronimo locator to find the implementation\n    //       because it needs some OSGi API we don't want to add\n    public void installJavaagent() {\n        if (agentInstalled && !force) {\n            // OpenEJB Agent already installed\"\n            return;\n        }\n\n        //\n        // Copy openejb-javaagent.jar to lib\n        //\n        boolean copyJavaagentJar = true;\n        final File javaagentJar = new File(paths.getCatalinaLibDir(), \"openejb-javaagent.jar\");\n        if (javaagentJar.exists()) {\n            if (paths.getOpenEJBJavaagentJar().length() == javaagentJar.length()) {\n                copyJavaagentJar = false;\n            }\n        }\n\n        if (copyJavaagentJar) {\n            try {\n                Installers.copyFile(paths.getOpenEJBJavaagentJar(), javaagentJar);\n                alerts.addInfo(\"Copy \" + paths.getOpenEJBJavaagentJar().getName() + \" to lib\");\n            } catch (final IOException e) {\n                alerts.addError(\"Unable to copy OpenEJB javaagent jar to Tomcat lib directory.  This will need to be performed manually.\", e);\n            }\n        }\n\n\n        //\n        // bin/catalina.sh\n        //\n\n        // read the catalina sh file\n        final String catalinaShOriginal = Installers.readAll(paths.getCatalinaShFile(), alerts);\n\n        // catalina sh will be null if we couldn't read the file\n        if (catalinaShOriginal == null) {\n            return;\n        }\n\n        // does the catalina sh contain our comment... it is possible that they commented out the magic script code, but there is no way to detect that\n        if (catalinaShOriginal.contains(\"Add OpenEJB javaagent\")) {\n            alerts.addWarning(\"OpenEJB javaagent already declared in Tomcat catalina.sh file.\");\n            return;\n        }\n\n        // if we can't backup the file, do not modify it\n        if (!Installers.backup(paths.getCatalinaShFile(), alerts)) {\n            return;\n        }\n\n        // add our magic bits to the catalina sh file\n        String openejbJavaagentPath = paths.getCatalinaHomeDir().toURI().relativize(javaagentJar.toURI()).getPath();\n        final String newCatalinaSh = catalinaShOriginal.replace(\"# ----- Execute The Requested Command\",\n                \"# Add OpenEJB javaagent\\n\" +\n                        \"if [ -r \\\"$CATALINA_HOME\\\"/\" + openejbJavaagentPath + \" ]; then\\n\" +\n                        \"  JAVA_OPTS=\\\"\\\\\\\"-javaagent:$CATALINA_HOME/\" + openejbJavaagentPath + \"\\\\\\\" $JAVA_OPTS\\\"\\n\" +\n                        \"fi\\n\" +\n                        \"\\n\" +\n                        \"# ----- Execute The Requested Command\");\n\n        // overwrite the catalina.sh file\n        if (Installers.writeAll(paths.getCatalinaShFile(), newCatalinaSh, alerts)) {\n            alerts.addInfo(\"Add OpenEJB JavaAgent to catalina.sh\");\n        }\n\n        boolean isCatalinaShExecutable = paths.getCatalinaShFile().canExecute();\n        if(!isCatalinaShExecutable) {\n            try {\n                isCatalinaShExecutable = paths.getCatalinaShFile().setExecutable(true);\n            } catch (final SecurityException e) {\n                alerts.addWarning(\"Cannot change CatalinaSh executable attribute.\");\n            }\n        }\n        if(!isCatalinaShExecutable) {\n            alerts.addWarning(\"CatalinaSh is not executable.\");\n        }\n\n        //\n        // bin/catalina.bat\n        //\n\n        // read the catalina bat file\n        final String catalinaBatOriginal = Installers.readAll(paths.getCatalinaBatFile(), alerts);\n\n        // catalina bat will be null if we couldn't read the file\n        if (catalinaBatOriginal == null) {\n            return;\n        }\n\n        // does the catalina bat contain our comment... it is possible that they commented out the magic script code, but there is no way to detect that\n        if (catalinaBatOriginal.contains(\"Add OpenEJB javaagent\")) {\n            alerts.addWarning(\"OpenEJB javaagent already declared in Tomcat catalina.bat file.\");\n            return;\n        }\n\n        // if we can't backup the file, do not modify it\n        if (!Installers.backup(paths.getCatalinaBatFile(), alerts)) {\n            return;\n        }\n\n        // add our magic bits to the catalina bat file\n        openejbJavaagentPath = openejbJavaagentPath.replace('/', '\\\\');\n        final String newCatalinaBat = catalinaBatOriginal.replace(\"rem ----- Execute The Requested Command\",\n                \"rem Add OpenEJB javaagent\\r\\n\" +\n                        \"if not exist \\\"%CATALINA_HOME%\\\\\" + openejbJavaagentPath + \"\\\" goto noOpenEJBJavaagent\\r\\n\" +\n                        \"set JAVA_OPTS=\\\"-javaagent:%CATALINA_HOME%\\\\\" + openejbJavaagentPath + \"\\\" %JAVA_OPTS%\\r\\n\" +\n                        \":noOpenEJBJavaagent\\r\\n\" +\n                        \"\\r\\n\" +\n                        \"rem ----- Execute The Requested Command\");\n\n        // overwrite the catalina.bat file\n        if (Installers.writeAll(paths.getCatalinaBatFile(), newCatalinaBat, alerts)) {\n            alerts.addInfo(\"Add OpenEJB JavaAgent to catalina.bat\");\n        }\n    }\n\n    /**\n     * Installs conf/tomee.xml and conf/logging.properties files.\n     * This method retrieves the tomee.xml and logging.properties files\n     * from openejb core jar file and installs them under the conf directory\n     * of tomcat. if there is already a conf/logging.properties file available\n     * then this method appends the contents of openejb logging.properties file\n     * to the exisiting properties file.\n     *\n     * Replace web.xml to set jasper in production mode instead of dev mode.\n     *\n     * NOTE:- If the existing conf/logging.properties file already has some openejb specific\n     * configuration, then this method will just leave the logging.properties file alone\n     * @param builtIn\n     */\n    public void installConfigFiles(final boolean builtIn) {\n        final File openejbCoreJar = paths.getOpenEJBCoreJar();\n        final File confDir = paths.getCatalinaConfDir();\n        final Alerts alerts = this.alerts;\n\n        if (openejbCoreJar == null) {\n            // the core jar contains the config files\n            return;\n        }\n        final JarFile coreJar;\n        try {\n            coreJar = new JarFile(openejbCoreJar);\n        } catch (final IOException e) {\n            return;\n        }\n\n        //\n        // conf/tomee.xml\n        //\n        final File openEjbXmlFile = new File(confDir, \"tomee.xml\");\n        if (!openEjbXmlFile.exists()) {\n            // read in the openejb.xml file from the openejb core jar\n            final String openEjbXml = Installers.readEntry(coreJar, \"default.openejb.conf\", alerts);\n            if (openEjbXml != null) {\n                if (Installers.writeAll(openEjbXmlFile, openEjbXml.replace(\"<openejb>\", \"<tomee>\").replace(\"</openejb>\", \"</tomee>\"), alerts)) {\n                    alerts.addInfo(\"Copy tomee.xml to conf\");\n                }\n            }\n        }\n\n\n        //\n        // conf/logging.properties\n        // now we are using tomcat one of jdk one by default\n        //\n        final String openejbLoggingProps = \"################################\\r\\n\" +\n                \"# OpenEJB/TomEE specific loggers\\r\\n\" +\n                \"################################\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# ACTIVATE LEVEL/HANDLERS YOU WANT\\r\\n\" +\n                \"# IF YOU ACTIVATE 5tomee.org.apache.juli.FileHandler\\r\\n\" +\n                \"# ADD IT TO handlers LINE LIKE:\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# handlers = 1catalina.org.apache.juli.FileHandler, 2localhost.org.apache.juli.FileHandler, 3manager.org.apache.juli.FileHandler, 4host-manager.org.apache.juli.FileHandler, 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# LEVELS:\\r\\n\" +\n                \"# =======\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# OpenEJB.level             = WARNING\\r\\n\" +\n                \"# OpenEJB.options.level     = INFO\\r\\n\" +\n                \"# OpenEJB.server.level      = INFO\\r\\n\" +\n                \"# OpenEJB.startup.level     = INFO\\r\\n\" +\n                \"# OpenEJB.startup.service.level = WARNING\\r\\n\" +\n                \"# OpenEJB.startup.config.level = INFO\\r\\n\" +\n                \"# OpenEJB.hsql.level        = INFO\\r\\n\" +\n                \"# CORBA-Adapter.level       = WARNING\\r\\n\" +\n                \"# Transaction.level         = WARNING\\r\\n\" +\n                \"# org.apache.activemq.level = SEVERE\\r\\n\" +\n                \"# org.apache.geronimo.level = SEVERE\\r\\n\" +\n                \"# openjpa.level             = WARNING\\r\\n\" +\n                \"# OpenEJB.cdi.level         = INFO\\r\\n\" +\n                \"# org.apache.webbeans.level = INFO\\r\\n\" +\n                \"# org.apache.openejb.level = FINE\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# HANDLERS:\\r\\n\" +\n                \"# =========\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# OpenEJB.handlers             = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.options.handlers     = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.server.handlers      = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.startup.handlers     = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.startup.service.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.startup.config.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.hsql.handlers        = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# CORBA-Adapter.handlers       = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# Transaction.handlers         = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# org.apache.activemq.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# org.apache.geronimo.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# openjpa.handlers             = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.cdi.handlers         = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# org.apache.webbeans.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# org.apache.openejb.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# TOMEE HANDLER SAMPLE:\\r\\n\" +\n                \"# =====================\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# 5tomee.org.apache.juli.FileHandler.level = FINEST\\r\\n\" +\n                \"# 5tomee.org.apache.juli.FileHandler.directory = ${catalina.base}/logs\\r\\n\" +\n                \"# 5tomee.org.apache.juli.FileHandler.prefix = tomee.\\r\\n\";\n        final File loggingPropsFile = new File(confDir, \"logging.properties\");\n        String newLoggingProps = null;\n        if (!loggingPropsFile.exists()) {\n            newLoggingProps = openejbLoggingProps;\n        } else {\n            final String loggingPropsOriginal = Installers.readAll(loggingPropsFile, alerts);\n            if (!loggingPropsOriginal.toLowerCase().contains(\"openejb\")) {\n                // append our properties\n                newLoggingProps = loggingPropsOriginal +\n                        \"\\r\\n\\r\\n\" +\n                        openejbLoggingProps + \"\\r\\n\";\n            }\n        }\n        if (builtIn) {\n            installTomEEJuli(alerts, loggingPropsFile, newLoggingProps);\n        }\n\n        final File openejbSystemProperties = new File(confDir, \"system.properties\");\n        if (!openejbSystemProperties.exists()) {\n            FileWriter systemPropertiesWriter = null;\n            try {\n                systemPropertiesWriter = new FileWriter(openejbSystemProperties);\n\n                systemPropertiesWriter.write(\"# all this properties are added at JVM system properties at startup\\n\");\n                systemPropertiesWriter.write(\"# here some default Apache TomEE system properties\\n\");\n                systemPropertiesWriter.write(\"# for more information please see http://tomee.apache.org/properties-listing.html\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\"# openejb.check.classloader = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.check.classloader.verbose = false\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\"# tomee.jaxws.subcontext = webservices\\n\");\n                systemPropertiesWriter.write(\"# tomee.jaxws.oldsubcontext = false\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\"# if you want to propagate a deployment on a cluster when a tomcat cluster is defined\\n\");\n                systemPropertiesWriter.write(\"# tomee.cluster.deployment = false\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\"# openejb.system.apps = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.servicemanager.enabled = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.jmx.active = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.descriptors.output = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.strict.interface.declaration = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.conf.file = conf/tomee.xml\\n\");\n                systemPropertiesWriter.write(\"# openejb.debuggable-vm-hackery = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.validation.skip = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.webservices.enabled = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.validation.output.level = MEDIUM\\n\");\n                systemPropertiesWriter.write(\"# openejb.user.mbeans.list = *\\n\");\n                systemPropertiesWriter.write(\"# openejb.deploymentId.format = {appId}/{ejbJarId}/{ejbName}\\n\");\n                systemPropertiesWriter.write(\"# openejb.jndiname.format = {deploymentId}{interfaceType.annotationName}\\n\");\n                systemPropertiesWriter.write(\"# openejb.deployments.package.include = .*\\n\");\n                systemPropertiesWriter.write(\"# openejb.deployments.package.exclude = \\n\");\n                systemPropertiesWriter.write(\"# openejb.autocreate.jta-datasource-from-non-jta-one = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.altdd.prefix = \\n\");\n                systemPropertiesWriter.write(\"# org.apache.openejb.default.system.interceptors = \\n\");\n                systemPropertiesWriter.write(\"# openejb.jndiname.failoncollision = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.wsAddress.format = /{ejbDeploymentId}\\n\");\n                systemPropertiesWriter.write(\"# org.apache.openejb.server.webservices.saaj.provider = \\n\");\n                systemPropertiesWriter.write(\"# openejb.nobanner = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.offline = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.jmx.active = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.exclude-include.order = include-exclude\\n\");\n                systemPropertiesWriter.write(\"# openejb.additional.exclude =\\n\");\n                systemPropertiesWriter.write(\"# openejb.additional.include =\\n\");\n                systemPropertiesWriter.write(\"# openejb.crosscontext = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.jsessionid-support = \\n\");\n                systemPropertiesWriter.write(\"# openejb.myfaces.disable-default-values = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.web.xml.major = \\n\");\n                systemPropertiesWriter.write(\"# openjpa.Log = \\n\");\n                systemPropertiesWriter.write(\"# openejb.jdbc.log = false\\n\");\n                systemPropertiesWriter.write(\"# javax.persistence.provider = org.apache.openjpa.persistence.PersistenceProviderImpl\\n\");\n                systemPropertiesWriter.write(\"# javax.persistence.transactionType = \\n\");\n                systemPropertiesWriter.write(\"# javax.persistence.jtaDataSource = \\n\");\n                systemPropertiesWriter.write(\"# javax.persistence.nonJtaDataSource = \\n\");\n\n                systemPropertiesWriter.write(\"#\\n\");\n                systemPropertiesWriter.write(\"# Properties for JAS RS\\n\");\n                systemPropertiesWriter.write(\"# openejb.jaxrs.application = \\n\");\n                systemPropertiesWriter.write(\"# openejb.cxf-rs.wadl-generator.ignoreRequests = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.cxf-rs.wadl-generator.ignoreMessageWriters = true\\n\");\n\n                systemPropertiesWriter.write(\"#\\n\");\n                systemPropertiesWriter.write(\"# These properties are only for cxf service (SOAP webservices) and TomEE+\\n\");\n                systemPropertiesWriter.write(\"# If you don't use special tricks and sun default implementation, uncommenting these 4 lines forces TomEE to use it without overhead at all = \\n\");\n                systemPropertiesWriter.write(\"# javax.xml.soap.MessageFactory = com.sun.xml.messaging.saaj.soap.ver1_1.SOAPMessageFactory1_1Impl\\n\");\n                systemPropertiesWriter.write(\"# javax.xml.soap.SOAPFactory = com.sun.xml.messaging.saaj.soap.ver1_1.SOAPFactory1_1Impl\\n\");\n                systemPropertiesWriter.write(\"# javax.xml.soap.SOAPConnectionFactory = com.sun.xml.messaging.saaj.client.p2p.HttpSOAPConnectionFactory\\n\");\n                systemPropertiesWriter.write(\"# javax.xml.soap.MetaFactory = com.sun.xml.messaging.saaj.soap.SAAJMetaFactoryImpl\\n\");\n            } catch (final IOException e) {\n                // ignored, this file is far to be mandatory\n            } finally {\n                if (systemPropertiesWriter != null) {\n                    try {\n                        systemPropertiesWriter.close();\n                    } catch (final IOException e) {\n                        // no-op\n                    }\n                }\n            }\n        }\n\n        //\n        // conf/web.xml\n        //\n        final JarFile openejbTomcatCommonJar;\n        try {\n            openejbTomcatCommonJar = new JarFile(paths.geOpenEJBTomcatCommonJar());\n        } catch (final IOException e) {\n            return;\n        }\n        final File webXmlFile = new File(confDir, \"web.xml\");\n        final String webXml = Installers.readEntry(openejbTomcatCommonJar, \"conf/web.xml\", alerts);\n        if (Installers.writeAll(webXmlFile, webXml, alerts)) {\n            alerts.addInfo(\"Set jasper in production mode in TomEE web.xml\");\n        }\n    }\n\n    private void installTomEEJuli(final Alerts alerts, final File loggingPropsFile, final String newLoggingProps) {\n        if (newLoggingProps != null && Installers.writeAll(\n                loggingPropsFile,\n                newLoggingProps.replace(\"java.util.logging.ConsoleHandler\", \"org.apache.tomee.jul.formatter.AsyncConsoleHandler\"),\n                alerts)) {\n            alerts.addInfo(\"Append OpenEJB config to logging.properties\");\n        }\n    }\n}\n",
        "human_patch_code": "/**\n *\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.tomee.installer;\n\nimport org.apache.openejb.loader.Options;\nimport org.apache.openejb.loader.SystemInstance;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.jar.JarFile;\n\npublic class Installer implements InstallerInterface {\n    private final Alerts alerts = new Alerts();\n\n    private final Paths paths;\n    private Status status = Status.NONE;\n    private boolean force;\n\n    private static final boolean listenerInstalled;\n    private static final boolean agentInstalled;\n    static {\n        final Options opts = SystemInstance.get().getOptions();\n        // is the OpenEJB listener installed\n        listenerInstalled = \"OpenEJBListener\".equals(opts.get(\"openejb.embedder.source\", \"\"))\n                || \"ServerListener\".equals(opts.get(\"openejb.embedder.source\", \"\"));\n\n        // is the OpenEJB javaagent installed\n        agentInstalled = InstallerTools.invokeStaticNoArgMethod(\n                \"org.apache.openejb.javaagent.Agent\", \"getInstrumentation\") != null;\n    }\n\n    public static boolean isListenerInstalled() {\n        return listenerInstalled;\n    }\n\n    public static boolean isAgentInstalled() {\n        return agentInstalled;\n    }\n\n    public Installer(final Paths paths) {\n        this.paths = paths;\n\n        if (listenerInstalled && agentInstalled) {\n            status = Status.INSTALLED;\n        }\n    }\n\n    public Installer(final Paths paths, final boolean force) {\n        this(paths);\n        this.force = force;\n    }\n\n    @Override\n    public PathsInterface getPaths() {\n        return paths;\n    }\n\n    @Override\n    public Alerts getAlerts() {\n        return alerts;\n    }\n\n    @Override\n    public void reset() {\n        alerts.reset();\n    }\n\n    @Override\n    public Status getStatus() {\n        return status;\n    }\n\n    @Override\n    public void installAll() {\n        installListener();\n        installJavaagent();\n        installConfigFiles(false);\n\n        removeTomcatLibJar(\"annotations-api.jar\");\n        // addJavaeeInEndorsed();\n        addTomEEJuli();\n\n        addTomEEAdminConfInTomcatUsers();\n        addTomEELinkToTomcatHome();\n\n        workaroundOnBat();\n\n        if (!alerts.hasErrors()) {\n            status = Status.REBOOT_REQUIRED;\n        }\n    }\n\n    // switch tomcat-juli with tomee-juli\n    // we keep the same name to let all tomcat tooling work as expected\n    private void addTomEEJuli() {\n        final File original = new File(paths.getCatalinaBinDir(), \"tomcat-juli.jar\");\n\n        final File juli = paths.findOpenEJBJar(\"tomee-juli\");\n        try {\n            Installers.copyFile(juli, new File(original.getAbsolutePath()));\n            if (!juli.delete()) { // remove original\n                juli.deleteOnExit();\n            }\n        } catch (final IOException e) {\n            alerts.addInfo(\"Add tomee user to tomcat-users.xml\");\n        }\n    }\n\n    public void addTomEEAdminConfInTomcatUsers() {\n        addTomEEAdminConfInTomcatUsers(false);\n    }\n\n    public void addTomEEAdminConfInTomcatUsers(final boolean securityActivated) {\n        // read server.xml\n        final String tomcatUsersXml = Installers.readAll(paths.getTomcatUsersXml(), alerts);\n\n        // server xml will be null if we couldn't read the file\n        if (tomcatUsersXml == null) {\n            return;\n        }\n\n        if (tomcatUsersXml.contains(\"tomee-admin\")) {\n            alerts.addWarning(\"Can't add tomee user to tomcat-users.xml\");\n            return;\n        }\n\n        // if we can't backup the file, do not modify it\n        if (!Installers.backup(paths.getTomcatUsersXml(), alerts)) {\n            return;\n        }\n\n        // add our listener\n        final String roleUserTags =\n                \"  <role rolename=\\\"tomee-admin\\\" />\\n\" +\n                        \"  <user username=\\\"tomee\\\" password=\\\"tomee\\\" roles=\\\"tomee-admin,manager-gui\\\" />\\n\";\n        final String content;\n        if (!securityActivated) {\n            content =\n                    \"  <!-- Activate those lines to get access to TomEE GUI -->\\n\" +\n                            \"  <!--\\n\" +\n                            roleUserTags +\n                            \"  -->\\n\" +\n                            \"</tomcat-users>\\n\";\n        } else {\n            content =\n                    \"  <!-- Activate those lines to get access to TomEE GUI\\n -->\" +\n                            roleUserTags +\n                            \"</tomcat-users>\\n\";\n\n        }\n        final String newTomcatUsers = tomcatUsersXml.replace(\"</tomcat-users>\", content);\n\n        // overwrite server.xml\n        if (Installers.writeAll(paths.getTomcatUsersXml(), newTomcatUsers, alerts)) {\n            alerts.addInfo(\"Add tomee user to tomcat-users.xml\");\n        }\n    }\n\n    public void installFull() {\n        installListener(\"org.apache.tomee.catalina.ServerListener\");\n        installJavaagent();\n\n        commentDeploymentDir();\n        installConfigFiles(true);\n\n        removeTomcatLibJar(\"annotations-api.jar\");\n        // addJavaeeInEndorsed();\n        addTomEEJuli(); // before moveLibs\n        moveLibs();\n\n        addTomEEAdminConfInTomcatUsers();\n        addTomEELinkToTomcatHome();\n\n        workaroundOnBat();\n\n        if (!alerts.hasErrors()) {\n            status = Status.REBOOT_REQUIRED;\n        }\n    }\n\n    private void workaroundOnBat() {\n        final File setclasspath = new File(paths.getCatalinaBinDir(), \"setclasspath.bat\");\n        String bat = Installers.readAll(setclasspath, alerts);\n        if (bat == null || bat.contains(\" NOT DEFINED \") /* already done, tomcat doesnt use yet this new Windows NT 4 syntax */) {\n            return;\n        }\n\n        // add our magic bits to the catalina bat file\n        bat = bat // could be regex but here the diff is explicit which is better IMO\n                .replace(\"not \\\"%JRE_HOME%\\\" == \\\"\\\"\", \"DEFINED JRE_HOME\")\n                .replace(\"not \\\"%JAVA_HOME%\\\" == \\\"\\\"\", \"DEFINED JAVA_HOME\")\n                .replace(\"not \\\"%_RUNJAVA%\\\" == \\\"\\\"\", \"DEFINED _RUNJAVA\")\n                .replace(\"not \\\"%_RUNJDB%\\\" == \\\"\\\"\", \"DEFINED _RUNJDB\")\n                .replace(\"\\\"%JAVA_HOME%\\\" == \\\"\\\"\", \"NOT DEFINED JAVA_HOME\");\n\n        // overwrite the catalina.bat file\n        if (!Installers.writeAll(setclasspath, bat, alerts)) {\n            alerts.addInfo(\"Can't add workarounds for setclasspath.bat\");\n        }\n    }\n\n    private void removeTomcatLibJar(final String name) {\n        final File jar = new File(paths.getCatalinaLibDir(), name);\n        removeJar(jar);\n    }\n\n    private void commentDeploymentDir() {\n        final File tomeeXml = new File(paths.getCatalinaConfDir(), \"tomee.xml\");\n        if (!tomeeXml.exists()) {\n            Installers.writeAll(tomeeXml,\n                    \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                            \"<tomee>\\n\" +\n                            \"  <!-- see http://tomee.apache.org/containers-and-resources.html -->\\n\\n\" +\n                            \"  <!-- activate next line to be able to deploy applications in apps -->\\n\" +\n                            \"  <!-- <Deployments dir=\\\"apps\\\" /> -->\\n\" +\n                            \"</tomee>\\n\", alerts);\n        }\n    }\n\n    private void addTomEELinkToTomcatHome() {\n        final File home = paths.getHome();\n        if(!home.exists()) {\n            return;\n        }\n        final String indeJsp = Installers.readAll(home, alerts);\n        if (indeJsp == null) {\n            return;\n        }\n\n        if (!indeJsp.contains(\"tomcatUrl\")) { // check the user didn't replaced the file, can be improved\n            alerts.addWarning(\"webapps/ROOT/index.jsp was modified\");\n            return;\n        }\n\n        final String newIndeJsp = indeJsp.replaceFirst(\"<div id=\\\"actions\\\">\",\n                \"<div id=\\\"actions\\\">\\n\" +\n                        \"                    <div class=\\\"button\\\">\\n\" +\n                        \"                        <a class=\\\"container shadow\\\" href=\\\"/tomee\\\"><span>TomEE Gui</span></a>\\n\" +\n                        \"                    </div>\");\n        Installers.writeAll(home, newIndeJsp, alerts);\n    }\n\n    private void moveLibs() {\n        final File libs = paths.getCatalinaLibDir();\n        final File[] files = paths.getOpenEJBLibDir().listFiles();\n        if (files != null) {\n            for (final File file : files) {\n                if (file.isDirectory()) {\n                    continue;\n                }\n                if (!file.getName().endsWith(\".jar\")) {\n                    continue;\n                }\n\n                try {\n                    Installers.copyFile(file, new File(libs, file.getName()));\n                    if (!file.delete()) {\n                        file.deleteOnExit();\n                    }\n                    alerts.addInfo(\"Copy \" + file.getName() + \" to lib\");\n                } catch (final IOException e) {\n                    alerts.addError(\"Unable to \" + file.getName() + \" to Tomcat lib directory.  This will need to be \" +\n                            \"performed manually.\", e);\n                }\n            }\n        }\n    }\n\n    /*\n    private void addJavaeeInEndorsed() {\n        final File endorsed = new File(paths.getCatalinaHomeDir(), \"endorsed\");\n        if (!endorsed.mkdir()) {\n            alerts.addWarning(\"can't create endorsed directory\");\n        }\n\n        final File jaxbApi = paths.findOpenEJBJar(\"geronimo-jaxb_2.2_spec\");\n        copyClasses(paths.getJavaEEAPIJar(), jaxbApi, new File(endorsed, \"jaxb-api.jar\"), \"javax/xml/bind/.*\",\n                Arrays.asList(\"javax/xml/bind/ContextFinder.class\", \"javax/xml/bind/DatatypeConverter.class\"));\n        removeJar(jaxbApi);\n\n        // don't put jaxb-impl in endorsed since it relies on the jvm itself\n        final File jaxbImpl = new File(paths.getCatalinaLibDir(), \"jaxb-impl.jar\");\n        if (!jaxbImpl.exists()) {\n            try {\n                Installers.copyFile(paths.getJAXBImpl(), jaxbImpl);\n            } catch (final IOException e) {\n                alerts.addError(\"can't copy \" + paths.getJAXBImpl().getPath() + \" to \" + endorsed.getPath() + \"/jaxb-impl.jar\");\n            }\n        }\n    }\n\n\n    private void copyClasses(final File javaEEAPIJar, final File sourceJar, final File destinationJar,\n                             final String pattern, final List<String> exceptions) {\n        if (javaEEAPIJar == null) {\n            throw new NullPointerException(\"javaEEAPIJar\");\n        }\n        if (sourceJar == null) {\n            throw new NullPointerException(\"sourceJar\");\n        }\n        if (destinationJar == null) {\n            throw new NullPointerException(\"destinationJar\");\n        }\n        if (pattern == null) {\n            throw new NullPointerException(\"pattern\");\n        }\n        if (exceptions == null) {\n            throw new NullPointerException(\"exceptions\");\n        }\n\n        if (destinationJar.exists()) {\n            return;\n        }\n\n        try {\n            final ByteArrayOutputStream destinationBuffer = new ByteArrayOutputStream(524288);\n            final ZipOutputStream destination = new ZipOutputStream(destinationBuffer);\n            final ZipInputStream source = new ZipInputStream(IO.read(sourceJar));\n            for (ZipEntry entry; (entry = source.getNextEntry()) != null; ) {\n                final String entryName = entry.getName();\n                if (!entryName.matches(pattern) || exceptions.contains(entryName)) {\n                    continue;\n                }\n                destination.putNextEntry(new ZipEntry(entryName));\n                IO.copy(source, destination);\n            }\n            IO.close(source);\n            final ZipInputStream source2 = new ZipInputStream(IO.read(javaEEAPIJar));\n            for (ZipEntry entry; (entry = source2.getNextEntry()) != null; ) {\n                final String entryName = entry.getName();\n                if (!entryName.matches(pattern) || !exceptions.contains(entryName)) {\n                    continue;\n                }\n\n                destination.putNextEntry(new ZipEntry(entryName));\n\n                IO.copy(source2, destination);\n            }\n            IO.close(source2);\n            IO.close(destination);\n            IO.copy(destinationBuffer.toByteArray(), destinationJar);\n        } catch (final IOException e) {\n            alerts.addError(e.getMessage());\n        }\n    }\n    */\n\n    private void removeJar(final File jar) {\n        if (jar.exists()) {\n            if (!jar.delete()) {\n                jar.deleteOnExit();\n            }\n            alerts.addInfo(\"Please restart the server or delete manually \" + jar.getName());\n        }\n    }\n\n    public void installListener() {\n        installListener(\"org.apache.tomee.loader.OpenEJBListener\");\n    }\n\n    public void installListener(final String listener) {\n        if (listenerInstalled && !force) {\n            // OpenEJB Listener already installed\n            return;\n        }\n        boolean copyOpenEJBLoader = true;\n\n        // copy loader jar to lib\n        final File destination = new File(paths.getCatalinaLibDir(), paths.getOpenEJBTomcatLoaderJar().getName());\n        if (destination.exists()) {\n            if (paths.getOpenEJBTomcatLoaderJar().length() == destination.length()) {\n                copyOpenEJBLoader = false;\n            }\n        }\n        if (copyOpenEJBLoader) {\n            try {\n                Installers.copyFile(paths.getOpenEJBTomcatLoaderJar(), destination);\n                alerts.addInfo(\"Copy \" + paths.getOpenEJBTomcatLoaderJar().getName() + \" to lib\");\n            } catch (final IOException e) {\n                alerts.addError(\"Unable to copy OpenEJB Tomcat loader jar to Tomcat lib directory.  This will need to be performed manually.\", e);\n            }\n        }\n\n        // read server.xml\n        final String serverXmlOriginal = Installers.readAll(paths.getServerXmlFile(), alerts);\n\n        // server xml will be null if we couldn't read the file\n        if (serverXmlOriginal == null) {\n            return;\n        }\n\n        // does the server.xml contain our listener name... it is possible that they commented out our listener, but that would be a PITA to detect\n        if (serverXmlOriginal.contains(listener)) {\n            alerts.addWarning(\"OpenEJB Listener already declared in Tomcat server.xml file.\");\n            return;\n        }\n\n        // if we can't backup the file, do not modify it\n        if (!Installers.backup(paths.getServerXmlFile(), alerts)) {\n            return;\n        }\n\n        // add our listener\n        String newServerXml = null;\n        try {\n            newServerXml = Installers.replace(serverXmlOriginal,\n                    \"<Server\",\n                    \"<Server\",\n                    \">\",\n                    \">\\r\\n\" +\n                            \"  <!-- TomEE plugin for Tomcat -->\\r\\n\" +\n                            \"  <Listener className=\\\"\" + listener + \"\\\" />\");\n        } catch (final IOException e) {\n            alerts.addError(\"Error while adding listener to server.xml file\", e);\n        }\n\n        //Add TomEE header\n        try {\n            newServerXml = Installers.replace(newServerXml,\n                    \"<Connector port=\\\"8080\\\"\",\n                    \"<Connector port=\\\"8080\\\"\",\n                    \"/>\",\n                    \"xpoweredBy=\\\"false\\\" server=\\\"Apache TomEE\\\" />\");\n\n            newServerXml = Installers.replace(newServerXml,\n                    \"<Connector port=\\\"8443\\\"\",\n                    \"<Connector port=\\\"8443\\\"\",\n                    \"/>\",\n                    \"xpoweredBy=\\\"false\\\" server=\\\"Apache TomEE\\\" />\");\n        } catch (final IOException e) {\n            alerts.addError(\"Error adding server attribute to server.xml file\", e);\n        }\n\n        // overwrite server.xml\n        if (Installers.writeAll(paths.getServerXmlFile(), newServerXml, alerts)) {\n            alerts.addInfo(\"Add OpenEJB listener to server.xml\");\n        }\n    }\n\n    // NOTE: we specify the jaxbcontext implementation because\n    //       we are using geronimo jaxb API and we don't want to go to\n    //       the geronimo locator to find the implementation\n    //       because it needs some OSGi API we don't want to add\n    public void installJavaagent() {\n        if (agentInstalled && !force) {\n            // OpenEJB Agent already installed\"\n            return;\n        }\n\n        //\n        // Copy openejb-javaagent.jar to lib\n        //\n        boolean copyJavaagentJar = true;\n        final File javaagentJar = new File(paths.getCatalinaLibDir(), \"openejb-javaagent.jar\");\n        if (javaagentJar.exists()) {\n            if (paths.getOpenEJBJavaagentJar().length() == javaagentJar.length()) {\n                copyJavaagentJar = false;\n            }\n        }\n\n        if (copyJavaagentJar) {\n            try {\n                Installers.copyFile(paths.getOpenEJBJavaagentJar(), javaagentJar);\n                alerts.addInfo(\"Copy \" + paths.getOpenEJBJavaagentJar().getName() + \" to lib\");\n            } catch (final IOException e) {\n                alerts.addError(\"Unable to copy OpenEJB javaagent jar to Tomcat lib directory.  This will need to be performed manually.\", e);\n            }\n        }\n\n\n        //\n        // bin/catalina.sh\n        //\n\n        // read the catalina sh file\n        final String catalinaShOriginal = Installers.readAll(paths.getCatalinaShFile(), alerts);\n\n        // catalina sh will be null if we couldn't read the file\n        if (catalinaShOriginal == null) {\n            return;\n        }\n\n        // does the catalina sh contain our comment... it is possible that they commented out the magic script code, but there is no way to detect that\n        if (catalinaShOriginal.contains(\"Add OpenEJB javaagent\")) {\n            alerts.addWarning(\"OpenEJB javaagent already declared in Tomcat catalina.sh file.\");\n            return;\n        }\n\n        // if we can't backup the file, do not modify it\n        if (!Installers.backup(paths.getCatalinaShFile(), alerts)) {\n            return;\n        }\n\n        // add our magic bits to the catalina sh file\n        String openejbJavaagentPath = paths.getCatalinaHomeDir().toURI().relativize(javaagentJar.toURI()).getPath();\n        final String newCatalinaSh = catalinaShOriginal.replace(\"# ----- Execute The Requested Command\",\n                \"# Add OpenEJB javaagent\\n\" +\n                        \"if [ -r \\\"$CATALINA_HOME\\\"/\" + openejbJavaagentPath + \" ]; then\\n\" +\n                        \"  JAVA_OPTS=\\\"\\\\\\\"-javaagent:$CATALINA_HOME/\" + openejbJavaagentPath + \"\\\\\\\" $JAVA_OPTS\\\"\\n\" +\n                        \"fi\\n\" +\n                        \"\\n\" +\n                        \"# ----- Execute The Requested Command\");\n\n        // overwrite the catalina.sh file\n        if (Installers.writeAll(paths.getCatalinaShFile(), newCatalinaSh, alerts)) {\n            alerts.addInfo(\"Add OpenEJB JavaAgent to catalina.sh\");\n        }\n\n        boolean isCatalinaShExecutable = paths.getCatalinaShFile().canExecute();\n        if(!isCatalinaShExecutable) {\n            try {\n                isCatalinaShExecutable = paths.getCatalinaShFile().setExecutable(true);\n            } catch (final SecurityException e) {\n                alerts.addWarning(\"Cannot change CatalinaSh executable attribute.\");\n            }\n        }\n        if(!isCatalinaShExecutable) {\n            alerts.addWarning(\"CatalinaSh is not executable.\");\n        }\n\n        //\n        // bin/catalina.bat\n        //\n\n        // read the catalina bat file\n        final String catalinaBatOriginal = Installers.readAll(paths.getCatalinaBatFile(), alerts);\n\n        // catalina bat will be null if we couldn't read the file\n        if (catalinaBatOriginal == null) {\n            return;\n        }\n\n        // does the catalina bat contain our comment... it is possible that they commented out the magic script code, but there is no way to detect that\n        if (catalinaBatOriginal.contains(\"Add OpenEJB javaagent\")) {\n            alerts.addWarning(\"OpenEJB javaagent already declared in Tomcat catalina.bat file.\");\n            return;\n        }\n\n        // if we can't backup the file, do not modify it\n        if (!Installers.backup(paths.getCatalinaBatFile(), alerts)) {\n            return;\n        }\n\n        // add our magic bits to the catalina bat file\n        openejbJavaagentPath = openejbJavaagentPath.replace('/', '\\\\');\n        final String newCatalinaBat = catalinaBatOriginal.replace(\"rem ----- Execute The Requested Command\",\n                \"rem Add OpenEJB javaagent\\r\\n\" +\n                        \"if not exist \\\"%CATALINA_HOME%\\\\\" + openejbJavaagentPath + \"\\\" goto noOpenEJBJavaagent\\r\\n\" +\n                        \"set JAVA_OPTS=\\\"-javaagent:%CATALINA_HOME%\\\\\" + openejbJavaagentPath + \"\\\" %JAVA_OPTS%\\r\\n\" +\n                        \":noOpenEJBJavaagent\\r\\n\" +\n                        \"\\r\\n\" +\n                        \"rem ----- Execute The Requested Command\");\n\n        // overwrite the catalina.bat file\n        if (Installers.writeAll(paths.getCatalinaBatFile(), newCatalinaBat, alerts)) {\n            alerts.addInfo(\"Add OpenEJB JavaAgent to catalina.bat\");\n        }\n    }\n\n    /**\n     * Installs conf/tomee.xml and conf/logging.properties files.\n     * This method retrieves the tomee.xml and logging.properties files\n     * from openejb core jar file and installs them under the conf directory\n     * of tomcat. if there is already a conf/logging.properties file available\n     * then this method appends the contents of openejb logging.properties file\n     * to the exisiting properties file.\n     *\n     * Replace web.xml to set jasper in production mode instead of dev mode.\n     *\n     * NOTE:- If the existing conf/logging.properties file already has some openejb specific\n     * configuration, then this method will just leave the logging.properties file alone\n     * @param builtIn\n     */\n    public void installConfigFiles(final boolean builtIn) {\n        final File openejbCoreJar = paths.getOpenEJBCoreJar();\n        final File confDir = paths.getCatalinaConfDir();\n        final Alerts alerts = this.alerts;\n\n        if (openejbCoreJar == null) {\n            // the core jar contains the config files\n            return;\n        }\n        final JarFile coreJar;\n        try {\n            coreJar = new JarFile(openejbCoreJar);\n        } catch (final IOException e) {\n            return;\n        }\n\n        //\n        // conf/tomee.xml\n        //\n        final File openEjbXmlFile = new File(confDir, \"tomee.xml\");\n        if (!openEjbXmlFile.exists()) {\n            // read in the openejb.xml file from the openejb core jar\n            final String openEjbXml = Installers.readEntry(coreJar, \"default.openejb.conf\", alerts);\n            if (openEjbXml != null) {\n                if (Installers.writeAll(openEjbXmlFile, openEjbXml.replace(\"<openejb>\", \"<tomee>\").replace(\"</openejb>\", \"</tomee>\"), alerts)) {\n                    alerts.addInfo(\"Copy tomee.xml to conf\");\n                }\n            }\n        }\n\n\n        //\n        // conf/logging.properties\n        // now we are using tomcat one of jdk one by default\n        //\n        final String openejbLoggingProps = \"################################\\r\\n\" +\n                \"# OpenEJB/TomEE specific loggers\\r\\n\" +\n                \"################################\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# ACTIVATE LEVEL/HANDLERS YOU WANT\\r\\n\" +\n                \"# IF YOU ACTIVATE 5tomee.org.apache.juli.FileHandler\\r\\n\" +\n                \"# ADD IT TO handlers LINE LIKE:\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# handlers = 1catalina.org.apache.juli.FileHandler, 2localhost.org.apache.juli.FileHandler, 3manager.org.apache.juli.FileHandler, 4host-manager.org.apache.juli.FileHandler, 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# LEVELS:\\r\\n\" +\n                \"# =======\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# OpenEJB.level             = WARNING\\r\\n\" +\n                \"# OpenEJB.options.level     = INFO\\r\\n\" +\n                \"# OpenEJB.server.level      = INFO\\r\\n\" +\n                \"# OpenEJB.startup.level     = INFO\\r\\n\" +\n                \"# OpenEJB.startup.service.level = WARNING\\r\\n\" +\n                \"# OpenEJB.startup.config.level = INFO\\r\\n\" +\n                \"# OpenEJB.hsql.level        = INFO\\r\\n\" +\n                \"# CORBA-Adapter.level       = WARNING\\r\\n\" +\n                \"# Transaction.level         = WARNING\\r\\n\" +\n                \"# org.apache.activemq.level = SEVERE\\r\\n\" +\n                \"# org.apache.geronimo.level = SEVERE\\r\\n\" +\n                \"# openjpa.level             = WARNING\\r\\n\" +\n                \"# OpenEJB.cdi.level         = INFO\\r\\n\" +\n                \"# org.apache.webbeans.level = INFO\\r\\n\" +\n                \"# org.apache.openejb.level = FINE\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# HANDLERS:\\r\\n\" +\n                \"# =========\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# OpenEJB.handlers             = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.options.handlers     = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.server.handlers      = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.startup.handlers     = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.startup.service.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.startup.config.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.hsql.handlers        = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# CORBA-Adapter.handlers       = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# Transaction.handlers         = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# org.apache.activemq.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# org.apache.geronimo.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# openjpa.handlers             = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.cdi.handlers         = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# org.apache.webbeans.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# org.apache.openejb.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# TOMEE HANDLER SAMPLE:\\r\\n\" +\n                \"# =====================\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# 5tomee.org.apache.juli.FileHandler.level = FINEST\\r\\n\" +\n                \"# 5tomee.org.apache.juli.FileHandler.directory = ${catalina.base}/logs\\r\\n\" +\n                \"# 5tomee.org.apache.juli.FileHandler.prefix = tomee.\\r\\n\";\n        final File loggingPropsFile = new File(confDir, \"logging.properties\");\n        String newLoggingProps = null;\n        if (!loggingPropsFile.exists()) {\n            newLoggingProps = openejbLoggingProps;\n        } else {\n            final String loggingPropsOriginal = Installers.readAll(loggingPropsFile, alerts);\n            if (!loggingPropsOriginal.toLowerCase().contains(\"openejb\")) {\n                // append our properties\n                newLoggingProps = loggingPropsOriginal +\n                        \"\\r\\n\\r\\n\" +\n                        openejbLoggingProps + \"\\r\\n\";\n            }\n        }\n        if (builtIn) {\n            installTomEEJuli(alerts, loggingPropsFile, newLoggingProps);\n        }\n\n        final File openejbSystemProperties = new File(confDir, \"system.properties\");\n        if (!openejbSystemProperties.exists()) {\n            FileWriter systemPropertiesWriter = null;\n            try {\n                systemPropertiesWriter = new FileWriter(openejbSystemProperties);\n\n                systemPropertiesWriter.write(\"# all this properties are added at JVM system properties at startup\\n\");\n                systemPropertiesWriter.write(\"# here some default Apache TomEE system properties\\n\");\n                systemPropertiesWriter.write(\"# for more information please see http://tomee.apache.org/properties-listing.html\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\n                    \"# allowed packages to be deserialized, by security we denied all by default, \" +\n                    \"tune tomee.serialization.class.whitelist packages to change it\\n\");\n                systemPropertiesWriter.write(\"# tomee.remote.support = true\\n\");\n                systemPropertiesWriter.write(\"tomee.serialization.class.blacklist = *\\n\");\n                systemPropertiesWriter.write(\"# tomee.serialization.class.whitelist = my.package\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\"# openejb.check.classloader = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.check.classloader.verbose = false\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\"# tomee.jaxws.subcontext = webservices\\n\");\n                systemPropertiesWriter.write(\"# tomee.jaxws.oldsubcontext = false\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\"# if you want to propagate a deployment on a cluster when a tomcat cluster is defined\\n\");\n                systemPropertiesWriter.write(\"# tomee.cluster.deployment = false\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\"# openejb.system.apps = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.servicemanager.enabled = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.jmx.active = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.descriptors.output = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.strict.interface.declaration = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.conf.file = conf/tomee.xml\\n\");\n                systemPropertiesWriter.write(\"# openejb.debuggable-vm-hackery = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.validation.skip = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.webservices.enabled = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.validation.output.level = MEDIUM\\n\");\n                systemPropertiesWriter.write(\"# openejb.user.mbeans.list = *\\n\");\n                systemPropertiesWriter.write(\"# openejb.deploymentId.format = {appId}/{ejbJarId}/{ejbName}\\n\");\n                systemPropertiesWriter.write(\"# openejb.jndiname.format = {deploymentId}{interfaceType.annotationName}\\n\");\n                systemPropertiesWriter.write(\"# openejb.deployments.package.include = .*\\n\");\n                systemPropertiesWriter.write(\"# openejb.deployments.package.exclude = \\n\");\n                systemPropertiesWriter.write(\"# openejb.autocreate.jta-datasource-from-non-jta-one = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.altdd.prefix = \\n\");\n                systemPropertiesWriter.write(\"# org.apache.openejb.default.system.interceptors = \\n\");\n                systemPropertiesWriter.write(\"# openejb.jndiname.failoncollision = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.wsAddress.format = /{ejbDeploymentId}\\n\");\n                systemPropertiesWriter.write(\"# org.apache.openejb.server.webservices.saaj.provider = \\n\");\n                systemPropertiesWriter.write(\"# openejb.nobanner = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.offline = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.jmx.active = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.exclude-include.order = include-exclude\\n\");\n                systemPropertiesWriter.write(\"# openejb.additional.exclude =\\n\");\n                systemPropertiesWriter.write(\"# openejb.additional.include =\\n\");\n                systemPropertiesWriter.write(\"# openejb.crosscontext = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.jsessionid-support = \\n\");\n                systemPropertiesWriter.write(\"# openejb.myfaces.disable-default-values = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.web.xml.major = \\n\");\n                systemPropertiesWriter.write(\"# openjpa.Log = \\n\");\n                systemPropertiesWriter.write(\"# openejb.jdbc.log = false\\n\");\n                systemPropertiesWriter.write(\"# javax.persistence.provider = org.apache.openjpa.persistence.PersistenceProviderImpl\\n\");\n                systemPropertiesWriter.write(\"# javax.persistence.transactionType = \\n\");\n                systemPropertiesWriter.write(\"# javax.persistence.jtaDataSource = \\n\");\n                systemPropertiesWriter.write(\"# javax.persistence.nonJtaDataSource = \\n\");\n\n                systemPropertiesWriter.write(\"#\\n\");\n                systemPropertiesWriter.write(\"# Properties for JAS RS\\n\");\n                systemPropertiesWriter.write(\"# openejb.jaxrs.application = \\n\");\n                systemPropertiesWriter.write(\"# openejb.cxf-rs.wadl-generator.ignoreRequests = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.cxf-rs.wadl-generator.ignoreMessageWriters = true\\n\");\n\n                systemPropertiesWriter.write(\"#\\n\");\n                systemPropertiesWriter.write(\"# These properties are only for cxf service (SOAP webservices) and TomEE+\\n\");\n                systemPropertiesWriter.write(\"# If you don't use special tricks and sun default implementation, uncommenting these 4 lines forces TomEE to use it without overhead at all = \\n\");\n                systemPropertiesWriter.write(\"# javax.xml.soap.MessageFactory = com.sun.xml.messaging.saaj.soap.ver1_1.SOAPMessageFactory1_1Impl\\n\");\n                systemPropertiesWriter.write(\"# javax.xml.soap.SOAPFactory = com.sun.xml.messaging.saaj.soap.ver1_1.SOAPFactory1_1Impl\\n\");\n                systemPropertiesWriter.write(\"# javax.xml.soap.SOAPConnectionFactory = com.sun.xml.messaging.saaj.client.p2p.HttpSOAPConnectionFactory\\n\");\n                systemPropertiesWriter.write(\"# javax.xml.soap.MetaFactory = com.sun.xml.messaging.saaj.soap.SAAJMetaFactoryImpl\\n\");\n            } catch (final IOException e) {\n                // ignored, this file is far to be mandatory\n            } finally {\n                if (systemPropertiesWriter != null) {\n                    try {\n                        systemPropertiesWriter.close();\n                    } catch (final IOException e) {\n                        // no-op\n                    }\n                }\n            }\n        }\n\n        //\n        // conf/web.xml\n        //\n        final JarFile openejbTomcatCommonJar;\n        try {\n            openejbTomcatCommonJar = new JarFile(paths.geOpenEJBTomcatCommonJar());\n        } catch (final IOException e) {\n            return;\n        }\n        final File webXmlFile = new File(confDir, \"web.xml\");\n        final String webXml = Installers.readEntry(openejbTomcatCommonJar, \"conf/web.xml\", alerts);\n        if (Installers.writeAll(webXmlFile, webXml, alerts)) {\n            alerts.addInfo(\"Set jasper in production mode in TomEE web.xml\");\n        }\n    }\n\n    private void installTomEEJuli(final Alerts alerts, final File loggingPropsFile, final String newLoggingProps) {\n        if (newLoggingProps != null && Installers.writeAll(\n                loggingPropsFile,\n                newLoggingProps.replace(\"java.util.logging.ConsoleHandler\", \"org.apache.tomee.jul.formatter.AsyncConsoleHandler\"),\n                alerts)) {\n            alerts.addInfo(\"Append OpenEJB config to logging.properties\");\n        }\n    }\n}\n"
      }
    ],
    "file_count": 6
  },
  "VUL4J-38": {
    "vul_id": "VUL4J-38",
    "cve_id": "CVE-2014-4172",
    "project": "apereo_java-cas-client",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl cas-client-core -Dtest=org.jasig.cas.client.validation.Cas10TicketValidatorTests",
    "test_all_cmd": "mvn test -pl cas-client-core",
    "human_patch_url": "https://github.com/apereo/java-cas-client/commit/ab6cbdc3daa451b4fef89c0bd0f4e6568f3aa9ef",
    "vulnerable_files": [
      {
        "file_path": "cas-client-core/src/main/java/org/jasig/cas/client/validation/AbstractUrlBasedTicketValidator.java",
        "file_name": "AbstractUrlBasedTicketValidator.java",
        "vulnerable_code": "/*\n * Licensed to Jasig under one or more contributor license\n * agreements. See the NOTICE file distributed with this work\n * for additional information regarding copyright ownership.\n * Jasig licenses this file to you under the Apache License,\n * Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License.  You may obtain a\n * copy of the License at the following location:\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jasig.cas.client.validation;\n\nimport java.io.UnsupportedEncodingException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.jasig.cas.client.ssl.HttpURLConnectionFactory;\nimport org.jasig.cas.client.ssl.HttpsURLConnectionFactory;\nimport org.jasig.cas.client.util.CommonUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Abstract validator implementation for tickets that must be validated against a server.\n *\n * @author Scott Battaglia\n * @since 3.1\n */\npublic abstract class AbstractUrlBasedTicketValidator implements TicketValidator {\n\n    protected final Logger logger = LoggerFactory.getLogger(getClass());\n\n    /**\n     * URLConnection factory instance to use when making validation requests to the CAS server.\n     * Defaults to {@link HttpsURLConnectionFactory}\n     */\n    private HttpURLConnectionFactory urlConnectionFactory = new HttpsURLConnectionFactory();\n\n    /**\n     * Prefix for the CAS server.   Should be everything up to the url endpoint, including the /.\n     *\n     * i.e. https://cas.rutgers.edu/\n     */\n    private final String casServerUrlPrefix;\n\n    /**\n     * Whether the request include a renew or not.\n     */\n    private boolean renew;\n\n    /**\n     * A map containing custom parameters to pass to the validation url.\n     */\n    private Map<String, String> customParameters;\n\n    private String encoding;\n\n    /**\n     * Constructs a new TicketValidator with the casServerUrlPrefix.\n     *\n     * @param casServerUrlPrefix the location of the CAS server.\n     */\n    protected AbstractUrlBasedTicketValidator(final String casServerUrlPrefix) {\n        this.casServerUrlPrefix = casServerUrlPrefix;\n        CommonUtils.assertNotNull(this.casServerUrlPrefix, \"casServerUrlPrefix cannot be null.\");\n    }\n\n    /**\n     * Template method for ticket validators that need to provide additional parameters to the validation url.\n     *\n     * @param urlParameters the map containing the parameters.\n     */\n    protected void populateUrlAttributeMap(final Map<String, String> urlParameters) {\n        // nothing to do\n    }\n\n    /**\n     * The endpoint of the validation URL.  Should be relative (i.e. not start with a \"/\").  I.e. validate or serviceValidate.\n     * @return the endpoint of the validation URL.\n     */\n    protected abstract String getUrlSuffix();\n\n    /**\n     * Disable XML Schema validation.  Note, setting this to true may not be reversable. Defaults to false. Setting it to false\n     * after setting it to true may not have any affect.\n     *\n     * @param disabled whether to disable or not.\n     */\n    protected abstract void setDisableXmlSchemaValidation(boolean disabled);\n\n    /**\n     * Constructs the URL to send the validation request to.\n     *\n     * @param ticket the ticket to be validated.\n     * @param serviceUrl the service identifier.\n     * @return the fully constructed URL.\n     */\n    protected final String constructValidationUrl(final String ticket, final String serviceUrl) {\n        final Map<String, String> urlParameters = new HashMap<String, String>();\n\n        logger.debug(\"Placing URL parameters in map.\");\n        urlParameters.put(\"ticket\", ticket);\n        urlParameters.put(\"service\", encodeUrl(serviceUrl));\n\n        if (this.renew) {\n            urlParameters.put(\"renew\", \"true\");\n        }\n\n        logger.debug(\"Calling template URL attribute map.\");\n        populateUrlAttributeMap(urlParameters);\n\n        logger.debug(\"Loading custom parameters from configuration.\");\n        if (this.customParameters != null) {\n            urlParameters.putAll(this.customParameters);\n        }\n\n        final String suffix = getUrlSuffix();\n        final StringBuilder buffer = new StringBuilder(urlParameters.size() * 10 + this.casServerUrlPrefix.length()\n                + suffix.length() + 1);\n\n        int i = 0;\n\n        buffer.append(this.casServerUrlPrefix);\n        if (!this.casServerUrlPrefix.endsWith(\"/\")) {\n            buffer.append(\"/\");\n        }\n        buffer.append(suffix);\n\n        for (Map.Entry<String, String> entry : urlParameters.entrySet()) {\n            final String key = entry.getKey();\n            final String value = entry.getValue();\n\n            if (value != null) {\n                buffer.append(i++ == 0 ? \"?\" : \"&\");\n                buffer.append(key);\n                buffer.append(\"=\");\n                buffer.append(value);\n            }\n        }\n\n        return buffer.toString();\n\n    }\n\n    /**\n     * Encodes a URL using the URLEncoder format.\n     *\n     * @param url the url to encode.\n     * @return the encoded url, or the original url if \"UTF-8\" character encoding could not be found.                       \n     */\n    protected final String encodeUrl(final String url) {\n        if (url == null) {\n            return null;\n        }\n\n        try {\n            return URLEncoder.encode(url, \"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            return url;\n        }\n    }\n\n    /**\n     * Parses the response from the server into a CAS Assertion.\n     *\n     * @param response the response from the server, in any format.\n     * @return the CAS assertion if one could be parsed from the response.\n     * @throws TicketValidationException if an Assertion could not be created.\n     *\n     */\n    protected abstract Assertion parseResponseFromServer(final String response) throws TicketValidationException;\n\n    /**\n     * Contacts the CAS Server to retrieve the response for the ticket validation.\n     *\n     * @param validationUrl the url to send the validation request to.\n     * @param ticket the ticket to validate.\n     * @return the response from the CAS server.\n     */\n\n    protected abstract String retrieveResponseFromServer(URL validationUrl, String ticket);\n\n    public final Assertion validate(final String ticket, final String service) throws TicketValidationException {\n        final String validationUrl = constructValidationUrl(ticket, service);\n        logger.debug(\"Constructing validation url: {}\", validationUrl);\n\n        try {\n            logger.debug(\"Retrieving response from server.\");\n            final String serverResponse = retrieveResponseFromServer(new URL(validationUrl), ticket);\n\n            if (serverResponse == null) {\n                throw new TicketValidationException(\"The CAS server returned no response.\");\n            }\n\n            logger.debug(\"Server response: {}\", serverResponse);\n\n            return parseResponseFromServer(serverResponse);\n        } catch (final MalformedURLException e) {\n            throw new TicketValidationException(e);\n        }\n    }\n\n    public final void setRenew(final boolean renew) {\n        this.renew = renew;\n    }\n\n    public final void setCustomParameters(final Map<String, String> customParameters) {\n        this.customParameters = customParameters;\n    }\n\n    public final void setEncoding(final String encoding) {\n        this.encoding = encoding;\n    }\n\n    protected final String getEncoding() {\n        return this.encoding;\n    }\n\n    protected final boolean isRenew() {\n        return this.renew;\n    }\n\n    protected final String getCasServerUrlPrefix() {\n        return this.casServerUrlPrefix;\n    }\n\n    protected final Map<String, String> getCustomParameters() {\n        return this.customParameters;\n    }\n\n    protected HttpURLConnectionFactory getURLConnectionFactory() {\n        return this.urlConnectionFactory;\n    }\n\n    public void setURLConnectionFactory(final HttpURLConnectionFactory urlConnectionFactory) {\n        this.urlConnectionFactory = urlConnectionFactory;\n    }\n}\n",
        "human_patch_code": "/*\n * Licensed to Jasig under one or more contributor license\n * agreements. See the NOTICE file distributed with this work\n * for additional information regarding copyright ownership.\n * Jasig licenses this file to you under the Apache License,\n * Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License.  You may obtain a\n * copy of the License at the following location:\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jasig.cas.client.validation;\n\nimport java.io.UnsupportedEncodingException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.jasig.cas.client.ssl.HttpURLConnectionFactory;\nimport org.jasig.cas.client.ssl.HttpsURLConnectionFactory;\nimport org.jasig.cas.client.util.CommonUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Abstract validator implementation for tickets that must be validated against a server.\n *\n * @author Scott Battaglia\n * @since 3.1\n */\npublic abstract class AbstractUrlBasedTicketValidator implements TicketValidator {\n\n    protected final Logger logger = LoggerFactory.getLogger(getClass());\n\n    /**\n     * URLConnection factory instance to use when making validation requests to the CAS server.\n     * Defaults to {@link HttpsURLConnectionFactory}\n     */\n    private HttpURLConnectionFactory urlConnectionFactory = new HttpsURLConnectionFactory();\n\n    /**\n     * Prefix for the CAS server.   Should be everything up to the url endpoint, including the /.\n     *\n     * i.e. https://cas.rutgers.edu/\n     */\n    private final String casServerUrlPrefix;\n\n    /**\n     * Whether the request include a renew or not.\n     */\n    private boolean renew;\n\n    /**\n     * A map containing custom parameters to pass to the validation url.\n     */\n    private Map<String, String> customParameters;\n\n    private String encoding;\n\n    /**\n     * Constructs a new TicketValidator with the casServerUrlPrefix.\n     *\n     * @param casServerUrlPrefix the location of the CAS server.\n     */\n    protected AbstractUrlBasedTicketValidator(final String casServerUrlPrefix) {\n        this.casServerUrlPrefix = casServerUrlPrefix;\n        CommonUtils.assertNotNull(this.casServerUrlPrefix, \"casServerUrlPrefix cannot be null.\");\n    }\n\n    /**\n     * Template method for ticket validators that need to provide additional parameters to the validation url.\n     *\n     * @param urlParameters the map containing the parameters.\n     */\n    protected void populateUrlAttributeMap(final Map<String, String> urlParameters) {\n        // nothing to do\n    }\n\n    /**\n     * The endpoint of the validation URL.  Should be relative (i.e. not start with a \"/\").  I.e. validate or serviceValidate.\n     * @return the endpoint of the validation URL.\n     */\n    protected abstract String getUrlSuffix();\n\n    /**\n     * Disable XML Schema validation.  Note, setting this to true may not be reversable. Defaults to false. Setting it to false\n     * after setting it to true may not have any affect.\n     *\n     * @param disabled whether to disable or not.\n     */\n    protected abstract void setDisableXmlSchemaValidation(boolean disabled);\n\n    /**\n     * Constructs the URL to send the validation request to.\n     *\n     * @param ticket the ticket to be validated.\n     * @param serviceUrl the service identifier.\n     * @return the fully constructed URL.\n     */\n    protected final String constructValidationUrl(final String ticket, final String serviceUrl) {\n        final Map<String, String> urlParameters = new HashMap<String, String>();\n\n        logger.debug(\"Placing URL parameters in map.\");\n        urlParameters.put(\"ticket\", ticket);\n        urlParameters.put(\"service\", serviceUrl);\n\n        if (this.renew) {\n            urlParameters.put(\"renew\", \"true\");\n        }\n\n        logger.debug(\"Calling template URL attribute map.\");\n        populateUrlAttributeMap(urlParameters);\n\n        logger.debug(\"Loading custom parameters from configuration.\");\n        if (this.customParameters != null) {\n            urlParameters.putAll(this.customParameters);\n        }\n\n        final String suffix = getUrlSuffix();\n        final StringBuilder buffer = new StringBuilder(urlParameters.size() * 10 + this.casServerUrlPrefix.length()\n                + suffix.length() + 1);\n\n        int i = 0;\n\n        buffer.append(this.casServerUrlPrefix);\n        if (!this.casServerUrlPrefix.endsWith(\"/\")) {\n            buffer.append(\"/\");\n        }\n        buffer.append(suffix);\n\n        for (Map.Entry<String, String> entry : urlParameters.entrySet()) {\n            final String key = entry.getKey();\n            final String value = entry.getValue();\n\n            if (value != null) {\n                buffer.append(i++ == 0 ? \"?\" : \"&\");\n                buffer.append(key);\n                buffer.append(\"=\");\n                final String encodedValue = encodeUrl(value);\n                buffer.append(encodedValue);\n            }\n        }\n\n        return buffer.toString();\n\n    }\n\n    /**\n     * Encodes a URL using the URLEncoder format.\n     *\n     * @param url the url to encode.\n     * @return the encoded url, or the original url if \"UTF-8\" character encoding could not be found.                       \n     */\n    protected final String encodeUrl(final String url) {\n        if (url == null) {\n            return null;\n        }\n\n        try {\n            return URLEncoder.encode(url, \"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            return url;\n        }\n    }\n\n    /**\n     * Parses the response from the server into a CAS Assertion.\n     *\n     * @param response the response from the server, in any format.\n     * @return the CAS assertion if one could be parsed from the response.\n     * @throws TicketValidationException if an Assertion could not be created.\n     *\n     */\n    protected abstract Assertion parseResponseFromServer(final String response) throws TicketValidationException;\n\n    /**\n     * Contacts the CAS Server to retrieve the response for the ticket validation.\n     *\n     * @param validationUrl the url to send the validation request to.\n     * @param ticket the ticket to validate.\n     * @return the response from the CAS server.\n     */\n\n    protected abstract String retrieveResponseFromServer(URL validationUrl, String ticket);\n\n    public final Assertion validate(final String ticket, final String service) throws TicketValidationException {\n        final String validationUrl = constructValidationUrl(ticket, service);\n        logger.debug(\"Constructing validation url: {}\", validationUrl);\n\n        try {\n            logger.debug(\"Retrieving response from server.\");\n            final String serverResponse = retrieveResponseFromServer(new URL(validationUrl), ticket);\n\n            if (serverResponse == null) {\n                throw new TicketValidationException(\"The CAS server returned no response.\");\n            }\n\n            logger.debug(\"Server response: {}\", serverResponse);\n\n            return parseResponseFromServer(serverResponse);\n        } catch (final MalformedURLException e) {\n            throw new TicketValidationException(e);\n        }\n    }\n\n    public final void setRenew(final boolean renew) {\n        this.renew = renew;\n    }\n\n    public final void setCustomParameters(final Map<String, String> customParameters) {\n        this.customParameters = customParameters;\n    }\n\n    public final void setEncoding(final String encoding) {\n        this.encoding = encoding;\n    }\n\n    protected final String getEncoding() {\n        return this.encoding;\n    }\n\n    protected final boolean isRenew() {\n        return this.renew;\n    }\n\n    protected final String getCasServerUrlPrefix() {\n        return this.casServerUrlPrefix;\n    }\n\n    protected final Map<String, String> getCustomParameters() {\n        return this.customParameters;\n    }\n\n    protected HttpURLConnectionFactory getURLConnectionFactory() {\n        return this.urlConnectionFactory;\n    }\n\n    public void setURLConnectionFactory(final HttpURLConnectionFactory urlConnectionFactory) {\n        this.urlConnectionFactory = urlConnectionFactory;\n    }\n}\n"
      },
      {
        "file_path": "cas-client-core/src/main/java/org/jasig/cas/client/validation/Cas20ServiceTicketValidator.java",
        "file_name": "Cas20ServiceTicketValidator.java",
        "vulnerable_code": "/*\n * Licensed to Jasig under one or more contributor license\n * agreements. See the NOTICE file distributed with this work\n * for additional information regarding copyright ownership.\n * Jasig licenses this file to you under the Apache License,\n * Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License.  You may obtain a\n * copy of the License at the following location:\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jasig.cas.client.validation;\n\nimport java.io.StringReader;\nimport java.util.*;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport org.jasig.cas.client.authentication.AttributePrincipal;\nimport org.jasig.cas.client.authentication.AttributePrincipalImpl;\nimport org.jasig.cas.client.proxy.Cas20ProxyRetriever;\nimport org.jasig.cas.client.proxy.ProxyGrantingTicketStorage;\nimport org.jasig.cas.client.proxy.ProxyRetriever;\nimport org.jasig.cas.client.util.CommonUtils;\nimport org.jasig.cas.client.util.XmlUtils;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Implementation of the TicketValidator that will validate Service Tickets in compliance with the CAS 2.\n *\n * @author Scott Battaglia\n * @since 3.1\n */\npublic class Cas20ServiceTicketValidator extends AbstractCasProtocolUrlBasedTicketValidator {\n\n    /** The CAS 2.0 protocol proxy callback url. */\n    private String proxyCallbackUrl;\n\n    /** The storage location of the proxy granting tickets. */\n    private ProxyGrantingTicketStorage proxyGrantingTicketStorage;\n\n    /** Implementation of the proxy retriever. */\n    private ProxyRetriever proxyRetriever;\n\n    /**\n     * Constructs an instance of the CAS 2.0 Service Ticket Validator with the supplied\n     * CAS server url prefix.\n     *\n     * @param casServerUrlPrefix the CAS Server URL prefix.\n     * @param urlFactory URL connection factory to use when communicating with the server\n     */\n    public Cas20ServiceTicketValidator(final String casServerUrlPrefix) {\n        super(casServerUrlPrefix);\n        this.proxyRetriever = new Cas20ProxyRetriever(casServerUrlPrefix, getEncoding(), getURLConnectionFactory());\n    }\n\n    /**\n     * Adds the pgtUrl to the list of parameters to pass to the CAS server.\n     *\n     * @param urlParameters the Map containing the existing parameters to send to the server.\n     */\n    protected final void populateUrlAttributeMap(final Map<String, String> urlParameters) {\n        urlParameters.put(\"pgtUrl\", encodeUrl(this.proxyCallbackUrl));\n    }\n\n    protected String getUrlSuffix() {\n        return \"serviceValidate\";\n    }\n\n    protected final Assertion parseResponseFromServer(final String response) throws TicketValidationException {\n        final String error = XmlUtils.getTextForElement(response, \"authenticationFailure\");\n\n        if (CommonUtils.isNotBlank(error)) {\n            throw new TicketValidationException(error);\n        }\n\n        final String principal = XmlUtils.getTextForElement(response, \"user\");\n        final String proxyGrantingTicketIou = XmlUtils.getTextForElement(response, \"proxyGrantingTicket\");\n\n        final String proxyGrantingTicket;\n        if (CommonUtils.isBlank(proxyGrantingTicketIou) || this.proxyGrantingTicketStorage == null) {\n            proxyGrantingTicket = null;\n        } else {\n            proxyGrantingTicket = this.proxyGrantingTicketStorage.retrieve(proxyGrantingTicketIou);\n        }\n\n        if (CommonUtils.isEmpty(principal)) {\n            throw new TicketValidationException(\"No principal was found in the response from the CAS server.\");\n        }\n\n        final Assertion assertion;\n        final Map<String, Object> attributes = extractCustomAttributes(response);\n        if (CommonUtils.isNotBlank(proxyGrantingTicket)) {\n            final AttributePrincipal attributePrincipal = new AttributePrincipalImpl(principal, attributes,\n                    proxyGrantingTicket, this.proxyRetriever);\n            assertion = new AssertionImpl(attributePrincipal);\n        } else {\n            assertion = new AssertionImpl(new AttributePrincipalImpl(principal, attributes));\n        }\n\n        customParseResponse(response, assertion);\n\n        return assertion;\n    }\n\n    /**\n     * Default attribute parsing of attributes that look like the following:\n     * &lt;cas:attributes&gt;\n     *  &lt;cas:attribute1&gt;value&lt;/cas:attribute1&gt;\n     *  &lt;cas:attribute2&gt;value&lt;/cas:attribute2&gt;\n     * &lt;/cas:attributes&gt;\n     * <p>\n     *\n     * Attributes look like following also parsed correctly:\n     * &lt;cas:attributes&gt;&lt;cas:attribute1&gt;value&lt;/cas:attribute1&gt;&lt;cas:attribute2&gt;value&lt;/cas:attribute2&gt;&lt;/cas:attributes&gt;\n     * <p>\n     *\n     * This code is here merely for sample/demonstration purposes for those wishing to modify the CAS2 protocol.  You'll\n     * probably want a more robust implementation or to use SAML 1.1\n     *\n     * @param xml the XML to parse.\n     * @return the map of attributes.\n     */\n    protected Map<String, Object> extractCustomAttributes(final String xml) {\n        final SAXParserFactory spf = SAXParserFactory.newInstance();\n        spf.setNamespaceAware(true);\n        spf.setValidating(false);\n        try {\n            final SAXParser saxParser = spf.newSAXParser();\n            final XMLReader xmlReader = saxParser.getXMLReader();\n            final CustomAttributeHandler handler = new CustomAttributeHandler();\n            xmlReader.setContentHandler(handler);\n            xmlReader.parse(new InputSource(new StringReader(xml)));\n            return handler.getAttributes();\n        } catch (final Exception e) {\n            logger.error(e.getMessage(), e);\n            return Collections.emptyMap();\n        }\n    }\n\n    /**\n     * Template method if additional custom parsing (such as Proxying) needs to be done.\n     *\n     * @param response the original response from the CAS server.\n     * @param assertion the partially constructed assertion.\n     * @throws TicketValidationException if there is a problem constructing the Assertion.\n     */\n    protected void customParseResponse(final String response, final Assertion assertion)\n            throws TicketValidationException {\n        // nothing to do\n    }\n\n    public final void setProxyCallbackUrl(final String proxyCallbackUrl) {\n        this.proxyCallbackUrl = proxyCallbackUrl;\n    }\n\n    public final void setProxyGrantingTicketStorage(final ProxyGrantingTicketStorage proxyGrantingTicketStorage) {\n        this.proxyGrantingTicketStorage = proxyGrantingTicketStorage;\n    }\n\n    public final void setProxyRetriever(final ProxyRetriever proxyRetriever) {\n        this.proxyRetriever = proxyRetriever;\n    }\n\n    protected final String getProxyCallbackUrl() {\n        return this.proxyCallbackUrl;\n    }\n\n    protected final ProxyGrantingTicketStorage getProxyGrantingTicketStorage() {\n        return this.proxyGrantingTicketStorage;\n    }\n\n    protected final ProxyRetriever getProxyRetriever() {\n        return this.proxyRetriever;\n    }\n\n    private class CustomAttributeHandler extends DefaultHandler {\n\n        private Map<String, Object> attributes;\n\n        private boolean foundAttributes;\n\n        private String currentAttribute;\n\n        private StringBuilder value;\n\n        @Override\n        public void startDocument() throws SAXException {\n            this.attributes = new HashMap<String, Object>();\n        }\n\n        @Override\n        public void startElement(final String namespaceURI, final String localName, final String qName,\n                final Attributes attributes) throws SAXException {\n            if (\"attributes\".equals(localName)) {\n                this.foundAttributes = true;\n            } else if (this.foundAttributes) {\n                this.value = new StringBuilder();\n                this.currentAttribute = localName;\n            }\n        }\n\n        @Override\n        public void characters(final char[] chars, final int start, final int length) throws SAXException {\n            if (this.currentAttribute != null) {\n                value.append(chars, start, length);\n            }\n        }\n\n        @Override\n        public void endElement(final String namespaceURI, final String localName, final String qName)\n                throws SAXException {\n            if (\"attributes\".equals(localName)) {\n                this.foundAttributes = false;\n                this.currentAttribute = null;\n            } else if (this.foundAttributes) {\n                final Object o = this.attributes.get(this.currentAttribute);\n\n                if (o == null) {\n                    this.attributes.put(this.currentAttribute, this.value.toString());\n                } else {\n                    final List<Object> items;\n                    if (o instanceof List) {\n                        items = (List<Object>) o;\n                    } else {\n                        items = new LinkedList<Object>();\n                        items.add(o);\n                        this.attributes.put(this.currentAttribute, items);\n                    }\n                    items.add(this.value.toString());\n                }\n            }\n        }\n\n        public Map<String, Object> getAttributes() {\n            return this.attributes;\n        }\n    }\n}\n",
        "human_patch_code": "/*\n * Licensed to Jasig under one or more contributor license\n * agreements. See the NOTICE file distributed with this work\n * for additional information regarding copyright ownership.\n * Jasig licenses this file to you under the Apache License,\n * Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License.  You may obtain a\n * copy of the License at the following location:\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jasig.cas.client.validation;\n\nimport java.io.StringReader;\nimport java.util.*;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport org.jasig.cas.client.authentication.AttributePrincipal;\nimport org.jasig.cas.client.authentication.AttributePrincipalImpl;\nimport org.jasig.cas.client.proxy.Cas20ProxyRetriever;\nimport org.jasig.cas.client.proxy.ProxyGrantingTicketStorage;\nimport org.jasig.cas.client.proxy.ProxyRetriever;\nimport org.jasig.cas.client.util.CommonUtils;\nimport org.jasig.cas.client.util.XmlUtils;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Implementation of the TicketValidator that will validate Service Tickets in compliance with the CAS 2.\n *\n * @author Scott Battaglia\n * @since 3.1\n */\npublic class Cas20ServiceTicketValidator extends AbstractCasProtocolUrlBasedTicketValidator {\n\n    /** The CAS 2.0 protocol proxy callback url. */\n    private String proxyCallbackUrl;\n\n    /** The storage location of the proxy granting tickets. */\n    private ProxyGrantingTicketStorage proxyGrantingTicketStorage;\n\n    /** Implementation of the proxy retriever. */\n    private ProxyRetriever proxyRetriever;\n\n    /**\n     * Constructs an instance of the CAS 2.0 Service Ticket Validator with the supplied\n     * CAS server url prefix.\n     *\n     * @param casServerUrlPrefix the CAS Server URL prefix.\n     * @param urlFactory URL connection factory to use when communicating with the server\n     */\n    public Cas20ServiceTicketValidator(final String casServerUrlPrefix) {\n        super(casServerUrlPrefix);\n        this.proxyRetriever = new Cas20ProxyRetriever(casServerUrlPrefix, getEncoding(), getURLConnectionFactory());\n    }\n\n    /**\n     * Adds the pgtUrl to the list of parameters to pass to the CAS server.\n     *\n     * @param urlParameters the Map containing the existing parameters to send to the server.\n     */\n    protected final void populateUrlAttributeMap(final Map<String, String> urlParameters) {\n        urlParameters.put(\"pgtUrl\", this.proxyCallbackUrl);\n    }\n\n    protected String getUrlSuffix() {\n        return \"serviceValidate\";\n    }\n\n    protected final Assertion parseResponseFromServer(final String response) throws TicketValidationException {\n        final String error = XmlUtils.getTextForElement(response, \"authenticationFailure\");\n\n        if (CommonUtils.isNotBlank(error)) {\n            throw new TicketValidationException(error);\n        }\n\n        final String principal = XmlUtils.getTextForElement(response, \"user\");\n        final String proxyGrantingTicketIou = XmlUtils.getTextForElement(response, \"proxyGrantingTicket\");\n\n        final String proxyGrantingTicket;\n        if (CommonUtils.isBlank(proxyGrantingTicketIou) || this.proxyGrantingTicketStorage == null) {\n            proxyGrantingTicket = null;\n        } else {\n            proxyGrantingTicket = this.proxyGrantingTicketStorage.retrieve(proxyGrantingTicketIou);\n        }\n\n        if (CommonUtils.isEmpty(principal)) {\n            throw new TicketValidationException(\"No principal was found in the response from the CAS server.\");\n        }\n\n        final Assertion assertion;\n        final Map<String, Object> attributes = extractCustomAttributes(response);\n        if (CommonUtils.isNotBlank(proxyGrantingTicket)) {\n            final AttributePrincipal attributePrincipal = new AttributePrincipalImpl(principal, attributes,\n                    proxyGrantingTicket, this.proxyRetriever);\n            assertion = new AssertionImpl(attributePrincipal);\n        } else {\n            assertion = new AssertionImpl(new AttributePrincipalImpl(principal, attributes));\n        }\n\n        customParseResponse(response, assertion);\n\n        return assertion;\n    }\n\n    /**\n     * Default attribute parsing of attributes that look like the following:\n     * &lt;cas:attributes&gt;\n     *  &lt;cas:attribute1&gt;value&lt;/cas:attribute1&gt;\n     *  &lt;cas:attribute2&gt;value&lt;/cas:attribute2&gt;\n     * &lt;/cas:attributes&gt;\n     * <p>\n     *\n     * Attributes look like following also parsed correctly:\n     * &lt;cas:attributes&gt;&lt;cas:attribute1&gt;value&lt;/cas:attribute1&gt;&lt;cas:attribute2&gt;value&lt;/cas:attribute2&gt;&lt;/cas:attributes&gt;\n     * <p>\n     *\n     * This code is here merely for sample/demonstration purposes for those wishing to modify the CAS2 protocol.  You'll\n     * probably want a more robust implementation or to use SAML 1.1\n     *\n     * @param xml the XML to parse.\n     * @return the map of attributes.\n     */\n    protected Map<String, Object> extractCustomAttributes(final String xml) {\n        final SAXParserFactory spf = SAXParserFactory.newInstance();\n        spf.setNamespaceAware(true);\n        spf.setValidating(false);\n        try {\n            final SAXParser saxParser = spf.newSAXParser();\n            final XMLReader xmlReader = saxParser.getXMLReader();\n            final CustomAttributeHandler handler = new CustomAttributeHandler();\n            xmlReader.setContentHandler(handler);\n            xmlReader.parse(new InputSource(new StringReader(xml)));\n            return handler.getAttributes();\n        } catch (final Exception e) {\n            logger.error(e.getMessage(), e);\n            return Collections.emptyMap();\n        }\n    }\n\n    /**\n     * Template method if additional custom parsing (such as Proxying) needs to be done.\n     *\n     * @param response the original response from the CAS server.\n     * @param assertion the partially constructed assertion.\n     * @throws TicketValidationException if there is a problem constructing the Assertion.\n     */\n    protected void customParseResponse(final String response, final Assertion assertion)\n            throws TicketValidationException {\n        // nothing to do\n    }\n\n    public final void setProxyCallbackUrl(final String proxyCallbackUrl) {\n        this.proxyCallbackUrl = proxyCallbackUrl;\n    }\n\n    public final void setProxyGrantingTicketStorage(final ProxyGrantingTicketStorage proxyGrantingTicketStorage) {\n        this.proxyGrantingTicketStorage = proxyGrantingTicketStorage;\n    }\n\n    public final void setProxyRetriever(final ProxyRetriever proxyRetriever) {\n        this.proxyRetriever = proxyRetriever;\n    }\n\n    protected final String getProxyCallbackUrl() {\n        return this.proxyCallbackUrl;\n    }\n\n    protected final ProxyGrantingTicketStorage getProxyGrantingTicketStorage() {\n        return this.proxyGrantingTicketStorage;\n    }\n\n    protected final ProxyRetriever getProxyRetriever() {\n        return this.proxyRetriever;\n    }\n\n    private class CustomAttributeHandler extends DefaultHandler {\n\n        private Map<String, Object> attributes;\n\n        private boolean foundAttributes;\n\n        private String currentAttribute;\n\n        private StringBuilder value;\n\n        @Override\n        public void startDocument() throws SAXException {\n            this.attributes = new HashMap<String, Object>();\n        }\n\n        @Override\n        public void startElement(final String namespaceURI, final String localName, final String qName,\n                final Attributes attributes) throws SAXException {\n            if (\"attributes\".equals(localName)) {\n                this.foundAttributes = true;\n            } else if (this.foundAttributes) {\n                this.value = new StringBuilder();\n                this.currentAttribute = localName;\n            }\n        }\n\n        @Override\n        public void characters(final char[] chars, final int start, final int length) throws SAXException {\n            if (this.currentAttribute != null) {\n                value.append(chars, start, length);\n            }\n        }\n\n        @Override\n        public void endElement(final String namespaceURI, final String localName, final String qName)\n                throws SAXException {\n            if (\"attributes\".equals(localName)) {\n                this.foundAttributes = false;\n                this.currentAttribute = null;\n            } else if (this.foundAttributes) {\n                final Object o = this.attributes.get(this.currentAttribute);\n\n                if (o == null) {\n                    this.attributes.put(this.currentAttribute, this.value.toString());\n                } else {\n                    final List<Object> items;\n                    if (o instanceof List) {\n                        items = (List<Object>) o;\n                    } else {\n                        items = new LinkedList<Object>();\n                        items.add(o);\n                        this.attributes.put(this.currentAttribute, items);\n                    }\n                    items.add(this.value.toString());\n                }\n            }\n        }\n\n        public Map<String, Object> getAttributes() {\n            return this.attributes;\n        }\n    }\n}\n"
      }
    ],
    "file_count": 2
  },
  "VUL4J-39": {
    "vul_id": "VUL4J-39",
    "cve_id": "CVE-2018-1192",
    "project": "cloudfoundry_uaa",
    "build_system": "Gradle",
    "compile_cmd": "./gradlew :cloudfoundry-identity-server:compileTestJava",
    "test_cmd": "./gradlew :cloudfoundry-identity-server:test --tests org.cloudfoundry.identity.uaa.authentication.event.UserAuthenticationSuccessEventTests",
    "test_all_cmd": "./gradlew :cloudfoundry-identity-server:test",
    "human_patch_url": "https://github.com/cloudfoundry/uaa/commit/a61bfabbad22f646ecf1f00016b448b26a60daf",
    "vulnerable_files": [
      {
        "file_path": "server/src/main/java/org/cloudfoundry/identity/uaa/authentication/UaaAuthenticationDetails.java",
        "file_name": "UaaAuthenticationDetails.java",
        "vulnerable_code": "/*******************************************************************************\n *     Cloud Foundry\n *     Copyright (c) [2009-2016] Pivotal Software, Inc. All Rights Reserved.\n *\n *     This product is licensed to you under the Apache License, Version 2.0 (the \"License\").\n *     You may not use this product except in compliance with the License.\n *\n *     This product includes a number of subcomponents with\n *     separate copyright notices and license terms. Your use of these\n *     subcomponents is subject to the terms and conditions of the\n *     subcomponent's license, as noted in the LICENSE file.\n *******************************************************************************/\npackage org.cloudfoundry.identity.uaa.authentication;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport org.bouncycastle.util.encoders.Base64;\nimport org.springframework.security.web.authentication.WebAuthenticationDetails;\nimport org.springframework.util.StringUtils;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.Serializable;\n\n/**\n * Contains additional information about the authentication request which may be\n * of use in auditing etc.\n *\n * @author Luke Taylor\n * @author Dave Syer\n */\npublic class UaaAuthenticationDetails implements Serializable {\n\n    public static final String ADD_NEW = \"add_new\";\n\n    public static final UaaAuthenticationDetails UNKNOWN = new UaaAuthenticationDetails();\n\n    private boolean addNew;\n\n    private final String origin;\n\n    private String sessionId;\n\n    private String clientId;\n\n    private UaaAuthenticationDetails() {\n        this.origin = \"unknown\";\n        this.sessionId = \"unknown\";\n        this.clientId = \"unknown\";\n    }\n\n    public UaaAuthenticationDetails(HttpServletRequest request) {\n        this(request, null);\n    }\n    public UaaAuthenticationDetails(HttpServletRequest request, String clientId) {\n        WebAuthenticationDetails webAuthenticationDetails = new WebAuthenticationDetails(request);\n        this.origin = webAuthenticationDetails.getRemoteAddress();\n        this.sessionId = webAuthenticationDetails.getSessionId();\n\n        if (clientId == null) {\n            this.clientId = request.getParameter(\"client_id\");\n            if(!StringUtils.hasText(this.clientId)) {\n                String authHeader = request.getHeader(\"Authorization\");\n                if(StringUtils.hasText(authHeader) && authHeader.startsWith(\"Basic \")) {\n                    String decodedCredentials = new String(Base64.decode(authHeader.substring(\"Basic \".length())));\n                    String[] split = decodedCredentials.split(\":\");\n                    this.clientId = split[0];\n                }\n            }\n        } else {\n            this.clientId = clientId;\n        }\n        this.addNew = Boolean.parseBoolean(request.getParameter(ADD_NEW));\n    }\n\n    public UaaAuthenticationDetails(@JsonProperty(\"addNew\") boolean addNew,\n                                    @JsonProperty(\"clientId\") String clientId,\n                                    @JsonProperty(\"origin\") String origin,\n                                    @JsonProperty(\"sessionId\") String sessionId) {\n        this.addNew = addNew;\n        this.clientId = clientId;\n        this.origin = origin;\n        this.sessionId = sessionId;\n    }\n\n    public String getOrigin() {\n        return origin;\n    }\n\n    public String getSessionId() {\n        return sessionId;\n    }\n\n    public String getClientId() {\n        return clientId;\n    }\n\n    public boolean isAddNew() {\n        return addNew;\n    }\n\n    public void setAddNew(boolean addNew) {\n        this.addNew = addNew;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        if (origin != null) {\n            sb.append(\"remoteAddress=\").append(origin);\n        }\n        if (clientId != null) {\n            if (sb.length() > 0) {\n                sb.append(\", \");\n            }\n            sb.append(\"clientId=\").append(clientId);\n        }\n        if (sessionId != null) {\n            if (sb.length() > 0) {\n                sb.append(\", \");\n            }\n            sb.append(\"sessionId=\").append(sessionId);\n        }\n        return sb.toString();\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((clientId == null) ? 0 : clientId.hashCode());\n        result = prime * result + ((origin == null) ? 0 : origin.hashCode());\n        result = prime * result + ((sessionId == null) ? 0 : sessionId.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        UaaAuthenticationDetails other = (UaaAuthenticationDetails) obj;\n        if (clientId == null) {\n            if (other.clientId != null)\n                return false;\n        }\n        else if (!clientId.equals(other.clientId))\n            return false;\n        if (origin == null) {\n            if (other.origin != null)\n                return false;\n        }\n        else if (!origin.equals(other.origin))\n            return false;\n        if (sessionId == null) {\n            if (other.sessionId != null)\n                return false;\n        }\n        else if (!sessionId.equals(other.sessionId))\n            return false;\n        return true;\n    }\n\n}\n",
        "human_patch_code": "/*******************************************************************************\n *     Cloud Foundry\n *     Copyright (c) [2009-2016] Pivotal Software, Inc. All Rights Reserved.\n *\n *     This product is licensed to you under the Apache License, Version 2.0 (the \"License\").\n *     You may not use this product except in compliance with the License.\n *\n *     This product includes a number of subcomponents with\n *     separate copyright notices and license terms. Your use of these\n *     subcomponents is subject to the terms and conditions of the\n *     subcomponent's license, as noted in the LICENSE file.\n *******************************************************************************/\npackage org.cloudfoundry.identity.uaa.authentication;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.Serializable;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport org.bouncycastle.util.encoders.Base64;\nimport org.springframework.security.web.authentication.WebAuthenticationDetails;\nimport org.springframework.util.StringUtils;\n\n/**\n * Contains additional information about the authentication request which may be\n * of use in auditing etc.\n *\n * @author Luke Taylor\n * @author Dave Syer\n */\npublic class UaaAuthenticationDetails implements Serializable {\n\n    public static final String ADD_NEW = \"add_new\";\n\n    public static final UaaAuthenticationDetails UNKNOWN = new UaaAuthenticationDetails();\n\n    private boolean addNew;\n\n    private final String origin;\n\n    private String sessionId;\n\n    private String clientId;\n\n    private UaaAuthenticationDetails() {\n        this.origin = \"unknown\";\n        this.sessionId = \"unknown\";\n        this.clientId = \"unknown\";\n    }\n\n    public UaaAuthenticationDetails(HttpServletRequest request) {\n        this(request, null);\n    }\n    public UaaAuthenticationDetails(HttpServletRequest request, String clientId) {\n        WebAuthenticationDetails webAuthenticationDetails = new WebAuthenticationDetails(request);\n        this.origin = webAuthenticationDetails.getRemoteAddress();\n        this.sessionId = webAuthenticationDetails.getSessionId();\n\n        if (clientId == null) {\n            this.clientId = request.getParameter(\"client_id\");\n            if(!StringUtils.hasText(this.clientId)) {\n                String authHeader = request.getHeader(\"Authorization\");\n                if(StringUtils.hasText(authHeader) && authHeader.startsWith(\"Basic \")) {\n                    String decodedCredentials = new String(Base64.decode(authHeader.substring(\"Basic \".length())));\n                    String[] split = decodedCredentials.split(\":\");\n                    this.clientId = split[0];\n                }\n            }\n        } else {\n            this.clientId = clientId;\n        }\n        this.addNew = Boolean.parseBoolean(request.getParameter(ADD_NEW));\n    }\n\n    public UaaAuthenticationDetails(@JsonProperty(\"addNew\") boolean addNew,\n                                    @JsonProperty(\"clientId\") String clientId,\n                                    @JsonProperty(\"origin\") String origin,\n                                    @JsonProperty(\"sessionId\") String sessionId) {\n        this.addNew = addNew;\n        this.clientId = clientId;\n        this.origin = origin;\n        this.sessionId = sessionId;\n    }\n\n    public String getOrigin() {\n        return origin;\n    }\n\n    public String getSessionId() {\n        return sessionId;\n    }\n\n    public String getClientId() {\n        return clientId;\n    }\n\n    public boolean isAddNew() {\n        return addNew;\n    }\n\n    public void setAddNew(boolean addNew) {\n        this.addNew = addNew;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        if (origin != null) {\n            sb.append(\"remoteAddress=\").append(origin);\n        }\n        if (clientId != null) {\n            if (sb.length() > 0) {\n                sb.append(\", \");\n            }\n            sb.append(\"clientId=\").append(clientId);\n        }\n        return sb.toString();\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((clientId == null) ? 0 : clientId.hashCode());\n        result = prime * result + ((origin == null) ? 0 : origin.hashCode());\n        result = prime * result + ((sessionId == null) ? 0 : sessionId.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        UaaAuthenticationDetails other = (UaaAuthenticationDetails) obj;\n        if (clientId == null) {\n            if (other.clientId != null)\n                return false;\n        }\n        else if (!clientId.equals(other.clientId))\n            return false;\n        if (origin == null) {\n            if (other.origin != null)\n                return false;\n        }\n        else if (!origin.equals(other.origin))\n            return false;\n        if (sessionId == null) {\n            if (other.sessionId != null)\n                return false;\n        }\n        else if (!sessionId.equals(other.sessionId))\n            return false;\n        return true;\n    }\n\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-40": {
    "vul_id": "VUL4J-40",
    "cve_id": "CVE-2019-3775",
    "project": "cloudfoundry_uaa",
    "build_system": "Gradle",
    "compile_cmd": "./gradlew :cloudfoundry-identity-server:compileTestJava",
    "test_cmd": "./gradlew :cloudfoundry-identity-server:test --tests org.cloudfoundry.identity.uaa.security.ScimUserSelfUpdateAllowedTest",
    "test_all_cmd": "./gradlew :cloudfoundry-identity-server:test",
    "human_patch_url": "https://github.com/cloudfoundry/uaa/commit/daeedbe499453b06856556f5e9f7e80d2d1ceb03",
    "vulnerable_files": [
      {
        "file_path": "server/src/main/java/org/cloudfoundry/identity/uaa/security/ScimUserSelfUpdateAllowed.java",
        "file_name": "ScimUserSelfUpdateAllowed.java",
        "vulnerable_code": "package org.cloudfoundry.identity.uaa.security;\n\nimport org.apache.commons.io.IOUtils;\nimport org.cloudfoundry.identity.uaa.scim.ScimUser;\nimport org.cloudfoundry.identity.uaa.scim.ScimUserProvisioning;\nimport org.cloudfoundry.identity.uaa.scim.exception.ScimResourceNotFoundException;\nimport org.cloudfoundry.identity.uaa.util.JsonUtils;\nimport org.cloudfoundry.identity.uaa.util.UaaUrlUtils;\nimport org.cloudfoundry.identity.uaa.zone.IdentityZoneHolder;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.IOException;\n\npublic class ScimUserSelfUpdateAllowed {\n\n    public static final int USER_ID_PATH_PARAMETER_INDEX = 1;\n    private ScimUserProvisioning scimUserProvisioning;\n\n    public ScimUserSelfUpdateAllowed(ScimUserProvisioning scimUserProvisioning) {\n        this.scimUserProvisioning = scimUserProvisioning;\n    }\n\n    public boolean isAllowed(HttpServletRequest request) throws IOException {\n        String requestBody = IOUtils.toString(request.getReader());\n        ScimUser scimUserFromRequest = JsonUtils.readValue(requestBody, ScimUser.class);\n\n        String id = UaaUrlUtils.extractPathVariableFromUrl(USER_ID_PATH_PARAMETER_INDEX, UaaUrlUtils.getRequestPath(request));\n        String zoneId = IdentityZoneHolder.get().getId();\n        ScimUser scimUserFromDb;\n\n        try {\n            scimUserFromDb = scimUserProvisioning.retrieve(id, zoneId);\n        } catch (ScimResourceNotFoundException e) {\n            return true;\n        }\n\n        if (!scimUserFromDb.getPrimaryEmail().equals(scimUserFromRequest.getPrimaryEmail())) {\n            return false;\n        }\n\n        if (!scimUserFromDb.getUserName().equals(scimUserFromRequest.getUserName())) {\n            return false;\n        }\n\n        if (scimUserFromDb.isVerified() != scimUserFromRequest.isVerified()) {\n            return false;\n        }\n\n        if (scimUserFromDb.isActive() != (scimUserFromRequest.isActive())) {\n            return false;\n        }\n\n        if (!scimUserFromDb.getOrigin().equals(scimUserFromRequest.getOrigin())) {\n            return false;\n        }\n\n\n        return true;\n    }\n\n}\n",
        "human_patch_code": "package org.cloudfoundry.identity.uaa.security;\n\nimport org.apache.commons.io.IOUtils;\nimport org.cloudfoundry.identity.uaa.scim.ScimUser;\nimport org.cloudfoundry.identity.uaa.scim.ScimUserProvisioning;\nimport org.cloudfoundry.identity.uaa.scim.exception.ScimResourceNotFoundException;\nimport org.cloudfoundry.identity.uaa.util.JsonUtils;\nimport org.cloudfoundry.identity.uaa.util.UaaUrlUtils;\nimport org.cloudfoundry.identity.uaa.zone.IdentityZoneHolder;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.IOException;\n\npublic class ScimUserSelfUpdateAllowed {\n\n    public static final int USER_ID_PATH_PARAMETER_INDEX = 1;\n    private ScimUserProvisioning scimUserProvisioning;\n\n    public ScimUserSelfUpdateAllowed(ScimUserProvisioning scimUserProvisioning) {\n        this.scimUserProvisioning = scimUserProvisioning;\n    }\n\n    public boolean isAllowed(HttpServletRequest request) throws IOException {\n        String requestBody = IOUtils.toString(request.getReader());\n        ScimUser scimUserFromRequest = JsonUtils.readValue(requestBody, ScimUser.class);\n\n        String id = UaaUrlUtils.extractPathVariableFromUrl(USER_ID_PATH_PARAMETER_INDEX, UaaUrlUtils.getRequestPath(request));\n        String zoneId = IdentityZoneHolder.get().getId();\n        ScimUser scimUserFromDb;\n\n        try {\n            scimUserFromDb = scimUserProvisioning.retrieve(id, zoneId);\n        } catch (ScimResourceNotFoundException e) {\n            return true;\n        }\n\n        if (!scimUserFromDb.getPrimaryEmail().equals(scimUserFromRequest.getPrimaryEmail())) {\n            return false;\n        }\n\n        if (!scimUserFromDb.getEmails().containsAll(scimUserFromRequest.getEmails())) {\n            return false;\n        }\n\n        if (!scimUserFromDb.getUserName().equals(scimUserFromRequest.getUserName())) {\n            return false;\n        }\n\n        if (scimUserFromDb.isVerified() != scimUserFromRequest.isVerified()) {\n            return false;\n        }\n\n        if (scimUserFromDb.isActive() != (scimUserFromRequest.isActive())) {\n            return false;\n        }\n\n        if (!scimUserFromDb.getOrigin().equals(scimUserFromRequest.getOrigin())) {\n            return false;\n        }\n\n\n        return true;\n    }\n\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-41": {
    "vul_id": "VUL4J-41",
    "cve_id": "CVE-2018-1002200",
    "project": "codehaus-plexus_plexus-archiver",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=org.codehaus.plexus.archiver.zip.ZipUnArchiverTest#testExtractingZipWithEntryOutsideDestDirThrowsException",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/codehaus-plexus/plexus-archiver/commit/58bc24e465c0842981692adbf6d75680298989de",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/org/codehaus/plexus/archiver/AbstractUnArchiver.java",
        "file_name": "AbstractUnArchiver.java",
        "vulnerable_code": "/**\n *\n * Copyright 2004 The Apache Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport org.codehaus.plexus.archiver.util.ArchiveEntryUtils;\nimport org.codehaus.plexus.components.io.attributes.SymlinkUtils;\nimport org.codehaus.plexus.components.io.fileselectors.FileSelector;\nimport org.codehaus.plexus.components.io.resources.PlexusIoResource;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * @author <a href=\"mailto:evenisse@codehaus.org\">Emmanuel Venisse</a>\n * @todo there should really be constructors which take the source file.\n */\npublic abstract class AbstractUnArchiver\n    extends AbstractLogEnabled\n    implements UnArchiver, FinalizerEnabled\n{\n\n    private File destDirectory;\n\n    private File destFile;\n\n    private File sourceFile;\n\n    private boolean overwrite = true;\n\n    private List finalizers;\n\n    private FileSelector[] fileSelectors;\n\n    /**\n     * since 2.3 is on by default\n     *\n     * @since 1.1\n     */\n    private boolean useJvmChmod = true;\n\n    /**\n     * @since 1.1\n     */\n    private boolean ignorePermissions = false;\n\n    public AbstractUnArchiver()\n    {\n        // no op\n    }\n\n    public AbstractUnArchiver( final File sourceFile )\n    {\n        this.sourceFile = sourceFile;\n    }\n\n    @Override\n    public File getDestDirectory()\n    {\n        return destDirectory;\n    }\n\n    @Override\n    public void setDestDirectory( final File destDirectory )\n    {\n        this.destDirectory = destDirectory;\n    }\n\n    @Override\n    public File getDestFile()\n    {\n        return destFile;\n    }\n\n    @Override\n    public void setDestFile( final File destFile )\n    {\n        this.destFile = destFile;\n    }\n\n    @Override\n    public File getSourceFile()\n    {\n        return sourceFile;\n    }\n\n    @Override\n    public void setSourceFile( final File sourceFile )\n    {\n        this.sourceFile = sourceFile;\n    }\n\n    @Override\n    public boolean isOverwrite()\n    {\n        return overwrite;\n    }\n\n    @Override\n    public void setOverwrite( final boolean b )\n    {\n        overwrite = b;\n    }\n\n    @Override\n    public final void extract()\n        throws ArchiverException\n    {\n        validate();\n        execute();\n        runArchiveFinalizers();\n    }\n\n    @Override\n    public final void extract( final String path, final File outputDirectory )\n        throws ArchiverException\n    {\n        validate( path, outputDirectory );\n        execute( path, outputDirectory );\n        runArchiveFinalizers();\n    }\n\n    @Override\n    public void addArchiveFinalizer( final ArchiveFinalizer finalizer )\n    {\n        if ( finalizers == null )\n        {\n            finalizers = new ArrayList();\n        }\n\n        finalizers.add( finalizer );\n    }\n\n    @Override\n    public void setArchiveFinalizers( final List archiveFinalizers )\n    {\n        finalizers = archiveFinalizers;\n    }\n\n    private void runArchiveFinalizers()\n        throws ArchiverException\n    {\n        if ( finalizers != null )\n        {\n            for ( Object finalizer1 : finalizers )\n            {\n                final ArchiveFinalizer finalizer = (ArchiveFinalizer) finalizer1;\n\n                finalizer.finalizeArchiveExtraction( this );\n            }\n        }\n    }\n\n    protected void validate( final String path, final File outputDirectory )\n    {\n    }\n\n    protected void validate()\n        throws ArchiverException\n    {\n        if ( sourceFile == null )\n        {\n            throw new ArchiverException( \"The source file isn't defined.\" );\n        }\n\n        if ( sourceFile.isDirectory() )\n        {\n            throw new ArchiverException( \"The source must not be a directory.\" );\n        }\n\n        if ( !sourceFile.exists() )\n        {\n            throw new ArchiverException( \"The source file \" + sourceFile + \" doesn't exist.\" );\n        }\n\n        if ( destDirectory == null && destFile == null )\n        {\n            throw new ArchiverException( \"The destination isn't defined.\" );\n        }\n\n        if ( destDirectory != null && destFile != null )\n        {\n            throw new ArchiverException( \"You must choose between a destination directory and a destination file.\" );\n        }\n\n        if ( destDirectory != null && !destDirectory.isDirectory() )\n        {\n            destFile = destDirectory;\n            destDirectory = null;\n        }\n\n        if ( destFile != null && destFile.isDirectory() )\n        {\n            destDirectory = destFile;\n            destFile = null;\n        }\n    }\n\n    @Override\n    public void setFileSelectors( final FileSelector[] fileSelectors )\n    {\n        this.fileSelectors = fileSelectors;\n    }\n\n    @Override\n    public FileSelector[] getFileSelectors()\n    {\n        return fileSelectors;\n    }\n\n    protected boolean isSelected( final String fileName, final PlexusIoResource fileInfo )\n        throws ArchiverException\n    {\n        if ( fileSelectors != null )\n        {\n            for ( FileSelector fileSelector : fileSelectors )\n            {\n                try\n                {\n\n                    if ( !fileSelector.isSelected( fileInfo ) )\n                    {\n                        return false;\n                    }\n                }\n                catch ( final IOException e )\n                {\n                    throw new ArchiverException(\n                        \"Failed to check, whether \" + fileInfo.getName() + \" is selected: \" + e.getMessage(), e );\n                }\n            }\n        }\n        return true;\n    }\n\n    protected abstract void execute()\n        throws ArchiverException;\n\n    protected abstract void execute( String path, File outputDirectory )\n        throws ArchiverException;\n\n    /**\n     * @since 1.1\n     */\n    @Override\n    public boolean isUseJvmChmod()\n    {\n        return useJvmChmod;\n    }\n\n    /**\n     * <b>jvm chmod won't set group level permissions !</b>\n     *\n     * @since 1.1\n     */\n    @Override\n    public void setUseJvmChmod( final boolean useJvmChmod )\n    {\n        this.useJvmChmod = useJvmChmod;\n    }\n\n    /**\n     * @since 1.1\n     */\n    @Override\n    public boolean isIgnorePermissions()\n    {\n        return ignorePermissions;\n    }\n\n    /**\n     * @since 1.1\n     */\n    @Override\n    public void setIgnorePermissions( final boolean ignorePermissions )\n    {\n        this.ignorePermissions = ignorePermissions;\n    }\n\n    protected void extractFile( final File srcF, final File dir, final InputStream compressedInputStream,\n                                final String entryName, final Date entryDate, final boolean isDirectory,\n                                final Integer mode, String symlinkDestination )\n        throws IOException, ArchiverException\n    {\n        // Hmm. Symlinks re-evaluate back to the original file here. Unsure if this is a good thing...\n        final File f = FileUtils.resolveFile( dir, entryName );\n\n        try\n        {\n            if ( !isOverwrite() && f.exists() && ( f.lastModified() >= entryDate.getTime() ) )\n            {\n                return;\n            }\n\n            // create intermediary directories - sometimes zip don't add them\n            final File dirF = f.getParentFile();\n            if ( dirF != null )\n            {\n                dirF.mkdirs();\n            }\n\n            if ( !StringUtils.isEmpty( symlinkDestination ) )\n            {\n                SymlinkUtils.createSymbolicLink( f, new File( symlinkDestination ) );\n            }\n            else if ( isDirectory )\n            {\n                f.mkdirs();\n            }\n            else\n            {\n                OutputStream out = null;\n                try\n                {\n                    out = new FileOutputStream( f );\n\n                    IOUtil.copy( compressedInputStream, out );\n                    out.close();\n                    out = null;\n                }\n                finally\n                {\n                    IOUtil.close( out );\n                }\n            }\n\n            f.setLastModified( entryDate.getTime() );\n\n            if ( !isIgnorePermissions() && mode != null && !isDirectory )\n            {\n                ArchiveEntryUtils.chmod( f, mode );\n            }\n        }\n        catch ( final FileNotFoundException ex )\n        {\n            getLogger().warn( \"Unable to expand to file \" + f.getPath() );\n        }\n    }\n\n}\n",
        "human_patch_code": "/**\n *\n * Copyright 2004 The Apache Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport org.codehaus.plexus.archiver.util.ArchiveEntryUtils;\nimport org.codehaus.plexus.components.io.attributes.SymlinkUtils;\nimport org.codehaus.plexus.components.io.fileselectors.FileSelector;\nimport org.codehaus.plexus.components.io.resources.PlexusIoResource;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * @author <a href=\"mailto:evenisse@codehaus.org\">Emmanuel Venisse</a>\n * @todo there should really be constructors which take the source file.\n */\npublic abstract class AbstractUnArchiver\n    extends AbstractLogEnabled\n    implements UnArchiver, FinalizerEnabled\n{\n\n    private File destDirectory;\n\n    private File destFile;\n\n    private File sourceFile;\n\n    private boolean overwrite = true;\n\n    private List finalizers;\n\n    private FileSelector[] fileSelectors;\n\n    /**\n     * since 2.3 is on by default\n     *\n     * @since 1.1\n     */\n    private boolean useJvmChmod = true;\n\n    /**\n     * @since 1.1\n     */\n    private boolean ignorePermissions = false;\n\n    public AbstractUnArchiver()\n    {\n        // no op\n    }\n\n    public AbstractUnArchiver( final File sourceFile )\n    {\n        this.sourceFile = sourceFile;\n    }\n\n    @Override\n    public File getDestDirectory()\n    {\n        return destDirectory;\n    }\n\n    @Override\n    public void setDestDirectory( final File destDirectory )\n    {\n        this.destDirectory = destDirectory;\n    }\n\n    @Override\n    public File getDestFile()\n    {\n        return destFile;\n    }\n\n    @Override\n    public void setDestFile( final File destFile )\n    {\n        this.destFile = destFile;\n    }\n\n    @Override\n    public File getSourceFile()\n    {\n        return sourceFile;\n    }\n\n    @Override\n    public void setSourceFile( final File sourceFile )\n    {\n        this.sourceFile = sourceFile;\n    }\n\n    @Override\n    public boolean isOverwrite()\n    {\n        return overwrite;\n    }\n\n    @Override\n    public void setOverwrite( final boolean b )\n    {\n        overwrite = b;\n    }\n\n    @Override\n    public final void extract()\n        throws ArchiverException\n    {\n        validate();\n        execute();\n        runArchiveFinalizers();\n    }\n\n    @Override\n    public final void extract( final String path, final File outputDirectory )\n        throws ArchiverException\n    {\n        validate( path, outputDirectory );\n        execute( path, outputDirectory );\n        runArchiveFinalizers();\n    }\n\n    @Override\n    public void addArchiveFinalizer( final ArchiveFinalizer finalizer )\n    {\n        if ( finalizers == null )\n        {\n            finalizers = new ArrayList();\n        }\n\n        finalizers.add( finalizer );\n    }\n\n    @Override\n    public void setArchiveFinalizers( final List archiveFinalizers )\n    {\n        finalizers = archiveFinalizers;\n    }\n\n    private void runArchiveFinalizers()\n        throws ArchiverException\n    {\n        if ( finalizers != null )\n        {\n            for ( Object finalizer1 : finalizers )\n            {\n                final ArchiveFinalizer finalizer = (ArchiveFinalizer) finalizer1;\n\n                finalizer.finalizeArchiveExtraction( this );\n            }\n        }\n    }\n\n    protected void validate( final String path, final File outputDirectory )\n    {\n    }\n\n    protected void validate()\n        throws ArchiverException\n    {\n        if ( sourceFile == null )\n        {\n            throw new ArchiverException( \"The source file isn't defined.\" );\n        }\n\n        if ( sourceFile.isDirectory() )\n        {\n            throw new ArchiverException( \"The source must not be a directory.\" );\n        }\n\n        if ( !sourceFile.exists() )\n        {\n            throw new ArchiverException( \"The source file \" + sourceFile + \" doesn't exist.\" );\n        }\n\n        if ( destDirectory == null && destFile == null )\n        {\n            throw new ArchiverException( \"The destination isn't defined.\" );\n        }\n\n        if ( destDirectory != null && destFile != null )\n        {\n            throw new ArchiverException( \"You must choose between a destination directory and a destination file.\" );\n        }\n\n        if ( destDirectory != null && !destDirectory.isDirectory() )\n        {\n            destFile = destDirectory;\n            destDirectory = null;\n        }\n\n        if ( destFile != null && destFile.isDirectory() )\n        {\n            destDirectory = destFile;\n            destFile = null;\n        }\n    }\n\n    @Override\n    public void setFileSelectors( final FileSelector[] fileSelectors )\n    {\n        this.fileSelectors = fileSelectors;\n    }\n\n    @Override\n    public FileSelector[] getFileSelectors()\n    {\n        return fileSelectors;\n    }\n\n    protected boolean isSelected( final String fileName, final PlexusIoResource fileInfo )\n        throws ArchiverException\n    {\n        if ( fileSelectors != null )\n        {\n            for ( FileSelector fileSelector : fileSelectors )\n            {\n                try\n                {\n\n                    if ( !fileSelector.isSelected( fileInfo ) )\n                    {\n                        return false;\n                    }\n                }\n                catch ( final IOException e )\n                {\n                    throw new ArchiverException(\n                        \"Failed to check, whether \" + fileInfo.getName() + \" is selected: \" + e.getMessage(), e );\n                }\n            }\n        }\n        return true;\n    }\n\n    protected abstract void execute()\n        throws ArchiverException;\n\n    protected abstract void execute( String path, File outputDirectory )\n        throws ArchiverException;\n\n    /**\n     * @since 1.1\n     */\n    @Override\n    public boolean isUseJvmChmod()\n    {\n        return useJvmChmod;\n    }\n\n    /**\n     * <b>jvm chmod won't set group level permissions !</b>\n     *\n     * @since 1.1\n     */\n    @Override\n    public void setUseJvmChmod( final boolean useJvmChmod )\n    {\n        this.useJvmChmod = useJvmChmod;\n    }\n\n    /**\n     * @since 1.1\n     */\n    @Override\n    public boolean isIgnorePermissions()\n    {\n        return ignorePermissions;\n    }\n\n    /**\n     * @since 1.1\n     */\n    @Override\n    public void setIgnorePermissions( final boolean ignorePermissions )\n    {\n        this.ignorePermissions = ignorePermissions;\n    }\n\n    protected void extractFile( final File srcF, final File dir, final InputStream compressedInputStream,\n                                final String entryName, final Date entryDate, final boolean isDirectory,\n                                final Integer mode, String symlinkDestination )\n        throws IOException, ArchiverException\n    {\n        // Hmm. Symlinks re-evaluate back to the original file here. Unsure if this is a good thing...\n        final File f = FileUtils.resolveFile( dir, entryName );\n\n        // Make sure that the resolved path of the extracted file doesn't escape the destination directory\n        String canonicalDirPath = dir.getCanonicalPath();\n        String canonicalDestPath = f.getCanonicalPath();\n\n        if ( !canonicalDestPath.startsWith( canonicalDirPath ) )\n        {\n            throw new ArchiverException( \"Entry is outside of the target directory (\" + entryName + \")\" );\n        }\n\n        try\n        {\n            if ( !isOverwrite() && f.exists() && ( f.lastModified() >= entryDate.getTime() ) )\n            {\n                return;\n            }\n\n            // create intermediary directories - sometimes zip don't add them\n            final File dirF = f.getParentFile();\n            if ( dirF != null )\n            {\n                dirF.mkdirs();\n            }\n\n            if ( !StringUtils.isEmpty( symlinkDestination ) )\n            {\n                SymlinkUtils.createSymbolicLink( f, new File( symlinkDestination ) );\n            }\n            else if ( isDirectory )\n            {\n                f.mkdirs();\n            }\n            else\n            {\n                OutputStream out = null;\n                try\n                {\n                    out = new FileOutputStream( f );\n\n                    IOUtil.copy( compressedInputStream, out );\n                    out.close();\n                    out = null;\n                }\n                finally\n                {\n                    IOUtil.close( out );\n                }\n            }\n\n            f.setLastModified( entryDate.getTime() );\n\n            if ( !isIgnorePermissions() && mode != null && !isDirectory )\n            {\n                ArchiveEntryUtils.chmod( f, mode );\n            }\n        }\n        catch ( final FileNotFoundException ex )\n        {\n            getLogger().warn( \"Unable to expand to file \" + f.getPath() );\n        }\n    }\n\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-42": {
    "vul_id": "VUL4J-42",
    "cve_id": "CVE-2017-1000487",
    "project": "codehaus-plexus_plexus-utils",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=org.codehaus.plexus.util.cli.CommandlineTest,org.codehaus.plexus.util.cli.shell.BourneShellTest",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/codehaus-plexus/plexus-utils/commit/b38a1b3a4352303e4312b2bb601a0d7ec6e28f41",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/org/codehaus/plexus/util/cli/Commandline.java",
        "file_name": "Commandline.java",
        "vulnerable_code": "package org.codehaus.plexus.util.cli;\n\n/*\n * Copyright The Codehaus Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/***************************************************************************************************\n * CruiseControl, a Continuous Integration Toolkit Copyright (c) 2001-2003, ThoughtWorks, Inc. 651 W\n * Washington Ave. Suite 500 Chicago, IL 60661 USA All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted\n * provided that the following conditions are met: + Redistributions of source code must retain the\n * above copyright notice, this list of conditions and the following disclaimer. + Redistributions\n * in binary form must reproduce the above copyright notice, this list of conditions and the\n * following disclaimer in the documentation and/or other materials provided with the distribution. +\n * Neither the name of ThoughtWorks, Inc., CruiseControl, nor the names of its contributors may be\n * used to endorse or promote products derived from this software without specific prior written\n * permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n **************************************************************************************************/\n\n/*\n * ====================================================================\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ====================================================================\n */\n\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.shell.BourneShell;\nimport org.codehaus.plexus.util.cli.shell.CmdShell;\nimport org.codehaus.plexus.util.cli.shell.CommandShell;\nimport org.codehaus.plexus.util.cli.shell.Shell;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Vector;\n\n/**\n * <p/>\n * Commandline objects help handling command lines specifying processes to\n * execute.\n * </p>\n * <p/>\n * The class can be used to define a command line as nested elements or as a\n * helper to define a command line by an application.\n * </p>\n * <p/>\n * <code>\n * &lt;someelement&gt;<br>\n * &nbsp;&nbsp;&lt;acommandline executable=\"/executable/to/run\"&gt;<br>\n * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument value=\"argument 1\" /&gt;<br>\n * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument line=\"argument_1 argument_2 argument_3\" /&gt;<br>\n * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument value=\"argument 4\" /&gt;<br>\n * &nbsp;&nbsp;&lt;/acommandline&gt;<br>\n * &lt;/someelement&gt;<br>\n * </code>\n * </p>\n * <p/>\n * The element <code>someelement</code> must provide a method\n * <code>createAcommandline</code> which returns an instance of this class.\n * </p>\n *\n * @author thomas.haas@softwired-inc.com\n * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n */\npublic class Commandline\n    implements Cloneable\n{\n    /**\n     * @deprecated Use {@link org.codehaus.plexus.util.Os} class instead.\n     */\n    protected static final String OS_NAME = \"os.name\";\n\n    /**\n     * @deprecated Use {@link org.codehaus.plexus.util.Os} class instead.\n     */\n    protected static final String WINDOWS = \"Windows\";\n\n    protected Vector arguments = new Vector();\n\n    //protected Vector envVars = new Vector();\n    // synchronized added to preserve synchronize of Vector class\n    protected Map envVars = Collections.synchronizedMap( new LinkedHashMap() );\n\n    private long pid = -1;\n\n    private Shell shell;\n\n    /**\n     * @deprecated Use {@link Commandline#setExecutable(String)} instead.\n     */\n    protected String executable;\n\n    /**\n     * @deprecated Use {@link Commandline#setWorkingDirectory(File)} or\n     * {@link Commandline#setWorkingDirectory(String)} instead.\n     */\n    private File workingDir;\n\n    /**\n     * Create a new command line object.\n     * Shell is autodetected from operating system\n     *\n     * @param toProcess\n     */\n    public Commandline( String toProcess, Shell shell )\n    {\n        this.shell = shell;\n\n        String[] tmp = new String[0];\n        try\n        {\n            tmp = CommandLineUtils.translateCommandline( toProcess );\n        }\n        catch ( Exception e )\n        {\n            System.err.println( \"Error translating Commandline.\" );\n        }\n        if ( ( tmp != null ) && ( tmp.length > 0 ) )\n        {\n            setExecutable( tmp[0] );\n            for ( int i = 1; i < tmp.length; i++ )\n            {\n                createArgument().setValue( tmp[i] );\n            }\n        }\n    }\n\n    /**\n     * Create a new command line object.\n     * Shell is autodetected from operating system\n     */\n    public Commandline( Shell shell )\n    {\n        this.shell = shell;\n    }\n\n    /**\n     * Create a new command line object.\n     * Shell is autodetected from operating system\n     *\n     * @param toProcess\n     */\n    public Commandline( String toProcess )\n    {\n        setDefaultShell();\n        String[] tmp = new String[0];\n        try\n        {\n            tmp = CommandLineUtils.translateCommandline( toProcess );\n        }\n        catch ( Exception e )\n        {\n            System.err.println( \"Error translating Commandline.\" );\n        }\n        if ( ( tmp != null ) && ( tmp.length > 0 ) )\n        {\n            setExecutable( tmp[0] );\n            for ( int i = 1; i < tmp.length; i++ )\n            {\n                createArgument().setValue( tmp[i] );\n            }\n        }\n    }\n\n    /**\n     * Create a new command line object.\n     * Shell is autodetected from operating system\n     */\n    public Commandline()\n    {\n        setDefaultShell();\n    }\n\n    public long getPid()\n    {\n        if ( pid == -1 )\n        {\n            pid = Long.parseLong( String.valueOf( System.currentTimeMillis() ) );\n        }\n\n        return pid;\n    }\n\n    public void setPid( long pid )\n    {\n        this.pid = pid;\n    }\n\n    /**\n     * Class to keep track of the position of an Argument.\n     */\n    // <p>This class is there to support the srcfile and targetfile\n    // elements of &lt;execon&gt; and &lt;transform&gt; - don't know\n    // whether there might be additional use cases.</p> --SB\n    public class Marker\n    {\n\n        private int position;\n\n        private int realPos = -1;\n\n        Marker( int position )\n        {\n            this.position = position;\n        }\n\n        /**\n         * Return the number of arguments that preceeded this marker.\n         * <p/>\n         * <p>The name of the executable - if set - is counted as the\n         * very first argument.</p>\n         */\n        public int getPosition()\n        {\n            if ( realPos == -1 )\n            {\n                realPos = ( getExecutable() == null ? 0 : 1 );\n                for ( int i = 0; i < position; i++ )\n                {\n                    Arg arg = (Arg) arguments.elementAt( i );\n                    realPos += arg.getParts().length;\n                }\n            }\n            return realPos;\n        }\n    }\n\n    /**\n     * <p>Sets the shell or command-line interpretor for the detected operating system,\n     * and the shell arguments.</p>\n     */\n    private void setDefaultShell()\n    {\n        //If this is windows set the shell to command.com or cmd.exe with correct arguments.\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            if ( Os.isFamily( Os.FAMILY_WIN9X ) )\n            {\n                setShell( new CommandShell() );\n            }\n            else\n            {\n                setShell( new CmdShell() );\n            }\n        }\n        else\n        {\n            setShell( new BourneShell() );\n        }\n    }\n\n    /**\n     * Creates an argument object.\n     * <p/>\n     * <p>Each commandline object has at most one instance of the\n     * argument class.  This method calls\n     * <code>this.createArgument(false)</code>.</p>\n     *\n     * @return the argument object.\n     * @see #createArgument(boolean)\n     * @deprecated Use {@link Commandline#createArg()} instead\n     */\n    public Argument createArgument()\n    {\n        return this.createArgument( false );\n    }\n\n    /**\n     * Creates an argument object and adds it to our list of args.\n     * <p/>\n     * <p>Each commandline object has at most one instance of the\n     * argument class.</p>\n     *\n     * @param insertAtStart if true, the argument is inserted at the\n     *                      beginning of the list of args, otherwise it is appended.\n     * @deprecated Use {@link Commandline#createArg(boolean)} instead\n     */\n    public Argument createArgument( boolean insertAtStart )\n    {\n        Argument argument = new Argument();\n        if ( insertAtStart )\n        {\n            arguments.insertElementAt( argument, 0 );\n        }\n        else\n        {\n            arguments.addElement( argument );\n        }\n        return argument;\n    }\n\n    /**\n     * Creates an argument object.\n     * <p/>\n     * <p>Each commandline object has at most one instance of the\n     * argument class.  This method calls\n     * <code>this.createArgument(false)</code>.</p>\n     *\n     * @return the argument object.\n     * @see #createArgument(boolean)\n     */\n    public Arg createArg()\n    {\n        return this.createArg( false );\n    }\n\n    /**\n     * Creates an argument object and adds it to our list of args.\n     * <p/>\n     * <p>Each commandline object has at most one instance of the\n     * argument class.</p>\n     *\n     * @param insertAtStart if true, the argument is inserted at the\n     *                      beginning of the list of args, otherwise it is appended.\n     */\n    public Arg createArg( boolean insertAtStart )\n    {\n        Arg argument = new Argument();\n        if ( insertAtStart )\n        {\n            arguments.insertElementAt( argument, 0 );\n        }\n        else\n        {\n            arguments.addElement( argument );\n        }\n        return argument;\n    }\n\n    /**\n     * Adds an argument object to our list of args.\n     *\n     * @return the argument object.\n     * @see #addArg(Arg,boolean)\n     */\n    public void addArg( Arg argument )\n    {\n        this.addArg( argument, false );\n    }\n\n    /**\n     * Adds an argument object to our list of args.\n     *\n     * @param insertAtStart if true, the argument is inserted at the\n     *                      beginning of the list of args, otherwise it is appended.\n     */\n    public void addArg( Arg argument, boolean insertAtStart )\n    {\n        if ( insertAtStart )\n        {\n            arguments.insertElementAt( argument, 0 );\n        }\n        else\n        {\n            arguments.addElement( argument );\n        }\n    }\n\n    /**\n     * Sets the executable to run.\n     */\n    public void setExecutable( String executable )\n    {\n        shell.setExecutable( executable );\n        this.executable = executable;\n    }\n\n    public String getExecutable()\n    {\n        String exec = shell.getExecutable();\n\n        if ( exec == null )\n        {\n            exec = executable;\n        }\n\n        return exec;\n    }\n\n    public void addArguments( String[] line )\n    {\n        for ( int i = 0; i < line.length; i++ )\n        {\n            createArgument().setValue( line[i] );\n        }\n    }\n\n    /**\n     * Add an environment variable\n     */\n    public void addEnvironment( String name, String value )\n    {\n        //envVars.add( name + \"=\" + value );\n        envVars.put( name, value );\n    }\n\n    /**\n     * Add system environment variables\n     */\n    public void addSystemEnvironment()\n        throws Exception\n    {\n        Properties systemEnvVars = CommandLineUtils.getSystemEnvVars();\n\n        for ( Iterator i = systemEnvVars.keySet().iterator(); i.hasNext(); )\n        {\n            String key = (String) i.next();\n            if ( !envVars.containsKey( key ) )\n            {\n                addEnvironment( key, systemEnvVars.getProperty( key ) );\n            }\n        }\n    }\n\n    /**\n     * Return the list of environment variables\n     */\n    public String[] getEnvironmentVariables()\n        throws CommandLineException\n    {\n        try\n        {\n            addSystemEnvironment();\n        }\n        catch ( Exception e )\n        {\n            throw new CommandLineException( \"Error setting up environmental variables\", e );\n        }\n        String[] environmentVars = new String[envVars.size()];\n        int i = 0;\n        for ( Iterator iterator = envVars.keySet().iterator(); iterator.hasNext(); )\n        {\n            String name = (String) iterator.next();\n            String value = (String) envVars.get( name );\n            environmentVars[i] = name + \"=\" + value;\n            i++;\n        }\n        return environmentVars;\n    }\n\n    /**\n     * Returns the executable and all defined arguments.\n     */\n    public String[] getCommandline()\n    {\n        final String[] args = getArguments();\n        String executable = getExecutable();\n\n        if ( executable == null )\n        {\n            return args;\n        }\n        final String[] result = new String[args.length + 1];\n        result[0] = executable;\n        System.arraycopy( args, 0, result, 1, args.length );\n        return result;\n    }\n\n    /**\n     * Returns the shell, executable and all defined arguments.\n     */\n    public String[] getShellCommandline()\n    {\n        // TODO: Provided only for backward compat. with <= 1.4\n        verifyShellState();\n\n        return (String[]) getShell().getShellCommandLine( getArguments() ).toArray( new String[0] );\n    }\n\n    /**\n     * Returns all arguments defined by <code>addLine</code>,\n     * <code>addValue</code> or the argument object.\n     */\n    public String[] getArguments()\n    {\n        Vector result = new Vector( arguments.size() * 2 );\n        for ( int i = 0; i < arguments.size(); i++ )\n        {\n            Argument arg = (Argument) arguments.elementAt( i );\n            String[] s = arg.getParts();\n            if ( s != null )\n            {\n                for ( int j = 0; j < s.length; j++ )\n                {\n                    result.addElement( s[j] );\n                }\n            }\n        }\n\n        String[] res = new String[result.size()];\n        result.copyInto( res );\n        return res;\n    }\n\n    public String toString()\n    {\n        return StringUtils.join( getShellCommandline(), \" \" );\n    }\n\n    public int size()\n    {\n        return getCommandline().length;\n    }\n\n    public Object clone()\n    {\n        Commandline c = new Commandline( (Shell) shell.clone() );\n        c.executable = executable;\n        c.workingDir = workingDir;\n        c.addArguments( getArguments() );\n        return c;\n    }\n\n    /**\n     * Clear out the whole command line.\n     */\n    public void clear()\n    {\n        executable = null;\n        workingDir = null;\n        shell.setExecutable( null );\n        shell.clearArguments();\n        arguments.removeAllElements();\n    }\n\n    /**\n     * Clear out the arguments but leave the executable in place for another operation.\n     */\n    public void clearArgs()\n    {\n        arguments.removeAllElements();\n    }\n\n    /**\n     * Return a marker.\n     * <p/>\n     * <p>This marker can be used to locate a position on the\n     * commandline - to insert something for example - when all\n     * parameters have been set.</p>\n     */\n    public Marker createMarker()\n    {\n        return new Marker( arguments.size() );\n    }\n\n    /**\n     * Sets execution directory.\n     */\n    public void setWorkingDirectory( String path )\n    {\n        shell.setWorkingDirectory( path );\n        workingDir = new File( path );\n    }\n\n    /**\n     * Sets execution directory.\n     */\n    public void setWorkingDirectory( File workingDirectory )\n    {\n        shell.setWorkingDirectory( workingDirectory );\n        workingDir = workingDirectory;\n    }\n\n    public File getWorkingDirectory()\n    {\n        File workDir = shell.getWorkingDirectory();\n\n        if ( workDir == null )\n        {\n            workDir = workingDir;\n        }\n\n        return workDir;\n    }\n\n    /**\n     * Executes the command.\n     */\n    public Process execute()\n        throws CommandLineException\n    {\n        // TODO: Provided only for backward compat. with <= 1.4\n        verifyShellState();\n\n        Process process;\n\n        //addEnvironment( \"MAVEN_TEST_ENVAR\", \"MAVEN_TEST_ENVAR_VALUE\" );\n\n        String[] environment = getEnvironmentVariables();\n\n        File workingDir = shell.getWorkingDirectory();\n\n        try\n        {\n            if ( workingDir == null )\n            {\n                process = Runtime.getRuntime().exec( getShellCommandline(), environment );\n            }\n            else\n            {\n                if ( !workingDir.exists() )\n                {\n                    throw new CommandLineException( \"Working directory \\\"\" + workingDir.getPath()\n                        + \"\\\" does not exist!\" );\n                }\n                else if ( !workingDir.isDirectory() )\n                {\n                    throw new CommandLineException( \"Path \\\"\" + workingDir.getPath()\n                        + \"\\\" does not specify a directory.\" );\n                }\n\n                process = Runtime.getRuntime().exec( getShellCommandline(), environment, workingDir );\n            }\n        }\n        catch ( IOException ex )\n        {\n            throw new CommandLineException( \"Error while executing process.\", ex );\n        }\n\n        return process;\n    }\n\n    /**\n     * @deprecated Remove once backward compat with plexus-utils <= 1.4 is no longer a consideration\n     */\n    private void verifyShellState()\n    {\n        if ( shell.getWorkingDirectory() == null )\n        {\n            shell.setWorkingDirectory( workingDir );\n        }\n\n        if ( shell.getExecutable() == null )\n        {\n            shell.setExecutable( executable );\n        }\n    }\n\n    public Properties getSystemEnvVars()\n        throws Exception\n    {\n        return CommandLineUtils.getSystemEnvVars();\n    }\n\n    /**\n     * Allows to set the shell to be used in this command line.\n     *\n     * @param shell\n     * @since 1.2\n     */\n    public void setShell( Shell shell )\n    {\n        this.shell = shell;\n    }\n\n    /**\n     * Get the shell to be used in this command line.\n     *\n     * @since 1.2\n     */\n    public Shell getShell()\n    {\n        return shell;\n    }\n\n    /**\n     * @deprecated Use {@link CommandLineUtils#translateCommandline(String)} instead.\n     */\n    public static String[] translateCommandline( String toProcess )\n        throws Exception\n    {\n        return CommandLineUtils.translateCommandline( toProcess );\n    }\n\n    /**\n     * @deprecated Use {@link CommandLineUtils#quote(String)} instead.\n     */\n    public static String quoteArgument( String argument )\n        throws CommandLineException\n    {\n        return CommandLineUtils.quote( argument );\n    }\n\n    /**\n     * @deprecated Use {@link CommandLineUtils#toString(String[])} instead.\n     */\n    public static String toString( String[] line )\n    {\n        return CommandLineUtils.toString( line );\n    }\n\n    public static class Argument\n        implements Arg\n    {\n        private String[] parts;\n\n        /* (non-Javadoc)\n         * @see org.codehaus.plexus.util.cli.Argumnt#setValue(java.lang.String)\n         */\n        public void setValue( String value )\n        {\n            if ( value != null )\n            {\n                parts = new String[] { value };\n            }\n        }\n\n        /* (non-Javadoc)\n         * @see org.codehaus.plexus.util.cli.Argumnt#setLine(java.lang.String)\n         */\n        public void setLine( String line )\n        {\n            if ( line == null )\n            {\n                return;\n            }\n            try\n            {\n                parts = CommandLineUtils.translateCommandline( line );\n            }\n            catch ( Exception e )\n            {\n                System.err.println( \"Error translating Commandline.\" );\n            }\n        }\n\n        /* (non-Javadoc)\n         * @see org.codehaus.plexus.util.cli.Argumnt#setFile(java.io.File)\n         */\n        public void setFile( File value )\n        {\n            parts = new String[] { value.getAbsolutePath() };\n        }\n\n        /* (non-Javadoc)\n         * @see org.codehaus.plexus.util.cli.Argumnt#getParts()\n         */\n        public String[] getParts()\n        {\n            return parts;\n        }\n    }\n}\n",
        "human_patch_code": "package org.codehaus.plexus.util.cli;\n\n/*\n * Copyright The Codehaus Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/***************************************************************************************************\n * CruiseControl, a Continuous Integration Toolkit Copyright (c) 2001-2003, ThoughtWorks, Inc. 651 W\n * Washington Ave. Suite 500 Chicago, IL 60661 USA All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted\n * provided that the following conditions are met: + Redistributions of source code must retain the\n * above copyright notice, this list of conditions and the following disclaimer. + Redistributions\n * in binary form must reproduce the above copyright notice, this list of conditions and the\n * following disclaimer in the documentation and/or other materials provided with the distribution. +\n * Neither the name of ThoughtWorks, Inc., CruiseControl, nor the names of its contributors may be\n * used to endorse or promote products derived from this software without specific prior written\n * permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n **************************************************************************************************/\n\n/*\n * ====================================================================\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ====================================================================\n */\n\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.shell.BourneShell;\nimport org.codehaus.plexus.util.cli.shell.CmdShell;\nimport org.codehaus.plexus.util.cli.shell.CommandShell;\nimport org.codehaus.plexus.util.cli.shell.Shell;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Vector;\n\n/**\n * <p/>\n * Commandline objects help handling command lines specifying processes to\n * execute.\n * </p>\n * <p/>\n * The class can be used to define a command line as nested elements or as a\n * helper to define a command line by an application.\n * </p>\n * <p/>\n * <code>\n * &lt;someelement&gt;<br>\n * &nbsp;&nbsp;&lt;acommandline executable=\"/executable/to/run\"&gt;<br>\n * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument value=\"argument 1\" /&gt;<br>\n * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument line=\"argument_1 argument_2 argument_3\" /&gt;<br>\n * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument value=\"argument 4\" /&gt;<br>\n * &nbsp;&nbsp;&lt;/acommandline&gt;<br>\n * &lt;/someelement&gt;<br>\n * </code>\n * </p>\n * <p/>\n * The element <code>someelement</code> must provide a method\n * <code>createAcommandline</code> which returns an instance of this class.\n * </p>\n *\n * @author thomas.haas@softwired-inc.com\n * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n */\npublic class Commandline\n    implements Cloneable\n{\n    /**\n     * @deprecated Use {@link org.codehaus.plexus.util.Os} class instead.\n     */\n    protected static final String OS_NAME = \"os.name\";\n\n    /**\n     * @deprecated Use {@link org.codehaus.plexus.util.Os} class instead.\n     */\n    protected static final String WINDOWS = \"Windows\";\n\n    protected Vector arguments = new Vector();\n\n    //protected Vector envVars = new Vector();\n    // synchronized added to preserve synchronize of Vector class\n    protected Map envVars = Collections.synchronizedMap( new LinkedHashMap() );\n\n    private long pid = -1;\n\n    private Shell shell;\n\n    /**\n     * @deprecated Use {@link Commandline#setExecutable(String)} instead.\n     */\n    protected String executable;\n\n    /**\n     * @deprecated Use {@link Commandline#setWorkingDirectory(File)} or\n     * {@link Commandline#setWorkingDirectory(String)} instead.\n     */\n    private File workingDir;\n\n    /**\n     * Create a new command line object.\n     * Shell is autodetected from operating system\n     *\n     * Shell usage is only desirable when generating code for remote execution.\n     *\n     * @param toProcess\n     */\n    public Commandline( String toProcess, Shell shell )\n    {\n        this.shell = shell;\n\n        String[] tmp = new String[0];\n        try\n        {\n            tmp = CommandLineUtils.translateCommandline( toProcess );\n        }\n        catch ( Exception e )\n        {\n            System.err.println( \"Error translating Commandline.\" );\n        }\n        if ( ( tmp != null ) && ( tmp.length > 0 ) )\n        {\n            setExecutable( tmp[0] );\n            for ( int i = 1; i < tmp.length; i++ )\n            {\n                createArgument().setValue( tmp[i] );\n            }\n        }\n    }\n\n    /**\n     * Create a new command line object.\n     * Shell is autodetected from operating system\n     *\n     * Shell usage is only desirable when generating code for remote execution.\n     */\n    public Commandline( Shell shell )\n    {\n        this.shell = shell;\n    }\n\n    /**\n     * Create a new command line object, given a command following POSIX sh quoting rules\n     *\n     * @param toProcess\n     */\n    public Commandline( String toProcess )\n    {\n        setDefaultShell();\n        String[] tmp = new String[0];\n        try\n        {\n            tmp = CommandLineUtils.translateCommandline( toProcess );\n        }\n        catch ( Exception e )\n        {\n            System.err.println( \"Error translating Commandline.\" );\n        }\n        if ( ( tmp != null ) && ( tmp.length > 0 ) )\n        {\n            setExecutable( tmp[0] );\n            for ( int i = 1; i < tmp.length; i++ )\n            {\n                createArgument().setValue( tmp[i] );\n            }\n        }\n    }\n\n    /**\n     * Create a new command line object.\n     */\n    public Commandline()\n    {\n        setDefaultShell();\n    }\n\n    public long getPid()\n    {\n        if ( pid == -1 )\n        {\n            pid = Long.parseLong( String.valueOf( System.currentTimeMillis() ) );\n        }\n\n        return pid;\n    }\n\n    public void setPid( long pid )\n    {\n        this.pid = pid;\n    }\n\n    /**\n     * Class to keep track of the position of an Argument.\n     */\n    // <p>This class is there to support the srcfile and targetfile\n    // elements of &lt;execon&gt; and &lt;transform&gt; - don't know\n    // whether there might be additional use cases.</p> --SB\n    public class Marker\n    {\n\n        private int position;\n\n        private int realPos = -1;\n\n        Marker( int position )\n        {\n            this.position = position;\n        }\n\n        /**\n         * Return the number of arguments that preceeded this marker.\n         * <p/>\n         * <p>The name of the executable - if set - is counted as the\n         * very first argument.</p>\n         */\n        public int getPosition()\n        {\n            if ( realPos == -1 )\n            {\n                realPos = ( getLiteralExecutable() == null ? 0 : 1 );\n                for ( int i = 0; i < position; i++ )\n                {\n                    Arg arg = (Arg) arguments.elementAt( i );\n                    realPos += arg.getParts().length;\n                }\n            }\n            return realPos;\n        }\n    }\n\n    /**\n     * <p>Sets the shell or command-line interpretor for the detected operating system,\n     * and the shell arguments.</p>\n     */\n    private void setDefaultShell()\n    {\n        //If this is windows set the shell to command.com or cmd.exe with correct arguments.\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            if ( Os.isFamily( Os.FAMILY_WIN9X ) )\n            {\n                setShell( new CommandShell() );\n            }\n            else\n            {\n                setShell( new CmdShell() );\n            }\n        }\n        else\n        {\n            setShell( new BourneShell() );\n        }\n    }\n\n    /**\n     * Creates an argument object.\n     * <p/>\n     * <p>Each commandline object has at most one instance of the\n     * argument class.  This method calls\n     * <code>this.createArgument(false)</code>.</p>\n     *\n     * @return the argument object.\n     * @see #createArgument(boolean)\n     * @deprecated Use {@link Commandline#createArg()} instead\n     */\n    public Argument createArgument()\n    {\n        return this.createArgument( false );\n    }\n\n    /**\n     * Creates an argument object and adds it to our list of args.\n     * <p/>\n     * <p>Each commandline object has at most one instance of the\n     * argument class.</p>\n     *\n     * @param insertAtStart if true, the argument is inserted at the\n     *                      beginning of the list of args, otherwise it is appended.\n     * @deprecated Use {@link Commandline#createArg(boolean)} instead\n     */\n    public Argument createArgument( boolean insertAtStart )\n    {\n        Argument argument = new Argument();\n        if ( insertAtStart )\n        {\n            arguments.insertElementAt( argument, 0 );\n        }\n        else\n        {\n            arguments.addElement( argument );\n        }\n        return argument;\n    }\n\n    /**\n     * Creates an argument object.\n     * <p/>\n     * <p>Each commandline object has at most one instance of the\n     * argument class.  This method calls\n     * <code>this.createArgument(false)</code>.</p>\n     *\n     * @return the argument object.\n     * @see #createArgument(boolean)\n     */\n    public Arg createArg()\n    {\n        return this.createArg( false );\n    }\n\n    /**\n     * Creates an argument object and adds it to our list of args.\n     * <p/>\n     * <p>Each commandline object has at most one instance of the\n     * argument class.</p>\n     *\n     * @param insertAtStart if true, the argument is inserted at the\n     *                      beginning of the list of args, otherwise it is appended.\n     */\n    public Arg createArg( boolean insertAtStart )\n    {\n        Arg argument = new Argument();\n        if ( insertAtStart )\n        {\n            arguments.insertElementAt( argument, 0 );\n        }\n        else\n        {\n            arguments.addElement( argument );\n        }\n        return argument;\n    }\n\n    /**\n     * Adds an argument object to our list of args.\n     *\n     * @return the argument object.\n     * @see #addArg(Arg,boolean)\n     */\n    public void addArg( Arg argument )\n    {\n        this.addArg( argument, false );\n    }\n\n    /**\n     * Adds an argument object to our list of args.\n     *\n     * @param insertAtStart if true, the argument is inserted at the\n     *                      beginning of the list of args, otherwise it is appended.\n     */\n    public void addArg( Arg argument, boolean insertAtStart )\n    {\n        if ( insertAtStart )\n        {\n            arguments.insertElementAt( argument, 0 );\n        }\n        else\n        {\n            arguments.addElement( argument );\n        }\n    }\n\n    /**\n     * Sets the executable to run.\n     */\n    public void setExecutable( String executable )\n    {\n        shell.setExecutable( executable );\n        this.executable = executable;\n    }\n\n    /**\n     * @return Executable to be run, as a literal string (no shell quoting/munging)\n     */\n    public String getLiteralExecutable()\n    {\n        return executable;\n    }\n\n    /**\n     * Return an executable name, quoted for shell use.\n     *\n     * Shell usage is only desirable when generating code for remote execution.\n     *\n     * @return Executable to be run, quoted for shell interpretation\n     */\n    public String getExecutable()\n    {\n        String exec = shell.getExecutable();\n\n        if ( exec == null )\n        {\n            exec = executable;\n        }\n\n        return exec;\n    }\n\n    public void addArguments( String[] line )\n    {\n        for ( int i = 0; i < line.length; i++ )\n        {\n            createArgument().setValue( line[i] );\n        }\n    }\n\n    /**\n     * Add an environment variable\n     */\n    public void addEnvironment( String name, String value )\n    {\n        //envVars.add( name + \"=\" + value );\n        envVars.put( name, value );\n    }\n\n    /**\n     * Add system environment variables\n     */\n    public void addSystemEnvironment()\n        throws Exception\n    {\n        Properties systemEnvVars = CommandLineUtils.getSystemEnvVars();\n\n        for ( Iterator i = systemEnvVars.keySet().iterator(); i.hasNext(); )\n        {\n            String key = (String) i.next();\n            if ( !envVars.containsKey( key ) )\n            {\n                addEnvironment( key, systemEnvVars.getProperty( key ) );\n            }\n        }\n    }\n\n    /**\n     * Return the list of environment variables\n     */\n    public String[] getEnvironmentVariables()\n        throws CommandLineException\n    {\n        try\n        {\n            addSystemEnvironment();\n        }\n        catch ( Exception e )\n        {\n            throw new CommandLineException( \"Error setting up environmental variables\", e );\n        }\n        String[] environmentVars = new String[envVars.size()];\n        int i = 0;\n        for ( Iterator iterator = envVars.keySet().iterator(); iterator.hasNext(); )\n        {\n            String name = (String) iterator.next();\n            String value = (String) envVars.get( name );\n            environmentVars[i] = name + \"=\" + value;\n            i++;\n        }\n        return environmentVars;\n    }\n\n    /**\n     * Returns the executable and all defined arguments.\n     */\n    public String[] getCommandline()\n    {\n        final String[] args = getArguments();\n        String executable = getLiteralExecutable();\n\n        if ( executable == null )\n        {\n            return args;\n        }\n        final String[] result = new String[args.length + 1];\n        result[0] = executable;\n        System.arraycopy( args, 0, result, 1, args.length );\n        return result;\n    }\n\n    /**\n     * Returns the shell, executable and all defined arguments.\n     *\n     * Shell usage is only desirable when generating code for remote execution.\n     */\n    public String[] getShellCommandline()\n    {\n        // TODO: Provided only for backward compat. with <= 1.4\n        verifyShellState();\n\n        return (String[]) getShell().getShellCommandLine( getArguments() ).toArray( new String[0] );\n    }\n\n    /**\n     * Returns all arguments defined by <code>addLine</code>,\n     * <code>addValue</code> or the argument object.\n     */\n    public String[] getArguments()\n    {\n        Vector result = new Vector( arguments.size() * 2 );\n        for ( int i = 0; i < arguments.size(); i++ )\n        {\n            Argument arg = (Argument) arguments.elementAt( i );\n            String[] s = arg.getParts();\n            if ( s != null )\n            {\n                for ( int j = 0; j < s.length; j++ )\n                {\n                    result.addElement( s[j] );\n                }\n            }\n        }\n\n        String[] res = new String[result.size()];\n        result.copyInto( res );\n        return res;\n    }\n\n    public String toString()\n    {\n        return StringUtils.join( getShellCommandline(), \" \" );\n    }\n\n    public int size()\n    {\n        return getCommandline().length;\n    }\n\n    public Object clone()\n    {\n        Commandline c = new Commandline( (Shell) shell.clone() );\n        c.executable = executable;\n        c.workingDir = workingDir;\n        c.addArguments( getArguments() );\n        return c;\n    }\n\n    /**\n     * Clear out the whole command line.\n     */\n    public void clear()\n    {\n        executable = null;\n        workingDir = null;\n        shell.setExecutable( null );\n        shell.clearArguments();\n        arguments.removeAllElements();\n    }\n\n    /**\n     * Clear out the arguments but leave the executable in place for another operation.\n     */\n    public void clearArgs()\n    {\n        arguments.removeAllElements();\n    }\n\n    /**\n     * Return a marker.\n     * <p/>\n     * <p>This marker can be used to locate a position on the\n     * commandline - to insert something for example - when all\n     * parameters have been set.</p>\n     */\n    public Marker createMarker()\n    {\n        return new Marker( arguments.size() );\n    }\n\n    /**\n     * Sets execution directory.\n     */\n    public void setWorkingDirectory( String path )\n    {\n        shell.setWorkingDirectory( path );\n        workingDir = new File( path );\n    }\n\n    /**\n     * Sets execution directory.\n     */\n    public void setWorkingDirectory( File workingDirectory )\n    {\n        shell.setWorkingDirectory( workingDirectory );\n        workingDir = workingDirectory;\n    }\n\n    public File getWorkingDirectory()\n    {\n        File workDir = shell.getWorkingDirectory();\n\n        if ( workDir == null )\n        {\n            workDir = workingDir;\n        }\n\n        return workDir;\n    }\n\n    /**\n     * Executes the command.\n     */\n    public Process execute()\n        throws CommandLineException\n    {\n        // TODO: Provided only for backward compat. with <= 1.4\n        verifyShellState();\n\n        Process process;\n\n        //addEnvironment( \"MAVEN_TEST_ENVAR\", \"MAVEN_TEST_ENVAR_VALUE\" );\n\n        String[] environment = getEnvironmentVariables();\n\n        File workingDir = shell.getWorkingDirectory();\n\n        try\n        {\n            if ( workingDir == null )\n            {\n                process = Runtime.getRuntime().exec( getCommandline(), environment, workingDir );\n            }\n            else\n            {\n                if ( !workingDir.exists() )\n                {\n                    throw new CommandLineException( \"Working directory \\\"\" + workingDir.getPath()\n                        + \"\\\" does not exist!\" );\n                }\n                else if ( !workingDir.isDirectory() )\n                {\n                    throw new CommandLineException( \"Path \\\"\" + workingDir.getPath()\n                        + \"\\\" does not specify a directory.\" );\n                }\n\n                process = Runtime.getRuntime().exec( getCommandline(), environment, workingDir );\n            }\n        }\n        catch ( IOException ex )\n        {\n            throw new CommandLineException( \"Error while executing process.\", ex );\n        }\n\n        return process;\n    }\n\n    /**\n     * @deprecated Remove once backward compat with plexus-utils <= 1.4 is no longer a consideration\n     */\n    private void verifyShellState()\n    {\n        if ( shell.getWorkingDirectory() == null )\n        {\n            shell.setWorkingDirectory( workingDir );\n        }\n\n        if ( shell.getOriginalExecutable() == null )\n        {\n            shell.setExecutable( executable );\n        }\n    }\n\n    public Properties getSystemEnvVars()\n        throws Exception\n    {\n        return CommandLineUtils.getSystemEnvVars();\n    }\n\n    /**\n     * Allows to set the shell to be used in this command line.\n     *\n     * Shell usage is only desirable when generating code for remote execution.\n     *\n     * @param shell\n     * @since 1.2\n     */\n    public void setShell( Shell shell )\n    {\n        this.shell = shell;\n    }\n\n    /**\n     * Get the shell to be used in this command line.\n     *\n     * Shell usage is only desirable when generating code for remote execution.\n     * @since 1.2\n     */\n    public Shell getShell()\n    {\n        return shell;\n    }\n\n    /**\n     * @deprecated Use {@link CommandLineUtils#translateCommandline(String)} instead.\n     */\n    public static String[] translateCommandline( String toProcess )\n        throws Exception\n    {\n        return CommandLineUtils.translateCommandline( toProcess );\n    }\n\n    /**\n     * @deprecated Use {@link CommandLineUtils#quote(String)} instead.\n     */\n    public static String quoteArgument( String argument )\n        throws CommandLineException\n    {\n        return CommandLineUtils.quote( argument );\n    }\n\n    /**\n     * @deprecated Use {@link CommandLineUtils#toString(String[])} instead.\n     */\n    public static String toString( String[] line )\n    {\n        return CommandLineUtils.toString( line );\n    }\n\n    public static class Argument\n        implements Arg\n    {\n        private String[] parts;\n\n        /* (non-Javadoc)\n         * @see org.codehaus.plexus.util.cli.Argumnt#setValue(java.lang.String)\n         */\n        public void setValue( String value )\n        {\n            if ( value != null )\n            {\n                parts = new String[] { value };\n            }\n        }\n\n        /* (non-Javadoc)\n         * @see org.codehaus.plexus.util.cli.Argumnt#setLine(java.lang.String)\n         */\n        public void setLine( String line )\n        {\n            if ( line == null )\n            {\n                return;\n            }\n            try\n            {\n                parts = CommandLineUtils.translateCommandline( line );\n            }\n            catch ( Exception e )\n            {\n                System.err.println( \"Error translating Commandline.\" );\n            }\n        }\n\n        /* (non-Javadoc)\n         * @see org.codehaus.plexus.util.cli.Argumnt#setFile(java.io.File)\n         */\n        public void setFile( File value )\n        {\n            parts = new String[] { value.getAbsolutePath() };\n        }\n\n        /* (non-Javadoc)\n         * @see org.codehaus.plexus.util.cli.Argumnt#getParts()\n         */\n        public String[] getParts()\n        {\n            return parts;\n        }\n    }\n}\n"
      },
      {
        "file_path": "src/main/java/org/codehaus/plexus/util/cli/shell/BourneShell.java",
        "file_name": "BourneShell.java",
        "vulnerable_code": "package org.codehaus.plexus.util.cli.shell;\n\n/*\n * Copyright The Codehaus Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author Jason van Zyl\n * @version $Id$\n */\npublic class BourneShell\n    extends Shell\n{\n    private static final char[] BASH_QUOTING_TRIGGER_CHARS = {\n        ' ',\n        '$',\n        ';',\n        '&',\n        '|',\n        '<',\n        '>',\n        '*',\n        '?',\n        '(',\n        ')',\n        '[',\n        ']',\n        '{',\n        '}',\n        '`' };\n\n    public BourneShell()\n    {\n        this( false );\n    }\n\n    public BourneShell( boolean isLoginShell )\n    {\n        setShellCommand( \"/bin/sh\" );\n        setArgumentQuoteDelimiter( '\\'' );\n        setExecutableQuoteDelimiter( '\\\"' );\n        setSingleQuotedArgumentEscaped( true );\n        setSingleQuotedExecutableEscaped( false );\n        setQuotedExecutableEnabled( true );\n        setArgumentEscapePattern(\"'\\\\%s'\");\n\n        if ( isLoginShell )\n        {\n            addShellArg( \"-l\" );\n        }\n    }\n\n    /** {@inheritDoc} */\n    public String getExecutable()\n    {\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            return super.getExecutable();\n        }\n\n        return unifyQuotes( super.getExecutable());\n    }\n\n    public List<String> getShellArgsList()\n    {\n        List<String> shellArgs = new ArrayList<String>();\n        List<String> existingShellArgs = super.getShellArgsList();\n\n        if ( ( existingShellArgs != null ) && !existingShellArgs.isEmpty() )\n        {\n            shellArgs.addAll( existingShellArgs );\n        }\n\n        shellArgs.add( \"-c\" );\n\n        return shellArgs;\n    }\n\n    public String[] getShellArgs()\n    {\n        String[] shellArgs = super.getShellArgs();\n        if ( shellArgs == null )\n        {\n            shellArgs = new String[0];\n        }\n\n        if ( ( shellArgs.length > 0 ) && !shellArgs[shellArgs.length - 1].equals( \"-c\" ) )\n        {\n            String[] newArgs = new String[shellArgs.length + 1];\n\n            System.arraycopy( shellArgs, 0, newArgs, 0, shellArgs.length );\n            newArgs[shellArgs.length] = \"-c\";\n\n            shellArgs = newArgs;\n        }\n\n        return shellArgs;\n    }\n\n    protected String getExecutionPreamble()\n    {\n        if ( getWorkingDirectoryAsString() == null )\n        {\n            return null;\n        }\n\n        String dir = getWorkingDirectoryAsString();\n        StringBuilder sb = new StringBuilder();\n        sb.append( \"cd \" );\n\n        sb.append( unifyQuotes( dir ) );\n        sb.append( \" && \" );\n\n        return sb.toString();\n    }\n\n    protected char[] getQuotingTriggerChars()\n    {\n        return BASH_QUOTING_TRIGGER_CHARS;\n    }\n\n    /**\n     * <p>Unify quotes in a path for the Bourne Shell.</p>\n     *\n     * <pre>\n     * BourneShell.unifyQuotes(null)                       = null\n     * BourneShell.unifyQuotes(\"\")                         = (empty)\n     * BourneShell.unifyQuotes(\"/test/quotedpath'abc\")     = /test/quotedpath\\'abc\n     * BourneShell.unifyQuotes(\"/test/quoted path'abc\")    = \"/test/quoted path'abc\"\n     * BourneShell.unifyQuotes(\"/test/quotedpath\\\"abc\")    = \"/test/quotedpath\\\"abc\"\n     * BourneShell.unifyQuotes(\"/test/quoted path\\\"abc\")   = \"/test/quoted path\\\"abc\"\n     * BourneShell.unifyQuotes(\"/test/quotedpath\\\"'abc\")   = \"/test/quotedpath\\\"'abc\"\n     * BourneShell.unifyQuotes(\"/test/quoted path\\\"'abc\")  = \"/test/quoted path\\\"'abc\"\n     * </pre>\n     *\n     * @param path not null path.\n     * @return the path unified correctly for the Bourne shell.\n     */\n    protected static String unifyQuotes( String path )\n    {\n        if ( path == null )\n        {\n            return null;\n        }\n\n        if ( path.indexOf( \" \" ) == -1 && path.indexOf( \"'\" ) != -1 && path.indexOf( \"\\\"\" ) == -1 )\n        {\n            return StringUtils.escape( path );\n        }\n\n        return StringUtils.quoteAndEscape( path, '\\\"', BASH_QUOTING_TRIGGER_CHARS );\n    }\n}\n",
        "human_patch_code": "package org.codehaus.plexus.util.cli.shell;\n\n/*\n * Copyright The Codehaus Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.codehaus.plexus.util.Os;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author Jason van Zyl\n * @version $Id$\n */\npublic class BourneShell\n    extends Shell\n{\n\n    public BourneShell()\n    {\n        this(false);\n    }\n\n    public BourneShell( boolean isLoginShell )\n    {\n        setUnconditionalQuoting( true );\n        setShellCommand( \"/bin/sh\" );\n        setArgumentQuoteDelimiter( '\\'' );\n        setExecutableQuoteDelimiter( '\\'' );\n        setSingleQuotedArgumentEscaped( true );\n        setSingleQuotedExecutableEscaped( false );\n        setQuotedExecutableEnabled( true );\n        setArgumentEscapePattern(\"'\\\\%s'\");\n\n        if ( isLoginShell )\n        {\n            addShellArg( \"-l\" );\n        }\n    }\n\n    /** {@inheritDoc} */\n    public String getExecutable()\n    {\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            return super.getExecutable();\n        }\n\n        return quoteOneItem( super.getOriginalExecutable(), true );\n    }\n\n    public List<String> getShellArgsList()\n    {\n        List<String> shellArgs = new ArrayList<String>();\n        List<String> existingShellArgs = super.getShellArgsList();\n\n        if ( ( existingShellArgs != null ) && !existingShellArgs.isEmpty() )\n        {\n            shellArgs.addAll( existingShellArgs );\n        }\n\n        shellArgs.add( \"-c\" );\n\n        return shellArgs;\n    }\n\n    public String[] getShellArgs()\n    {\n        String[] shellArgs = super.getShellArgs();\n        if ( shellArgs == null )\n        {\n            shellArgs = new String[0];\n        }\n\n        if ( ( shellArgs.length > 0 ) && !shellArgs[shellArgs.length - 1].equals( \"-c\" ) )\n        {\n            String[] newArgs = new String[shellArgs.length + 1];\n\n            System.arraycopy( shellArgs, 0, newArgs, 0, shellArgs.length );\n            newArgs[shellArgs.length] = \"-c\";\n\n            shellArgs = newArgs;\n        }\n\n        return shellArgs;\n    }\n\n    protected String getExecutionPreamble()\n    {\n        if ( getWorkingDirectoryAsString() == null )\n        {\n            return null;\n        }\n\n        String dir = getWorkingDirectoryAsString();\n        StringBuilder sb = new StringBuilder();\n        sb.append( \"cd \" );\n\n        sb.append( quoteOneItem( dir, false ) );\n        sb.append( \" && \" );\n\n        return sb.toString();\n    }\n\n    /**\n     * <p>Unify quotes in a path for the Bourne Shell.</p>\n     *\n     * <pre>\n     * BourneShell.quoteOneItem(null)                       = null\n     * BourneShell.quoteOneItem(\"\")                         = ''\n     * BourneShell.quoteOneItem(\"/test/quotedpath'abc\")     = '/test/quotedpath'\"'\"'abc'\n     * BourneShell.quoteOneItem(\"/test/quoted path'abc\")    = '/test/quoted pat'\"'\"'habc'\n     * BourneShell.quoteOneItem(\"/test/quotedpath\\\"abc\")    = '/test/quotedpath\"abc'\n     * BourneShell.quoteOneItem(\"/test/quoted path\\\"abc\")   = '/test/quoted path\"abc'\n     * BourneShell.quoteOneItem(\"/test/quotedpath\\\"'abc\")   = '/test/quotedpath\"'\"'\"'abc'\n     * BourneShell.quoteOneItem(\"/test/quoted path\\\"'abc\")  = '/test/quoted path\"'\"'\"'abc'\n     * </pre>\n     *\n     * @param path not null path.\n     * @return the path unified correctly for the Bourne shell.\n     */\n    protected String quoteOneItem( String path, boolean isExecutable )\n    {\n        if ( path == null )\n        {\n            return null;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        sb.append( \"'\" );\n        sb.append( path.replace( \"'\", \"'\\\"'\\\"'\" ) );\n        sb.append( \"'\" );\n\n        return sb.toString();\n    }\n}\n"
      },
      {
        "file_path": "src/main/java/org/codehaus/plexus/util/cli/shell/Shell.java",
        "file_name": "Shell.java",
        "vulnerable_code": "package org.codehaus.plexus.util.cli.shell;\n\n/*\n * Copyright The Codehaus Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * <p>\n * Class that abstracts the Shell functionality,\n * with subclases for shells that behave particularly, like\n * <ul>\n * <li><code>command.com</code></li>\n * <li><code>cmd.exe</code></li>\n * </ul>\n * </p>\n *\n * @author <a href=\"mailto:carlos@apache.org\">Carlos Sanchez</a>\n * @since 1.2\n * @version $Id$\n */\npublic class Shell\n    implements Cloneable\n{\n    private static final char[] DEFAULT_QUOTING_TRIGGER_CHARS = { ' ' };\n\n    private String shellCommand;\n\n    private List<String> shellArgs = new ArrayList<String>();\n\n    private boolean quotedArgumentsEnabled = true;\n\n    private String executable;\n\n    private String workingDir;\n\n    private boolean quotedExecutableEnabled = true;\n\n    private boolean doubleQuotedArgumentEscaped = false;\n\n    private boolean singleQuotedArgumentEscaped = false;\n\n    private boolean doubleQuotedExecutableEscaped = false;\n\n    private boolean singleQuotedExecutableEscaped = false;\n\n    private char argQuoteDelimiter = '\\\"';\n\n    private char exeQuoteDelimiter = '\\\"';\n\n    private String argumentEscapePattern = \"\\\\%s\";\n\n    /**\n     * Set the command to execute the shell (eg. COMMAND.COM, /bin/bash,...)\n     *\n     * @param shellCommand\n     */\n    public void setShellCommand( String shellCommand )\n    {\n        this.shellCommand = shellCommand;\n    }\n\n    /**\n     * Get the command to execute the shell\n     *\n     * @return\n     */\n    public String getShellCommand()\n    {\n        return shellCommand;\n    }\n\n    /**\n     * Set the shell arguments when calling a command line (not the executable arguments)\n     * (eg. /X /C for CMD.EXE)\n     *\n     * @param shellArgs\n     */\n    public void setShellArgs( String[] shellArgs )\n    {\n        this.shellArgs.clear();\n        this.shellArgs.addAll( Arrays.asList( shellArgs ) );\n    }\n\n    /**\n     * Get the shell arguments\n     *\n     * @return\n     */\n    public String[] getShellArgs()\n    {\n        if ( ( shellArgs == null ) || shellArgs.isEmpty() )\n        {\n            return null;\n        }\n        else\n        {\n            return (String[]) shellArgs.toArray( new String[shellArgs.size()] );\n        }\n    }\n\n    /**\n     * Get the command line for the provided executable and arguments in this shell\n     *\n     * @param executable executable that the shell has to call\n     * @param arguments  arguments for the executable, not the shell\n     * @return List with one String object with executable and arguments quoted as needed\n     */\n    public List<String> getCommandLine( String executable, String[] arguments )\n    {\n        return getRawCommandLine( executable, arguments );\n    }\n\n    protected List<String> getRawCommandLine( String executable, String[] arguments )\n    {\n        List<String> commandLine = new ArrayList<String>();\n        StringBuilder sb = new StringBuilder();\n\n        if ( executable != null )\n        {\n            String preamble = getExecutionPreamble();\n            if ( preamble != null )\n            {\n                sb.append( preamble );\n            }\n\n            if ( isQuotedExecutableEnabled() )\n            {\n                char[] escapeChars = getEscapeChars( isSingleQuotedExecutableEscaped(), isDoubleQuotedExecutableEscaped() );\n\n                sb.append( StringUtils.quoteAndEscape( getExecutable(), getExecutableQuoteDelimiter(), escapeChars, getQuotingTriggerChars(), '\\\\', false ) );\n            }\n            else\n            {\n                sb.append( getExecutable() );\n            }\n        }\n        for ( int i = 0; i < arguments.length; i++ )\n        {\n            if ( sb.length() > 0 )\n            {\n                sb.append( \" \" );\n            }\n\n            if ( isQuotedArgumentsEnabled() )\n            {\n                char[] escapeChars = getEscapeChars( isSingleQuotedArgumentEscaped(), isDoubleQuotedArgumentEscaped() );\n\n                sb.append( StringUtils.quoteAndEscape( arguments[i], getArgumentQuoteDelimiter(), escapeChars, getQuotingTriggerChars(), getArgumentEscapePattern(), false ) );\n            }\n            else\n            {\n                sb.append( arguments[i] );\n            }\n        }\n\n        commandLine.add( sb.toString() );\n\n        return commandLine;\n    }\n\n    protected char[] getQuotingTriggerChars()\n    {\n        return DEFAULT_QUOTING_TRIGGER_CHARS;\n    }\n\n    protected String getExecutionPreamble()\n    {\n        return null;\n    }\n\n    protected char[] getEscapeChars( boolean includeSingleQuote, boolean includeDoubleQuote )\n    {\n        StringBuilder buf = new StringBuilder( 2 );\n        if ( includeSingleQuote )\n        {\n            buf.append( '\\'' );\n        }\n\n        if ( includeDoubleQuote )\n        {\n            buf.append( '\\\"' );\n        }\n\n        char[] result = new char[buf.length()];\n        buf.getChars( 0, buf.length(), result, 0 );\n\n        return result;\n    }\n\n    protected boolean isDoubleQuotedArgumentEscaped()\n    {\n        return doubleQuotedArgumentEscaped;\n    }\n\n    protected boolean isSingleQuotedArgumentEscaped()\n    {\n        return singleQuotedArgumentEscaped;\n    }\n\n    protected boolean isDoubleQuotedExecutableEscaped()\n    {\n        return doubleQuotedExecutableEscaped;\n    }\n\n    protected boolean isSingleQuotedExecutableEscaped()\n    {\n        return singleQuotedExecutableEscaped;\n    }\n\n    protected void setArgumentQuoteDelimiter( char argQuoteDelimiter )\n    {\n        this.argQuoteDelimiter = argQuoteDelimiter;\n    }\n\n    protected char getArgumentQuoteDelimiter()\n    {\n        return argQuoteDelimiter;\n    }\n\n    protected void setExecutableQuoteDelimiter( char exeQuoteDelimiter )\n    {\n        this.exeQuoteDelimiter = exeQuoteDelimiter;\n    }\n\n    protected char getExecutableQuoteDelimiter()\n    {\n        return exeQuoteDelimiter;\n    }\n\n    protected void setArgumentEscapePattern(String argumentEscapePattern)\n    {\n        this.argumentEscapePattern = argumentEscapePattern;\n    }\n\n    protected String getArgumentEscapePattern() {\n        return argumentEscapePattern;\n    }\n\n    /**\n     * Get the full command line to execute, including shell command, shell arguments,\n     * executable and executable arguments\n     *\n     * @param arguments  arguments for the executable, not the shell\n     * @return List of String objects, whose array version is suitable to be used as argument\n     *         of Runtime.getRuntime().exec()\n     */\n    public List<String> getShellCommandLine( String[] arguments )\n    {\n\n        List<String> commandLine = new ArrayList<String>();\n\n        if ( getShellCommand() != null )\n        {\n            commandLine.add( getShellCommand() );\n        }\n\n        if ( getShellArgs() != null )\n        {\n            commandLine.addAll( getShellArgsList() );\n        }\n\n        commandLine.addAll( getCommandLine( getExecutable(), arguments ) );\n\n        return commandLine;\n\n    }\n\n    public List<String> getShellArgsList()\n    {\n        return shellArgs;\n    }\n\n    public void addShellArg( String arg )\n    {\n        shellArgs.add( arg );\n    }\n\n    public void setQuotedArgumentsEnabled( boolean quotedArgumentsEnabled )\n    {\n        this.quotedArgumentsEnabled = quotedArgumentsEnabled;\n    }\n\n    public boolean isQuotedArgumentsEnabled()\n    {\n        return quotedArgumentsEnabled;\n    }\n\n    public void setQuotedExecutableEnabled( boolean quotedExecutableEnabled )\n    {\n        this.quotedExecutableEnabled = quotedExecutableEnabled;\n    }\n\n    public boolean isQuotedExecutableEnabled()\n    {\n        return quotedExecutableEnabled;\n    }\n\n    /**\n     * Sets the executable to run.\n     */\n    public void setExecutable( String executable )\n    {\n        if ( ( executable == null ) || ( executable.length() == 0 ) )\n        {\n            return;\n        }\n        this.executable = executable.replace( '/', File.separatorChar ).replace( '\\\\', File.separatorChar );\n    }\n\n    public String getExecutable()\n    {\n        return executable;\n    }\n\n    /**\n     * Sets execution directory.\n     */\n    public void setWorkingDirectory( String path )\n    {\n        if ( path != null )\n        {\n            workingDir = path;\n        }\n    }\n\n    /**\n     * Sets execution directory.\n     */\n    public void setWorkingDirectory( File workingDir )\n    {\n        if ( workingDir != null )\n        {\n            this.workingDir = workingDir.getAbsolutePath();\n        }\n    }\n\n    public File getWorkingDirectory()\n    {\n        return workingDir == null ? null : new File( workingDir );\n    }\n\n    public String getWorkingDirectoryAsString()\n    {\n        return workingDir;\n    }\n\n    public void clearArguments()\n    {\n        shellArgs.clear();\n    }\n\n    public Object clone()\n    {\n        Shell shell = new Shell();\n        shell.setExecutable( getExecutable() );\n        shell.setWorkingDirectory( getWorkingDirectory() );\n        shell.setShellArgs( getShellArgs() );\n        return shell;\n    }\n\n    public String getOriginalExecutable()\n    {\n        return executable;\n    }\n\n    public List<String> getOriginalCommandLine( String executable, String[] arguments )\n    {\n        return getRawCommandLine( executable, arguments );\n    }\n\n    protected void setDoubleQuotedArgumentEscaped( boolean doubleQuotedArgumentEscaped )\n    {\n        this.doubleQuotedArgumentEscaped = doubleQuotedArgumentEscaped;\n    }\n\n    protected void setDoubleQuotedExecutableEscaped( boolean doubleQuotedExecutableEscaped )\n    {\n        this.doubleQuotedExecutableEscaped = doubleQuotedExecutableEscaped;\n    }\n\n    protected void setSingleQuotedArgumentEscaped( boolean singleQuotedArgumentEscaped )\n    {\n        this.singleQuotedArgumentEscaped = singleQuotedArgumentEscaped;\n    }\n\n    protected void setSingleQuotedExecutableEscaped( boolean singleQuotedExecutableEscaped )\n    {\n        this.singleQuotedExecutableEscaped = singleQuotedExecutableEscaped;\n    }\n}\n",
        "human_patch_code": "package org.codehaus.plexus.util.cli.shell;\n\n/*\n * Copyright The Codehaus Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * <p>\n * Class that abstracts the Shell functionality,\n * with subclases for shells that behave particularly, like\n * <ul>\n * <li><code>command.com</code></li>\n * <li><code>cmd.exe</code></li>\n * </ul>\n * </p>\n *\n * @author <a href=\"mailto:carlos@apache.org\">Carlos Sanchez</a>\n * @since 1.2\n * @version $Id$\n */\npublic class Shell\n    implements Cloneable\n{\n    private static final char[] DEFAULT_QUOTING_TRIGGER_CHARS = { ' ' };\n\n    private String shellCommand;\n\n    private List<String> shellArgs = new ArrayList<String>();\n\n    private boolean quotedArgumentsEnabled = true;\n\n    private boolean unconditionallyQuote = false;\n\n    private String executable;\n\n    private String workingDir;\n\n    private boolean quotedExecutableEnabled = true;\n\n    private boolean doubleQuotedArgumentEscaped = false;\n\n    private boolean singleQuotedArgumentEscaped = false;\n\n    private boolean doubleQuotedExecutableEscaped = false;\n\n    private boolean singleQuotedExecutableEscaped = false;\n\n    private char argQuoteDelimiter = '\\\"';\n\n    private char exeQuoteDelimiter = '\\\"';\n\n    private String argumentEscapePattern = \"\\\\%s\";\n\n    /**\n     * Toggle unconditional quoting\n     *\n     * @param unconditionallyQuote\n     */\n    public void setUnconditionalQuoting(boolean unconditionallyQuote)\n    {\n        this.unconditionallyQuote = unconditionallyQuote;\n    }\n\n    /**\n     * Set the command to execute the shell (eg. COMMAND.COM, /bin/bash,...)\n     *\n     * @param shellCommand\n     */\n    public void setShellCommand( String shellCommand )\n    {\n        this.shellCommand = shellCommand;\n    }\n\n    /**\n     * Get the command to execute the shell\n     *\n     * @return\n     */\n    public String getShellCommand()\n    {\n        return shellCommand;\n    }\n\n    /**\n     * Set the shell arguments when calling a command line (not the executable arguments)\n     * (eg. /X /C for CMD.EXE)\n     *\n     * @param shellArgs\n     */\n    public void setShellArgs( String[] shellArgs )\n    {\n        this.shellArgs.clear();\n        this.shellArgs.addAll( Arrays.asList( shellArgs ) );\n    }\n\n    /**\n     * Get the shell arguments\n     *\n     * @return\n     */\n    public String[] getShellArgs()\n    {\n        if ( ( shellArgs == null ) || shellArgs.isEmpty() )\n        {\n            return null;\n        }\n        else\n        {\n            return (String[]) shellArgs.toArray( new String[shellArgs.size()] );\n        }\n    }\n\n    /**\n     * Get the command line for the provided executable and arguments in this shell\n     *\n     * @param executable executable that the shell has to call\n     * @param arguments  arguments for the executable, not the shell\n     * @return List with one String object with executable and arguments quoted as needed\n     */\n    public List<String> getCommandLine( String executable, String[] arguments )\n    {\n        return getRawCommandLine( executable, arguments );\n    }\n\n    protected String quoteOneItem(String inputString, boolean isExecutable)\n    {\n        char[] escapeChars = getEscapeChars( isSingleQuotedExecutableEscaped(), isDoubleQuotedExecutableEscaped() );\n        return StringUtils.quoteAndEscape(\n            inputString,\n            isExecutable ? getExecutableQuoteDelimiter() : getArgumentQuoteDelimiter(),\n            escapeChars,\n            getQuotingTriggerChars(),\n            '\\\\',\n            unconditionallyQuote\n        );\n    }\n\n    protected List<String> getRawCommandLine( String executable, String[] arguments )\n    {\n        List<String> commandLine = new ArrayList<String>();\n        StringBuilder sb = new StringBuilder();\n\n        if ( executable != null )\n        {\n            String preamble = getExecutionPreamble();\n            if ( preamble != null )\n            {\n                sb.append( preamble );\n            }\n\n            if ( isQuotedExecutableEnabled() )\n            {\n                sb.append( quoteOneItem( getOriginalExecutable(), true ) );\n            }\n            else\n            {\n                sb.append( getExecutable() );\n            }\n        }\n        for ( int i = 0; i < arguments.length; i++ )\n        {\n            if ( sb.length() > 0 )\n            {\n                sb.append( \" \" );\n            }\n\n            if ( isQuotedArgumentsEnabled() )\n            {\n                sb.append( quoteOneItem( arguments[i], false ) );\n            }\n            else\n            {\n                sb.append( arguments[i] );\n            }\n        }\n\n        commandLine.add( sb.toString() );\n\n        return commandLine;\n    }\n\n    protected char[] getQuotingTriggerChars()\n    {\n        return DEFAULT_QUOTING_TRIGGER_CHARS;\n    }\n\n    protected String getExecutionPreamble()\n    {\n        return null;\n    }\n\n    protected char[] getEscapeChars( boolean includeSingleQuote, boolean includeDoubleQuote )\n    {\n        StringBuilder buf = new StringBuilder( 2 );\n        if ( includeSingleQuote )\n        {\n            buf.append( '\\'' );\n        }\n\n        if ( includeDoubleQuote )\n        {\n            buf.append( '\\\"' );\n        }\n\n        char[] result = new char[buf.length()];\n        buf.getChars( 0, buf.length(), result, 0 );\n\n        return result;\n    }\n\n    protected boolean isDoubleQuotedArgumentEscaped()\n    {\n        return doubleQuotedArgumentEscaped;\n    }\n\n    protected boolean isSingleQuotedArgumentEscaped()\n    {\n        return singleQuotedArgumentEscaped;\n    }\n\n    protected boolean isDoubleQuotedExecutableEscaped()\n    {\n        return doubleQuotedExecutableEscaped;\n    }\n\n    protected boolean isSingleQuotedExecutableEscaped()\n    {\n        return singleQuotedExecutableEscaped;\n    }\n\n    protected void setArgumentQuoteDelimiter( char argQuoteDelimiter )\n    {\n        this.argQuoteDelimiter = argQuoteDelimiter;\n    }\n\n    protected char getArgumentQuoteDelimiter()\n    {\n        return argQuoteDelimiter;\n    }\n\n    protected void setExecutableQuoteDelimiter( char exeQuoteDelimiter )\n    {\n        this.exeQuoteDelimiter = exeQuoteDelimiter;\n    }\n\n    protected char getExecutableQuoteDelimiter()\n    {\n        return exeQuoteDelimiter;\n    }\n\n    protected void setArgumentEscapePattern(String argumentEscapePattern)\n    {\n        this.argumentEscapePattern = argumentEscapePattern;\n    }\n\n    protected String getArgumentEscapePattern() {\n        return argumentEscapePattern;\n    }\n\n    /**\n     * Get the full command line to execute, including shell command, shell arguments,\n     * executable and executable arguments\n     *\n     * @param arguments  arguments for the executable, not the shell\n     * @return List of String objects, whose array version is suitable to be used as argument\n     *         of Runtime.getRuntime().exec()\n     */\n    public List<String> getShellCommandLine( String[] arguments )\n    {\n\n        List<String> commandLine = new ArrayList<String>();\n\n        if ( getShellCommand() != null )\n        {\n            commandLine.add( getShellCommand() );\n        }\n\n        if ( getShellArgs() != null )\n        {\n            commandLine.addAll( getShellArgsList() );\n        }\n\n        commandLine.addAll( getCommandLine( getOriginalExecutable(), arguments ) );\n\n        return commandLine;\n\n    }\n\n    public List<String> getShellArgsList()\n    {\n        return shellArgs;\n    }\n\n    public void addShellArg( String arg )\n    {\n        shellArgs.add( arg );\n    }\n\n    public void setQuotedArgumentsEnabled( boolean quotedArgumentsEnabled )\n    {\n        this.quotedArgumentsEnabled = quotedArgumentsEnabled;\n    }\n\n    public boolean isQuotedArgumentsEnabled()\n    {\n        return quotedArgumentsEnabled;\n    }\n\n    public void setQuotedExecutableEnabled( boolean quotedExecutableEnabled )\n    {\n        this.quotedExecutableEnabled = quotedExecutableEnabled;\n    }\n\n    public boolean isQuotedExecutableEnabled()\n    {\n        return quotedExecutableEnabled;\n    }\n\n    /**\n     * Sets the executable to run.\n     */\n    public void setExecutable( String executable )\n    {\n        if ( ( executable == null ) || ( executable.length() == 0 ) )\n        {\n            return;\n        }\n        this.executable = executable.replace( '/', File.separatorChar ).replace( '\\\\', File.separatorChar );\n    }\n\n    public String getExecutable()\n    {\n        return executable;\n    }\n\n    /**\n     * Sets execution directory.\n     */\n    public void setWorkingDirectory( String path )\n    {\n        if ( path != null )\n        {\n            workingDir = path;\n        }\n    }\n\n    /**\n     * Sets execution directory.\n     */\n    public void setWorkingDirectory( File workingDir )\n    {\n        if ( workingDir != null )\n        {\n            this.workingDir = workingDir.getAbsolutePath();\n        }\n    }\n\n    public File getWorkingDirectory()\n    {\n        return workingDir == null ? null : new File( workingDir );\n    }\n\n    public String getWorkingDirectoryAsString()\n    {\n        return workingDir;\n    }\n\n    public void clearArguments()\n    {\n        shellArgs.clear();\n    }\n\n    public Object clone()\n    {\n        Shell shell = new Shell();\n        shell.setExecutable( getExecutable() );\n        shell.setWorkingDirectory( getWorkingDirectory() );\n        shell.setShellArgs( getShellArgs() );\n        return shell;\n    }\n\n    public String getOriginalExecutable()\n    {\n        return executable;\n    }\n\n    public List<String> getOriginalCommandLine( String executable, String[] arguments )\n    {\n        return getRawCommandLine( executable, arguments );\n    }\n\n    protected void setDoubleQuotedArgumentEscaped( boolean doubleQuotedArgumentEscaped )\n    {\n        this.doubleQuotedArgumentEscaped = doubleQuotedArgumentEscaped;\n    }\n\n    protected void setDoubleQuotedExecutableEscaped( boolean doubleQuotedExecutableEscaped )\n    {\n        this.doubleQuotedExecutableEscaped = doubleQuotedExecutableEscaped;\n    }\n\n    protected void setSingleQuotedArgumentEscaped( boolean singleQuotedArgumentEscaped )\n    {\n        this.singleQuotedArgumentEscaped = singleQuotedArgumentEscaped;\n    }\n\n    protected void setSingleQuotedExecutableEscaped( boolean singleQuotedExecutableEscaped )\n    {\n        this.singleQuotedExecutableEscaped = singleQuotedExecutableEscaped;\n    }\n}\n"
      }
    ],
    "file_count": 3
  },
  "VUL4J-43": {
    "vul_id": "VUL4J-43",
    "cve_id": "CVE-2018-20227",
    "project": "eclipse_rdf4j",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install; mvn -pl util test-compile",
    "test_cmd": "mvn test -pl util -Dtest=org.eclipse.rdf4j.common.io.ZipUtilTest#testWriteEntryPathTraversing",
    "test_all_cmd": "mvn test -pl util",
    "human_patch_url": "https://github.com/eclipse/rdf4j/commit/df15a4d7a8f2789c043b27c9eafe1b30316cfa79",
    "vulnerable_files": [
      {
        "file_path": "util/src/main/java/org/eclipse/rdf4j/common/io/ZipUtil.java",
        "file_name": "ZipUtil.java",
        "vulnerable_code": "/*******************************************************************************\n * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Distribution License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/org/documents/edl-v10.php.\n *******************************************************************************/\n\npackage org.eclipse.rdf4j.common.io;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\n\n/**\n * Zip-related utilities.\n */\npublic class ZipUtil {\n\n\t/**\n\t * Magic number for ZIP files (4 bytes: <tt>0x04034b50</tt>).\n\t */\n\tprivate final static byte MAGIC_NUMBER[] = { (byte)0x50, (byte)0x4B, (byte)0x03, (byte)0x04 };\n\n\tpublic static boolean isZipStream(InputStream in)\n\t\tthrows IOException\n\t{\n\t\tin.mark(MAGIC_NUMBER.length);\n\t\tbyte[] fileHeader = IOUtil.readBytes(in, MAGIC_NUMBER.length);\n\t\tin.reset();\n\t\treturn Arrays.equals(MAGIC_NUMBER, fileHeader);\n\t}\n\n\t/**\n\t * Extract the contents of a zipfile to a directory.\n\t * \n\t * @param zipFile\n\t *        the zip file to extract\n\t * @param destDir\n\t *        the destination directory\n\t * @throws IOException\n\t *         when something untoward happens during the extraction process\n\t */\n\tpublic static void extract(File zipFile, File destDir)\n\t\tthrows IOException\n\t{\n\t\ttry (ZipFile zf = new ZipFile(zipFile)) {\n\t\t\textract(zf, destDir);\n\t\t}\n\t}\n\n\t/**\n\t * Extract the contents of a zipfile to a directory.\n\t * \n\t * @param zipFile\n\t *        the zip file to extract\n\t * @param destDir\n\t *        the destination directory\n\t * @throws IOException\n\t *         when something untowards happens during the extraction process\n\t */\n\tpublic static void extract(ZipFile zipFile, File destDir)\n\t\tthrows IOException\n\t{\n\t\tassert destDir.isDirectory();\n\n\t\tEnumeration<? extends ZipEntry> entries = zipFile.entries();\n\t\twhile (entries.hasMoreElements()) {\n\t\t\tZipEntry entry = entries.nextElement();\n\t\t\twriteEntry(zipFile, entry, destDir);\n\t\t}\n\t}\n\n\t/**\n\t * Write an entry to a zip file.\n\t * \n\t * @param zipFile\n\t *        the zip file to read from\n\t * @param entry\n\t *        the entry to process\n\t * @param destDir\n\t *        the file to write to\n\t * @throws IOException\n\t *         if the entry could not be processed\n\t */\n\tpublic static void writeEntry(ZipFile zipFile, ZipEntry entry, File destDir)\n\t\tthrows IOException\n\t{\n\t\tFile outFile = new File(destDir, entry.getName());\n\n\t\tif (entry.isDirectory()) {\n\t\t\toutFile.mkdirs();\n\t\t}\n\t\telse {\n\t\t\toutFile.getParentFile().mkdirs();\n\n\t\t\ttry (InputStream in = zipFile.getInputStream(entry)) {\n\t\t\t\tIOUtil.writeStream(in, outFile);\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "human_patch_code": "/*******************************************************************************\n * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Distribution License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/org/documents/edl-v10.php.\n *******************************************************************************/\n\npackage org.eclipse.rdf4j.common.io;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\n\n/**\n * Zip-related utilities.\n */\npublic class ZipUtil {\n\n\t/**\n\t * Magic number for ZIP files (4 bytes: <tt>0x04034b50</tt>).\n\t */\n\tprivate final static byte MAGIC_NUMBER[] = { (byte)0x50, (byte)0x4B, (byte)0x03, (byte)0x04 };\n\n\t/**\n\t * Test if an input stream is a zip input stream by checking the \"magic number\"\n\t * \n\t * @param in input stream\n\t * @return true if start of input stream matches magic number\n\t * @throws IOException \n\t */\n\tpublic static boolean isZipStream(InputStream in) throws IOException {\n\t\tin.mark(MAGIC_NUMBER.length);\n\t\tbyte[] fileHeader = IOUtil.readBytes(in, MAGIC_NUMBER.length);\n\t\tin.reset();\n\t\treturn Arrays.equals(MAGIC_NUMBER, fileHeader);\n\t}\n\n\t/**\n\t * Extract the contents of a zipfile to a directory.\n\t * \n\t * @param zipFile\n\t *        the zip file to extract\n\t * @param destDir\n\t *        the destination directory\n\t * @throws IOException\n\t *         when something untoward happens during the extraction process\n\t */\n\tpublic static void extract(File zipFile, File destDir) throws IOException {\n\t\ttry (ZipFile zf = new ZipFile(zipFile)) {\n\t\t\textract(zf, destDir);\n\t\t}\n\t}\n\n\t/**\n\t * Extract the contents of a zipfile to a directory.\n\t * \n\t * @param zipFile\n\t *        the zip file to extract\n\t * @param destDir\n\t *        the destination directory\n\t * @throws IOException\n\t *         when something untoward happens during the extraction process\n\t */\n\tpublic static void extract(ZipFile zipFile, File destDir) throws IOException {\n\t\tassert destDir.isDirectory();\n\n\t\tEnumeration<? extends ZipEntry> entries = zipFile.entries();\n\t\twhile (entries.hasMoreElements()) {\n\t\t\tZipEntry entry = entries.nextElement();\n\t\t\twriteEntry(zipFile, entry, destDir);\n\t\t}\n\t}\n\n\t/**\n\t * Write an entry to a zip file.\n\t * \n\t * @param zipFile\n\t *        the zip file to read from\n\t * @param entry\n\t *        the entry to process\n\t * @param destDir\n\t *        the file to write to\n\t * @throws IOException\n\t *         if the entry could not be processed\n\t */\n\tpublic static void writeEntry(ZipFile zipFile, ZipEntry entry, File destDir) throws IOException {\n\t\tFile outFile = new File(destDir, entry.getName());\n\n\t\tif (! outFile.getCanonicalFile().toPath().startsWith(destDir.toPath())) {\n\t\t\tthrow new IOException(\"Zip entry outside destination directory: \" + entry.getName());\n\t\t}\n\t\t\t\t\n\t\tif (entry.isDirectory()) {\n\t\t\toutFile.mkdirs();\n\t\t} else {\n\t\t\toutFile.getParentFile().mkdirs();\n\n\t\t\ttry (InputStream in = zipFile.getInputStream(entry)) {\n\t\t\t\tIOUtil.writeStream(in, outFile);\n\t\t\t}\n\t\t}\n\t}\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-44": {
    "vul_id": "VUL4J-44",
    "cve_id": "CVE-2013-5960",
    "project": "ESAPI_esapi-java-legacy",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=org.owasp.esapi.codecs.CodecImmunityTest",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/ESAPI/esapi-java-legacy/commit/b7cbc53f9cc967cf1a5a9463d8c6fef9ed6ef4f7",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/org/owasp/esapi/codecs/PercentCodec.java",
        "file_name": "PercentCodec.java",
        "vulnerable_code": "/**\n * OWASP Enterprise Security API (ESAPI)\n * \n * This file is part of the Open Web Application Security Project (OWASP)\n * Enterprise Security API (ESAPI) project. For details, please see\n * <a href=\"http://www.owasp.org/index.php/ESAPI\">http://www.owasp.org/index.php/ESAPI</a>.\n *\n * Copyright (c) 2007 - The OWASP Foundation\n * \n * The ESAPI is published by OWASP under the BSD license. You should read and accept the\n * LICENSE before you use, modify, and/or redistribute this software.\n * \n * @author Jeff Williams <a href=\"http://www.aspectsecurity.com\">Aspect Security</a>\n * @created 2007\n */\npackage org.owasp.esapi.codecs;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Set;\n\nimport org.owasp.esapi.util.CollectionsUtil;\n\n/**\n * Implementation of the Codec interface for percent encoding (aka URL encoding).\n * \n * @author Jeff Williams (jeff.williams .at. aspectsecurity.com) <a\n *         href=\"http://www.aspectsecurity.com\">Aspect Security</a>\n * @since June 1, 2007\n * @see org.owasp.esapi.Encoder\n */\npublic class PercentCodec extends Codec\n{\n\tprivate static final String ALPHA_NUMERIC_STR = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\t@SuppressWarnings(\"unused\")\n\tprivate static final String RFC3986_RESERVED_STR = \":/?#[]@!$&'()*+,;=\";\n\tprivate static final String RFC3986_NON_ALPHANUMERIC_UNRESERVED_STR = \"-._~\";\n\t\t// rfc3986 2.3: For consistency, percent-encoded octets\n\t\t// in the ranges of ALPHA (%41-%5A and %61-%7A), DIGIT\n\t\t// (%30-%39), hyphen (%2D), period (%2E), underscore\n\t\t// (%5F), or tilde (%7E) should not be created by URI\n\t\t// producers\n\tprivate static final boolean ENCODED_NON_ALPHA_NUMERIC_UNRESERVED = true;\n\tprivate static final String UNENCODED_STR = ALPHA_NUMERIC_STR +\n\t\t(ENCODED_NON_ALPHA_NUMERIC_UNRESERVED ? \"\" : RFC3986_NON_ALPHANUMERIC_UNRESERVED_STR);\n\tprivate static final Set<Character> UNENCODED_SET = CollectionsUtil.strToUnmodifiableSet(UNENCODED_STR);\n\n\t/**\n\t * Convinence method to encode a string into UTF-8. This\n\t * wraps the {@link UnsupportedEncodingException} that\n\t * {@link String#getBytes(String)} throws in a\n\t * {@link IllegalStateException} as UTF-8 support is required\n\t * by the Java spec and should never throw this exception.\n\t * @param str the string to encode\n\t * @return str encoded in UTF-8 as bytes.\n\t * @throws IllegalStateException wrapped {@link\n\t *\tUnsupportedEncodingException} if\n\t *\t{@link String.getBytes(String)} throws it.\n\t */\n\tprivate static byte[] toUtf8Bytes(String str)\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn str.getBytes(\"UTF-8\");\n\t\t}\n\t\tcatch(UnsupportedEncodingException e)\n\t\t{\n\t\t\tthrow new IllegalStateException(\"The Java spec requires UTF-8 support.\", e);\n\t\t}\n\t}\n\n\t/**\n\t * Append the two upper case hex characters for a byte.\n\t * @param sb The string buffer to append to.\n\t * @param b The byte to hexify\n\t * @return sb with the hex characters appended.\n\t */\n\t// rfc3986 2.1: For consistency, URI producers \n\t// should use uppercase hexadecimal digits for all percent-\n\t// encodings.\n\tprivate static StringBuilder appendTwoUpperHex(StringBuilder sb, int b)\n\t{\n\t\tif(b < Byte.MIN_VALUE || b > Byte.MAX_VALUE)\n\t\t\tthrow new IllegalArgumentException(\"b is not a byte (was \" + b + ')');\n\t\tb &= 0xFF;\n\t\tif(b<0x10)\n\t\t\tsb.append('0');\n\t\treturn sb.append(Integer.toHexString(b).toUpperCase());\n\t}\n\n\t/**\n\t * Encode a character for URLs\n\t * @param immune characters not to encode\n\t * @param c character to encode\n\t * @return the encoded string representing c\n\t */\n\tpublic String encodeCharacter( char[] immune, Character c )\n\t{\n\t\tString cStr = String.valueOf(c.charValue());\n\t\tbyte[] bytes;\n\t\tStringBuilder sb;\n\n\t\tif(UNENCODED_SET.contains(c))\n\t\t\treturn cStr;\n\n\t\tbytes = toUtf8Bytes(cStr);\n\t\tsb = new StringBuilder(bytes.length * 3);\n\t\tfor(byte b : bytes)\n\t\t\tappendTwoUpperHex(sb.append('%'), b);\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t * \n\t * Formats all are legal both upper/lower case:\n\t *   %hh;\n\t *   \n\t * @param input\n\t * \t\t\tencoded character using percent characters (such as URL encoding)\n\t */\n\tpublic Character decodeCharacter( PushbackString input ) {\n\t\tinput.mark();\n\t\tCharacter first = input.next();\n\t\tif ( first == null ) {\n\t\t\tinput.reset();\n\t\t\treturn null;\n\t\t}\n\n\t\t// if this is not an encoded character, return null\n\t\tif (first != '%' ) {\n\t\t\tinput.reset();\n\t\t\treturn null;\n\t\t}\n\n\t\t// Search for exactly 2 hex digits following\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor ( int i=0; i<2; i++ ) {\n\t\t\tCharacter c = input.nextHex();\n\t\t\tif ( c != null ) sb.append( c );\n\t\t}\n\t\tif ( sb.length() == 2 ) {\n\t\t\ttry {\n\t\t\t\t// parse the hex digit and create a character\n\t\t\t\tint i = Integer.parseInt(sb.toString(), 16);\n\t\t\t\tif (Character.isValidCodePoint(i)) {\n\t\t\t\t\treturn (char) i;\n\t\t\t\t}\n\t\t\t} catch( NumberFormatException ignored ) { }\n\t\t}\n\t\tinput.reset();\n\t\treturn null;\n\t}\n\n}\n",
        "human_patch_code": "/**\n * OWASP Enterprise Security API (ESAPI)\n * \n * This file is part of the Open Web Application Security Project (OWASP)\n * Enterprise Security API (ESAPI) project. For details, please see\n * <a href=\"http://www.owasp.org/index.php/ESAPI\">http://www.owasp.org/index.php/ESAPI</a>.\n *\n * Copyright (c) 2007 - The OWASP Foundation\n * \n * The ESAPI is published by OWASP under the BSD license. You should read and accept the\n * LICENSE before you use, modify, and/or redistribute this software.\n * \n * @author Jeff Williams <a href=\"http://www.aspectsecurity.com\">Aspect Security</a>\n * @created 2007\n */\npackage org.owasp.esapi.codecs;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Set;\n\nimport org.owasp.esapi.util.CollectionsUtil;\n\n/**\n * Implementation of the Codec interface for percent encoding (aka URL encoding).\n * \n * @author Jeff Williams (jeff.williams .at. aspectsecurity.com) <a\n *         href=\"http://www.aspectsecurity.com\">Aspect Security</a>\n * @since June 1, 2007\n * @see org.owasp.esapi.Encoder\n */\npublic class PercentCodec extends Codec\n{\n\tprivate static final String ALPHA_NUMERIC_STR = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\t@SuppressWarnings(\"unused\")\n\tprivate static final String RFC3986_RESERVED_STR = \":/?#[]@!$&'()*+,;=\";\n\tprivate static final String RFC3986_NON_ALPHANUMERIC_UNRESERVED_STR = \"-._~\";\n\t\t// rfc3986 2.3: For consistency, percent-encoded octets\n\t\t// in the ranges of ALPHA (%41-%5A and %61-%7A), DIGIT\n\t\t// (%30-%39), hyphen (%2D), period (%2E), underscore\n\t\t// (%5F), or tilde (%7E) should not be created by URI\n\t\t// producers\n\tprivate static final boolean ENCODED_NON_ALPHA_NUMERIC_UNRESERVED = true;\n\tprivate static final String UNENCODED_STR = ALPHA_NUMERIC_STR +\n\t\t(ENCODED_NON_ALPHA_NUMERIC_UNRESERVED ? \"\" : RFC3986_NON_ALPHANUMERIC_UNRESERVED_STR);\n\tprivate static final Set<Character> UNENCODED_SET = CollectionsUtil.strToUnmodifiableSet(UNENCODED_STR);\n\n\t/**\n\t * Convinence method to encode a string into UTF-8. This\n\t * wraps the {@link UnsupportedEncodingException} that\n\t * {@link String#getBytes(String)} throws in a\n\t * {@link IllegalStateException} as UTF-8 support is required\n\t * by the Java spec and should never throw this exception.\n\t * @param str the string to encode\n\t * @return str encoded in UTF-8 as bytes.\n\t * @throws IllegalStateException wrapped {@link\n\t *\tUnsupportedEncodingException} if\n\t *\t{@link String.getBytes(String)} throws it.\n\t */\n\tprivate static byte[] toUtf8Bytes(String str)\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn str.getBytes(\"UTF-8\");\n\t\t}\n\t\tcatch(UnsupportedEncodingException e)\n\t\t{\n\t\t\tthrow new IllegalStateException(\"The Java spec requires UTF-8 support.\", e);\n\t\t}\n\t}\n\n\t/**\n\t * Append the two upper case hex characters for a byte.\n\t * @param sb The string buffer to append to.\n\t * @param b The byte to hexify\n\t * @return sb with the hex characters appended.\n\t */\n\t// rfc3986 2.1: For consistency, URI producers \n\t// should use uppercase hexadecimal digits for all percent-\n\t// encodings.\n\tprivate static StringBuilder appendTwoUpperHex(StringBuilder sb, int b)\n\t{\n\t\tif(b < Byte.MIN_VALUE || b > Byte.MAX_VALUE)\n\t\t\tthrow new IllegalArgumentException(\"b is not a byte (was \" + b + ')');\n\t\tb &= 0xFF;\n\t\tif(b<0x10)\n\t\t\tsb.append('0');\n\t\treturn sb.append(Integer.toHexString(b).toUpperCase());\n\t}\n\n\t/**\n\t * Encode a character for URLs\n\t * @param immune Additional characters not to encode. Note this could\n     *               break URL encoding as referenced in RFC 3986. You should\n     *               especially be wary of including '%' in this list of immune\n     *               characters since it is used as the \"escape\" character for\n     *               the hex encoding and including it may result in subsequent\n     *               and/or dangerous results when decoding.\n\t * @param c character to encode\n\t * @return the encoded string representing c\n\t */\n\tpublic String encodeCharacter( char[] immune, Character c )\n\t{\n\t\tString cStr = String.valueOf(c.charValue());\n\t\tbyte[] bytes;\n\t\tStringBuilder sb;\n\n        // check for user specified immune characters\n        if ( immune != null && containsCharacter( c.charValue(), immune ) )\n            return cStr;\n\n        // check for standard characters (e.g., alphanumeric, etc.)\n\t\tif(UNENCODED_SET.contains(c))\n\t\t\treturn cStr;\n\n\t\tbytes = toUtf8Bytes(cStr);\n\t\tsb = new StringBuilder(bytes.length * 3);\n\t\tfor(byte b : bytes)\n\t\t\tappendTwoUpperHex(sb.append('%'), b);\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t * \n\t * Formats all are legal both upper/lower case:\n\t *   %hh;\n\t *   \n\t * @param input\n\t * \t\t\tencoded character using percent characters (such as URL encoding)\n\t */\n\tpublic Character decodeCharacter( PushbackString input ) {\n\t\tinput.mark();\n\t\tCharacter first = input.next();\n\t\tif ( first == null ) {\n\t\t\tinput.reset();\n\t\t\treturn null;\n\t\t}\n\n\t\t// if this is not an encoded character, return null\n\t\tif (first != '%' ) {\n\t\t\tinput.reset();\n\t\t\treturn null;\n\t\t}\n\n\t\t// Search for exactly 2 hex digits following\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor ( int i=0; i<2; i++ ) {\n\t\t\tCharacter c = input.nextHex();\n\t\t\tif ( c != null ) sb.append( c );\n\t\t}\n\t\tif ( sb.length() == 2 ) {\n\t\t\ttry {\n\t\t\t\t// parse the hex digit and create a character\n\t\t\t\tint i = Integer.parseInt(sb.toString(), 16);\n\t\t\t\tif (Character.isValidCodePoint(i)) {\n\t\t\t\t\treturn (char) i;\n\t\t\t\t}\n\t\t\t} catch( NumberFormatException ignored ) { }\n\t\t}\n\t\tinput.reset();\n\t\treturn null;\n\t}\n\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-45": {
    "vul_id": "VUL4J-45",
    "cve_id": "CVE-2018-1000854",
    "project": "esigate_esigate",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl esigate-core -Dtest=org.esigate.xml.XsltRendererTest#testSecureRendering",
    "test_all_cmd": "mvn test -pl esigate-core",
    "human_patch_url": "https://github.com/esigate/esigate/commit/30cad23a8f282600c9b045e1af09f6f8a65357b1",
    "vulnerable_files": [
      {
        "file_path": "esigate-core/src/main/java/org/esigate/xml/XsltRenderer.java",
        "file_name": "XsltRenderer.java",
        "vulnerable_code": "/* \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage org.esigate.xml;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringReader;\nimport java.io.Writer;\n\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMResult;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamSource;\n\nimport nu.validator.htmlparser.common.DoctypeExpectation;\nimport nu.validator.htmlparser.dom.Dom2Sax;\nimport nu.validator.htmlparser.dom.HtmlDocumentBuilder;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.esigate.Driver;\nimport org.esigate.HttpErrorPage;\nimport org.esigate.Renderer;\nimport org.esigate.http.HttpResponseUtils;\nimport org.esigate.impl.DriverRequest;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * Applies an XSLT transformation to the retrieved data.\n * \n * If no namespace is specified in the document to transform, it is asumed as:<br />\n * xmlns=\"http://www.w3.org/1999/xhtml\"\n * \n * @author Stanislav Bernatskyi\n * @author Francois-Xavier Bonnet\n */\npublic class XsltRenderer implements Renderer {\n    private static final TransformerFactory TRANSFORMER_FACTORY = TransformerFactory.newInstance();\n    private Transformer transformer;\n\n    /**\n     * @param template\n     *            The path to the xsl template, relative to the context root\n     * @param driver\n     *            driver\n     * @param originalRequest\n     * @throws IOException\n     *             If an error occurs while writing to the output\n     * @throws HttpErrorPage\n     */\n    public XsltRenderer(String template, Driver driver, DriverRequest originalRequest) throws IOException,\n            HttpErrorPage {\n        StringBuilder templateStringBuilder = new StringBuilder();\n        CloseableHttpResponse response = driver.render(template, originalRequest.getOriginalRequest());\n        templateStringBuilder.append(HttpResponseUtils.toString(response));\n        transformer = createTransformer(IOUtils.toInputStream(templateStringBuilder));\n    }\n\n    /**\n     * @param xsl\n     *            The xsl template to apply as a String\n     * @throws IOException\n     *             If an error occurs while writing to the output\n     */\n    public XsltRenderer(String xsl) throws IOException {\n        InputStream templateStream = IOUtils.toInputStream(xsl);\n        transformer = createTransformer(templateStream);\n    }\n\n    private static Transformer createTransformer(InputStream templateStream) throws IOException {\n        try {\n            return TRANSFORMER_FACTORY.newTransformer(new StreamSource(templateStream));\n        } catch (TransformerConfigurationException e) {\n            throw new ProcessingFailedException(\"Failed to create XSLT template\", e);\n        } finally {\n            templateStream.close();\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void render(DriverRequest httpRequest, String src, Writer out) throws IOException {\n        try {\n            HtmlDocumentBuilder htmlDocumentBuilder = new HtmlDocumentBuilder();\n            htmlDocumentBuilder.setDoctypeExpectation(DoctypeExpectation.NO_DOCTYPE_ERRORS);\n            Document document = htmlDocumentBuilder.parse(new InputSource(new StringReader(src)));\n            Source source = new DOMSource(document);\n            DOMResult result = new DOMResult();\n            transformer.transform(source, result);\n            XhtmlSerializer serializer = new XhtmlSerializer(out);\n            Dom2Sax dom2Sax = new Dom2Sax(serializer, serializer);\n            dom2Sax.parse(result.getNode());\n        } catch (TransformerException e) {\n            throw new ProcessingFailedException(\"Failed to transform source\", e);\n        } catch (SAXException e) {\n            throw new ProcessingFailedException(\"Failed serialize transformation result\", e);\n        }\n    }\n}\n",
        "human_patch_code": "/* \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage org.esigate.xml;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringReader;\nimport java.io.Writer;\n\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMResult;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.XMLConstants;\n\nimport nu.validator.htmlparser.common.DoctypeExpectation;\nimport nu.validator.htmlparser.dom.Dom2Sax;\nimport nu.validator.htmlparser.dom.HtmlDocumentBuilder;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.esigate.Driver;\nimport org.esigate.HttpErrorPage;\nimport org.esigate.Renderer;\nimport org.esigate.http.HttpResponseUtils;\nimport org.esigate.impl.DriverRequest;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n\n/**\n * Applies an XSLT transformation to the retrieved data.\n * \n * If no namespace is specified in the document to transform, it is asumed as:<br />\n * xmlns=\"http://www.w3.org/1999/xhtml\"\n * \n * @author Stanislav Bernatskyi\n * @author Francois-Xavier Bonnet\n */\npublic class XsltRenderer implements Renderer {\n    private static final TransformerFactory TRANSFORMER_FACTORY = TransformerFactory.newInstance();\n    private Transformer transformer;\n\n    /**\n     * @param template\n     *            The path to the xsl template, relative to the context root\n     * @param driver\n     *            driver\n     * @param originalRequest\n     * @throws IOException\n     *             If an error occurs while writing to the output\n     * @throws HttpErrorPage\n     */\n    public XsltRenderer(String template, Driver driver, DriverRequest originalRequest) throws IOException,\n            HttpErrorPage {\n        StringBuilder templateStringBuilder = new StringBuilder();\n        CloseableHttpResponse response = driver.render(template, originalRequest.getOriginalRequest());\n        templateStringBuilder.append(HttpResponseUtils.toString(response));\n        transformer = createTransformer(IOUtils.toInputStream(templateStringBuilder));\n    }\n\n    /**\n     * @param xsl\n     *            The xsl template to apply as a String\n     * @throws IOException\n     *             If an error occurs while writing to the output\n     */\n    public XsltRenderer(String xsl) throws IOException {\n        InputStream templateStream = IOUtils.toInputStream(xsl);\n        transformer = createTransformer(templateStream);\n    }\n\n    private static Transformer createTransformer(InputStream templateStream) throws IOException {\n        try {\n            // Ensure XSLT cannot use advanced extensions during processing.\n            TRANSFORMER_FACTORY.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            return TRANSFORMER_FACTORY.newTransformer(new StreamSource(templateStream));\n        } catch (TransformerConfigurationException e) {\n            throw new ProcessingFailedException(\"Failed to create XSLT template\", e);\n        } finally {\n            templateStream.close();\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void render(DriverRequest httpRequest, String src, Writer out) throws IOException {\n        try {\n            HtmlDocumentBuilder htmlDocumentBuilder = new HtmlDocumentBuilder();\n            htmlDocumentBuilder.setDoctypeExpectation(DoctypeExpectation.NO_DOCTYPE_ERRORS);\n            Document document = htmlDocumentBuilder.parse(new InputSource(new StringReader(src)));\n            Source source = new DOMSource(document);\n            DOMResult result = new DOMResult();\n            transformer.transform(source, result);\n            XhtmlSerializer serializer = new XhtmlSerializer(out);\n            Dom2Sax dom2Sax = new Dom2Sax(serializer, serializer);\n            dom2Sax.parse(result.getNode());\n        } catch (TransformerException e) {\n            throw new ProcessingFailedException(\"Failed to transform source\", e);\n        } catch (SAXException e) {\n            throw new ProcessingFailedException(\"Failed serialize transformation result\", e);\n        }\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-46": {
    "vul_id": "VUL4J-46",
    "cve_id": "CVE-2016-3720",
    "project": "FasterXML_jackson-dataformat-xml",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=com.fasterxml.jackson.dataformat.xml.TestCVE_2016_3720",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/FasterXML/jackson-dataformat-xml/commit/f0f19a4c924d9db9a1e2830434061c8640092cc0",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/com/fasterxml/jackson/dataformat/xml/XmlFactory.java",
        "file_name": "XmlFactory.java",
        "vulnerable_code": "package com.fasterxml.jackson.dataformat.xml;\n\nimport java.io.*;\n\nimport javax.xml.stream.*;\n\nimport org.codehaus.stax2.io.Stax2ByteArraySource;\nimport org.codehaus.stax2.io.Stax2CharArraySource;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.format.InputAccessor;\nimport com.fasterxml.jackson.core.format.MatchStrength;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\nimport com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser;\nimport com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;\nimport com.fasterxml.jackson.dataformat.xml.util.StaxUtil;\n\n/**\n* Factory used for constructing {@link FromXmlParser} and {@link ToXmlGenerator}\n* instances.\n*<p>\n* Implements {@link JsonFactory} since interface for constructing XML backed\n* parsers and generators is quite similar to dealing with JSON.\n* \n* @author Tatu Saloranta (tatu.saloranta@iki.fi)\n*/\npublic class XmlFactory extends JsonFactory\n{\n    private static final long serialVersionUID = 1; // 2.6\n\n    /**\n     * Name used to identify XML format\n     * (and returned by {@link #getFormatName()}\n     */\n    public final static String FORMAT_NAME_XML = \"XML\";\n\n    /**\n     * Bitfield (set of flags) of all parser features that are enabled\n     * by default.\n     */\n    final static int DEFAULT_XML_PARSER_FEATURE_FLAGS = FromXmlParser.Feature.collectDefaults();\n\n    /**\n     * Bitfield (set of flags) of all generator features that are enabled\n     * by default.\n     */\n    final static int DEFAULT_XML_GENERATOR_FEATURE_FLAGS = ToXmlGenerator.Feature.collectDefaults();\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected int _xmlParserFeatures;\n\n    protected int _xmlGeneratorFeatures;\n\n    // non-final for setters (why are they needed again?)\n    protected transient XMLInputFactory _xmlInputFactory;\n\n    protected transient XMLOutputFactory _xmlOutputFactory;\n\n    protected String _cfgNameForTextElement;\n    \n    /*\n    /**********************************************************\n    /* Factory construction, configuration\n    /**********************************************************\n     */\n\n    /**\n     * Default constructor used to create factory instances.\n     * Creation of a factory instance is a light-weight operation,\n     * but it is still a good idea to reuse limited number of\n     * factory instances (and quite often just a single instance):\n     * factories are used as context for storing some reused\n     * processing objects (such as symbol tables parsers use)\n     * and this reuse only works within context of a single\n     * factory instance.\n     */\n    public XmlFactory() { this(null, null, null); }\n\n    public XmlFactory(ObjectCodec oc) {\n        this(oc, null, null);\n    }\n\n    public XmlFactory(XMLInputFactory xmlIn) {\n        this(null, xmlIn, null);\n    }\n    \n    public XmlFactory(XMLInputFactory xmlIn, XMLOutputFactory xmlOut) {\n        this(null, xmlIn, xmlOut);\n    }\n    \n    public XmlFactory(ObjectCodec oc, XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n    {\n        this(oc, DEFAULT_XML_PARSER_FEATURE_FLAGS, DEFAULT_XML_GENERATOR_FEATURE_FLAGS,\n                xmlIn, xmlOut, null);\n    }\n\n    protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\n            XMLInputFactory xmlIn, XMLOutputFactory xmlOut,\n            String nameForTextElem)\n    {\n        super(oc);\n        _xmlParserFeatures = xpFeatures;\n        _xmlGeneratorFeatures = xgFeatures;\n        _cfgNameForTextElement = nameForTextElem;\n        if (xmlIn == null) {\n            xmlIn = XMLInputFactory.newInstance();\n        }\n        if (xmlOut == null) {\n            xmlOut = XMLOutputFactory.newInstance();\n        }\n        _initFactories(xmlIn, xmlOut);\n        _xmlInputFactory = xmlIn;\n        _xmlOutputFactory = xmlOut;\n    }\n\n    /**\n     * @since 2.2.1\n     */\n    protected XmlFactory(XmlFactory src, ObjectCodec oc)\n    {\n        super(src, oc);\n        _xmlParserFeatures = src._xmlParserFeatures;\n        _xmlGeneratorFeatures = src._xmlGeneratorFeatures;\n        _cfgNameForTextElement = src._cfgNameForTextElement;\n        _xmlInputFactory = src._xmlInputFactory;\n        _xmlOutputFactory = src._xmlOutputFactory;\n    }\n    \n    protected void _initFactories(XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n    {\n        // Better ensure namespaces get built properly, so:\n        xmlOut.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n        // and for parser, force coalescing as well (much simpler to use)\n        xmlIn.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);\n    }\n\n    /**\n     * Note: compared to base implementation by {@link JsonFactory},\n     * here the copy will actually share underlying XML input and\n     * output factories, as there is no way to make copies of those.\n     * \n     * @since 2.1\n     */\n    @Override\n    public XmlFactory copy() {\n        _checkInvalidCopy(XmlFactory.class);\n        return new XmlFactory(this, null);\n    }\n\n    @Override\n    public Version version() {\n        return PackageVersion.VERSION;\n    }\n\n    /*\n    /**********************************************************\n    /* Serializable overrides\n    /**********************************************************\n     */\n\n    /**\n     * Hiding place for JDK-serialization unthawed factories...\n     */\n    protected transient String _jdkXmlInFactory;\n\n    /**\n     * Hiding place for JDK-serialization unthawed factories...\n     */\n    protected transient String _jdkXmlOutFactory;\n\n    /**\n     * Method that we need to override to actually make restoration go\n     * through constructors etc.\n     */\n    @Override // since JsonFactory already implemented it\n    protected Object readResolve() {\n        if (_jdkXmlInFactory == null) {\n            throw new IllegalStateException(\"No XMLInputFactory class name read during JDK deserialization\");\n        }\n        if (_jdkXmlOutFactory == null) {\n            throw new IllegalStateException(\"No XMLOutputFactory class name read during JDK deserialization\");\n        }\n        try {\n            XMLInputFactory inf = (XMLInputFactory) Class.forName(_jdkXmlInFactory).newInstance();\n            XMLOutputFactory outf = (XMLOutputFactory) Class.forName(_jdkXmlOutFactory).newInstance();\n            return new XmlFactory(_objectCodec, _xmlParserFeatures, _xmlGeneratorFeatures,\n                    inf, outf, _cfgNameForTextElement);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalArgumentException(e);\n        } catch (InstantiationException e) {\n            throw new IllegalArgumentException(e);\n        } catch (IllegalAccessException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    /**\n     * In addition to default serialization, which mostly works, need\n     * to handle case of XML factories, hence override.\n     */\n    private void readObject(ObjectInputStream in)\n            throws IOException, ClassNotFoundException\n    {\n        in.defaultReadObject();\n        _jdkXmlInFactory = in.readUTF();\n        _jdkXmlOutFactory = in.readUTF();\n    }\n\n    /**\n     * In addition to default serialization, which mostly works, need\n     * to handle case of XML factories, hence override.\n     */\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeUTF(_xmlInputFactory.getClass().getName());\n        out.writeUTF(_xmlOutputFactory.getClass().getName());\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, XML-specific\n    /**********************************************************\n     */\n    \n    /**\n     * @since 2.1\n     */\n    public void setXMLTextElementName(String name) {\n        _cfgNameForTextElement = name;\n    }\n\n    /**\n     * @since 2.2\n     */\n    public String getXMLTextElementName() {\n        return _cfgNameForTextElement;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, XML, parser setting\n    /**********************************************************\n     */\n\n    /**\n     * Method for enabling or disabling specified XML parser feature.\n     */\n    public final XmlFactory configure(FromXmlParser.Feature f, boolean state)\n    {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }\n\n    /**\n     * Method for enabling specified XML parser feature.\n     */\n    public XmlFactory enable(FromXmlParser.Feature f) {\n        _xmlParserFeatures |= f.getMask();\n        return this;\n    }\n\n    /**\n     * Method for disabling specified XML parser feature.\n     */\n    public XmlFactory disable(FromXmlParser.Feature f) {\n        _xmlParserFeatures &= ~f.getMask();\n        return this;\n    }\n\n    /**\n     * Checked whether specified XML parser feature is enabled.\n     */\n    public final boolean isEnabled(FromXmlParser.Feature f) {\n        return (_xmlParserFeatures & f.getMask()) != 0;\n    }\n\n    /*\n    /******************************************************\n    /* Configuration, XML, generator settings\n    /******************************************************\n     */\n\n    /**\n     * Method for enabling or disabling specified XML generator feature.\n     */\n    public final XmlFactory configure(ToXmlGenerator.Feature f, boolean state) {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }\n\n    /**\n     * Method for enabling specified XML generator feature.\n     */\n    public XmlFactory enable(ToXmlGenerator.Feature f) {\n        _xmlGeneratorFeatures |= f.getMask();\n        return this;\n    }\n\n    /**\n     * Method for disabling specified XML generator feature.\n     */\n    public XmlFactory disable(ToXmlGenerator.Feature f) {\n        _xmlGeneratorFeatures &= ~f.getMask();\n        return this;\n    }\n\n    /**\n     * Check whether specified XML generator feature is enabled.\n     */\n    public final boolean isEnabled(ToXmlGenerator.Feature f) {\n        return (_xmlGeneratorFeatures & f.getMask()) != 0;\n    }\n\n    /*\n    /**********************************************************\n    /* Additional configuration\n    /**********************************************************\n     */\n\n    /** @since 2.4 */\n    public XMLInputFactory getXMLInputFactory() {\n        return _xmlInputFactory;\n    }\n\n    public void setXMLInputFactory(XMLInputFactory f) {\n        _xmlInputFactory = f;\n    }\n\n    /** @since 2.4 */\n    public XMLOutputFactory getXMLOutputFactory() {\n        return _xmlOutputFactory;\n    }\n    \n    public void setXMLOutputFactory(XMLOutputFactory f) {\n        _xmlOutputFactory = f;\n    }\n\n    /*\n    /**********************************************************\n    /* Format detection functionality\n    /**********************************************************\n     */\n\n    /**\n     * Method that returns short textual id identifying format\n     * this factory supports.\n     *<p>\n     * Note: sub-classes should override this method; default\n     * implementation will return null for all sub-classes\n     */\n    @Override\n    public String getFormatName() {\n        return FORMAT_NAME_XML;\n    }\n\n    @Override\n    public MatchStrength hasFormat(InputAccessor acc) throws IOException {\n        return hasXMLFormat(acc);\n    }\n\n    /**\n     * XML format does require support from custom {@link ObjectCodec}\n     * (that is, {@link XmlMapper}), so need to return true here.\n     * \n     * @return True since XML format does require support from codec\n     */\n    @Override\n    public boolean requiresCustomCodec() { return true; }\n\n    /*\n    /**********************************************************\n    /* Capability introspection\n    /**********************************************************\n     */\n\n    /**\n     * As of 2.4, we do have actual capability for passing char arrays\n     * efficiently, but unfortunately\n     * have no working mechanism for recycling buffers. So we have to \n     * admit that can not make efficient use.\n     */\n    @Override\n    public boolean canUseCharArrays() { return false; }\n\n    @Override // since 2.6\n    public Class<FromXmlParser.Feature> getFormatReadFeatureType() {\n        return FromXmlParser.Feature.class;\n    }\n\n    @Override // since 2.6\n    public Class<ToXmlGenerator.Feature> getFormatWriteFeatureType() {\n        return ToXmlGenerator.Feature.class;\n    }\n\n    /*\n    /**********************************************************\n    /* Overrides of public methods: parsing\n    /**********************************************************\n     */\n\n    /**\n     * Overridden just to prevent trying to optimize access via char array;\n     * while nice idea, problem is that we don't have proper hooks to ensure\n     * that temporary buffer gets recycled; so let's just use StringReader.\n     */\n    @SuppressWarnings(\"resource\")\n    @Override\n    public JsonParser createParser(String content) throws IOException {\n        Reader r = new StringReader(content);\n        IOContext ctxt = _createContext(r, true);\n        if (_inputDecorator != null) {\n            r = _inputDecorator.decorate(ctxt, r);\n        }\n        return _createParser(r, ctxt);\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides of public methods: generation\n    /**********************************************************\n     */\n\n    @Override\n    public ToXmlGenerator createGenerator(OutputStream out) throws IOException {\n        return createGenerator(out, JsonEncoding.UTF8);\n    }\n    \n    @Override\n    public ToXmlGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException\n    {\n        // false -> we won't manage the stream unless explicitly directed to\n        IOContext ctxt = _createContext(out, false);\n        ctxt.setEncoding(enc);\n        return new ToXmlGenerator(ctxt,\n                _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, _createXmlWriter(out));\n    }\n    \n    @Override\n    public ToXmlGenerator createGenerator(Writer out) throws IOException\n    {\n        return new ToXmlGenerator(_createContext(out, false),\n                _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, _createXmlWriter(out));\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override\n    public ToXmlGenerator createGenerator(File f, JsonEncoding enc) throws IOException\n    {\n        OutputStream out = new FileOutputStream(f);\n        // true -> yes, we have to manage the stream since we created it\n        IOContext ctxt = _createContext(out, true);\n        ctxt.setEncoding(enc);\n        return new ToXmlGenerator(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, _createXmlWriter(out));\n    }\n\n    /*\n    /**********************************************************\n    /* Extended public API, mostly for XmlMapper\n    /**********************************************************\n     */\n\n    /**\n     * Factory method that wraps given {@link XMLStreamReader}, usually to allow\n     * partial data-binding.\n     * \n     * @since 2.4\n     */\n    public FromXmlParser createParser(XMLStreamReader sr) throws IOException\n    {\n        // note: should NOT move parser if already pointing to START_ELEMENT\n        if (sr.getEventType() != XMLStreamConstants.START_ELEMENT) {\n            try {\n                sr = _initializeXmlReader(sr);\n            } catch (XMLStreamException e) {\n                return StaxUtil.throwXmlAsIOException(e);\n            }\n        }\n\n        // false -> not managed\n        FromXmlParser xp = new FromXmlParser(_createContext(sr, false),\n                _generatorFeatures, _xmlGeneratorFeatures, _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    /**\n     * Factory method that wraps given {@link XMLStreamWriter}, usually to allow\n     * incremental serialization to compose large output by serializing a sequence\n     * of individual objects.\n     *\n     * @since 2.4\n     */\n    public ToXmlGenerator createGenerator(XMLStreamWriter sw) throws IOException\n    {\n        try {\n            sw = _initializeXmlWriter(sw);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        IOContext ctxt = _createContext(sw, false);\n        return new ToXmlGenerator(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sw);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal factory method overrides\n    /**********************************************************\n     */\n\n    @Override\n    protected FromXmlParser _createParser(InputStream in, IOContext ctxt) throws IOException\n    {\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(in);\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    @Override\n    protected FromXmlParser _createParser(Reader r, IOContext ctxt) throws IOException\n    {\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(r);\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    @Override\n    protected FromXmlParser _createParser(char[] data, int offset, int len, IOContext ctxt,\n            boolean recycleBuffer) throws IOException\n    {\n        // !!! TODO: add proper handling of 'recycleBuffer'; currently its handling\n        //    is always same as if 'false' was passed\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(new Stax2CharArraySource(data, offset, len));\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n    \n    @Override\n    protected FromXmlParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException\n    {\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(new Stax2ByteArraySource(data, offset, len));\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    @Override\n    protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException {\n        // this method should never get called here, so:\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal factory methods, XML-specific\n    /**********************************************************************\n     */\n\n    protected XMLStreamWriter _createXmlWriter(OutputStream out) throws IOException\n    {\n        try {\n            return _initializeXmlWriter(_xmlOutputFactory.createXMLStreamWriter(out, \"UTF-8\"));\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n    }\n\n    protected XMLStreamWriter _createXmlWriter(Writer w) throws IOException\n    {\n        try {\n            return _initializeXmlWriter(_xmlOutputFactory.createXMLStreamWriter(w));\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n    }\n\n    protected final XMLStreamWriter _initializeXmlWriter(XMLStreamWriter sw) throws IOException, XMLStreamException\n    {\n        // And just for Sun Stax parser (JDK default), seems that we better define default namespace\n        // (Woodstox doesn't care) -- otherwise it'll add unnecessary odd declaration\n        sw.setDefaultNamespace(\"\");\n        return sw;\n    }\n\n    protected final XMLStreamReader _initializeXmlReader(XMLStreamReader sr) throws IOException, XMLStreamException\n    {\n        // for now, nothing to do... except let's find the root element\n        while (sr.next() != XMLStreamConstants.START_ELEMENT) {\n            ;\n        }\n        return sr;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, format auto-detection\n    /**********************************************************************\n     */\n\n    private final static byte UTF8_BOM_1 = (byte) 0xEF;\n    private final static byte UTF8_BOM_2 = (byte) 0xBB;\n    private final static byte UTF8_BOM_3 = (byte) 0xBF;\n\n    private final static byte BYTE_x = (byte) 'x';\n    private final static byte BYTE_m = (byte) 'm';\n    private final static byte BYTE_l = (byte) 'l';\n    private final static byte BYTE_D = (byte) 'D';\n\n    private final static byte BYTE_LT = (byte) '<';\n    private final static byte BYTE_QMARK = (byte) '?';\n    private final static byte BYTE_EXCL = (byte) '!';\n    private final static byte BYTE_HYPHEN = (byte) '-';\n    \n    /**\n     * Method that tries to figure out if content seems to be in some kind\n     * of XML format.\n     * Note that implementation here is not nearly as robust as what underlying\n     * Stax parser will do; the idea is to first support common encodings,\n     * then expand as needed (for example, it is not all that hard to support\n     * UTF-16; but it is some work and not needed quite yet)\n     */\n    public static MatchStrength hasXMLFormat(InputAccessor acc) throws IOException\n    {\n        /* Basically we just need to find \"<!\", \"<?\" or \"<NAME\"... but ideally\n         * we would actually see the XML declaration\n         */\n        if (!acc.hasMoreBytes()) {\n            return MatchStrength.INCONCLUSIVE;\n        }\n        byte b = acc.nextByte();\n        // Very first thing, a UTF-8 BOM? (later improvements: other BOM's, heuristics)\n        if (b == UTF8_BOM_1) { // yes, looks like UTF-8 BOM\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            if (acc.nextByte() != UTF8_BOM_2) {\n                return MatchStrength.NO_MATCH;\n            }\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            if (acc.nextByte() != UTF8_BOM_3) {\n                return MatchStrength.NO_MATCH;\n            }\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            b = acc.nextByte();\n        }\n        // otherwise: XML declaration?\n        boolean maybeXmlDecl = (b == BYTE_LT);\n        if (!maybeXmlDecl) {\n            int ch = skipSpace(acc, b);\n            if (ch < 0) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            b = (byte) ch;\n            // If we did not get an LT, shouldn't be valid XML (minus encoding issues etc)\n           if (b != BYTE_LT) {\n                return MatchStrength.NO_MATCH;\n            }\n        }\n        if (!acc.hasMoreBytes()) {\n            return MatchStrength.INCONCLUSIVE;\n        }\n        b = acc.nextByte();\n        // Couple of choices here\n        if (b == BYTE_QMARK) { // <?\n            b = acc.nextByte();\n            if (b == BYTE_x) {\n                if (maybeXmlDecl) {\n                    if (acc.hasMoreBytes() && acc.nextByte() == BYTE_m) {\n                        if (acc.hasMoreBytes() && acc.nextByte() == BYTE_l) {\n                            return MatchStrength.FULL_MATCH;\n                        }\n                    }\n                }\n                // but even with just partial match, we ought to be fine\n                return MatchStrength.SOLID_MATCH;\n            }\n            // Ok to start with some other char too; just not xml declaration\n            if (validXmlNameStartChar(acc, b)) {\n                return MatchStrength.SOLID_MATCH;\n            }\n        } else if (b == BYTE_EXCL) {\n            /* must be <!-- comment --> or <!DOCTYPE ...>, since\n             * <![CDATA[ ]]> can NOT come outside of root\n             */\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            b = acc.nextByte();\n            if (b == BYTE_HYPHEN) {\n                if (!acc.hasMoreBytes()) {\n                    return MatchStrength.INCONCLUSIVE;\n                }\n                if (acc.nextByte() == BYTE_HYPHEN) {\n                    return MatchStrength.SOLID_MATCH;\n                }\n            } else if (b == BYTE_D) {\n                return tryMatch(acc, \"OCTYPE\", MatchStrength.SOLID_MATCH);\n            }\n        } else {\n            // maybe root element? Just needs to match first char.\n            if (validXmlNameStartChar(acc, b)) {\n                return MatchStrength.SOLID_MATCH;\n            }\n        }\n        return MatchStrength.NO_MATCH;\n    }\n\n    private final static boolean validXmlNameStartChar(InputAccessor acc, byte b)\n        throws IOException\n    {\n        /* Can make it actual real XML check in future; for now we do just crude\n         * check for ASCII range\n         */\n        int ch = (int) b & 0xFF;\n        if (ch >= 'A') { // in theory, colon could be; in practice it should never be valid (wrt namespace)\n            // This is where we'd check for multi-byte UTF-8 chars (or whatever encoding is in use)...\n            return true;\n        }\n        return false;\n    }\n    \n    private final static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength)\n        throws IOException\n    {\n        for (int i = 0, len = matchStr.length(); i < len; ++i) {\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            if (acc.nextByte() != matchStr.charAt(i)) {\n                return MatchStrength.NO_MATCH;\n            }\n        }\n        return fullMatchStrength;\n    }\n    \n    private final static int skipSpace(InputAccessor acc, byte b) throws IOException\n    {\n        while (true) {\n            int ch = (int) b & 0xFF;\n            if (!(ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t')) {\n                return ch;\n            }\n            if (!acc.hasMoreBytes()) {\n                return -1;\n            }\n            b = acc.nextByte();\n            ch = (int) b & 0xFF;\n        }\n    }\n\n}\n",
        "human_patch_code": "package com.fasterxml.jackson.dataformat.xml;\n\nimport java.io.*;\n\nimport javax.xml.stream.*;\n\nimport org.codehaus.stax2.io.Stax2ByteArraySource;\nimport org.codehaus.stax2.io.Stax2CharArraySource;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.format.InputAccessor;\nimport com.fasterxml.jackson.core.format.MatchStrength;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\nimport com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser;\nimport com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;\nimport com.fasterxml.jackson.dataformat.xml.util.StaxUtil;\n\n/**\n* Factory used for constructing {@link FromXmlParser} and {@link ToXmlGenerator}\n* instances.\n*<p>\n* Implements {@link JsonFactory} since interface for constructing XML backed\n* parsers and generators is quite similar to dealing with JSON.\n* \n* @author Tatu Saloranta (tatu.saloranta@iki.fi)\n*/\npublic class XmlFactory extends JsonFactory\n{\n    private static final long serialVersionUID = 1; // 2.6\n\n    /**\n     * Name used to identify XML format\n     * (and returned by {@link #getFormatName()}\n     */\n    public final static String FORMAT_NAME_XML = \"XML\";\n\n    /**\n     * Bitfield (set of flags) of all parser features that are enabled\n     * by default.\n     */\n    final static int DEFAULT_XML_PARSER_FEATURE_FLAGS = FromXmlParser.Feature.collectDefaults();\n\n    /**\n     * Bitfield (set of flags) of all generator features that are enabled\n     * by default.\n     */\n    final static int DEFAULT_XML_GENERATOR_FEATURE_FLAGS = ToXmlGenerator.Feature.collectDefaults();\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected int _xmlParserFeatures;\n\n    protected int _xmlGeneratorFeatures;\n\n    // non-final for setters (why are they needed again?)\n    protected transient XMLInputFactory _xmlInputFactory;\n\n    protected transient XMLOutputFactory _xmlOutputFactory;\n\n    protected String _cfgNameForTextElement;\n    \n    /*\n    /**********************************************************\n    /* Factory construction, configuration\n    /**********************************************************\n     */\n\n    /**\n     * Default constructor used to create factory instances.\n     * Creation of a factory instance is a light-weight operation,\n     * but it is still a good idea to reuse limited number of\n     * factory instances (and quite often just a single instance):\n     * factories are used as context for storing some reused\n     * processing objects (such as symbol tables parsers use)\n     * and this reuse only works within context of a single\n     * factory instance.\n     */\n    public XmlFactory() { this(null, null, null); }\n\n    public XmlFactory(ObjectCodec oc) {\n        this(oc, null, null);\n    }\n\n    public XmlFactory(XMLInputFactory xmlIn) {\n        this(null, xmlIn, null);\n    }\n    \n    public XmlFactory(XMLInputFactory xmlIn, XMLOutputFactory xmlOut) {\n        this(null, xmlIn, xmlOut);\n    }\n    \n    public XmlFactory(ObjectCodec oc, XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n    {\n        this(oc, DEFAULT_XML_PARSER_FEATURE_FLAGS, DEFAULT_XML_GENERATOR_FEATURE_FLAGS,\n                xmlIn, xmlOut, null);\n    }\n\n    protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\n            XMLInputFactory xmlIn, XMLOutputFactory xmlOut,\n            String nameForTextElem)\n    {\n        super(oc);\n        _xmlParserFeatures = xpFeatures;\n        _xmlGeneratorFeatures = xgFeatures;\n        _cfgNameForTextElement = nameForTextElem;\n        if (xmlIn == null) {\n            xmlIn = XMLInputFactory.newInstance();\n            // as per [dataformat-xml#190], disable external entity expansion by default\n            xmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n        }\n        if (xmlOut == null) {\n            xmlOut = XMLOutputFactory.newInstance();\n        }\n        _initFactories(xmlIn, xmlOut);\n        _xmlInputFactory = xmlIn;\n        _xmlOutputFactory = xmlOut;\n    }\n\n    /**\n     * @since 2.2.1\n     */\n    protected XmlFactory(XmlFactory src, ObjectCodec oc)\n    {\n        super(src, oc);\n        _xmlParserFeatures = src._xmlParserFeatures;\n        _xmlGeneratorFeatures = src._xmlGeneratorFeatures;\n        _cfgNameForTextElement = src._cfgNameForTextElement;\n        _xmlInputFactory = src._xmlInputFactory;\n        _xmlOutputFactory = src._xmlOutputFactory;\n    }\n    \n    protected void _initFactories(XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n    {\n        // Better ensure namespaces get built properly, so:\n        xmlOut.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n        // and for parser, force coalescing as well (much simpler to use)\n        xmlIn.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);\n    }\n\n    /**\n     * Note: compared to base implementation by {@link JsonFactory},\n     * here the copy will actually share underlying XML input and\n     * output factories, as there is no way to make copies of those.\n     * \n     * @since 2.1\n     */\n    @Override\n    public XmlFactory copy() {\n        _checkInvalidCopy(XmlFactory.class);\n        return new XmlFactory(this, null);\n    }\n\n    @Override\n    public Version version() {\n        return PackageVersion.VERSION;\n    }\n\n    /*\n    /**********************************************************\n    /* Serializable overrides\n    /**********************************************************\n     */\n\n    /**\n     * Hiding place for JDK-serialization unthawed factories...\n     */\n    protected transient String _jdkXmlInFactory;\n\n    /**\n     * Hiding place for JDK-serialization unthawed factories...\n     */\n    protected transient String _jdkXmlOutFactory;\n\n    /**\n     * Method that we need to override to actually make restoration go\n     * through constructors etc.\n     */\n    @Override // since JsonFactory already implemented it\n    protected Object readResolve() {\n        if (_jdkXmlInFactory == null) {\n            throw new IllegalStateException(\"No XMLInputFactory class name read during JDK deserialization\");\n        }\n        if (_jdkXmlOutFactory == null) {\n            throw new IllegalStateException(\"No XMLOutputFactory class name read during JDK deserialization\");\n        }\n        try {\n            XMLInputFactory inf = (XMLInputFactory) Class.forName(_jdkXmlInFactory).newInstance();\n            XMLOutputFactory outf = (XMLOutputFactory) Class.forName(_jdkXmlOutFactory).newInstance();\n            return new XmlFactory(_objectCodec, _xmlParserFeatures, _xmlGeneratorFeatures,\n                    inf, outf, _cfgNameForTextElement);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalArgumentException(e);\n        } catch (InstantiationException e) {\n            throw new IllegalArgumentException(e);\n        } catch (IllegalAccessException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    /**\n     * In addition to default serialization, which mostly works, need\n     * to handle case of XML factories, hence override.\n     */\n    private void readObject(ObjectInputStream in)\n            throws IOException, ClassNotFoundException\n    {\n        in.defaultReadObject();\n        _jdkXmlInFactory = in.readUTF();\n        _jdkXmlOutFactory = in.readUTF();\n    }\n\n    /**\n     * In addition to default serialization, which mostly works, need\n     * to handle case of XML factories, hence override.\n     */\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeUTF(_xmlInputFactory.getClass().getName());\n        out.writeUTF(_xmlOutputFactory.getClass().getName());\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, XML-specific\n    /**********************************************************\n     */\n    \n    /**\n     * @since 2.1\n     */\n    public void setXMLTextElementName(String name) {\n        _cfgNameForTextElement = name;\n    }\n\n    /**\n     * @since 2.2\n     */\n    public String getXMLTextElementName() {\n        return _cfgNameForTextElement;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, XML, parser setting\n    /**********************************************************\n     */\n\n    /**\n     * Method for enabling or disabling specified XML parser feature.\n     */\n    public final XmlFactory configure(FromXmlParser.Feature f, boolean state)\n    {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }\n\n    /**\n     * Method for enabling specified XML parser feature.\n     */\n    public XmlFactory enable(FromXmlParser.Feature f) {\n        _xmlParserFeatures |= f.getMask();\n        return this;\n    }\n\n    /**\n     * Method for disabling specified XML parser feature.\n     */\n    public XmlFactory disable(FromXmlParser.Feature f) {\n        _xmlParserFeatures &= ~f.getMask();\n        return this;\n    }\n\n    /**\n     * Checked whether specified XML parser feature is enabled.\n     */\n    public final boolean isEnabled(FromXmlParser.Feature f) {\n        return (_xmlParserFeatures & f.getMask()) != 0;\n    }\n\n    /*\n    /******************************************************\n    /* Configuration, XML, generator settings\n    /******************************************************\n     */\n\n    /**\n     * Method for enabling or disabling specified XML generator feature.\n     */\n    public final XmlFactory configure(ToXmlGenerator.Feature f, boolean state) {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }\n\n    /**\n     * Method for enabling specified XML generator feature.\n     */\n    public XmlFactory enable(ToXmlGenerator.Feature f) {\n        _xmlGeneratorFeatures |= f.getMask();\n        return this;\n    }\n\n    /**\n     * Method for disabling specified XML generator feature.\n     */\n    public XmlFactory disable(ToXmlGenerator.Feature f) {\n        _xmlGeneratorFeatures &= ~f.getMask();\n        return this;\n    }\n\n    /**\n     * Check whether specified XML generator feature is enabled.\n     */\n    public final boolean isEnabled(ToXmlGenerator.Feature f) {\n        return (_xmlGeneratorFeatures & f.getMask()) != 0;\n    }\n\n    /*\n    /**********************************************************\n    /* Additional configuration\n    /**********************************************************\n     */\n\n    /** @since 2.4 */\n    public XMLInputFactory getXMLInputFactory() {\n        return _xmlInputFactory;\n    }\n\n    public void setXMLInputFactory(XMLInputFactory f) {\n        _xmlInputFactory = f;\n    }\n\n    /** @since 2.4 */\n    public XMLOutputFactory getXMLOutputFactory() {\n        return _xmlOutputFactory;\n    }\n    \n    public void setXMLOutputFactory(XMLOutputFactory f) {\n        _xmlOutputFactory = f;\n    }\n\n    /*\n    /**********************************************************\n    /* Format detection functionality\n    /**********************************************************\n     */\n\n    /**\n     * Method that returns short textual id identifying format\n     * this factory supports.\n     *<p>\n     * Note: sub-classes should override this method; default\n     * implementation will return null for all sub-classes\n     */\n    @Override\n    public String getFormatName() {\n        return FORMAT_NAME_XML;\n    }\n\n    @Override\n    public MatchStrength hasFormat(InputAccessor acc) throws IOException {\n        return hasXMLFormat(acc);\n    }\n\n    /**\n     * XML format does require support from custom {@link ObjectCodec}\n     * (that is, {@link XmlMapper}), so need to return true here.\n     * \n     * @return True since XML format does require support from codec\n     */\n    @Override\n    public boolean requiresCustomCodec() { return true; }\n\n    /*\n    /**********************************************************\n    /* Capability introspection\n    /**********************************************************\n     */\n\n    /**\n     * As of 2.4, we do have actual capability for passing char arrays\n     * efficiently, but unfortunately\n     * have no working mechanism for recycling buffers. So we have to \n     * admit that can not make efficient use.\n     */\n    @Override\n    public boolean canUseCharArrays() { return false; }\n\n    @Override // since 2.6\n    public Class<FromXmlParser.Feature> getFormatReadFeatureType() {\n        return FromXmlParser.Feature.class;\n    }\n\n    @Override // since 2.6\n    public Class<ToXmlGenerator.Feature> getFormatWriteFeatureType() {\n        return ToXmlGenerator.Feature.class;\n    }\n\n    /*\n    /**********************************************************\n    /* Overrides of public methods: parsing\n    /**********************************************************\n     */\n\n    /**\n     * Overridden just to prevent trying to optimize access via char array;\n     * while nice idea, problem is that we don't have proper hooks to ensure\n     * that temporary buffer gets recycled; so let's just use StringReader.\n     */\n    @SuppressWarnings(\"resource\")\n    @Override\n    public JsonParser createParser(String content) throws IOException {\n        Reader r = new StringReader(content);\n        IOContext ctxt = _createContext(r, true);\n        if (_inputDecorator != null) {\n            r = _inputDecorator.decorate(ctxt, r);\n        }\n        return _createParser(r, ctxt);\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides of public methods: generation\n    /**********************************************************\n     */\n\n    @Override\n    public ToXmlGenerator createGenerator(OutputStream out) throws IOException {\n        return createGenerator(out, JsonEncoding.UTF8);\n    }\n    \n    @Override\n    public ToXmlGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException\n    {\n        // false -> we won't manage the stream unless explicitly directed to\n        IOContext ctxt = _createContext(out, false);\n        ctxt.setEncoding(enc);\n        return new ToXmlGenerator(ctxt,\n                _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, _createXmlWriter(out));\n    }\n    \n    @Override\n    public ToXmlGenerator createGenerator(Writer out) throws IOException\n    {\n        return new ToXmlGenerator(_createContext(out, false),\n                _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, _createXmlWriter(out));\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override\n    public ToXmlGenerator createGenerator(File f, JsonEncoding enc) throws IOException\n    {\n        OutputStream out = new FileOutputStream(f);\n        // true -> yes, we have to manage the stream since we created it\n        IOContext ctxt = _createContext(out, true);\n        ctxt.setEncoding(enc);\n        return new ToXmlGenerator(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, _createXmlWriter(out));\n    }\n\n    /*\n    /**********************************************************\n    /* Extended public API, mostly for XmlMapper\n    /**********************************************************\n     */\n\n    /**\n     * Factory method that wraps given {@link XMLStreamReader}, usually to allow\n     * partial data-binding.\n     * \n     * @since 2.4\n     */\n    public FromXmlParser createParser(XMLStreamReader sr) throws IOException\n    {\n        // note: should NOT move parser if already pointing to START_ELEMENT\n        if (sr.getEventType() != XMLStreamConstants.START_ELEMENT) {\n            try {\n                sr = _initializeXmlReader(sr);\n            } catch (XMLStreamException e) {\n                return StaxUtil.throwXmlAsIOException(e);\n            }\n        }\n\n        // false -> not managed\n        FromXmlParser xp = new FromXmlParser(_createContext(sr, false),\n                _generatorFeatures, _xmlGeneratorFeatures, _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    /**\n     * Factory method that wraps given {@link XMLStreamWriter}, usually to allow\n     * incremental serialization to compose large output by serializing a sequence\n     * of individual objects.\n     *\n     * @since 2.4\n     */\n    public ToXmlGenerator createGenerator(XMLStreamWriter sw) throws IOException\n    {\n        try {\n            sw = _initializeXmlWriter(sw);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        IOContext ctxt = _createContext(sw, false);\n        return new ToXmlGenerator(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sw);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal factory method overrides\n    /**********************************************************\n     */\n\n    @Override\n    protected FromXmlParser _createParser(InputStream in, IOContext ctxt) throws IOException\n    {\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(in);\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    @Override\n    protected FromXmlParser _createParser(Reader r, IOContext ctxt) throws IOException\n    {\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(r);\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    @Override\n    protected FromXmlParser _createParser(char[] data, int offset, int len, IOContext ctxt,\n            boolean recycleBuffer) throws IOException\n    {\n        // !!! TODO: add proper handling of 'recycleBuffer'; currently its handling\n        //    is always same as if 'false' was passed\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(new Stax2CharArraySource(data, offset, len));\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n    \n    @Override\n    protected FromXmlParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException\n    {\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(new Stax2ByteArraySource(data, offset, len));\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    @Override\n    protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException {\n        // this method should never get called here, so:\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal factory methods, XML-specific\n    /**********************************************************************\n     */\n\n    protected XMLStreamWriter _createXmlWriter(OutputStream out) throws IOException\n    {\n        try {\n            return _initializeXmlWriter(_xmlOutputFactory.createXMLStreamWriter(out, \"UTF-8\"));\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n    }\n\n    protected XMLStreamWriter _createXmlWriter(Writer w) throws IOException\n    {\n        try {\n            return _initializeXmlWriter(_xmlOutputFactory.createXMLStreamWriter(w));\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n    }\n\n    protected final XMLStreamWriter _initializeXmlWriter(XMLStreamWriter sw) throws IOException, XMLStreamException\n    {\n        // And just for Sun Stax parser (JDK default), seems that we better define default namespace\n        // (Woodstox doesn't care) -- otherwise it'll add unnecessary odd declaration\n        sw.setDefaultNamespace(\"\");\n        return sw;\n    }\n\n    protected final XMLStreamReader _initializeXmlReader(XMLStreamReader sr) throws IOException, XMLStreamException\n    {\n        // for now, nothing to do... except let's find the root element\n        while (sr.next() != XMLStreamConstants.START_ELEMENT) {\n            ;\n        }\n        return sr;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, format auto-detection\n    /**********************************************************************\n     */\n\n    private final static byte UTF8_BOM_1 = (byte) 0xEF;\n    private final static byte UTF8_BOM_2 = (byte) 0xBB;\n    private final static byte UTF8_BOM_3 = (byte) 0xBF;\n\n    private final static byte BYTE_x = (byte) 'x';\n    private final static byte BYTE_m = (byte) 'm';\n    private final static byte BYTE_l = (byte) 'l';\n    private final static byte BYTE_D = (byte) 'D';\n\n    private final static byte BYTE_LT = (byte) '<';\n    private final static byte BYTE_QMARK = (byte) '?';\n    private final static byte BYTE_EXCL = (byte) '!';\n    private final static byte BYTE_HYPHEN = (byte) '-';\n    \n    /**\n     * Method that tries to figure out if content seems to be in some kind\n     * of XML format.\n     * Note that implementation here is not nearly as robust as what underlying\n     * Stax parser will do; the idea is to first support common encodings,\n     * then expand as needed (for example, it is not all that hard to support\n     * UTF-16; but it is some work and not needed quite yet)\n     */\n    public static MatchStrength hasXMLFormat(InputAccessor acc) throws IOException\n    {\n        /* Basically we just need to find \"<!\", \"<?\" or \"<NAME\"... but ideally\n         * we would actually see the XML declaration\n         */\n        if (!acc.hasMoreBytes()) {\n            return MatchStrength.INCONCLUSIVE;\n        }\n        byte b = acc.nextByte();\n        // Very first thing, a UTF-8 BOM? (later improvements: other BOM's, heuristics)\n        if (b == UTF8_BOM_1) { // yes, looks like UTF-8 BOM\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            if (acc.nextByte() != UTF8_BOM_2) {\n                return MatchStrength.NO_MATCH;\n            }\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            if (acc.nextByte() != UTF8_BOM_3) {\n                return MatchStrength.NO_MATCH;\n            }\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            b = acc.nextByte();\n        }\n        // otherwise: XML declaration?\n        boolean maybeXmlDecl = (b == BYTE_LT);\n        if (!maybeXmlDecl) {\n            int ch = skipSpace(acc, b);\n            if (ch < 0) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            b = (byte) ch;\n            // If we did not get an LT, shouldn't be valid XML (minus encoding issues etc)\n           if (b != BYTE_LT) {\n                return MatchStrength.NO_MATCH;\n            }\n        }\n        if (!acc.hasMoreBytes()) {\n            return MatchStrength.INCONCLUSIVE;\n        }\n        b = acc.nextByte();\n        // Couple of choices here\n        if (b == BYTE_QMARK) { // <?\n            b = acc.nextByte();\n            if (b == BYTE_x) {\n                if (maybeXmlDecl) {\n                    if (acc.hasMoreBytes() && acc.nextByte() == BYTE_m) {\n                        if (acc.hasMoreBytes() && acc.nextByte() == BYTE_l) {\n                            return MatchStrength.FULL_MATCH;\n                        }\n                    }\n                }\n                // but even with just partial match, we ought to be fine\n                return MatchStrength.SOLID_MATCH;\n            }\n            // Ok to start with some other char too; just not xml declaration\n            if (validXmlNameStartChar(acc, b)) {\n                return MatchStrength.SOLID_MATCH;\n            }\n        } else if (b == BYTE_EXCL) {\n            /* must be <!-- comment --> or <!DOCTYPE ...>, since\n             * <![CDATA[ ]]> can NOT come outside of root\n             */\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            b = acc.nextByte();\n            if (b == BYTE_HYPHEN) {\n                if (!acc.hasMoreBytes()) {\n                    return MatchStrength.INCONCLUSIVE;\n                }\n                if (acc.nextByte() == BYTE_HYPHEN) {\n                    return MatchStrength.SOLID_MATCH;\n                }\n            } else if (b == BYTE_D) {\n                return tryMatch(acc, \"OCTYPE\", MatchStrength.SOLID_MATCH);\n            }\n        } else {\n            // maybe root element? Just needs to match first char.\n            if (validXmlNameStartChar(acc, b)) {\n                return MatchStrength.SOLID_MATCH;\n            }\n        }\n        return MatchStrength.NO_MATCH;\n    }\n\n    private final static boolean validXmlNameStartChar(InputAccessor acc, byte b)\n        throws IOException\n    {\n        /* Can make it actual real XML check in future; for now we do just crude\n         * check for ASCII range\n         */\n        int ch = (int) b & 0xFF;\n        if (ch >= 'A') { // in theory, colon could be; in practice it should never be valid (wrt namespace)\n            // This is where we'd check for multi-byte UTF-8 chars (or whatever encoding is in use)...\n            return true;\n        }\n        return false;\n    }\n    \n    private final static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength)\n        throws IOException\n    {\n        for (int i = 0, len = matchStr.length(); i < len; ++i) {\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            if (acc.nextByte() != matchStr.charAt(i)) {\n                return MatchStrength.NO_MATCH;\n            }\n        }\n        return fullMatchStrength;\n    }\n    \n    private final static int skipSpace(InputAccessor acc, byte b) throws IOException\n    {\n        while (true) {\n            int ch = (int) b & 0xFF;\n            if (!(ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t')) {\n                return ch;\n            }\n            if (!acc.hasMoreBytes()) {\n                return -1;\n            }\n            b = acc.nextByte();\n            ch = (int) b & 0xFF;\n        }\n    }\n\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-47": {
    "vul_id": "VUL4J-47",
    "cve_id": "CVE-2016-7051",
    "project": "FasterXML_jackson-dataformat-xml",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=com.fasterxml.jackson.dataformat.xml.SupportDTDDefaultsTest#testDTDAttempt",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/FasterXML/jackson-dataformat-xml/commit/eeff2c312e9d4caa8c9f27b8f740c7529d00524a",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/com/fasterxml/jackson/dataformat/xml/XmlFactory.java",
        "file_name": "XmlFactory.java",
        "vulnerable_code": "package com.fasterxml.jackson.dataformat.xml;\n\nimport java.io.*;\n\nimport javax.xml.stream.*;\n\nimport org.codehaus.stax2.io.Stax2ByteArraySource;\nimport org.codehaus.stax2.io.Stax2CharArraySource;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.format.InputAccessor;\nimport com.fasterxml.jackson.core.format.MatchStrength;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\nimport com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser;\nimport com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;\nimport com.fasterxml.jackson.dataformat.xml.util.StaxUtil;\n\n/**\n* Factory used for constructing {@link FromXmlParser} and {@link ToXmlGenerator}\n* instances.\n*<p>\n* Implements {@link JsonFactory} since interface for constructing XML backed\n* parsers and generators is quite similar to dealing with JSON.\n* \n* @author Tatu Saloranta (tatu.saloranta@iki.fi)\n*/\npublic class XmlFactory extends JsonFactory\n{\n    private static final long serialVersionUID = 1; // 2.6\n\n    /**\n     * Name used to identify XML format\n     * (and returned by {@link #getFormatName()}\n     */\n    public final static String FORMAT_NAME_XML = \"XML\";\n\n    /**\n     * Bitfield (set of flags) of all parser features that are enabled\n     * by default.\n     */\n    final static int DEFAULT_XML_PARSER_FEATURE_FLAGS = FromXmlParser.Feature.collectDefaults();\n\n    /**\n     * Bitfield (set of flags) of all generator features that are enabled\n     * by default.\n     */\n    final static int DEFAULT_XML_GENERATOR_FEATURE_FLAGS = ToXmlGenerator.Feature.collectDefaults();\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected int _xmlParserFeatures;\n\n    protected int _xmlGeneratorFeatures;\n\n    // non-final for setters (why are they needed again?)\n    protected transient XMLInputFactory _xmlInputFactory;\n\n    protected transient XMLOutputFactory _xmlOutputFactory;\n\n    protected String _cfgNameForTextElement;\n    \n    /*\n    /**********************************************************\n    /* Factory construction, configuration\n    /**********************************************************\n     */\n\n    /**\n     * Default constructor used to create factory instances.\n     * Creation of a factory instance is a light-weight operation,\n     * but it is still a good idea to reuse limited number of\n     * factory instances (and quite often just a single instance):\n     * factories are used as context for storing some reused\n     * processing objects (such as symbol tables parsers use)\n     * and this reuse only works within context of a single\n     * factory instance.\n     */\n    public XmlFactory() { this(null, null, null); }\n\n    public XmlFactory(ObjectCodec oc) {\n        this(oc, null, null);\n    }\n\n    public XmlFactory(XMLInputFactory xmlIn) {\n        this(null, xmlIn, null);\n    }\n    \n    public XmlFactory(XMLInputFactory xmlIn, XMLOutputFactory xmlOut) {\n        this(null, xmlIn, xmlOut);\n    }\n    \n    public XmlFactory(ObjectCodec oc, XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n    {\n        this(oc, DEFAULT_XML_PARSER_FEATURE_FLAGS, DEFAULT_XML_GENERATOR_FEATURE_FLAGS,\n                xmlIn, xmlOut, null);\n    }\n\n    protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\n            XMLInputFactory xmlIn, XMLOutputFactory xmlOut,\n            String nameForTextElem)\n    {\n        super(oc);\n        _xmlParserFeatures = xpFeatures;\n        _xmlGeneratorFeatures = xgFeatures;\n        _cfgNameForTextElement = nameForTextElem;\n        if (xmlIn == null) {\n            xmlIn = XMLInputFactory.newInstance();\n            // as per [dataformat-xml#190], disable external entity expansion by default\n            xmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n        }\n        if (xmlOut == null) {\n            xmlOut = XMLOutputFactory.newInstance();\n        }\n        _initFactories(xmlIn, xmlOut);\n        _xmlInputFactory = xmlIn;\n        _xmlOutputFactory = xmlOut;\n    }\n\n    /**\n     * @since 2.2.1\n     */\n    protected XmlFactory(XmlFactory src, ObjectCodec oc)\n    {\n        super(src, oc);\n        _xmlParserFeatures = src._xmlParserFeatures;\n        _xmlGeneratorFeatures = src._xmlGeneratorFeatures;\n        _cfgNameForTextElement = src._cfgNameForTextElement;\n        _xmlInputFactory = src._xmlInputFactory;\n        _xmlOutputFactory = src._xmlOutputFactory;\n    }\n    \n    protected void _initFactories(XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n    {\n        // Better ensure namespaces get built properly, so:\n        xmlOut.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n        // and for parser, force coalescing as well (much simpler to use)\n        xmlIn.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);\n    }\n\n    /**\n     * Note: compared to base implementation by {@link JsonFactory},\n     * here the copy will actually share underlying XML input and\n     * output factories, as there is no way to make copies of those.\n     * \n     * @since 2.1\n     */\n    @Override\n    public XmlFactory copy() {\n        _checkInvalidCopy(XmlFactory.class);\n        return new XmlFactory(this, null);\n    }\n\n    @Override\n    public Version version() {\n        return PackageVersion.VERSION;\n    }\n\n    /*\n    /**********************************************************\n    /* Serializable overrides\n    /**********************************************************\n     */\n\n    /**\n     * Hiding place for JDK-serialization unthawed factories...\n     */\n    protected transient String _jdkXmlInFactory;\n\n    /**\n     * Hiding place for JDK-serialization unthawed factories...\n     */\n    protected transient String _jdkXmlOutFactory;\n\n    /**\n     * Method that we need to override to actually make restoration go\n     * through constructors etc.\n     */\n    @Override // since JsonFactory already implemented it\n    protected Object readResolve() {\n        if (_jdkXmlInFactory == null) {\n            throw new IllegalStateException(\"No XMLInputFactory class name read during JDK deserialization\");\n        }\n        if (_jdkXmlOutFactory == null) {\n            throw new IllegalStateException(\"No XMLOutputFactory class name read during JDK deserialization\");\n        }\n        try {\n            XMLInputFactory inf = (XMLInputFactory) Class.forName(_jdkXmlInFactory).newInstance();\n            XMLOutputFactory outf = (XMLOutputFactory) Class.forName(_jdkXmlOutFactory).newInstance();\n            return new XmlFactory(_objectCodec, _xmlParserFeatures, _xmlGeneratorFeatures,\n                    inf, outf, _cfgNameForTextElement);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalArgumentException(e);\n        } catch (InstantiationException e) {\n            throw new IllegalArgumentException(e);\n        } catch (IllegalAccessException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    /**\n     * In addition to default serialization, which mostly works, need\n     * to handle case of XML factories, hence override.\n     */\n    private void readObject(ObjectInputStream in)\n            throws IOException, ClassNotFoundException\n    {\n        in.defaultReadObject();\n        _jdkXmlInFactory = in.readUTF();\n        _jdkXmlOutFactory = in.readUTF();\n    }\n\n    /**\n     * In addition to default serialization, which mostly works, need\n     * to handle case of XML factories, hence override.\n     */\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeUTF(_xmlInputFactory.getClass().getName());\n        out.writeUTF(_xmlOutputFactory.getClass().getName());\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, XML-specific\n    /**********************************************************\n     */\n    \n    /**\n     * @since 2.1\n     */\n    public void setXMLTextElementName(String name) {\n        _cfgNameForTextElement = name;\n    }\n\n    /**\n     * @since 2.2\n     */\n    public String getXMLTextElementName() {\n        return _cfgNameForTextElement;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, XML, parser setting\n    /**********************************************************\n     */\n\n    /**\n     * Method for enabling or disabling specified XML parser feature.\n     */\n    public final XmlFactory configure(FromXmlParser.Feature f, boolean state)\n    {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }\n\n    /**\n     * Method for enabling specified XML parser feature.\n     */\n    public XmlFactory enable(FromXmlParser.Feature f) {\n        _xmlParserFeatures |= f.getMask();\n        return this;\n    }\n\n    /**\n     * Method for disabling specified XML parser feature.\n     */\n    public XmlFactory disable(FromXmlParser.Feature f) {\n        _xmlParserFeatures &= ~f.getMask();\n        return this;\n    }\n\n    /**\n     * Checked whether specified XML parser feature is enabled.\n     */\n    public final boolean isEnabled(FromXmlParser.Feature f) {\n        return (_xmlParserFeatures & f.getMask()) != 0;\n    }\n\n    /*\n    /******************************************************\n    /* Configuration, XML, generator settings\n    /******************************************************\n     */\n\n    /**\n     * Method for enabling or disabling specified XML generator feature.\n     */\n    public final XmlFactory configure(ToXmlGenerator.Feature f, boolean state) {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }\n\n    /**\n     * Method for enabling specified XML generator feature.\n     */\n    public XmlFactory enable(ToXmlGenerator.Feature f) {\n        _xmlGeneratorFeatures |= f.getMask();\n        return this;\n    }\n\n    /**\n     * Method for disabling specified XML generator feature.\n     */\n    public XmlFactory disable(ToXmlGenerator.Feature f) {\n        _xmlGeneratorFeatures &= ~f.getMask();\n        return this;\n    }\n\n    /**\n     * Check whether specified XML generator feature is enabled.\n     */\n    public final boolean isEnabled(ToXmlGenerator.Feature f) {\n        return (_xmlGeneratorFeatures & f.getMask()) != 0;\n    }\n\n    /*\n    /**********************************************************\n    /* Additional configuration\n    /**********************************************************\n     */\n\n    /** @since 2.4 */\n    public XMLInputFactory getXMLInputFactory() {\n        return _xmlInputFactory;\n    }\n\n    public void setXMLInputFactory(XMLInputFactory f) {\n        _xmlInputFactory = f;\n    }\n\n    /** @since 2.4 */\n    public XMLOutputFactory getXMLOutputFactory() {\n        return _xmlOutputFactory;\n    }\n    \n    public void setXMLOutputFactory(XMLOutputFactory f) {\n        _xmlOutputFactory = f;\n    }\n\n    /*\n    /**********************************************************\n    /* Format detection functionality\n    /**********************************************************\n     */\n\n    /**\n     * Method that returns short textual id identifying format\n     * this factory supports.\n     *<p>\n     * Note: sub-classes should override this method; default\n     * implementation will return null for all sub-classes\n     */\n    @Override\n    public String getFormatName() {\n        return FORMAT_NAME_XML;\n    }\n\n    @Override\n    public MatchStrength hasFormat(InputAccessor acc) throws IOException {\n        return hasXMLFormat(acc);\n    }\n\n    /**\n     * XML format does require support from custom {@link ObjectCodec}\n     * (that is, {@link XmlMapper}), so need to return true here.\n     * \n     * @return True since XML format does require support from codec\n     */\n    @Override\n    public boolean requiresCustomCodec() { return true; }\n\n    /*\n    /**********************************************************\n    /* Capability introspection\n    /**********************************************************\n     */\n\n    /**\n     * As of 2.4, we do have actual capability for passing char arrays\n     * efficiently, but unfortunately\n     * have no working mechanism for recycling buffers. So we have to \n     * admit that can not make efficient use.\n     */\n    @Override\n    public boolean canUseCharArrays() { return false; }\n\n    @Override // since 2.6\n    public Class<FromXmlParser.Feature> getFormatReadFeatureType() {\n        return FromXmlParser.Feature.class;\n    }\n\n    @Override // since 2.6\n    public Class<ToXmlGenerator.Feature> getFormatWriteFeatureType() {\n        return ToXmlGenerator.Feature.class;\n    }\n\n    /*\n    /**********************************************************\n    /* Overrides of public methods: parsing\n    /**********************************************************\n     */\n\n    /**\n     * Overridden just to prevent trying to optimize access via char array;\n     * while nice idea, problem is that we don't have proper hooks to ensure\n     * that temporary buffer gets recycled; so let's just use StringReader.\n     */\n    @SuppressWarnings(\"resource\")\n    @Override\n    public JsonParser createParser(String content) throws IOException {\n        Reader r = new StringReader(content);\n        IOContext ctxt = _createContext(r, true);\n        if (_inputDecorator != null) {\n            r = _inputDecorator.decorate(ctxt, r);\n        }\n        return _createParser(r, ctxt);\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides of public methods: generation\n    /**********************************************************\n     */\n\n    @Override\n    public ToXmlGenerator createGenerator(OutputStream out) throws IOException {\n        return createGenerator(out, JsonEncoding.UTF8);\n    }\n    \n    @Override\n    public ToXmlGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException\n    {\n        // false -> we won't manage the stream unless explicitly directed to\n        IOContext ctxt = _createContext(out, false);\n        ctxt.setEncoding(enc);\n        return new ToXmlGenerator(ctxt,\n                _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, _createXmlWriter(out));\n    }\n    \n    @Override\n    public ToXmlGenerator createGenerator(Writer out) throws IOException\n    {\n        return new ToXmlGenerator(_createContext(out, false),\n                _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, _createXmlWriter(out));\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override\n    public ToXmlGenerator createGenerator(File f, JsonEncoding enc) throws IOException\n    {\n        OutputStream out = new FileOutputStream(f);\n        // true -> yes, we have to manage the stream since we created it\n        IOContext ctxt = _createContext(out, true);\n        ctxt.setEncoding(enc);\n        return new ToXmlGenerator(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, _createXmlWriter(out));\n    }\n\n    /*\n    /**********************************************************\n    /* Extended public API, mostly for XmlMapper\n    /**********************************************************\n     */\n\n    /**\n     * Factory method that wraps given {@link XMLStreamReader}, usually to allow\n     * partial data-binding.\n     * \n     * @since 2.4\n     */\n    public FromXmlParser createParser(XMLStreamReader sr) throws IOException\n    {\n        // note: should NOT move parser if already pointing to START_ELEMENT\n        if (sr.getEventType() != XMLStreamConstants.START_ELEMENT) {\n            try {\n                sr = _initializeXmlReader(sr);\n            } catch (XMLStreamException e) {\n                return StaxUtil.throwXmlAsIOException(e);\n            }\n        }\n\n        // false -> not managed\n        FromXmlParser xp = new FromXmlParser(_createContext(sr, false),\n                _generatorFeatures, _xmlGeneratorFeatures, _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    /**\n     * Factory method that wraps given {@link XMLStreamWriter}, usually to allow\n     * incremental serialization to compose large output by serializing a sequence\n     * of individual objects.\n     *\n     * @since 2.4\n     */\n    public ToXmlGenerator createGenerator(XMLStreamWriter sw) throws IOException\n    {\n        try {\n            sw = _initializeXmlWriter(sw);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        IOContext ctxt = _createContext(sw, false);\n        return new ToXmlGenerator(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sw);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal factory method overrides\n    /**********************************************************\n     */\n\n    @Override\n    protected FromXmlParser _createParser(InputStream in, IOContext ctxt) throws IOException\n    {\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(in);\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    @Override\n    protected FromXmlParser _createParser(Reader r, IOContext ctxt) throws IOException\n    {\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(r);\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    @Override\n    protected FromXmlParser _createParser(char[] data, int offset, int len, IOContext ctxt,\n            boolean recycleBuffer) throws IOException\n    {\n        // !!! TODO: add proper handling of 'recycleBuffer'; currently its handling\n        //    is always same as if 'false' was passed\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(new Stax2CharArraySource(data, offset, len));\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n    \n    @Override\n    protected FromXmlParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException\n    {\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(new Stax2ByteArraySource(data, offset, len));\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    @Override\n    protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException {\n        // this method should never get called here, so:\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal factory methods, XML-specific\n    /**********************************************************************\n     */\n\n    protected XMLStreamWriter _createXmlWriter(OutputStream out) throws IOException\n    {\n        try {\n            return _initializeXmlWriter(_xmlOutputFactory.createXMLStreamWriter(out, \"UTF-8\"));\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n    }\n\n    protected XMLStreamWriter _createXmlWriter(Writer w) throws IOException\n    {\n        try {\n            return _initializeXmlWriter(_xmlOutputFactory.createXMLStreamWriter(w));\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n    }\n\n    protected final XMLStreamWriter _initializeXmlWriter(XMLStreamWriter sw) throws IOException, XMLStreamException\n    {\n        // And just for Sun Stax parser (JDK default), seems that we better define default namespace\n        // (Woodstox doesn't care) -- otherwise it'll add unnecessary odd declaration\n        sw.setDefaultNamespace(\"\");\n        return sw;\n    }\n\n    protected final XMLStreamReader _initializeXmlReader(XMLStreamReader sr) throws IOException, XMLStreamException\n    {\n        // for now, nothing to do... except let's find the root element\n        while (sr.next() != XMLStreamConstants.START_ELEMENT) {\n            ;\n        }\n        return sr;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, format auto-detection\n    /**********************************************************************\n     */\n\n    private final static byte UTF8_BOM_1 = (byte) 0xEF;\n    private final static byte UTF8_BOM_2 = (byte) 0xBB;\n    private final static byte UTF8_BOM_3 = (byte) 0xBF;\n\n    private final static byte BYTE_x = (byte) 'x';\n    private final static byte BYTE_m = (byte) 'm';\n    private final static byte BYTE_l = (byte) 'l';\n    private final static byte BYTE_D = (byte) 'D';\n\n    private final static byte BYTE_LT = (byte) '<';\n    private final static byte BYTE_QMARK = (byte) '?';\n    private final static byte BYTE_EXCL = (byte) '!';\n    private final static byte BYTE_HYPHEN = (byte) '-';\n    \n    /**\n     * Method that tries to figure out if content seems to be in some kind\n     * of XML format.\n     * Note that implementation here is not nearly as robust as what underlying\n     * Stax parser will do; the idea is to first support common encodings,\n     * then expand as needed (for example, it is not all that hard to support\n     * UTF-16; but it is some work and not needed quite yet)\n     */\n    public static MatchStrength hasXMLFormat(InputAccessor acc) throws IOException\n    {\n        /* Basically we just need to find \"<!\", \"<?\" or \"<NAME\"... but ideally\n         * we would actually see the XML declaration\n         */\n        if (!acc.hasMoreBytes()) {\n            return MatchStrength.INCONCLUSIVE;\n        }\n        byte b = acc.nextByte();\n        // Very first thing, a UTF-8 BOM? (later improvements: other BOM's, heuristics)\n        if (b == UTF8_BOM_1) { // yes, looks like UTF-8 BOM\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            if (acc.nextByte() != UTF8_BOM_2) {\n                return MatchStrength.NO_MATCH;\n            }\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            if (acc.nextByte() != UTF8_BOM_3) {\n                return MatchStrength.NO_MATCH;\n            }\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            b = acc.nextByte();\n        }\n        // otherwise: XML declaration?\n        boolean maybeXmlDecl = (b == BYTE_LT);\n        if (!maybeXmlDecl) {\n            int ch = skipSpace(acc, b);\n            if (ch < 0) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            b = (byte) ch;\n            // If we did not get an LT, shouldn't be valid XML (minus encoding issues etc)\n           if (b != BYTE_LT) {\n                return MatchStrength.NO_MATCH;\n            }\n        }\n        if (!acc.hasMoreBytes()) {\n            return MatchStrength.INCONCLUSIVE;\n        }\n        b = acc.nextByte();\n        // Couple of choices here\n        if (b == BYTE_QMARK) { // <?\n            b = acc.nextByte();\n            if (b == BYTE_x) {\n                if (maybeXmlDecl) {\n                    if (acc.hasMoreBytes() && acc.nextByte() == BYTE_m) {\n                        if (acc.hasMoreBytes() && acc.nextByte() == BYTE_l) {\n                            return MatchStrength.FULL_MATCH;\n                        }\n                    }\n                }\n                // but even with just partial match, we ought to be fine\n                return MatchStrength.SOLID_MATCH;\n            }\n            // Ok to start with some other char too; just not xml declaration\n            if (validXmlNameStartChar(acc, b)) {\n                return MatchStrength.SOLID_MATCH;\n            }\n        } else if (b == BYTE_EXCL) {\n            /* must be <!-- comment --> or <!DOCTYPE ...>, since\n             * <![CDATA[ ]]> can NOT come outside of root\n             */\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            b = acc.nextByte();\n            if (b == BYTE_HYPHEN) {\n                if (!acc.hasMoreBytes()) {\n                    return MatchStrength.INCONCLUSIVE;\n                }\n                if (acc.nextByte() == BYTE_HYPHEN) {\n                    return MatchStrength.SOLID_MATCH;\n                }\n            } else if (b == BYTE_D) {\n                return tryMatch(acc, \"OCTYPE\", MatchStrength.SOLID_MATCH);\n            }\n        } else {\n            // maybe root element? Just needs to match first char.\n            if (validXmlNameStartChar(acc, b)) {\n                return MatchStrength.SOLID_MATCH;\n            }\n        }\n        return MatchStrength.NO_MATCH;\n    }\n\n    private final static boolean validXmlNameStartChar(InputAccessor acc, byte b)\n        throws IOException\n    {\n        /* Can make it actual real XML check in future; for now we do just crude\n         * check for ASCII range\n         */\n        int ch = (int) b & 0xFF;\n        if (ch >= 'A') { // in theory, colon could be; in practice it should never be valid (wrt namespace)\n            // This is where we'd check for multi-byte UTF-8 chars (or whatever encoding is in use)...\n            return true;\n        }\n        return false;\n    }\n    \n    private final static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength)\n        throws IOException\n    {\n        for (int i = 0, len = matchStr.length(); i < len; ++i) {\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            if (acc.nextByte() != matchStr.charAt(i)) {\n                return MatchStrength.NO_MATCH;\n            }\n        }\n        return fullMatchStrength;\n    }\n    \n    private final static int skipSpace(InputAccessor acc, byte b) throws IOException\n    {\n        while (true) {\n            int ch = (int) b & 0xFF;\n            if (!(ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t')) {\n                return ch;\n            }\n            if (!acc.hasMoreBytes()) {\n                return -1;\n            }\n            b = acc.nextByte();\n            ch = (int) b & 0xFF;\n        }\n    }\n\n}\n",
        "human_patch_code": "package com.fasterxml.jackson.dataformat.xml;\n\nimport java.io.*;\n\nimport javax.xml.stream.*;\n\nimport org.codehaus.stax2.io.Stax2ByteArraySource;\nimport org.codehaus.stax2.io.Stax2CharArraySource;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.format.InputAccessor;\nimport com.fasterxml.jackson.core.format.MatchStrength;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\nimport com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser;\nimport com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;\nimport com.fasterxml.jackson.dataformat.xml.util.StaxUtil;\n\n/**\n* Factory used for constructing {@link FromXmlParser} and {@link ToXmlGenerator}\n* instances.\n*<p>\n* Implements {@link JsonFactory} since interface for constructing XML backed\n* parsers and generators is quite similar to dealing with JSON.\n* \n* @author Tatu Saloranta (tatu.saloranta@iki.fi)\n*/\npublic class XmlFactory extends JsonFactory\n{\n    private static final long serialVersionUID = 1; // 2.6\n\n    /**\n     * Name used to identify XML format\n     * (and returned by {@link #getFormatName()}\n     */\n    public final static String FORMAT_NAME_XML = \"XML\";\n\n    /**\n     * Bitfield (set of flags) of all parser features that are enabled\n     * by default.\n     */\n    final static int DEFAULT_XML_PARSER_FEATURE_FLAGS = FromXmlParser.Feature.collectDefaults();\n\n    /**\n     * Bitfield (set of flags) of all generator features that are enabled\n     * by default.\n     */\n    final static int DEFAULT_XML_GENERATOR_FEATURE_FLAGS = ToXmlGenerator.Feature.collectDefaults();\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected int _xmlParserFeatures;\n\n    protected int _xmlGeneratorFeatures;\n\n    // non-final for setters (why are they needed again?)\n    protected transient XMLInputFactory _xmlInputFactory;\n\n    protected transient XMLOutputFactory _xmlOutputFactory;\n\n    protected String _cfgNameForTextElement;\n    \n    /*\n    /**********************************************************\n    /* Factory construction, configuration\n    /**********************************************************\n     */\n\n    /**\n     * Default constructor used to create factory instances.\n     * Creation of a factory instance is a light-weight operation,\n     * but it is still a good idea to reuse limited number of\n     * factory instances (and quite often just a single instance):\n     * factories are used as context for storing some reused\n     * processing objects (such as symbol tables parsers use)\n     * and this reuse only works within context of a single\n     * factory instance.\n     */\n    public XmlFactory() { this(null, null, null); }\n\n    public XmlFactory(ObjectCodec oc) {\n        this(oc, null, null);\n    }\n\n    public XmlFactory(XMLInputFactory xmlIn) {\n        this(null, xmlIn, null);\n    }\n    \n    public XmlFactory(XMLInputFactory xmlIn, XMLOutputFactory xmlOut) {\n        this(null, xmlIn, xmlOut);\n    }\n    \n    public XmlFactory(ObjectCodec oc, XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n    {\n        this(oc, DEFAULT_XML_PARSER_FEATURE_FLAGS, DEFAULT_XML_GENERATOR_FEATURE_FLAGS,\n                xmlIn, xmlOut, null);\n    }\n\n    protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\n            XMLInputFactory xmlIn, XMLOutputFactory xmlOut,\n            String nameForTextElem)\n    {\n        super(oc);\n        _xmlParserFeatures = xpFeatures;\n        _xmlGeneratorFeatures = xgFeatures;\n        _cfgNameForTextElement = nameForTextElem;\n        if (xmlIn == null) {\n            xmlIn = XMLInputFactory.newInstance();\n            // as per [dataformat-xml#190], disable external entity expansion by default\n            xmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n            // and ditto wrt [dataformat-xml#211], SUPPORT_DTD\n            xmlIn.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE);\n        }\n        if (xmlOut == null) {\n            xmlOut = XMLOutputFactory.newInstance();\n        }\n        _initFactories(xmlIn, xmlOut);\n        _xmlInputFactory = xmlIn;\n        _xmlOutputFactory = xmlOut;\n    }\n\n    /**\n     * @since 2.2.1\n     */\n    protected XmlFactory(XmlFactory src, ObjectCodec oc)\n    {\n        super(src, oc);\n        _xmlParserFeatures = src._xmlParserFeatures;\n        _xmlGeneratorFeatures = src._xmlGeneratorFeatures;\n        _cfgNameForTextElement = src._cfgNameForTextElement;\n        _xmlInputFactory = src._xmlInputFactory;\n        _xmlOutputFactory = src._xmlOutputFactory;\n    }\n    \n    protected void _initFactories(XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n    {\n        // Better ensure namespaces get built properly, so:\n        xmlOut.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n        // and for parser, force coalescing as well (much simpler to use)\n        xmlIn.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);\n    }\n\n    /**\n     * Note: compared to base implementation by {@link JsonFactory},\n     * here the copy will actually share underlying XML input and\n     * output factories, as there is no way to make copies of those.\n     * \n     * @since 2.1\n     */\n    @Override\n    public XmlFactory copy() {\n        _checkInvalidCopy(XmlFactory.class);\n        return new XmlFactory(this, null);\n    }\n\n    @Override\n    public Version version() {\n        return PackageVersion.VERSION;\n    }\n\n    /*\n    /**********************************************************\n    /* Serializable overrides\n    /**********************************************************\n     */\n\n    /**\n     * Hiding place for JDK-serialization unthawed factories...\n     */\n    protected transient String _jdkXmlInFactory;\n\n    /**\n     * Hiding place for JDK-serialization unthawed factories...\n     */\n    protected transient String _jdkXmlOutFactory;\n\n    /**\n     * Method that we need to override to actually make restoration go\n     * through constructors etc.\n     */\n    @Override // since JsonFactory already implemented it\n    protected Object readResolve() {\n        if (_jdkXmlInFactory == null) {\n            throw new IllegalStateException(\"No XMLInputFactory class name read during JDK deserialization\");\n        }\n        if (_jdkXmlOutFactory == null) {\n            throw new IllegalStateException(\"No XMLOutputFactory class name read during JDK deserialization\");\n        }\n        try {\n            XMLInputFactory inf = (XMLInputFactory) Class.forName(_jdkXmlInFactory).newInstance();\n            XMLOutputFactory outf = (XMLOutputFactory) Class.forName(_jdkXmlOutFactory).newInstance();\n            return new XmlFactory(_objectCodec, _xmlParserFeatures, _xmlGeneratorFeatures,\n                    inf, outf, _cfgNameForTextElement);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalArgumentException(e);\n        } catch (InstantiationException e) {\n            throw new IllegalArgumentException(e);\n        } catch (IllegalAccessException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    /**\n     * In addition to default serialization, which mostly works, need\n     * to handle case of XML factories, hence override.\n     */\n    private void readObject(ObjectInputStream in)\n            throws IOException, ClassNotFoundException\n    {\n        in.defaultReadObject();\n        _jdkXmlInFactory = in.readUTF();\n        _jdkXmlOutFactory = in.readUTF();\n    }\n\n    /**\n     * In addition to default serialization, which mostly works, need\n     * to handle case of XML factories, hence override.\n     */\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeUTF(_xmlInputFactory.getClass().getName());\n        out.writeUTF(_xmlOutputFactory.getClass().getName());\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, XML-specific\n    /**********************************************************\n     */\n    \n    /**\n     * @since 2.1\n     */\n    public void setXMLTextElementName(String name) {\n        _cfgNameForTextElement = name;\n    }\n\n    /**\n     * @since 2.2\n     */\n    public String getXMLTextElementName() {\n        return _cfgNameForTextElement;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration, XML, parser setting\n    /**********************************************************\n     */\n\n    /**\n     * Method for enabling or disabling specified XML parser feature.\n     */\n    public final XmlFactory configure(FromXmlParser.Feature f, boolean state)\n    {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }\n\n    /**\n     * Method for enabling specified XML parser feature.\n     */\n    public XmlFactory enable(FromXmlParser.Feature f) {\n        _xmlParserFeatures |= f.getMask();\n        return this;\n    }\n\n    /**\n     * Method for disabling specified XML parser feature.\n     */\n    public XmlFactory disable(FromXmlParser.Feature f) {\n        _xmlParserFeatures &= ~f.getMask();\n        return this;\n    }\n\n    /**\n     * Checked whether specified XML parser feature is enabled.\n     */\n    public final boolean isEnabled(FromXmlParser.Feature f) {\n        return (_xmlParserFeatures & f.getMask()) != 0;\n    }\n\n    /*\n    /******************************************************\n    /* Configuration, XML, generator settings\n    /******************************************************\n     */\n\n    /**\n     * Method for enabling or disabling specified XML generator feature.\n     */\n    public final XmlFactory configure(ToXmlGenerator.Feature f, boolean state) {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }\n\n    /**\n     * Method for enabling specified XML generator feature.\n     */\n    public XmlFactory enable(ToXmlGenerator.Feature f) {\n        _xmlGeneratorFeatures |= f.getMask();\n        return this;\n    }\n\n    /**\n     * Method for disabling specified XML generator feature.\n     */\n    public XmlFactory disable(ToXmlGenerator.Feature f) {\n        _xmlGeneratorFeatures &= ~f.getMask();\n        return this;\n    }\n\n    /**\n     * Check whether specified XML generator feature is enabled.\n     */\n    public final boolean isEnabled(ToXmlGenerator.Feature f) {\n        return (_xmlGeneratorFeatures & f.getMask()) != 0;\n    }\n\n    /*\n    /**********************************************************\n    /* Additional configuration\n    /**********************************************************\n     */\n\n    /** @since 2.4 */\n    public XMLInputFactory getXMLInputFactory() {\n        return _xmlInputFactory;\n    }\n\n    public void setXMLInputFactory(XMLInputFactory f) {\n        _xmlInputFactory = f;\n    }\n\n    /** @since 2.4 */\n    public XMLOutputFactory getXMLOutputFactory() {\n        return _xmlOutputFactory;\n    }\n    \n    public void setXMLOutputFactory(XMLOutputFactory f) {\n        _xmlOutputFactory = f;\n    }\n\n    /*\n    /**********************************************************\n    /* Format detection functionality\n    /**********************************************************\n     */\n\n    /**\n     * Method that returns short textual id identifying format\n     * this factory supports.\n     *<p>\n     * Note: sub-classes should override this method; default\n     * implementation will return null for all sub-classes\n     */\n    @Override\n    public String getFormatName() {\n        return FORMAT_NAME_XML;\n    }\n\n    @Override\n    public MatchStrength hasFormat(InputAccessor acc) throws IOException {\n        return hasXMLFormat(acc);\n    }\n\n    /**\n     * XML format does require support from custom {@link ObjectCodec}\n     * (that is, {@link XmlMapper}), so need to return true here.\n     * \n     * @return True since XML format does require support from codec\n     */\n    @Override\n    public boolean requiresCustomCodec() { return true; }\n\n    /*\n    /**********************************************************\n    /* Capability introspection\n    /**********************************************************\n     */\n\n    /**\n     * As of 2.4, we do have actual capability for passing char arrays\n     * efficiently, but unfortunately\n     * have no working mechanism for recycling buffers. So we have to \n     * admit that can not make efficient use.\n     */\n    @Override\n    public boolean canUseCharArrays() { return false; }\n\n    @Override // since 2.6\n    public Class<FromXmlParser.Feature> getFormatReadFeatureType() {\n        return FromXmlParser.Feature.class;\n    }\n\n    @Override // since 2.6\n    public Class<ToXmlGenerator.Feature> getFormatWriteFeatureType() {\n        return ToXmlGenerator.Feature.class;\n    }\n\n    /*\n    /**********************************************************\n    /* Overrides of public methods: parsing\n    /**********************************************************\n     */\n\n    /**\n     * Overridden just to prevent trying to optimize access via char array;\n     * while nice idea, problem is that we don't have proper hooks to ensure\n     * that temporary buffer gets recycled; so let's just use StringReader.\n     */\n    @SuppressWarnings(\"resource\")\n    @Override\n    public JsonParser createParser(String content) throws IOException {\n        Reader r = new StringReader(content);\n        IOContext ctxt = _createContext(r, true);\n        if (_inputDecorator != null) {\n            r = _inputDecorator.decorate(ctxt, r);\n        }\n        return _createParser(r, ctxt);\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides of public methods: generation\n    /**********************************************************\n     */\n\n    @Override\n    public ToXmlGenerator createGenerator(OutputStream out) throws IOException {\n        return createGenerator(out, JsonEncoding.UTF8);\n    }\n    \n    @Override\n    public ToXmlGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException\n    {\n        // false -> we won't manage the stream unless explicitly directed to\n        IOContext ctxt = _createContext(out, false);\n        ctxt.setEncoding(enc);\n        return new ToXmlGenerator(ctxt,\n                _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, _createXmlWriter(out));\n    }\n    \n    @Override\n    public ToXmlGenerator createGenerator(Writer out) throws IOException\n    {\n        return new ToXmlGenerator(_createContext(out, false),\n                _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, _createXmlWriter(out));\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override\n    public ToXmlGenerator createGenerator(File f, JsonEncoding enc) throws IOException\n    {\n        OutputStream out = new FileOutputStream(f);\n        // true -> yes, we have to manage the stream since we created it\n        IOContext ctxt = _createContext(out, true);\n        ctxt.setEncoding(enc);\n        return new ToXmlGenerator(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, _createXmlWriter(out));\n    }\n\n    /*\n    /**********************************************************\n    /* Extended public API, mostly for XmlMapper\n    /**********************************************************\n     */\n\n    /**\n     * Factory method that wraps given {@link XMLStreamReader}, usually to allow\n     * partial data-binding.\n     * \n     * @since 2.4\n     */\n    public FromXmlParser createParser(XMLStreamReader sr) throws IOException\n    {\n        // note: should NOT move parser if already pointing to START_ELEMENT\n        if (sr.getEventType() != XMLStreamConstants.START_ELEMENT) {\n            try {\n                sr = _initializeXmlReader(sr);\n            } catch (XMLStreamException e) {\n                return StaxUtil.throwXmlAsIOException(e);\n            }\n        }\n\n        // false -> not managed\n        FromXmlParser xp = new FromXmlParser(_createContext(sr, false),\n                _generatorFeatures, _xmlGeneratorFeatures, _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    /**\n     * Factory method that wraps given {@link XMLStreamWriter}, usually to allow\n     * incremental serialization to compose large output by serializing a sequence\n     * of individual objects.\n     *\n     * @since 2.4\n     */\n    public ToXmlGenerator createGenerator(XMLStreamWriter sw) throws IOException\n    {\n        try {\n            sw = _initializeXmlWriter(sw);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        IOContext ctxt = _createContext(sw, false);\n        return new ToXmlGenerator(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sw);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal factory method overrides\n    /**********************************************************\n     */\n\n    @Override\n    protected FromXmlParser _createParser(InputStream in, IOContext ctxt) throws IOException\n    {\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(in);\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    @Override\n    protected FromXmlParser _createParser(Reader r, IOContext ctxt) throws IOException\n    {\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(r);\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    @Override\n    protected FromXmlParser _createParser(char[] data, int offset, int len, IOContext ctxt,\n            boolean recycleBuffer) throws IOException\n    {\n        // !!! TODO: add proper handling of 'recycleBuffer'; currently its handling\n        //    is always same as if 'false' was passed\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(new Stax2CharArraySource(data, offset, len));\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n    \n    @Override\n    protected FromXmlParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException\n    {\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(new Stax2ByteArraySource(data, offset, len));\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    @Override\n    protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException {\n        // this method should never get called here, so:\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal factory methods, XML-specific\n    /**********************************************************************\n     */\n\n    protected XMLStreamWriter _createXmlWriter(OutputStream out) throws IOException\n    {\n        try {\n            return _initializeXmlWriter(_xmlOutputFactory.createXMLStreamWriter(out, \"UTF-8\"));\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n    }\n\n    protected XMLStreamWriter _createXmlWriter(Writer w) throws IOException\n    {\n        try {\n            return _initializeXmlWriter(_xmlOutputFactory.createXMLStreamWriter(w));\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n    }\n\n    protected final XMLStreamWriter _initializeXmlWriter(XMLStreamWriter sw) throws IOException, XMLStreamException\n    {\n        // And just for Sun Stax parser (JDK default), seems that we better define default namespace\n        // (Woodstox doesn't care) -- otherwise it'll add unnecessary odd declaration\n        sw.setDefaultNamespace(\"\");\n        return sw;\n    }\n\n    protected final XMLStreamReader _initializeXmlReader(XMLStreamReader sr) throws IOException, XMLStreamException\n    {\n        // for now, nothing to do... except let's find the root element\n        while (sr.next() != XMLStreamConstants.START_ELEMENT) {\n            ;\n        }\n        return sr;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, format auto-detection\n    /**********************************************************************\n     */\n\n    private final static byte UTF8_BOM_1 = (byte) 0xEF;\n    private final static byte UTF8_BOM_2 = (byte) 0xBB;\n    private final static byte UTF8_BOM_3 = (byte) 0xBF;\n\n    private final static byte BYTE_x = (byte) 'x';\n    private final static byte BYTE_m = (byte) 'm';\n    private final static byte BYTE_l = (byte) 'l';\n    private final static byte BYTE_D = (byte) 'D';\n\n    private final static byte BYTE_LT = (byte) '<';\n    private final static byte BYTE_QMARK = (byte) '?';\n    private final static byte BYTE_EXCL = (byte) '!';\n    private final static byte BYTE_HYPHEN = (byte) '-';\n    \n    /**\n     * Method that tries to figure out if content seems to be in some kind\n     * of XML format.\n     * Note that implementation here is not nearly as robust as what underlying\n     * Stax parser will do; the idea is to first support common encodings,\n     * then expand as needed (for example, it is not all that hard to support\n     * UTF-16; but it is some work and not needed quite yet)\n     */\n    public static MatchStrength hasXMLFormat(InputAccessor acc) throws IOException\n    {\n        /* Basically we just need to find \"<!\", \"<?\" or \"<NAME\"... but ideally\n         * we would actually see the XML declaration\n         */\n        if (!acc.hasMoreBytes()) {\n            return MatchStrength.INCONCLUSIVE;\n        }\n        byte b = acc.nextByte();\n        // Very first thing, a UTF-8 BOM? (later improvements: other BOM's, heuristics)\n        if (b == UTF8_BOM_1) { // yes, looks like UTF-8 BOM\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            if (acc.nextByte() != UTF8_BOM_2) {\n                return MatchStrength.NO_MATCH;\n            }\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            if (acc.nextByte() != UTF8_BOM_3) {\n                return MatchStrength.NO_MATCH;\n            }\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            b = acc.nextByte();\n        }\n        // otherwise: XML declaration?\n        boolean maybeXmlDecl = (b == BYTE_LT);\n        if (!maybeXmlDecl) {\n            int ch = skipSpace(acc, b);\n            if (ch < 0) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            b = (byte) ch;\n            // If we did not get an LT, shouldn't be valid XML (minus encoding issues etc)\n           if (b != BYTE_LT) {\n                return MatchStrength.NO_MATCH;\n            }\n        }\n        if (!acc.hasMoreBytes()) {\n            return MatchStrength.INCONCLUSIVE;\n        }\n        b = acc.nextByte();\n        // Couple of choices here\n        if (b == BYTE_QMARK) { // <?\n            b = acc.nextByte();\n            if (b == BYTE_x) {\n                if (maybeXmlDecl) {\n                    if (acc.hasMoreBytes() && acc.nextByte() == BYTE_m) {\n                        if (acc.hasMoreBytes() && acc.nextByte() == BYTE_l) {\n                            return MatchStrength.FULL_MATCH;\n                        }\n                    }\n                }\n                // but even with just partial match, we ought to be fine\n                return MatchStrength.SOLID_MATCH;\n            }\n            // Ok to start with some other char too; just not xml declaration\n            if (validXmlNameStartChar(acc, b)) {\n                return MatchStrength.SOLID_MATCH;\n            }\n        } else if (b == BYTE_EXCL) {\n            /* must be <!-- comment --> or <!DOCTYPE ...>, since\n             * <![CDATA[ ]]> can NOT come outside of root\n             */\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            b = acc.nextByte();\n            if (b == BYTE_HYPHEN) {\n                if (!acc.hasMoreBytes()) {\n                    return MatchStrength.INCONCLUSIVE;\n                }\n                if (acc.nextByte() == BYTE_HYPHEN) {\n                    return MatchStrength.SOLID_MATCH;\n                }\n            } else if (b == BYTE_D) {\n                return tryMatch(acc, \"OCTYPE\", MatchStrength.SOLID_MATCH);\n            }\n        } else {\n            // maybe root element? Just needs to match first char.\n            if (validXmlNameStartChar(acc, b)) {\n                return MatchStrength.SOLID_MATCH;\n            }\n        }\n        return MatchStrength.NO_MATCH;\n    }\n\n    private final static boolean validXmlNameStartChar(InputAccessor acc, byte b)\n        throws IOException\n    {\n        /* Can make it actual real XML check in future; for now we do just crude\n         * check for ASCII range\n         */\n        int ch = (int) b & 0xFF;\n        if (ch >= 'A') { // in theory, colon could be; in practice it should never be valid (wrt namespace)\n            // This is where we'd check for multi-byte UTF-8 chars (or whatever encoding is in use)...\n            return true;\n        }\n        return false;\n    }\n    \n    private final static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength)\n        throws IOException\n    {\n        for (int i = 0, len = matchStr.length(); i < len; ++i) {\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            if (acc.nextByte() != matchStr.charAt(i)) {\n                return MatchStrength.NO_MATCH;\n            }\n        }\n        return fullMatchStrength;\n    }\n    \n    private final static int skipSpace(InputAccessor acc, byte b) throws IOException\n    {\n        while (true) {\n            int ch = (int) b & 0xFF;\n            if (!(ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t')) {\n                return ch;\n            }\n            if (!acc.hasMoreBytes()) {\n                return -1;\n            }\n            b = acc.nextByte();\n            ch = (int) b & 0xFF;\n        }\n    }\n\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-48": {
    "vul_id": "VUL4J-48",
    "cve_id": "CVE-2018-1000531",
    "project": "inversoft_prime-jwt",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=org.primeframework.jwt.VulnerabilityTest#test_unsecuredJWT_validation",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/inversoft/prime-jwt/commit/abb0d479389a2509f939452a6767dc424bb5e6ba",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/org/primeframework/jwt/JWTDecoder.java",
        "file_name": "JWTDecoder.java",
        "vulnerable_code": "/*\n * Copyright (c) 2016-2018, Inversoft Inc., All Rights Reserved\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific\n * language governing permissions and limitations under the License.\n */\n\npackage org.primeframework.jwt;\n\nimport org.primeframework.jwt.domain.Algorithm;\nimport org.primeframework.jwt.domain.Header;\nimport org.primeframework.jwt.domain.InvalidJWTException;\nimport org.primeframework.jwt.domain.InvalidJWTSignatureException;\nimport org.primeframework.jwt.domain.JWT;\nimport org.primeframework.jwt.domain.JWTExpiredException;\nimport org.primeframework.jwt.domain.JWTUnavailableForProcessingException;\nimport org.primeframework.jwt.domain.MissingVerifierException;\nimport org.primeframework.jwt.json.Mapper;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Function;\n\n/**\n * @author Daniel DeGroff\n */\npublic class JWTDecoder {\n\n  private static JWTDecoder instance;\n\n  public static JWTDecoder getInstance() {\n    if (instance == null) {\n      instance = new JWTDecoder();\n    }\n\n    return instance;\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. One more verifiers may be provided, the first verifier found\n   * supporting the algorithm reported by the JWT header will be utilized.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT The encoded JWT in string format.\n   * @param verifiers  A map of verifiers.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Verifier... verifiers) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    // An unsecured JWT will not contain a signature and should only have a header and a payload.\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n\n    // If parts.length == 2 we have no signature, if no verifiers were provided, decode if header says 'none', else throw an exception\n    if (parts.length == 2 && verifiers.length == 0) {\n      if (header.algorithm == Algorithm.none) {\n        return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n      } else {\n        throw new InvalidJWTSignatureException();\n      }\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    Verifier verifier = null;\n    for (Verifier v : verifiers) {\n      if (v.canVerify(header.algorithm)) {\n        verifier = v;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. A JWT header value named <code>kid</code> is expected to\n   * contain the key to lookup the correct verifier.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT The encoded JWT in string format.\n   * @param verifiers  A map of verifiers.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers) {\n    return decode(encodedJWT, verifiers, h -> h.get(\"kid\"));\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. The key used to lookup the correct verifier is provided by the\n   * <code>keyFunction</code>. The key function is provided the JWT header and is expected to return a string key to\n   * look up the correct verifier.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT  The encoded JWT in string format.\n   * @param verifiers   A map of verifiers.\n   * @param keyFunction A function used to lookup the verifier key from the header.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers, Function<Header, String> keyFunction) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n    Objects.requireNonNull(keyFunction);\n\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n    // If parts.length == 2 we have no signature, if no verifiers were provided, decode if header says 'none', else throw an exception\n    if (parts.length == 2 && verifiers.isEmpty()) {\n      if (header.algorithm == Algorithm.none) {\n        return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n      } else {\n        throw new InvalidJWTSignatureException();\n      }\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    String key = keyFunction.apply(header);\n    Verifier verifier = verifiers.get(key);\n    if (verifier != null) {\n      if (!verifier.canVerify(header.algorithm)) {\n        verifier = null;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  private byte[] base64Decode(byte[] bytes) {\n    try {\n      return Base64.getUrlDecoder().decode(bytes);\n    } catch (IllegalArgumentException e) {\n      throw new InvalidJWTException(\"The encoded JWT is not properly Base64 encoded.\", e);\n    }\n  }\n\n  private JWT decode(String encodedJWT, Header header, String[] parts, Verifier verifier) {\n    int index = encodedJWT.lastIndexOf(\".\");\n    // The message comprises the first two segments of the entire JWT, the signature is the last segment.\n    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);\n\n    // If a signature is provided and verifier must be provided.\n    if (parts.length == 3 && verifier == null) {\n      throw new MissingVerifierException(\"No Verifier has been provided for verify a signature signed using [\" + header.algorithm.getName() + \"]\");\n    }\n\n    // A verifier was provided but no signature exists, this is treated as an invalid signature.\n    if (parts.length == 2 && verifier != null) {\n      throw new InvalidJWTSignatureException();\n    }\n\n    if (parts.length == 3) {\n      // Verify the signature before de-serializing the payload.\n      byte[] signature = base64Decode(parts[2].getBytes(StandardCharsets.UTF_8));\n      verifier.verify(header.algorithm, message, signature);\n    }\n\n    JWT jwt = Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n\n    // Verify expiration claim\n    if (jwt.isExpired()) {\n      throw new JWTExpiredException();\n    }\n\n    // Verify the notBefore claim\n    if (jwt.isUnavailableForProcessing()) {\n      throw new JWTUnavailableForProcessingException();\n    }\n\n    return jwt;\n  }\n\n  private String[] getParts(String encodedJWT) {\n    String[] parts = encodedJWT.split(\"\\\\.\");\n    // Secured JWT XXXXX.YYYYY.ZZZZZ, Unsecured JWT XXXXX.YYYYY.\n    if (parts.length == 3 || (parts.length == 2 && encodedJWT.endsWith(\".\"))) {\n      return parts;\n    }\n\n    throw new InvalidJWTException(\"The encoded JWT is not properly formatted. Expected a three part dot separated string.\");\n  }\n}\n",
        "human_patch_code": "/*\n * Copyright (c) 2016-2018, Inversoft Inc., All Rights Reserved\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific\n * language governing permissions and limitations under the License.\n */\n\npackage org.primeframework.jwt;\n\nimport org.primeframework.jwt.domain.Algorithm;\nimport org.primeframework.jwt.domain.Header;\nimport org.primeframework.jwt.domain.InvalidJWTException;\nimport org.primeframework.jwt.domain.InvalidJWTSignatureException;\nimport org.primeframework.jwt.domain.JWT;\nimport org.primeframework.jwt.domain.JWTExpiredException;\nimport org.primeframework.jwt.domain.JWTUnavailableForProcessingException;\nimport org.primeframework.jwt.domain.MissingVerifierException;\nimport org.primeframework.jwt.json.Mapper;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Function;\n\n/**\n * @author Daniel DeGroff\n */\npublic class JWTDecoder {\n\n  private static JWTDecoder instance;\n\n  public static JWTDecoder getInstance() {\n    if (instance == null) {\n      instance = new JWTDecoder();\n    }\n\n    return instance;\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. One more verifiers may be provided, the first verifier found\n   * supporting the algorithm reported by the JWT header will be utilized.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT The encoded JWT in string format.\n   * @param verifiers  A map of verifiers.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Verifier... verifiers) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    // An unsecured JWT will not contain a signature and should only have a header and a payload.\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n\n    // If parts.length == 2 we have no signature, if no verifiers were provided, decode if header says 'none', else throw an exception\n    if (parts.length == 2 && verifiers.length == 0) {\n      if (header.algorithm == Algorithm.none) {\n        return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n      } else {\n        throw new InvalidJWTSignatureException();\n      }\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    Verifier verifier = null;\n    for (Verifier v : verifiers) {\n      if (v.canVerify(header.algorithm)) {\n        verifier = v;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. A JWT header value named <code>kid</code> is expected to\n   * contain the key to lookup the correct verifier.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT The encoded JWT in string format.\n   * @param verifiers  A map of verifiers.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers) {\n    return decode(encodedJWT, verifiers, h -> h.get(\"kid\"));\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. The key used to lookup the correct verifier is provided by the\n   * <code>keyFunction</code>. The key function is provided the JWT header and is expected to return a string key to\n   * look up the correct verifier.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT  The encoded JWT in string format.\n   * @param verifiers   A map of verifiers.\n   * @param keyFunction A function used to lookup the verifier key from the header.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers, Function<Header, String> keyFunction) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n    Objects.requireNonNull(keyFunction);\n\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n    // If parts.length == 2 we have no signature, if no verifiers were provided, decode if header says 'none', else throw an exception\n    if (parts.length == 2 && verifiers.isEmpty()) {\n      if (header.algorithm == Algorithm.none) {\n        return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n      } else {\n        throw new InvalidJWTSignatureException();\n      }\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    String key = keyFunction.apply(header);\n    Verifier verifier = verifiers.get(key);\n    if (verifier != null) {\n      if (!verifier.canVerify(header.algorithm)) {\n        verifier = null;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  private byte[] base64Decode(byte[] bytes) {\n    try {\n      return Base64.getUrlDecoder().decode(bytes);\n    } catch (IllegalArgumentException e) {\n      throw new InvalidJWTException(\"The encoded JWT is not properly Base64 encoded.\", e);\n    }\n  }\n\n  private JWT decode(String encodedJWT, Header header, String[] parts, Verifier verifier) {\n    // The callers of this decode will have already handled 'none' if it was deemed to be valid based upon\n    // the provided verifiers. At this point, if we have a 'none' algorithm specified in the header, it is invalid.\n    if (header.algorithm == Algorithm.none) {\n      throw new MissingVerifierException(\"No Verifier has been provided for verify a signature signed using [\" + header.algorithm.getName() + \"]\");\n    }\n\n    // If a signature is provided and verifier must be provided.\n    if (parts.length == 3 && verifier == null) {\n      throw new MissingVerifierException(\"No Verifier has been provided for verify a signature signed using [\" + header.algorithm.getName() + \"]\");\n    }\n\n    // A verifier was provided but no signature exists, this is treated as an invalid signature.\n    if (parts.length == 2 && verifier != null) {\n      throw new InvalidJWTSignatureException();\n    }\n\n    int index = encodedJWT.lastIndexOf(\".\");\n    // The message comprises the first two segments of the entire JWT, the signature is the last segment.\n    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);\n\n    if (parts.length == 3) {\n      // Verify the signature before de-serializing the payload.\n      byte[] signature = base64Decode(parts[2].getBytes(StandardCharsets.UTF_8));\n      verifier.verify(header.algorithm, message, signature);\n    }\n\n    JWT jwt = Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n\n    // Verify expiration claim\n    if (jwt.isExpired()) {\n      throw new JWTExpiredException();\n    }\n\n    // Verify the notBefore claim\n    if (jwt.isUnavailableForProcessing()) {\n      throw new JWTUnavailableForProcessingException();\n    }\n\n    return jwt;\n  }\n\n  private String[] getParts(String encodedJWT) {\n    String[] parts = encodedJWT.split(\"\\\\.\");\n    // Secured JWT XXXXX.YYYYY.ZZZZZ, Unsecured JWT XXXXX.YYYYY.\n    if (parts.length == 3 || (parts.length == 2 && encodedJWT.endsWith(\".\"))) {\n      return parts;\n    }\n\n    throw new InvalidJWTException(\"The encoded JWT is not properly formatted. Expected a three part dot separated string.\");\n  }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-49": {
    "vul_id": "VUL4J-49",
    "cve_id": "CVE-2018-1000125",
    "project": "inversoft_prime-jwt",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=org.primeframework.jwt.JWTTest#test_SingedWithoutSignature",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/inversoft/prime-jwt/commit/0d94dcef0133d699f21d217e922564adbb83a227",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/org/primeframework/jwt/JWTDecoder.java",
        "file_name": "JWTDecoder.java",
        "vulnerable_code": "/*\n * Copyright (c) 2016-2018, Inversoft Inc., All Rights Reserved\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific\n * language governing permissions and limitations under the License.\n */\n\npackage org.primeframework.jwt;\n\nimport org.primeframework.jwt.domain.Algorithm;\nimport org.primeframework.jwt.domain.Header;\nimport org.primeframework.jwt.domain.InvalidJWTException;\nimport org.primeframework.jwt.domain.JWT;\nimport org.primeframework.jwt.domain.JWTExpiredException;\nimport org.primeframework.jwt.domain.JWTUnavailableForProcessingException;\nimport org.primeframework.jwt.domain.MissingVerifierException;\nimport org.primeframework.jwt.json.Mapper;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Function;\n\n/**\n * @author Daniel DeGroff\n */\npublic class JWTDecoder {\n\n  private static JWTDecoder instance;\n\n  public static JWTDecoder getInstance() {\n    if (instance == null) {\n      instance = new JWTDecoder();\n    }\n\n    return instance;\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. One more verifiers may be provided, the first verifier found\n   * supporting the algorithm reported by the JWT header will be utilized.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT The encoded JWT in string format.\n   * @param verifiers  A map of verifiers.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Verifier... verifiers) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    // An unsecured JWT will not contain a signature and should only have a header and a payload.\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n\n    // Be particular about decoding an unsecured JWT. If the JWT is signed or any verifiers were provided don't do it.\n    if (header.algorithm == Algorithm.none && parts.length == 2 && verifiers.length == 0) {\n      return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    Verifier verifier = null;\n    for (Verifier v : verifiers) {\n      if (v.canVerify(header.algorithm)) {\n        verifier = v;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. A JWT header value named <code>kid</code> is expected to\n   * contain the key to lookup the correct verifier.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT The encoded JWT in string format.\n   * @param verifiers  A map of verifiers.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers) {\n    return decode(encodedJWT, verifiers, h -> h.get(\"kid\"));\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. The key used to lookup the correct verifier is provided by the\n   * <code>keyFunction</code>. The key function is provided the JWT header and is expected to return a string key to\n   * look up the correct verifier.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT  The encoded JWT in string format.\n   * @param verifiers   A map of verifiers.\n   * @param keyFunction A function used to lookup the verifier key from the header.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers, Function<Header, String> keyFunction) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n    // Be particular about decoding an unsecured JWT. If the JWT is signed or any verifiers were provided don't do it.\n    if (header.algorithm == Algorithm.none && parts.length == 2 && verifiers.isEmpty()) {\n      return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    String key = keyFunction.apply(header);\n    Verifier verifier = verifiers.get(key);\n    if (verifier != null) {\n      if (!verifier.canVerify(header.algorithm)) {\n        verifier = null;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  private byte[] base64Decode(byte[] bytes) {\n    try {\n      return Base64.getUrlDecoder().decode(bytes);\n    } catch (IllegalArgumentException e) {\n      throw new InvalidJWTException(\"The encoded JWT is not properly Base64 encoded.\", e);\n    }\n  }\n\n  private JWT decode(String encodedJWT, Header header, String[] parts, Verifier verifier) {\n    int index = encodedJWT.lastIndexOf(\".\");\n    // The message comprises the first two segments of the entire JWT, the signature is the last segment.\n    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);\n\n    // If a signature is provided and verifier must be provided.\n    if (parts.length == 3 && verifier == null) {\n      throw new MissingVerifierException(\"No Verifier has been provided for verify a signature signed using [\" + header.algorithm.getName() + \"]\");\n    }\n\n    if (parts.length == 3) {\n      // Verify the signature before de-serializing the payload.\n      byte[] signature = base64Decode(parts[2].getBytes(StandardCharsets.UTF_8));\n      verifier.verify(header.algorithm, message, signature);\n    }\n\n    JWT jwt = Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n\n    // Verify expiration claim\n    if (jwt.isExpired()) {\n      throw new JWTExpiredException();\n    }\n\n    // Verify the notBefore claim\n    if (jwt.isUnavailableForProcessing()) {\n      throw new JWTUnavailableForProcessingException();\n    }\n\n    return jwt;\n  }\n\n  private String[] getParts(String encodedJWT) {\n    String[] parts = encodedJWT.split(\"\\\\.\");\n    // Secured JWT XXXXX.YYYYY.ZZZZZ, Unsecured JWT XXXXX.YYYYY.\n    if (parts.length == 3 || (parts.length == 2 && encodedJWT.endsWith(\".\"))) {\n      return parts;\n    }\n\n    throw new InvalidJWTException(\"The encoded JWT is not properly formatted. Expected a three part dot separated string.\");\n  }\n}\n",
        "human_patch_code": "/*\n * Copyright (c) 2016-2018, Inversoft Inc., All Rights Reserved\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific\n * language governing permissions and limitations under the License.\n */\n\npackage org.primeframework.jwt;\n\nimport org.primeframework.jwt.domain.Algorithm;\nimport org.primeframework.jwt.domain.Header;\nimport org.primeframework.jwt.domain.InvalidJWTException;\nimport org.primeframework.jwt.domain.InvalidJWTSignatureException;\nimport org.primeframework.jwt.domain.JWT;\nimport org.primeframework.jwt.domain.JWTExpiredException;\nimport org.primeframework.jwt.domain.JWTUnavailableForProcessingException;\nimport org.primeframework.jwt.domain.MissingVerifierException;\nimport org.primeframework.jwt.json.Mapper;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Function;\n\n/**\n * @author Daniel DeGroff\n */\npublic class JWTDecoder {\n\n  private static JWTDecoder instance;\n\n  public static JWTDecoder getInstance() {\n    if (instance == null) {\n      instance = new JWTDecoder();\n    }\n\n    return instance;\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. One more verifiers may be provided, the first verifier found\n   * supporting the algorithm reported by the JWT header will be utilized.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT The encoded JWT in string format.\n   * @param verifiers  A map of verifiers.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Verifier... verifiers) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    // An unsecured JWT will not contain a signature and should only have a header and a payload.\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n\n    // If parts.length == 2 we have no signature, if no verifiers were provided, decode if header says 'none', else throw an exception\n    if (parts.length == 2 && verifiers.length == 0) {\n      if (header.algorithm == Algorithm.none) {\n        return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n      } else {\n        throw new InvalidJWTSignatureException();\n      }\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    Verifier verifier = null;\n    for (Verifier v : verifiers) {\n      if (v.canVerify(header.algorithm)) {\n        verifier = v;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. A JWT header value named <code>kid</code> is expected to\n   * contain the key to lookup the correct verifier.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT The encoded JWT in string format.\n   * @param verifiers  A map of verifiers.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers) {\n    return decode(encodedJWT, verifiers, h -> h.get(\"kid\"));\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. The key used to lookup the correct verifier is provided by the\n   * <code>keyFunction</code>. The key function is provided the JWT header and is expected to return a string key to\n   * look up the correct verifier.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT  The encoded JWT in string format.\n   * @param verifiers   A map of verifiers.\n   * @param keyFunction A function used to lookup the verifier key from the header.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers, Function<Header, String> keyFunction) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n    // If parts.length == 2 we have no signature, if no verifiers were provided, decode if header says 'none', else throw an exception\n    if (parts.length == 2 && verifiers.isEmpty()) {\n      if (header.algorithm == Algorithm.none) {\n        return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n      } else {\n        throw new InvalidJWTSignatureException();\n      }\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    String key = keyFunction.apply(header);\n    Verifier verifier = verifiers.get(key);\n    if (verifier != null) {\n      if (!verifier.canVerify(header.algorithm)) {\n        verifier = null;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  private byte[] base64Decode(byte[] bytes) {\n    try {\n      return Base64.getUrlDecoder().decode(bytes);\n    } catch (IllegalArgumentException e) {\n      throw new InvalidJWTException(\"The encoded JWT is not properly Base64 encoded.\", e);\n    }\n  }\n\n  private JWT decode(String encodedJWT, Header header, String[] parts, Verifier verifier) {\n    int index = encodedJWT.lastIndexOf(\".\");\n    // The message comprises the first two segments of the entire JWT, the signature is the last segment.\n    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);\n\n    // If a signature is provided and verifier must be provided.\n    if (parts.length == 3 && verifier == null) {\n      throw new MissingVerifierException(\"No Verifier has been provided for verify a signature signed using [\" + header.algorithm.getName() + \"]\");\n    }\n\n    // A verifier was provided but no signature exists, this is treated as an invalid signature.\n    if (parts.length == 2 && verifier != null) {\n      throw new InvalidJWTSignatureException();\n    }\n\n    if (parts.length == 3) {\n      // Verify the signature before de-serializing the payload.\n      byte[] signature = base64Decode(parts[2].getBytes(StandardCharsets.UTF_8));\n      verifier.verify(header.algorithm, message, signature);\n    }\n\n    JWT jwt = Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n\n    // Verify expiration claim\n    if (jwt.isExpired()) {\n      throw new JWTExpiredException();\n    }\n\n    // Verify the notBefore claim\n    if (jwt.isUnavailableForProcessing()) {\n      throw new JWTUnavailableForProcessingException();\n    }\n\n    return jwt;\n  }\n\n  private String[] getParts(String encodedJWT) {\n    String[] parts = encodedJWT.split(\"\\\\.\");\n    // Secured JWT XXXXX.YYYYY.ZZZZZ, Unsecured JWT XXXXX.YYYYY.\n    if (parts.length == 3 || (parts.length == 2 && encodedJWT.endsWith(\".\"))) {\n      return parts;\n    }\n\n    throw new InvalidJWTException(\"The encoded JWT is not properly formatted. Expected a three part dot separated string.\");\n  }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-50": {
    "vul_id": "VUL4J-50",
    "cve_id": "CVE-2013-4378",
    "project": "javamelody_javamelody",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl javamelody-core -Dtest=net.bull.javamelody.TestHtmlSessionInformationsReport#testCVE_2013_4378",
    "test_all_cmd": "mvn test -pl javamelody-core",
    "human_patch_url": "https://github.com/javamelody/javamelody/commit/aacbc46151ff4ac1ca34ce0899c2a6113071c66e",
    "vulnerable_files": [
      {
        "file_path": "javamelody-core/src/main/java/net/bull/javamelody/HtmlSessionInformationsReport.java",
        "file_name": "HtmlSessionInformationsReport.java",
        "vulnerable_code": "/*\n * Copyright 2008-2012 by Emeric Vernat\n *\n *     This file is part of Java Melody.\n *\n * Java Melody is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Java Melody is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Java Melody.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage net.bull.javamelody;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.text.DateFormat;\nimport java.text.DecimalFormat;\nimport java.util.Collections;\nimport java.util.List;\n\nimport net.bull.javamelody.SessionInformations.SessionAttribute;\n\n/**\n * Partie du rapport html pour les sessions http.\n * @author Emeric Vernat\n */\nclass HtmlSessionInformationsReport extends HtmlAbstractReport {\n\tprivate static final String A_HREF_PART_SESSIONS = \"<a href='?part=sessions\";\n\tprivate final List<SessionInformations> sessionsInformations;\n\tprivate final DecimalFormat integerFormat = I18N.createIntegerFormat();\n\tprivate final DateFormat durationFormat = I18N.createDurationFormat();\n\tprivate final DateFormat expiryFormat = I18N.createDateAndTimeFormat();\n\n\tHtmlSessionInformationsReport(List<SessionInformations> sessionsInformations, Writer writer) {\n\t\tsuper(writer);\n\t\tthis.sessionsInformations = sessionsInformations;\n\t}\n\n\t@Override\n\tvoid toHtml() throws IOException {\n\t\twriteBackAndRefreshLinks();\n\t\twriteln(\"<br/>\");\n\n\t\tassert sessionsInformations != null;\n\t\tif (sessionsInformations.isEmpty()) {\n\t\t\twriteln(\"#Aucune_session#\");\n\t\t\treturn;\n\t\t}\n\t\twriteTitle(\"system-users.png\", getString(\"Sessions\"));\n\t\twriteSessions(sessionsInformations);\n\t\tlong totalSerializedSize = 0;\n\t\tint nbSerializableSessions = 0;\n\t\tfor (final SessionInformations sessionInformations : sessionsInformations) {\n\t\t\tfinal int size = sessionInformations.getSerializedSize();\n\t\t\tif (size >= 0) {\n\t\t\t\ttotalSerializedSize += size;\n\t\t\t\tnbSerializableSessions++;\n\t\t\t}\n\t\t}\n\t\tfinal long meanSerializedSize;\n\t\tif (nbSerializableSessions > 0) {\n\t\t\tmeanSerializedSize = totalSerializedSize / nbSerializableSessions;\n\t\t} else {\n\t\t\tmeanSerializedSize = -1;\n\t\t}\n\t\twriteln(\"<div align='right'>\"\n\t\t\t\t+ getFormattedString(\"nb_sessions\", sessionsInformations.size()) + \"<br/><br/>\"\n\t\t\t\t+ getFormattedString(\"taille_moyenne_sessions\", meanSerializedSize) + \"</div>\");\n\t}\n\n\tprivate void writeSessions(List<SessionInformations> sessions) throws IOException {\n\t\tboolean displayUser = false;\n\t\tfor (final SessionInformations sessionInformations : sessions) {\n\t\t\tif (sessionInformations.getRemoteUser() != null) {\n\t\t\t\tdisplayUser = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfinal HtmlTable table = new HtmlTable();\n\t\ttable.beginTable(getString(\"Sessions\"));\n\t\twrite(\"<th>#Session_id#</th><th class='sorttable_numeric'>#Dernier_acces#</th>\");\n\t\twrite(\"<th class='sorttable_numeric'>#Age#</th><th class='sorttable_date'>#Expiration#</th>\");\n\t\twrite(\"<th class='sorttable_numeric'>#Nb_attributs#</th><th>#Serialisable#</th><th>#Taille_serialisee#</th>\");\n\t\twrite(\"<th class='sorttable_numeric'>#Adresse_IP#</th><th>#Pays#</th>\");\n\t\tif (displayUser) {\n\t\t\twrite(\"<th>#Utilisateur#</th>\");\n\t\t}\n\t\twrite(\"<th class='noPrint'>#Invalider#</th>\");\n\t\tfor (final SessionInformations session : sessions) {\n\t\t\ttable.nextRow();\n\t\t\twriteSession(session, displayUser);\n\t\t}\n\t\ttable.endTable();\n\t}\n\n\tprivate void writeBackAndRefreshLinks() throws IOException {\n\t\twriteln(\"<div class='noPrint'>\");\n\t\twriteln(\"<a href='javascript:history.back()'>\");\n\t\twriteln(\"<img src='?resource=action_back.png' alt='#Retour#'/> #Retour#</a>\");\n\t\twriteln(\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\");\n\t\twriteln(A_HREF_PART_SESSIONS + \"'>\");\n\t\twriteln(\"<img src='?resource=action_refresh.png' alt='#Actualiser#'/> #Actualiser#</a>\");\n\t\tif (isPdfEnabled()) {\n\t\t\twriteln(\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\");\n\t\t\twrite(A_HREF_PART_SESSIONS + \"&amp;format=pdf' title='#afficher_PDF#'>\");\n\t\t\twrite(\"<img src='?resource=pdf.png' alt='#PDF#'/> #PDF#</a>\");\n\t\t}\n\t\twriteln(\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\");\n\t\twriteln(A_HREF_PART_SESSIONS\n\t\t\t\t+ \"&amp;action=invalidate_sessions' onclick=\\\"javascript:return confirm('\"\n\t\t\t\t+ getStringForJavascript(\"confirm_invalidate_sessions\") + \"');\\\">\");\n\t\twriteln(\"<img width='16' height='16' src='?resource=user-trash.png' alt='#invalidate_sessions#' title='#invalidate_sessions#' /> #invalidate_sessions#</a>\");\n\t\twriteln(\"</div>\");\n\t}\n\n\tprivate void writeBackAndRefreshLinksForSession(String sessionId) throws IOException {\n\t\twriteln(\"<div class='noPrint'>\");\n\t\twriteln(\"<a href='javascript:history.back()'><img src='?resource=action_back.png' alt='#Retour#'/> #Retour#</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\");\n\t\twriteln(A_HREF_PART_SESSIONS + \"&amp;sessionId=\" + urlEncode(sessionId) + \"'>\");\n\t\twriteln(\"<img src='?resource=action_refresh.png' alt='#Actualiser#'/> #Actualiser#</a>\");\n\t\twriteln(\"</div>\");\n\t}\n\n\tprivate void writeSession(SessionInformations session, boolean displayUser) throws IOException {\n\t\tfinal String nextColumnAlignRight = \"</td><td align='right'>\";\n\t\tfinal String nextColumnAlignCenter = \"</td><td align='center'>\";\n\t\twrite(\"<td><a href='?part=sessions&amp;sessionId=\");\n\t\twrite(htmlEncodeButNotSpace(session.getId()));\n\t\twrite(\"'>\");\n\t\twrite(htmlEncodeButNotSpace(session.getId()));\n\t\twrite(\"</a>\");\n\t\twrite(nextColumnAlignRight);\n\t\twrite(durationFormat.format(session.getLastAccess()));\n\t\twrite(nextColumnAlignRight);\n\t\twrite(durationFormat.format(session.getAge()));\n\t\twrite(nextColumnAlignRight);\n\t\twrite(expiryFormat.format(session.getExpirationDate()));\n\n\t\twrite(nextColumnAlignRight);\n\t\twrite(integerFormat.format(session.getAttributeCount()));\n\t\twrite(nextColumnAlignCenter);\n\t\tif (session.isSerializable()) {\n\t\t\twrite(\"#oui#\");\n\t\t} else {\n\t\t\twrite(\"<span class='severe'>#non#</span>\");\n\t\t}\n\t\twrite(nextColumnAlignRight);\n\t\twrite(integerFormat.format(session.getSerializedSize()));\n\t\tfinal String nextColumn = \"</td><td>\";\n\t\twrite(nextColumn);\n\t\tfinal String remoteAddr = session.getRemoteAddr();\n\t\tif (remoteAddr == null) {\n\t\t\twrite(\"&nbsp;\");\n\t\t} else {\n\t\t\twrite(remoteAddr);\n\t\t}\n\t\twrite(nextColumnAlignCenter);\n\t\twriteCountry(session);\n\t\tif (displayUser) {\n\t\t\twrite(nextColumn);\n\t\t\tfinal String remoteUser = session.getRemoteUser();\n\t\t\tif (remoteUser == null) {\n\t\t\t\twrite(\"&nbsp;\");\n\t\t\t} else {\n\t\t\t\twriteDirectly(htmlEncodeButNotSpace(remoteUser));\n\t\t\t}\n\t\t}\n\t\twrite(\"</td><td align='center' class='noPrint'>\");\n\t\twrite(A_HREF_PART_SESSIONS);\n\t\twrite(\"&amp;action=invalidate_session&amp;sessionId=\");\n\t\twrite(urlEncode(session.getId()));\n\t\twrite(\"' onclick=\\\"javascript:return confirm('\"\n\t\t\t\t+ getStringForJavascript(\"confirm_invalidate_session\") + \"');\\\">\");\n\t\twrite(\"<img width='16' height='16' src='?resource=user-trash.png' alt='#invalidate_session#' title='#invalidate_session#' />\");\n\t\twrite(\"</a>\");\n\t\twrite(\"</td>\");\n\t}\n\n\tprivate void writeCountry(SessionInformations session) throws IOException {\n\t\tfinal String country = session.getCountry();\n\t\tif (country == null) {\n\t\t\twrite(\"&nbsp;\");\n\t\t} else {\n\t\t\tfinal String fileName = \"flags/\" + country + \".gif\";\n\t\t\tif (getClass().getResource(Parameters.getResourcePath(fileName)) == null) {\n\t\t\t\twrite(country);\n\t\t\t} else {\n\t\t\t\twrite(\"<img src='?resource=\");\n\t\t\t\twrite(fileName);\n\t\t\t\twrite(\"' alt='\");\n\t\t\t\twrite(country);\n\t\t\t\twrite(\"' title='\");\n\t\t\t\twrite(session.getCountryDisplay());\n\t\t\t\twrite(\"' />\");\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid writeSessionDetails(String sessionId, SessionInformations sessionInformations)\n\t\t\tthrows IOException {\n\t\twriteBackAndRefreshLinksForSession(sessionId);\n\t\twriteln(\"<br/>\");\n\n\t\tif (sessionInformations == null) {\n\t\t\twriteln(getFormattedString(\"session_invalidee\", htmlEncodeButNotSpace(sessionId)));\n\t\t\treturn;\n\t\t}\n\t\twriteTitle(\"system-users.png\",\n\t\t\t\tgetFormattedString(\"Details_session\", htmlEncodeButNotSpace(sessionId)));\n\t\twriteSessions(Collections.singletonList(sessionInformations));\n\n\t\twriteln(\"<br/><b>#Attributs#</b>\");\n\t\twriteSessionAttributes(sessionInformations);\n\t}\n\n\tprivate void writeSessionAttributes(SessionInformations sessionInformations) throws IOException {\n\t\tfinal HtmlTable table = new HtmlTable();\n\t\ttable.beginTable(getString(\"Attributs\"));\n\t\twrite(\"<th>#Nom#</th><th>Type</th><th>#Serialisable#</th><th>#Taille_serialisee#</th><th>#Contenu#</th>\");\n\t\tfor (final SessionAttribute sessionAttribute : sessionInformations.getAttributes()) {\n\t\t\ttable.nextRow();\n\t\t\twriteAttribute(sessionAttribute);\n\t\t}\n\t\ttable.endTable();\n\t}\n\n\tprivate void writeAttribute(SessionAttribute sessionAttribute) throws IOException {\n\t\twrite(\"<td>\");\n\t\twriteDirectly(htmlEncodeButNotSpace(sessionAttribute.getName()));\n\t\twrite(\"</td><td>\");\n\t\twrite(String.valueOf(sessionAttribute.getType()));\n\t\twrite(\"</td><td align='center'>\");\n\t\tif (sessionAttribute.isSerializable()) {\n\t\t\twrite(\"#oui#\");\n\t\t} else {\n\t\t\twrite(\"<span class='severe'>#non#</span>\");\n\t\t}\n\t\twrite(\"</td><td align='right'>\");\n\t\twrite(integerFormat.format(sessionAttribute.getSerializedSize()));\n\t\twrite(\"</td><td>\");\n\t\twriteDirectly(htmlEncodeButNotSpace(String.valueOf(sessionAttribute.getContent())));\n\t\twrite(\"</td>\");\n\t}\n}\n",
        "human_patch_code": "/*\r\n * Copyright 2008-2012 by Emeric Vernat\r\n *\r\n *     This file is part of Java Melody.\r\n *\r\n * Java Melody is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * Java Melody is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with Java Melody.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage net.bull.javamelody;\r\n\r\nimport java.io.IOException;\r\nimport java.io.Writer;\r\nimport java.text.DateFormat;\r\nimport java.text.DecimalFormat;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\nimport net.bull.javamelody.SessionInformations.SessionAttribute;\r\n\r\n/**\r\n * Partie du rapport html pour les sessions http.\r\n * @author Emeric Vernat\r\n */\r\nclass HtmlSessionInformationsReport extends HtmlAbstractReport {\r\n\tprivate static final String A_HREF_PART_SESSIONS = \"<a href='?part=sessions\";\r\n\tprivate final List<SessionInformations> sessionsInformations;\r\n\tprivate final DecimalFormat integerFormat = I18N.createIntegerFormat();\r\n\tprivate final DateFormat durationFormat = I18N.createDurationFormat();\r\n\tprivate final DateFormat expiryFormat = I18N.createDateAndTimeFormat();\r\n\r\n\tHtmlSessionInformationsReport(List<SessionInformations> sessionsInformations, Writer writer) {\r\n\t\tsuper(writer);\r\n\t\tthis.sessionsInformations = sessionsInformations;\r\n\t}\r\n\r\n\t@Override\r\n\tvoid toHtml() throws IOException {\r\n\t\twriteBackAndRefreshLinks();\r\n\t\twriteln(\"<br/>\");\r\n\r\n\t\tassert sessionsInformations != null;\r\n\t\tif (sessionsInformations.isEmpty()) {\r\n\t\t\twriteln(\"#Aucune_session#\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\twriteTitle(\"system-users.png\", getString(\"Sessions\"));\r\n\t\twriteSessions(sessionsInformations);\r\n\t\tlong totalSerializedSize = 0;\r\n\t\tint nbSerializableSessions = 0;\r\n\t\tfor (final SessionInformations sessionInformations : sessionsInformations) {\r\n\t\t\tfinal int size = sessionInformations.getSerializedSize();\r\n\t\t\tif (size >= 0) {\r\n\t\t\t\ttotalSerializedSize += size;\r\n\t\t\t\tnbSerializableSessions++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfinal long meanSerializedSize;\r\n\t\tif (nbSerializableSessions > 0) {\r\n\t\t\tmeanSerializedSize = totalSerializedSize / nbSerializableSessions;\r\n\t\t} else {\r\n\t\t\tmeanSerializedSize = -1;\r\n\t\t}\r\n\t\twriteln(\"<div align='right'>\"\r\n\t\t\t\t+ getFormattedString(\"nb_sessions\", sessionsInformations.size()) + \"<br/><br/>\"\r\n\t\t\t\t+ getFormattedString(\"taille_moyenne_sessions\", meanSerializedSize) + \"</div>\");\r\n\t}\r\n\r\n\tprivate void writeSessions(List<SessionInformations> sessions) throws IOException {\r\n\t\tboolean displayUser = false;\r\n\t\tfor (final SessionInformations sessionInformations : sessions) {\r\n\t\t\tif (sessionInformations.getRemoteUser() != null) {\r\n\t\t\t\tdisplayUser = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfinal HtmlTable table = new HtmlTable();\r\n\t\ttable.beginTable(getString(\"Sessions\"));\r\n\t\twrite(\"<th>#Session_id#</th><th class='sorttable_numeric'>#Dernier_acces#</th>\");\r\n\t\twrite(\"<th class='sorttable_numeric'>#Age#</th><th class='sorttable_date'>#Expiration#</th>\");\r\n\t\twrite(\"<th class='sorttable_numeric'>#Nb_attributs#</th><th>#Serialisable#</th><th>#Taille_serialisee#</th>\");\r\n\t\twrite(\"<th class='sorttable_numeric'>#Adresse_IP#</th><th>#Pays#</th>\");\r\n\t\tif (displayUser) {\r\n\t\t\twrite(\"<th>#Utilisateur#</th>\");\r\n\t\t}\r\n\t\twrite(\"<th class='noPrint'>#Invalider#</th>\");\r\n\t\tfor (final SessionInformations session : sessions) {\r\n\t\t\ttable.nextRow();\r\n\t\t\twriteSession(session, displayUser);\r\n\t\t}\r\n\t\ttable.endTable();\r\n\t}\r\n\r\n\tprivate void writeBackAndRefreshLinks() throws IOException {\r\n\t\twriteln(\"<div class='noPrint'>\");\r\n\t\twriteln(\"<a href='javascript:history.back()'>\");\r\n\t\twriteln(\"<img src='?resource=action_back.png' alt='#Retour#'/> #Retour#</a>\");\r\n\t\twriteln(\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\");\r\n\t\twriteln(A_HREF_PART_SESSIONS + \"'>\");\r\n\t\twriteln(\"<img src='?resource=action_refresh.png' alt='#Actualiser#'/> #Actualiser#</a>\");\r\n\t\tif (isPdfEnabled()) {\r\n\t\t\twriteln(\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\");\r\n\t\t\twrite(A_HREF_PART_SESSIONS + \"&amp;format=pdf' title='#afficher_PDF#'>\");\r\n\t\t\twrite(\"<img src='?resource=pdf.png' alt='#PDF#'/> #PDF#</a>\");\r\n\t\t}\r\n\t\twriteln(\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\");\r\n\t\twriteln(A_HREF_PART_SESSIONS\r\n\t\t\t\t+ \"&amp;action=invalidate_sessions' onclick=\\\"javascript:return confirm('\"\r\n\t\t\t\t+ getStringForJavascript(\"confirm_invalidate_sessions\") + \"');\\\">\");\r\n\t\twriteln(\"<img width='16' height='16' src='?resource=user-trash.png' alt='#invalidate_sessions#' title='#invalidate_sessions#' /> #invalidate_sessions#</a>\");\r\n\t\twriteln(\"</div>\");\r\n\t}\r\n\r\n\tprivate void writeBackAndRefreshLinksForSession(String sessionId) throws IOException {\r\n\t\twriteln(\"<div class='noPrint'>\");\r\n\t\twriteln(\"<a href='javascript:history.back()'><img src='?resource=action_back.png' alt='#Retour#'/> #Retour#</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\");\r\n\t\twriteln(A_HREF_PART_SESSIONS + \"&amp;sessionId=\" + urlEncode(sessionId) + \"'>\");\r\n\t\twriteln(\"<img src='?resource=action_refresh.png' alt='#Actualiser#'/> #Actualiser#</a>\");\r\n\t\twriteln(\"</div>\");\r\n\t}\r\n\r\n\tprivate void writeSession(SessionInformations session, boolean displayUser) throws IOException {\r\n\t\tfinal String nextColumnAlignRight = \"</td><td align='right'>\";\r\n\t\tfinal String nextColumnAlignCenter = \"</td><td align='center'>\";\r\n\t\twrite(\"<td><a href='?part=sessions&amp;sessionId=\");\r\n\t\twrite(htmlEncodeButNotSpace(session.getId()));\r\n\t\twrite(\"'>\");\r\n\t\twrite(htmlEncodeButNotSpace(session.getId()));\r\n\t\twrite(\"</a>\");\r\n\t\twrite(nextColumnAlignRight);\r\n\t\twrite(durationFormat.format(session.getLastAccess()));\r\n\t\twrite(nextColumnAlignRight);\r\n\t\twrite(durationFormat.format(session.getAge()));\r\n\t\twrite(nextColumnAlignRight);\r\n\t\twrite(expiryFormat.format(session.getExpirationDate()));\r\n\r\n\t\twrite(nextColumnAlignRight);\r\n\t\twrite(integerFormat.format(session.getAttributeCount()));\r\n\t\twrite(nextColumnAlignCenter);\r\n\t\tif (session.isSerializable()) {\r\n\t\t\twrite(\"#oui#\");\r\n\t\t} else {\r\n\t\t\twrite(\"<span class='severe'>#non#</span>\");\r\n\t\t}\r\n\t\twrite(nextColumnAlignRight);\r\n\t\twrite(integerFormat.format(session.getSerializedSize()));\r\n\t\tfinal String nextColumn = \"</td><td>\";\r\n\t\twrite(nextColumn);\r\n\t\tfinal String remoteAddr = session.getRemoteAddr();\r\n\t\tif (remoteAddr == null) {\r\n\t\t\twrite(\"&nbsp;\");\r\n\t\t} else {\r\n\t\t\twrite(htmlEncodeButNotSpace(remoteAddr));\r\n\t\t}\r\n\t\twrite(nextColumnAlignCenter);\r\n\t\twriteCountry(session);\r\n\t\tif (displayUser) {\r\n\t\t\twrite(nextColumn);\r\n\t\t\tfinal String remoteUser = session.getRemoteUser();\r\n\t\t\tif (remoteUser == null) {\r\n\t\t\t\twrite(\"&nbsp;\");\r\n\t\t\t} else {\r\n\t\t\t\twriteDirectly(htmlEncodeButNotSpace(remoteUser));\r\n\t\t\t}\r\n\t\t}\r\n\t\twrite(\"</td><td align='center' class='noPrint'>\");\r\n\t\twrite(A_HREF_PART_SESSIONS);\r\n\t\twrite(\"&amp;action=invalidate_session&amp;sessionId=\");\r\n\t\twrite(urlEncode(session.getId()));\r\n\t\twrite(\"' onclick=\\\"javascript:return confirm('\"\r\n\t\t\t\t+ getStringForJavascript(\"confirm_invalidate_session\") + \"');\\\">\");\r\n\t\twrite(\"<img width='16' height='16' src='?resource=user-trash.png' alt='#invalidate_session#' title='#invalidate_session#' />\");\r\n\t\twrite(\"</a>\");\r\n\t\twrite(\"</td>\");\r\n\t}\r\n\r\n\tprivate void writeCountry(SessionInformations session) throws IOException {\r\n\t\tfinal String country = session.getCountry();\r\n\t\tif (country == null) {\r\n\t\t\twrite(\"&nbsp;\");\r\n\t\t} else {\r\n\t\t\tfinal String fileName = \"flags/\" + country + \".gif\";\r\n\t\t\tif (getClass().getResource(Parameters.getResourcePath(fileName)) == null) {\r\n\t\t\t\twrite(country);\r\n\t\t\t} else {\r\n\t\t\t\twrite(\"<img src='?resource=\");\r\n\t\t\t\twrite(fileName);\r\n\t\t\t\twrite(\"' alt='\");\r\n\t\t\t\twrite(country);\r\n\t\t\t\twrite(\"' title='\");\r\n\t\t\t\twrite(session.getCountryDisplay());\r\n\t\t\t\twrite(\"' />\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvoid writeSessionDetails(String sessionId, SessionInformations sessionInformations)\r\n\t\t\tthrows IOException {\r\n\t\twriteBackAndRefreshLinksForSession(sessionId);\r\n\t\twriteln(\"<br/>\");\r\n\r\n\t\tif (sessionInformations == null) {\r\n\t\t\twriteln(getFormattedString(\"session_invalidee\", htmlEncodeButNotSpace(sessionId)));\r\n\t\t\treturn;\r\n\t\t}\r\n\t\twriteTitle(\"system-users.png\",\r\n\t\t\t\tgetFormattedString(\"Details_session\", htmlEncodeButNotSpace(sessionId)));\r\n\t\twriteSessions(Collections.singletonList(sessionInformations));\r\n\r\n\t\twriteln(\"<br/><b>#Attributs#</b>\");\r\n\t\twriteSessionAttributes(sessionInformations);\r\n\t}\r\n\r\n\tprivate void writeSessionAttributes(SessionInformations sessionInformations) throws IOException {\r\n\t\tfinal HtmlTable table = new HtmlTable();\r\n\t\ttable.beginTable(getString(\"Attributs\"));\r\n\t\twrite(\"<th>#Nom#</th><th>Type</th><th>#Serialisable#</th><th>#Taille_serialisee#</th><th>#Contenu#</th>\");\r\n\t\tfor (final SessionAttribute sessionAttribute : sessionInformations.getAttributes()) {\r\n\t\t\ttable.nextRow();\r\n\t\t\twriteAttribute(sessionAttribute);\r\n\t\t}\r\n\t\ttable.endTable();\r\n\t}\r\n\r\n\tprivate void writeAttribute(SessionAttribute sessionAttribute) throws IOException {\r\n\t\twrite(\"<td>\");\r\n\t\twriteDirectly(htmlEncodeButNotSpace(sessionAttribute.getName()));\r\n\t\twrite(\"</td><td>\");\r\n\t\twrite(String.valueOf(sessionAttribute.getType()));\r\n\t\twrite(\"</td><td align='center'>\");\r\n\t\tif (sessionAttribute.isSerializable()) {\r\n\t\t\twrite(\"#oui#\");\r\n\t\t} else {\r\n\t\t\twrite(\"<span class='severe'>#non#</span>\");\r\n\t\t}\r\n\t\twrite(\"</td><td align='right'>\");\r\n\t\twrite(integerFormat.format(sessionAttribute.getSerializedSize()));\r\n\t\twrite(\"</td><td>\");\r\n\t\twriteDirectly(htmlEncodeButNotSpace(String.valueOf(sessionAttribute.getContent())));\r\n\t\twrite(\"</td>\");\r\n\t}\r\n}\r\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-52": {
    "vul_id": "VUL4J-52",
    "cve_id": "CVE-2018-1000865",
    "project": "jenkinsci_groovy-sandbox",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=org.kohsuke.groovy.sandbox.FinalizerTest",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/jenkinsci/groovy-sandbox/commit/0cd7ec12b7c56cfa3167d99c5f43147ce05449d3",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/org/kohsuke/groovy/sandbox/SandboxTransformer.java",
        "file_name": "SandboxTransformer.java",
        "vulnerable_code": "package org.kohsuke.groovy.sandbox;\n\nimport groovy.lang.Script;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicReference;\nimport org.codehaus.groovy.GroovyBugError;\nimport org.codehaus.groovy.ast.ASTNode;\nimport org.codehaus.groovy.ast.ClassCodeExpressionTransformer;\nimport org.codehaus.groovy.ast.ClassHelper;\nimport org.codehaus.groovy.ast.ClassNode;\nimport org.codehaus.groovy.ast.ConstructorNode;\nimport org.codehaus.groovy.ast.FieldNode;\nimport org.codehaus.groovy.ast.MethodNode;\nimport org.codehaus.groovy.ast.Parameter;\nimport org.codehaus.groovy.ast.expr.ArgumentListExpression;\nimport org.codehaus.groovy.ast.expr.AttributeExpression;\nimport org.codehaus.groovy.ast.expr.CastExpression;\nimport org.codehaus.groovy.ast.expr.ClassExpression;\nimport org.codehaus.groovy.ast.expr.ClosureExpression;\nimport org.codehaus.groovy.ast.expr.ConstantExpression;\nimport org.codehaus.groovy.ast.expr.DeclarationExpression;\nimport org.codehaus.groovy.ast.expr.EmptyExpression;\nimport org.codehaus.groovy.ast.expr.Expression;\nimport org.codehaus.groovy.ast.expr.ListExpression;\nimport org.codehaus.groovy.ast.expr.MethodCallExpression;\nimport org.codehaus.groovy.ast.expr.MethodPointerExpression;\nimport org.codehaus.groovy.ast.expr.PostfixExpression;\nimport org.codehaus.groovy.ast.expr.PrefixExpression;\nimport org.codehaus.groovy.ast.expr.PropertyExpression;\nimport org.codehaus.groovy.ast.expr.StaticMethodCallExpression;\nimport org.codehaus.groovy.ast.expr.TupleExpression;\nimport org.codehaus.groovy.classgen.GeneratorContext;\nimport org.codehaus.groovy.control.CompilePhase;\nimport org.codehaus.groovy.control.SourceUnit;\nimport org.codehaus.groovy.control.customizers.CompilationCustomizer;\nimport org.codehaus.groovy.ast.expr.ConstructorCallExpression;\nimport org.codehaus.groovy.ast.expr.BinaryExpression;\nimport org.codehaus.groovy.runtime.ScriptBytecodeAdapter;\nimport org.codehaus.groovy.syntax.Token;\nimport org.codehaus.groovy.syntax.Types;\nimport org.codehaus.groovy.ast.expr.FieldExpression;\nimport org.codehaus.groovy.ast.expr.VariableExpression;\nimport org.kohsuke.groovy.sandbox.impl.Checker;\nimport org.kohsuke.groovy.sandbox.impl.Ops;\nimport org.kohsuke.groovy.sandbox.impl.SandboxedMethodClosure;\n\nimport static org.codehaus.groovy.ast.expr.ArgumentListExpression.EMPTY_ARGUMENTS;\nimport org.codehaus.groovy.ast.stmt.BlockStatement;\nimport org.codehaus.groovy.ast.stmt.ExpressionStatement;\nimport org.codehaus.groovy.ast.stmt.Statement;\nimport org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;\nimport static org.codehaus.groovy.syntax.Types.*;\n\n/**\n * Transforms Groovy code at compile-time to intercept when the script interacts with the outside world.\n *\n * <p>\n * Sometimes you'd like to run Groovy scripts in a sandbox environment, where you only want it to\n * access limited subset of the rest of JVM. This transformation makes that possible by letting you inspect\n * every step of the script execution when it makes method calls and property/field/array access.\n *\n * <p>\n * Once the script is transformed, every intercepted operation results in a call to {@link Checker},\n * which further forwards the call to {@link GroovyInterceptor} for inspection.\n *\n *\n * <p>\n * To use it, add it to the {@link org.codehaus.groovy.control.CompilerConfiguration}, like this:\n *\n * <pre>\n * def cc = new CompilerConfiguration()\n * cc.addCompilationCustomizers(new SandboxTransformer())\n * sh = new GroovyShell(cc)\n * </pre>\n *\n * <p>\n * By default, this code intercepts everything that can be intercepted, which are:\n * <ul>\n *     <li>Method calls (instance method and static method)\n *     <li>Object allocation (that is, a constructor call except of the form \"this(...)\" and \"super(...)\")\n *     <li>Property access (e.g., z=foo.bar, z=foo.\"bar\") and assignment (e.g., foo.bar=z, foo.\"bar\"=z)\n *     <li>Attribute access (e.g., z=foo.@bar) and assignments (e.g., foo.@bar=z)\n *     <li>Array access and assignment (z=x[y] and x[y]=z)\n * </ul>\n * <p>\n * You can disable interceptions selectively by setting respective {@code interceptXXX} flags to {@code false}.\n *\n * <p>\n * There'll be a substantial hit to the performance of the execution.\n *\n * @author Kohsuke Kawaguchi\n */\npublic class SandboxTransformer extends CompilationCustomizer {\n    /**\n     * Intercept method calls\n     */\n    boolean interceptMethodCall=true;\n    /**\n     * Intercept object instantiation by intercepting its constructor call.\n     *\n     * Note that Java byte code doesn't allow the interception of super(...) and this(...)\n     * so the object instantiation by defining and instantiating a subtype cannot be intercepted.\n     */\n    boolean interceptConstructor=true;\n    /**\n     * Intercept property access for both read \"(...).y\" and write \"(...).y=...\"\n     */\n    boolean interceptProperty=true;\n    /**\n     * Intercept array access for both read \"y=a[x]\" and write \"a[x]=y\"\n     */\n    boolean interceptArray=true;\n    /**\n     * Intercept attribute access for both read \"z=x.@y\" and write \"x.@y=z\"\n     */\n    boolean interceptAttribute=true;\n\n    public SandboxTransformer() {\n        super(CompilePhase.CANONICALIZATION);\n    }\n\n    @Override\n    public void call(final SourceUnit source, GeneratorContext context, ClassNode classNode) {\n        if (classNode == null) { // TODO is this even possible? CpsTransformer implies it is not.\n            return;\n        }\n\n        ClassCodeExpressionTransformer visitor = createVisitor(source, classNode);\n\n        processConstructors(visitor, classNode);\n        for (MethodNode m : classNode.getMethods()) {\n            visitor.visitMethod(m);\n        }\n        for (Statement s : classNode.getObjectInitializerStatements()) {\n            s.visit(visitor);\n        }\n        for (FieldNode f : classNode.getFields()) {\n            visitor.visitField(f);\n        }\n    }\n\n    /** Do not care about {@code super} calls for classes extending these types. */\n    private static final Set<String> TRIVIAL_CONSTRUCTORS = new HashSet<>(Arrays.asList(\n        Object.class.getName(),\n        Script.class.getName(),\n        \"com.cloudbees.groovy.cps.SerializableScript\",\n        \"org.jenkinsci.plugins.workflow.cps.CpsScript\"));\n    /**\n     * Apply SECURITY-582 fix to constructors.\n     */\n    public void processConstructors(final ClassCodeExpressionTransformer visitor, ClassNode classNode) {\n        ClassNode superClass = classNode.getSuperClass();\n        List<ConstructorNode> declaredConstructors = classNode.getDeclaredConstructors();\n        if (TRIVIAL_CONSTRUCTORS.contains(superClass.getName())) {\n            for (ConstructorNode c : declaredConstructors) {\n                visitor.visitMethod(c);\n            }\n        } else {\n            if (declaredConstructors.isEmpty()) {\n                ConstructorNode syntheticConstructor = new ConstructorNode(Modifier.PUBLIC, new BlockStatement());\n                declaredConstructors = Collections.singletonList(syntheticConstructor);\n                classNode.addConstructor(syntheticConstructor);\n            } else {\n                declaredConstructors = new ArrayList<>(declaredConstructors);\n            }\n            for (ConstructorNode c : declaredConstructors) {\n                Statement code = c.getCode();\n                List<Statement> body;\n                if (code instanceof BlockStatement) {\n                    body = ((BlockStatement) code).getStatements();\n                } else {\n                    body = Collections.singletonList(code);\n                }\n                TupleExpression superArgs = new TupleExpression();\n                if (!body.isEmpty() && body.get(0) instanceof ExpressionStatement && ((ExpressionStatement) body.get(0)).getExpression() instanceof ConstructorCallExpression) {\n                    ConstructorCallExpression cce = (ConstructorCallExpression) ((ExpressionStatement) body.get(0)).getExpression();\n                    if (cce.isThisCall()) { // these are fine as is\n                        visitor.visitMethod(c);\n                        continue;\n                    } else if (cce.isSuperCall()) {\n                        body = body.subList(1, body.size());\n                        superArgs = ((TupleExpression) cce.getArguments());\n                    }\n                }\n                List<Expression> thisArgs = new ArrayList<>();\n                final TupleExpression _superArgs = superArgs;\n                final AtomicReference<Expression> superArgsTransformed = new AtomicReference<>();\n                ((ScopeTrackingClassCodeExpressionTransformer) visitor).withMethod(c, new Runnable() {\n                    @Override\n                    public void run() {\n                        superArgsTransformed.set(((VisitorImpl) visitor).transformArguments(_superArgs));\n                    }\n                });\n                thisArgs.add(((VisitorImpl) visitor).makeCheckedCall(\"checkedSuperConstructor\", new ClassExpression(superClass), superArgsTransformed.get()));\n                Parameter[] origParams = c.getParameters();\n                for (Parameter p : origParams) {\n                    thisArgs.add(new VariableExpression(p));\n                }\n                c.setCode(new BlockStatement(new Statement[] {new ExpressionStatement(new ConstructorCallExpression(ClassNode.THIS, new TupleExpression(thisArgs)))}, c.getVariableScope()));\n                Parameter[] params = new Parameter[origParams.length + 1];\n                params[0] = new Parameter(new ClassNode(Checker.SuperConstructorWrapper.class), \"$scw\");\n                System.arraycopy(origParams, 0, params, 1, origParams.length);\n                List<Expression> scwArgs = new ArrayList<>();\n                int x = 0;\n                for (Expression superArg : superArgs) {\n                    scwArgs.add(/*new CastExpression(superArg.getType(), */new MethodCallExpression(new VariableExpression(\"$scw\"), \"arg\", new ConstantExpression(x++))/*)*/);\n                }\n                List<Statement> body2 = new ArrayList<>();\n                body2.add(0, new ExpressionStatement(new ConstructorCallExpression(ClassNode.SUPER, new ArgumentListExpression(scwArgs))));\n                for (final Statement s : body) {\n                    ((ScopeTrackingClassCodeExpressionTransformer) visitor).withMethod(c, new Runnable() {\n                        @Override\n                        public void run() {\n                            s.visit(visitor);\n                        }\n                    });\n                    body2.add(s);\n                }\n                ConstructorNode c2 = new ConstructorNode(Modifier.PRIVATE, params, c.getExceptions(), new BlockStatement(body2, c.getVariableScope()));\n                // perhaps more misleading than helpful: c2.setSourcePosition(c);\n                classNode.addConstructor(c2);\n            }\n        }\n    }\n\n    @Deprecated\n    public ClassCodeExpressionTransformer createVisitor(SourceUnit source) {\n        return createVisitor(source, null);\n    }\n    \n    public ClassCodeExpressionTransformer createVisitor(SourceUnit source, ClassNode clazz) {\n        return new VisitorImpl(source, clazz);\n    }\n\n    class VisitorImpl extends ScopeTrackingClassCodeExpressionTransformer {\n        private final SourceUnit sourceUnit;\n        /**\n         * Invocation/property access without the left-hand side expression (for example {@code foo()}\n         * as opposed to {@code something.foo()} means {@code this.foo()} in Java, but this is not\n         * so in Groovy.\n         *\n         * In Groovy, {@code foo()} inside a closure uses the closure object itself as the lhs value,\n         * whereas {@code this} in closure refers to a nearest enclosing non-closure object.\n         *\n         * So we cannot always expand {@code foo()} to {@code this.foo()}.\n         *\n         * To keep track of when we can expand {@code foo()} to {@code this.foo()} and when we can't,\n         * we maintain this flag as we visit the expression tree. This flag is set to true\n         * while we are visiting the body of the closure (the part between { ... }), and switched\n         * back to false as we visit inner classes.\n         *\n         * To correctly expand {@code foo()} in the closure requires an access to the closure object itself,\n         * and unfortunately Groovy doesn't seem to have any reliable way to do this. The hack I came up\n         * with is {@code asWritable().getOwner()}, but even that is subject to the method resolution rule.\n         *\n         */\n        private boolean visitingClosureBody;\n\n        /**\n         * Current class we are traversing.\n         */\n        private ClassNode clazz;\n\n        VisitorImpl(SourceUnit sourceUnit, ClassNode clazz) {\n            this.sourceUnit = sourceUnit;\n            this.clazz = clazz;\n        }\n\n        @Override\n        public void visitMethod(MethodNode node) {\n            if (clazz == null) { // compatibility\n                clazz = node.getDeclaringClass();\n            }\n            super.visitMethod(node);\n        }\n\n        /**\n         * Transforms the arguments of a call.\n         * Groovy primarily uses {@link ArgumentListExpression} for this,\n         * but the signature doesn't guarantee that. So this method takes care of that.\n         */\n        Expression transformArguments(Expression e) {\n            List<Expression> l;\n            if (e instanceof TupleExpression) {\n                List<Expression> expressions = ((TupleExpression) e).getExpressions();\n                l = new ArrayList<>(expressions.size());\n                for (Expression expression : expressions) {\n                    l.add(transform(expression));\n                }\n            } else {\n                l = Collections.singletonList(transform(e));\n            }\n\n            // checkdCall expects an array\n            return withLoc(e,new MethodCallExpression(new ListExpression(l),\"toArray\",new ArgumentListExpression()));\n        }\n        \n        Expression makeCheckedCall(String name, Expression... arguments) {\n            return new StaticMethodCallExpression(checkerClass,name,\n                new ArgumentListExpression(arguments));\n        }\n    \n        @Override\n        public Expression transform(Expression exp) {\n            Expression o = innerTransform(exp);\n            if (o!=exp) {\n                o.setSourcePosition(exp);\n            }\n            return o;\n        }\n\n        private Expression innerTransform(Expression exp) {\n            if (exp instanceof ClosureExpression) {\n                // ClosureExpression.transformExpression doesn't visit the code inside\n                ClosureExpression ce = (ClosureExpression)exp;\n                try (StackVariableSet scope = new StackVariableSet(this)) {\n                    Parameter[] parameters = ce.getParameters();\n                    if (parameters != null) {\n                        // Explicitly defined parameters, i.e., \".findAll { i -> i == 'bar' }\"\n                        if (parameters.length > 0) {\n                            for (Parameter p : parameters) {\n                                declareVariable(p);\n                            }\n                        } else {\n                            // Implicit parameter - i.e., \".findAll { it == 'bar' }\"\n                            declareVariable(new Parameter(ClassHelper.DYNAMIC_TYPE, \"it\"));\n                        }\n                    }\n                    boolean old = visitingClosureBody;\n                    visitingClosureBody = true;\n                    try {\n                        ce.getCode().visit(this);\n                    } finally {\n                        visitingClosureBody = old;\n                    }\n                }\n            }\n\n            if (exp instanceof MethodCallExpression && interceptMethodCall) {\n                // lhs.foo(arg1,arg2) => checkedCall(lhs,\"foo\",arg1,arg2)\n                // lhs+rhs => lhs.plus(rhs)\n                // Integer.plus(Integer) => DefaultGroovyMethods.plus\n                // lhs || rhs => lhs.or(rhs)\n                MethodCallExpression call = (MethodCallExpression) exp;\n\n                Expression objExp;\n                if (call.isImplicitThis() && visitingClosureBody && !isLocalVariableExpression(call.getObjectExpression()))\n                    objExp = CLOSURE_THIS;\n                else\n                    objExp = transform(call.getObjectExpression());\n\n                Expression arg1 = call.getMethod();\n                Expression arg2 = transformArguments(call.getArguments());\n\n                if (call.getObjectExpression() instanceof VariableExpression && ((VariableExpression) call.getObjectExpression()).getName().equals(\"super\")) {\n                    if (clazz == null) {\n                        throw new IllegalStateException(\"owning class not defined\");\n                    }\n                    return makeCheckedCall(\"checkedSuperCall\", new ClassExpression(clazz), objExp, arg1, arg2);\n                } else {\n                    return makeCheckedCall(\"checkedCall\",\n                            objExp,\n                            boolExp(call.isSafe()),\n                            boolExp(call.isSpreadSafe()),\n                            arg1,\n                            arg2);\n                }\n            }\n            \n            if (exp instanceof StaticMethodCallExpression && interceptMethodCall) {\n                /*\n                    Groovy doesn't use StaticMethodCallExpression as much as it could in compilation.\n                    For example, \"Math.max(1,2)\" results in a regular MethodCallExpression.\n\n                    Static import handling uses StaticMethodCallExpression, and so are some\n                    ASTTransformations like ToString,EqualsAndHashCode, etc.\n                 */\n                StaticMethodCallExpression call = (StaticMethodCallExpression) exp;\n                return makeCheckedCall(\"checkedStaticCall\",\n                            new ClassExpression(call.getOwnerType()),\n                            new ConstantExpression(call.getMethod()),\n                            transformArguments(call.getArguments())\n                    );\n            }\n\n            if (exp instanceof MethodPointerExpression && interceptMethodCall) {\n                MethodPointerExpression mpe = (MethodPointerExpression) exp;\n                return new ConstructorCallExpression(\n                        new ClassNode(SandboxedMethodClosure.class),\n                        new ArgumentListExpression(mpe.getExpression(), mpe.getMethodName())\n                );\n            }\n\n            if (exp instanceof ConstructorCallExpression && interceptConstructor) {\n                if (!((ConstructorCallExpression) exp).isSpecialCall()) {\n                    // creating a new instance, like \"new Foo(...)\"\n                    return makeCheckedCall(\"checkedConstructor\",\n                            new ClassExpression(exp.getType()),\n                            transformArguments(((ConstructorCallExpression) exp).getArguments())\n                    );\n                } else {\n                    // we can't really intercept constructor calling super(...) or this(...),\n                    // since it has to be the first method call in a constructor.\n                    // but see SECURITY-582 fix above\n                }\n            }\n\n            if (exp instanceof AttributeExpression && interceptAttribute) {\n                AttributeExpression ae = (AttributeExpression) exp;\n                return makeCheckedCall(\"checkedGetAttribute\",\n                    transform(ae.getObjectExpression()),\n                    boolExp(ae.isSafe()),\n                    boolExp(ae.isSpreadSafe()),\n                    transform(ae.getProperty())\n                );\n            }\n\n            if (exp instanceof PropertyExpression && interceptProperty) {\n                PropertyExpression pe = (PropertyExpression) exp;\n                return makeCheckedCall(\"checkedGetProperty\",\n                    transformObjectExpression(pe),\n                    boolExp(pe.isSafe()),\n                    boolExp(pe.isSpreadSafe()),\n                    transform(pe.getProperty())\n                );\n            }\n\n            if (exp instanceof VariableExpression && interceptProperty) {\n                VariableExpression vexp = (VariableExpression) exp;\n                if (isLocalVariable(vexp.getName()) || vexp.getName().equals(\"this\") || vexp.getName().equals(\"super\")) {\n                    // We don't care what sandboxed code does to itself until it starts interacting with outside world\n                    return super.transform(exp);\n                } else {\n                    // if the variable is not in-scope local variable, it gets treated as a property access with implicit this.\n                    // see AsmClassGenerator.visitVariableExpression and processClassVariable.\n                    PropertyExpression pexp = new PropertyExpression(VariableExpression.THIS_EXPRESSION, vexp.getName());\n                    pexp.setImplicitThis(true);\n                    withLoc(exp,pexp);\n                    return transform(pexp);\n                }\n            }\n\n            if (exp instanceof DeclarationExpression) {\n                handleDeclarations((DeclarationExpression) exp);\n            }\n\n            if (exp instanceof BinaryExpression) {\n                BinaryExpression be = (BinaryExpression) exp;\n                // this covers everything from a+b to a=b\n                if (ofType(be.getOperation().getType(),ASSIGNMENT_OPERATOR)) {\n                    // simple assignment like '=' as well as compound assignments like \"+=\",\"-=\", etc.\n\n                    // How we dispatch this depends on the type of left expression.\n                    // \n                    // What can be LHS?\n                    // according to AsmClassGenerator, PropertyExpression, AttributeExpression, FieldExpression, VariableExpression\n\n                    Expression lhs = be.getLeftExpression();\n                    if (lhs instanceof VariableExpression) {\n                        VariableExpression vexp = (VariableExpression) lhs;\n                        if (isLocalVariable(vexp.getName()) || vexp.getName().equals(\"this\") || vexp.getName().equals(\"super\")) {\n                            // We don't care what sandboxed code does to itself until it starts interacting with outside world\n                            return super.transform(exp);\n                        } else {\n                            // if the variable is not in-scope local variable, it gets treated as a property access with implicit this.\n                            // see AsmClassGenerator.visitVariableExpression and processClassVariable.\n                            PropertyExpression pexp = new PropertyExpression(VariableExpression.THIS_EXPRESSION, vexp.getName());\n                            pexp.setImplicitThis(true);\n                            pexp.setSourcePosition(vexp);\n\n                            lhs = pexp;\n                        }\n                    } // no else here\n                    if (lhs instanceof PropertyExpression) {\n                        PropertyExpression pe = (PropertyExpression) lhs;\n                        String name = null;\n                        if (lhs instanceof AttributeExpression) {\n                            if (interceptAttribute)\n                                name = \"checkedSetAttribute\";\n                        } else {\n                            Expression receiver = pe.getObjectExpression();\n                            if (receiver instanceof VariableExpression && ((VariableExpression) receiver).getName().equals(\"this\")) {\n                                FieldNode field = clazz != null ? clazz.getField(pe.getPropertyAsString()) : null;\n                                if (field != null) { // could also verify that it is final, but not necessary\n                                    // cf. BinaryExpression.transformExpression; super.transform(exp) transforms the LHS to checkedGetProperty\n                                    return new BinaryExpression(lhs, be.getOperation(), transform(be.getRightExpression()));\n                                } // else this is a property which we need to check\n                            }\n                            if (interceptProperty)\n                                name = \"checkedSetProperty\";\n                        }\n                        if (name==null) // not intercepting?\n                            return super.transform(exp);\n\n                        return makeCheckedCall(name,\n                                transformObjectExpression(pe),\n                                pe.getProperty(),\n                                boolExp(pe.isSafe()),\n                                boolExp(pe.isSpreadSafe()),\n                                intExp(be.getOperation().getType()),\n                                transform(be.getRightExpression())\n                        );\n                    } else\n                    if (lhs instanceof FieldExpression) {\n                        // while javadoc of FieldExpression isn't very clear,\n                        // AsmClassGenerator maps this to GETSTATIC/SETSTATIC/GETFIELD/SETFIELD access.\n                        // not sure how we can intercept this, so skipping this for now\n                        return super.transform(exp);\n                    } else\n                    if (lhs instanceof BinaryExpression) {\n                        BinaryExpression lbe = (BinaryExpression) lhs;\n                        if (lbe.getOperation().getType()==Types.LEFT_SQUARE_BRACKET && interceptArray) {// expression of the form \"x[y] = z\"\n                            return makeCheckedCall(\"checkedSetArray\",\n                                    transform(lbe.getLeftExpression()),\n                                    transform(lbe.getRightExpression()),\n                                    intExp(be.getOperation().getType()),\n                                    transform(be.getRightExpression())\n                            );\n                        }\n                    } else\n                        throw new AssertionError(\"Unexpected LHS of an assignment: \" + lhs.getClass());\n                }\n                if (be.getOperation().getType()==Types.LEFT_SQUARE_BRACKET) {// array reference\n                    if (interceptArray)\n                        return makeCheckedCall(\"checkedGetArray\",\n                                transform(be.getLeftExpression()),\n                                transform(be.getRightExpression())\n                        );\n                } else\n                if (be.getOperation().getType()==Types.KEYWORD_INSTANCEOF) {// instanceof operator\n                    return super.transform(exp);\n                } else\n                if (Ops.isLogicalOperator(be.getOperation().getType())) {\n                    return super.transform(exp);\n                } else\n                if (be.getOperation().getType()==Types.KEYWORD_IN) {// membership operator: JENKINS-28154\n                    // This requires inverted operand order:\n                    // \"a in [...]\" -> \"[...].isCase(a)\"\n                    if (interceptMethodCall)\n                        return makeCheckedCall(\"checkedCall\",\n                                transform(be.getRightExpression()),\n                                boolExp(false),\n                                boolExp(false),\n                                stringExp(\"isCase\"),\n                                transform(be.getLeftExpression())\n\n                        );\n                } else\n                if (Ops.isRegexpComparisonOperator(be.getOperation().getType())) {\n                    if (interceptMethodCall)\n                        return makeCheckedCall(\"checkedStaticCall\",\n                                classExp(ScriptBytecodeAdapterClass),\n                                stringExp(Ops.binaryOperatorMethods(be.getOperation().getType())),\n                                transform(be.getLeftExpression()),\n                                transform(be.getRightExpression())\n                        );\n                } else\n                if (Ops.isComparisionOperator(be.getOperation().getType())) {\n                    if (interceptMethodCall) {\n                        return makeCheckedCall(\"checkedComparison\",\n                                transform(be.getLeftExpression()),\n                                intExp(be.getOperation().getType()),\n                                transform(be.getRightExpression())\n                        );\n                    }\n                } else\n                if (interceptMethodCall) {\n                    // normally binary operators like a+b\n                    // TODO: check what other weird binary operators land here\n                    return makeCheckedCall(\"checkedBinaryOp\",\n                            transform(be.getLeftExpression()),\n                            intExp(be.getOperation().getType()),\n                            transform(be.getRightExpression())\n                    );\n                }\n            }\n\n            if (exp instanceof PostfixExpression) {\n                PostfixExpression pe = (PostfixExpression) exp;\n                return prefixPostfixExp(exp, pe.getExpression(), pe.getOperation(), \"Postfix\");\n            }\n            if (exp instanceof PrefixExpression) {\n                PrefixExpression pe = (PrefixExpression) exp;\n                return prefixPostfixExp(exp, pe.getExpression(), pe.getOperation(), \"Prefix\");\n            }\n\n            if (exp instanceof CastExpression) {\n                CastExpression ce = (CastExpression) exp;\n                return makeCheckedCall(\"checkedCast\",\n                        classExp(exp.getType()),\n                        transform(ce.getExpression()),\n                        boolExp(ce.isIgnoringAutoboxing()),\n                        boolExp(ce.isCoerce()),\n                        boolExp(ce.isStrict())\n                );\n            }\n\n            return super.transform(exp);\n        }\n\n        private Expression prefixPostfixExp(Expression whole, Expression atom, Token opToken, String mode) {\n            String op = opToken.getText().equals(\"++\") ? \"next\" : \"previous\";\n\n            // a[b]++\n            if (atom instanceof BinaryExpression && ((BinaryExpression) atom).getOperation().getType()==Types.LEFT_SQUARE_BRACKET && interceptArray) {\n                return makeCheckedCall(\"checked\" + mode + \"Array\",\n                        transform(((BinaryExpression) atom).getLeftExpression()),\n                        transform(((BinaryExpression) atom).getRightExpression()),\n                        stringExp(op)\n                );\n            }\n\n            // a++\n            if (atom instanceof VariableExpression) {\n                VariableExpression ve = (VariableExpression) atom;\n                if (isLocalVariable(ve.getName())) {\n                    if (mode.equals(\"Postfix\")) {\n                        // a trick to rewrite a++ without introducing a new local variable\n                        //     a++ -> [a,a=a.next()][0]\n                        return transform(withLoc(whole,new BinaryExpression(\n                                new ListExpression(Arrays.asList(\n                                    atom,\n                                    new BinaryExpression(atom, ASSIGNMENT_OP,\n                                        withLoc(atom,new MethodCallExpression(atom,op,EMPTY_ARGUMENTS)))\n                                )),\n                                new Token(Types.LEFT_SQUARE_BRACKET, \"[\", -1,-1),\n                                new ConstantExpression(0)\n                        )));\n                    } else {\n                        // ++a -> a=a.next()\n                        return transform(withLoc(whole,new BinaryExpression(atom,ASSIGNMENT_OP,\n                                withLoc(atom,new MethodCallExpression(atom,op,EMPTY_ARGUMENTS)))\n                        ));\n                    }\n                } else {\n                    // if the variable is not in-scope local variable, it gets treated as a property access with implicit this.\n                    // see AsmClassGenerator.visitVariableExpression and processClassVariable.\n                    PropertyExpression pexp = new PropertyExpression(VariableExpression.THIS_EXPRESSION, ve.getName());\n                    pexp.setImplicitThis(true);\n                    pexp.setSourcePosition(atom);\n\n                    atom = pexp;\n                    // fall through to the \"a.b++\" case below\n                }\n            }\n\n            // a.b++\n            if (atom instanceof PropertyExpression && interceptProperty) {\n                PropertyExpression pe = (PropertyExpression) atom;\n                return makeCheckedCall(\"checked\" + mode + \"Property\",\n                        transformObjectExpression(pe),\n                        pe.getProperty(),\n                        boolExp(pe.isSafe()),\n                        boolExp(pe.isSpreadSafe()),\n                        stringExp(op)\n                );\n            }\n\n            return whole;\n        }\n\n        /**\n         * Decorates an {@link ASTNode} by copying source location from another node.\n         */\n        private <T extends ASTNode> T withLoc(ASTNode src, T t) {\n            t.setSourcePosition(src);\n            return t;\n        }\n\n        /**\n         * See {@link #visitingClosureBody} for the details of what this method is about.\n         */\n        private Expression transformObjectExpression(PropertyExpression exp) {\n            if (exp.isImplicitThis() && visitingClosureBody && !isLocalVariableExpression(exp.getObjectExpression())) {\n                return CLOSURE_THIS;\n            } else {\n                return transform(exp.getObjectExpression());\n            }\n        }\n\n        private boolean isLocalVariableExpression(Expression exp) {\n            if (exp != null && exp instanceof VariableExpression) {\n                return isLocalVariable(((VariableExpression) exp).getName());\n            }\n\n            return false;\n        }\n\n        ConstantExpression boolExp(boolean v) {\n            return v ? ConstantExpression.PRIM_TRUE : ConstantExpression.PRIM_FALSE;\n        }\n\n        ConstantExpression intExp(int v) {\n            return new ConstantExpression(v,true);\n        }\n\n        ClassExpression classExp(ClassNode c) {\n            return new ClassExpression(c);\n        }\n\n        ConstantExpression stringExp(String v) {\n            return new ConstantExpression(v);\n        }\n\n        @Override\n        public void visitExpressionStatement(ExpressionStatement es) {\n            Expression exp = es.getExpression();\n            if (exp instanceof DeclarationExpression) {\n                DeclarationExpression de = (DeclarationExpression) exp;\n                Expression leftExpression = de.getLeftExpression();\n                if (leftExpression instanceof VariableExpression) {\n                    // Only cast and transform if the RHS is *not* an EmptyExpression, i.e., \"String foo;\" would not be cast/transformed.\n                    if (!(de.getRightExpression() instanceof EmptyExpression) &&\n                            mightBePositionalArgumentConstructor((VariableExpression) leftExpression)) {\n                        CastExpression ce = new CastExpression(leftExpression.getType(), de.getRightExpression());\n                        ce.setCoerce(true);\n                        es.setExpression(transform(new DeclarationExpression(leftExpression, de.getOperation(), ce)));\n                        return;\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"not supporting tuples yet\"); // cf. \"Unexpected LHS of an assignment\" above\n                }\n            }\n            super.visitExpressionStatement(es);\n        }\n\n        @Override\n        protected SourceUnit getSourceUnit() {\n            return sourceUnit;\n        }\n    }\n\n    /**\n     * Checks if a {@link DeclarationExpression#getVariableExpression} might induce {@link DefaultTypeTransformation#castToType} to call a constructor.\n     * If so, {@link Checker#checkedCast} should be run.\n     * Will be false for example if the declared type is an array, {@code abstract}, or unspecified (just {@code def}).\n     * Not yet supporting {@link DeclarationExpression#getTupleExpression} on LHS;\n     * and currently ignoring {@link DeclarationExpression#getRightExpression} though some might not possibly be arrays, {@link Collection}s, or {@link Map}s.\n     */\n    public static boolean mightBePositionalArgumentConstructor(VariableExpression ve) {\n        ClassNode type = ve.getType();\n        if (type.isArray()) {\n            return false; // do not care about componentType\n        }\n        Class clazz;\n        try {\n            clazz = type.getTypeClass();\n        } catch (GroovyBugError x) {\n            return false; // \"ClassNode#getTypeClass for \u2026 is called before the type class is set\" when assigning to a type defined in Groovy source\n        }\n        return clazz != null && clazz != Object.class && !Modifier.isAbstract(clazz.getModifiers());\n    }\n\n    static final Token ASSIGNMENT_OP = new Token(Types.ASSIGN, \"=\", -1, -1);\n\n    static final ClassNode checkerClass = new ClassNode(Checker.class);\n    static final ClassNode ScriptBytecodeAdapterClass = new ClassNode(ScriptBytecodeAdapter.class);\n\n    /**\n     * Expression that accesses the closure object itself from within the closure.\n     *\n     * Currently a hacky \"asWritable().getOwner()\"\n     */\n    static final Expression CLOSURE_THIS;\n\n    static {\n        MethodCallExpression aw = new MethodCallExpression(new VariableExpression(\"this\"),\"asWritable\",EMPTY_ARGUMENTS);\n        aw.setImplicitThis(true);\n\n        CLOSURE_THIS = new MethodCallExpression(aw,\"getOwner\",EMPTY_ARGUMENTS);\n    }\n}\n",
        "human_patch_code": "package org.kohsuke.groovy.sandbox;\n\nimport groovy.lang.Script;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicReference;\nimport org.codehaus.groovy.GroovyBugError;\nimport org.codehaus.groovy.ast.ASTNode;\nimport org.codehaus.groovy.ast.ClassCodeExpressionTransformer;\nimport org.codehaus.groovy.ast.ClassHelper;\nimport org.codehaus.groovy.ast.ClassNode;\nimport org.codehaus.groovy.ast.ConstructorNode;\nimport org.codehaus.groovy.ast.FieldNode;\nimport org.codehaus.groovy.ast.MethodNode;\nimport org.codehaus.groovy.ast.Parameter;\nimport org.codehaus.groovy.ast.expr.ArgumentListExpression;\nimport org.codehaus.groovy.ast.expr.AttributeExpression;\nimport org.codehaus.groovy.ast.expr.CastExpression;\nimport org.codehaus.groovy.ast.expr.ClassExpression;\nimport org.codehaus.groovy.ast.expr.ClosureExpression;\nimport org.codehaus.groovy.ast.expr.ConstantExpression;\nimport org.codehaus.groovy.ast.expr.DeclarationExpression;\nimport org.codehaus.groovy.ast.expr.EmptyExpression;\nimport org.codehaus.groovy.ast.expr.Expression;\nimport org.codehaus.groovy.ast.expr.ListExpression;\nimport org.codehaus.groovy.ast.expr.MethodCallExpression;\nimport org.codehaus.groovy.ast.expr.MethodPointerExpression;\nimport org.codehaus.groovy.ast.expr.PostfixExpression;\nimport org.codehaus.groovy.ast.expr.PrefixExpression;\nimport org.codehaus.groovy.ast.expr.PropertyExpression;\nimport org.codehaus.groovy.ast.expr.StaticMethodCallExpression;\nimport org.codehaus.groovy.ast.expr.TupleExpression;\nimport org.codehaus.groovy.classgen.GeneratorContext;\nimport org.codehaus.groovy.control.CompilePhase;\nimport org.codehaus.groovy.control.SourceUnit;\nimport org.codehaus.groovy.control.customizers.CompilationCustomizer;\nimport org.codehaus.groovy.ast.expr.ConstructorCallExpression;\nimport org.codehaus.groovy.ast.expr.BinaryExpression;\nimport org.codehaus.groovy.runtime.ScriptBytecodeAdapter;\nimport org.codehaus.groovy.syntax.Token;\nimport org.codehaus.groovy.syntax.Types;\nimport org.codehaus.groovy.ast.expr.FieldExpression;\nimport org.codehaus.groovy.ast.expr.VariableExpression;\nimport org.kohsuke.groovy.sandbox.impl.Checker;\nimport org.kohsuke.groovy.sandbox.impl.Ops;\nimport org.kohsuke.groovy.sandbox.impl.SandboxedMethodClosure;\n\nimport static org.codehaus.groovy.ast.expr.ArgumentListExpression.EMPTY_ARGUMENTS;\nimport org.codehaus.groovy.ast.stmt.BlockStatement;\nimport org.codehaus.groovy.ast.stmt.ExpressionStatement;\nimport org.codehaus.groovy.ast.stmt.Statement;\nimport org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;\nimport static org.codehaus.groovy.syntax.Types.*;\n\n/**\n * Transforms Groovy code at compile-time to intercept when the script interacts with the outside world.\n *\n * <p>\n * Sometimes you'd like to run Groovy scripts in a sandbox environment, where you only want it to\n * access limited subset of the rest of JVM. This transformation makes that possible by letting you inspect\n * every step of the script execution when it makes method calls and property/field/array access.\n *\n * <p>\n * Once the script is transformed, every intercepted operation results in a call to {@link Checker},\n * which further forwards the call to {@link GroovyInterceptor} for inspection.\n *\n *\n * <p>\n * To use it, add it to the {@link org.codehaus.groovy.control.CompilerConfiguration}, like this:\n *\n * <pre>\n * def cc = new CompilerConfiguration()\n * cc.addCompilationCustomizers(new SandboxTransformer())\n * sh = new GroovyShell(cc)\n * </pre>\n *\n * <p>\n * By default, this code intercepts everything that can be intercepted, which are:\n * <ul>\n *     <li>Method calls (instance method and static method)\n *     <li>Object allocation (that is, a constructor call except of the form \"this(...)\" and \"super(...)\")\n *     <li>Property access (e.g., z=foo.bar, z=foo.\"bar\") and assignment (e.g., foo.bar=z, foo.\"bar\"=z)\n *     <li>Attribute access (e.g., z=foo.@bar) and assignments (e.g., foo.@bar=z)\n *     <li>Array access and assignment (z=x[y] and x[y]=z)\n * </ul>\n * <p>\n * You can disable interceptions selectively by setting respective {@code interceptXXX} flags to {@code false}.\n *\n * <p>\n * There'll be a substantial hit to the performance of the execution.\n *\n * @author Kohsuke Kawaguchi\n */\npublic class SandboxTransformer extends CompilationCustomizer {\n    /**\n     * Intercept method calls\n     */\n    boolean interceptMethodCall=true;\n    /**\n     * Intercept object instantiation by intercepting its constructor call.\n     *\n     * Note that Java byte code doesn't allow the interception of super(...) and this(...)\n     * so the object instantiation by defining and instantiating a subtype cannot be intercepted.\n     */\n    boolean interceptConstructor=true;\n    /**\n     * Intercept property access for both read \"(...).y\" and write \"(...).y=...\"\n     */\n    boolean interceptProperty=true;\n    /**\n     * Intercept array access for both read \"y=a[x]\" and write \"a[x]=y\"\n     */\n    boolean interceptArray=true;\n    /**\n     * Intercept attribute access for both read \"z=x.@y\" and write \"x.@y=z\"\n     */\n    boolean interceptAttribute=true;\n\n    public SandboxTransformer() {\n        super(CompilePhase.CANONICALIZATION);\n    }\n\n    @Override\n    public void call(final SourceUnit source, GeneratorContext context, ClassNode classNode) {\n        if (classNode == null) { // TODO is this even possible? CpsTransformer implies it is not.\n            return;\n        }\n\n        ClassCodeExpressionTransformer visitor = createVisitor(source, classNode);\n\n        processConstructors(visitor, classNode);\n        for (MethodNode m : classNode.getMethods()) {\n            forbidIfFinalizer(m);\n            visitor.visitMethod(m);\n        }\n        for (Statement s : classNode.getObjectInitializerStatements()) {\n            s.visit(visitor);\n        }\n        for (FieldNode f : classNode.getFields()) {\n            visitor.visitField(f);\n        }\n    }\n\n    /**\n     * {@link Object#finalize} is called by the JVM outside of the sandbox, so overriding it in a\n     * sandboxed script is not allowed.\n     */\n    public void forbidIfFinalizer(MethodNode m) {\n        if (m.getName().equals(\"finalize\") && m.isVoidMethod() && !m.isPrivate() && !m.isStatic()) {\n            boolean safe = false;\n            // There must be at least one parameter without an initial expression for the method to be acceptable.\n            for (Parameter p : m.getParameters()) {\n                if (!p.hasInitialExpression()) {\n                    safe = true;\n                    break;\n                }\n            }\n            if (!safe) {\n                throw new SecurityException(\"Sandboxed code may not override Object.finalize()\");\n            }\n        }\n    }\n\n    /** Do not care about {@code super} calls for classes extending these types. */\n    private static final Set<String> TRIVIAL_CONSTRUCTORS = new HashSet<>(Arrays.asList(\n        Object.class.getName(),\n        Script.class.getName(),\n        \"com.cloudbees.groovy.cps.SerializableScript\",\n        \"org.jenkinsci.plugins.workflow.cps.CpsScript\"));\n    /**\n     * Apply SECURITY-582 fix to constructors.\n     */\n    public void processConstructors(final ClassCodeExpressionTransformer visitor, ClassNode classNode) {\n        ClassNode superClass = classNode.getSuperClass();\n        List<ConstructorNode> declaredConstructors = classNode.getDeclaredConstructors();\n        if (TRIVIAL_CONSTRUCTORS.contains(superClass.getName())) {\n            for (ConstructorNode c : declaredConstructors) {\n                visitor.visitMethod(c);\n            }\n        } else {\n            if (declaredConstructors.isEmpty()) {\n                ConstructorNode syntheticConstructor = new ConstructorNode(Modifier.PUBLIC, new BlockStatement());\n                declaredConstructors = Collections.singletonList(syntheticConstructor);\n                classNode.addConstructor(syntheticConstructor);\n            } else {\n                declaredConstructors = new ArrayList<>(declaredConstructors);\n            }\n            for (ConstructorNode c : declaredConstructors) {\n                Statement code = c.getCode();\n                List<Statement> body;\n                if (code instanceof BlockStatement) {\n                    body = ((BlockStatement) code).getStatements();\n                } else {\n                    body = Collections.singletonList(code);\n                }\n                TupleExpression superArgs = new TupleExpression();\n                if (!body.isEmpty() && body.get(0) instanceof ExpressionStatement && ((ExpressionStatement) body.get(0)).getExpression() instanceof ConstructorCallExpression) {\n                    ConstructorCallExpression cce = (ConstructorCallExpression) ((ExpressionStatement) body.get(0)).getExpression();\n                    if (cce.isThisCall()) { // these are fine as is\n                        visitor.visitMethod(c);\n                        continue;\n                    } else if (cce.isSuperCall()) {\n                        body = body.subList(1, body.size());\n                        superArgs = ((TupleExpression) cce.getArguments());\n                    }\n                }\n                List<Expression> thisArgs = new ArrayList<>();\n                final TupleExpression _superArgs = superArgs;\n                final AtomicReference<Expression> superArgsTransformed = new AtomicReference<>();\n                ((ScopeTrackingClassCodeExpressionTransformer) visitor).withMethod(c, new Runnable() {\n                    @Override\n                    public void run() {\n                        superArgsTransformed.set(((VisitorImpl) visitor).transformArguments(_superArgs));\n                    }\n                });\n                thisArgs.add(((VisitorImpl) visitor).makeCheckedCall(\"checkedSuperConstructor\", new ClassExpression(superClass), superArgsTransformed.get()));\n                Parameter[] origParams = c.getParameters();\n                for (Parameter p : origParams) {\n                    thisArgs.add(new VariableExpression(p));\n                }\n                c.setCode(new BlockStatement(new Statement[] {new ExpressionStatement(new ConstructorCallExpression(ClassNode.THIS, new TupleExpression(thisArgs)))}, c.getVariableScope()));\n                Parameter[] params = new Parameter[origParams.length + 1];\n                params[0] = new Parameter(new ClassNode(Checker.SuperConstructorWrapper.class), \"$scw\");\n                System.arraycopy(origParams, 0, params, 1, origParams.length);\n                List<Expression> scwArgs = new ArrayList<>();\n                int x = 0;\n                for (Expression superArg : superArgs) {\n                    scwArgs.add(/*new CastExpression(superArg.getType(), */new MethodCallExpression(new VariableExpression(\"$scw\"), \"arg\", new ConstantExpression(x++))/*)*/);\n                }\n                List<Statement> body2 = new ArrayList<>();\n                body2.add(0, new ExpressionStatement(new ConstructorCallExpression(ClassNode.SUPER, new ArgumentListExpression(scwArgs))));\n                for (final Statement s : body) {\n                    ((ScopeTrackingClassCodeExpressionTransformer) visitor).withMethod(c, new Runnable() {\n                        @Override\n                        public void run() {\n                            s.visit(visitor);\n                        }\n                    });\n                    body2.add(s);\n                }\n                ConstructorNode c2 = new ConstructorNode(Modifier.PRIVATE, params, c.getExceptions(), new BlockStatement(body2, c.getVariableScope()));\n                // perhaps more misleading than helpful: c2.setSourcePosition(c);\n                classNode.addConstructor(c2);\n            }\n        }\n    }\n\n    @Deprecated\n    public ClassCodeExpressionTransformer createVisitor(SourceUnit source) {\n        return createVisitor(source, null);\n    }\n    \n    public ClassCodeExpressionTransformer createVisitor(SourceUnit source, ClassNode clazz) {\n        return new VisitorImpl(source, clazz);\n    }\n\n    class VisitorImpl extends ScopeTrackingClassCodeExpressionTransformer {\n        private final SourceUnit sourceUnit;\n        /**\n         * Invocation/property access without the left-hand side expression (for example {@code foo()}\n         * as opposed to {@code something.foo()} means {@code this.foo()} in Java, but this is not\n         * so in Groovy.\n         *\n         * In Groovy, {@code foo()} inside a closure uses the closure object itself as the lhs value,\n         * whereas {@code this} in closure refers to a nearest enclosing non-closure object.\n         *\n         * So we cannot always expand {@code foo()} to {@code this.foo()}.\n         *\n         * To keep track of when we can expand {@code foo()} to {@code this.foo()} and when we can't,\n         * we maintain this flag as we visit the expression tree. This flag is set to true\n         * while we are visiting the body of the closure (the part between { ... }), and switched\n         * back to false as we visit inner classes.\n         *\n         * To correctly expand {@code foo()} in the closure requires an access to the closure object itself,\n         * and unfortunately Groovy doesn't seem to have any reliable way to do this. The hack I came up\n         * with is {@code asWritable().getOwner()}, but even that is subject to the method resolution rule.\n         *\n         */\n        private boolean visitingClosureBody;\n\n        /**\n         * Current class we are traversing.\n         */\n        private ClassNode clazz;\n\n        VisitorImpl(SourceUnit sourceUnit, ClassNode clazz) {\n            this.sourceUnit = sourceUnit;\n            this.clazz = clazz;\n        }\n\n        @Override\n        public void visitMethod(MethodNode node) {\n            if (clazz == null) { // compatibility\n                clazz = node.getDeclaringClass();\n            }\n            super.visitMethod(node);\n        }\n\n        /**\n         * Transforms the arguments of a call.\n         * Groovy primarily uses {@link ArgumentListExpression} for this,\n         * but the signature doesn't guarantee that. So this method takes care of that.\n         */\n        Expression transformArguments(Expression e) {\n            List<Expression> l;\n            if (e instanceof TupleExpression) {\n                List<Expression> expressions = ((TupleExpression) e).getExpressions();\n                l = new ArrayList<>(expressions.size());\n                for (Expression expression : expressions) {\n                    l.add(transform(expression));\n                }\n            } else {\n                l = Collections.singletonList(transform(e));\n            }\n\n            // checkdCall expects an array\n            return withLoc(e,new MethodCallExpression(new ListExpression(l),\"toArray\",new ArgumentListExpression()));\n        }\n        \n        Expression makeCheckedCall(String name, Expression... arguments) {\n            return new StaticMethodCallExpression(checkerClass,name,\n                new ArgumentListExpression(arguments));\n        }\n    \n        @Override\n        public Expression transform(Expression exp) {\n            Expression o = innerTransform(exp);\n            if (o!=exp) {\n                o.setSourcePosition(exp);\n            }\n            return o;\n        }\n\n        private Expression innerTransform(Expression exp) {\n            if (exp instanceof ClosureExpression) {\n                // ClosureExpression.transformExpression doesn't visit the code inside\n                ClosureExpression ce = (ClosureExpression)exp;\n                try (StackVariableSet scope = new StackVariableSet(this)) {\n                    Parameter[] parameters = ce.getParameters();\n                    if (parameters != null) {\n                        // Explicitly defined parameters, i.e., \".findAll { i -> i == 'bar' }\"\n                        if (parameters.length > 0) {\n                            for (Parameter p : parameters) {\n                                declareVariable(p);\n                            }\n                        } else {\n                            // Implicit parameter - i.e., \".findAll { it == 'bar' }\"\n                            declareVariable(new Parameter(ClassHelper.DYNAMIC_TYPE, \"it\"));\n                        }\n                    }\n                    boolean old = visitingClosureBody;\n                    visitingClosureBody = true;\n                    try {\n                        ce.getCode().visit(this);\n                    } finally {\n                        visitingClosureBody = old;\n                    }\n                }\n            }\n\n            if (exp instanceof MethodCallExpression && interceptMethodCall) {\n                // lhs.foo(arg1,arg2) => checkedCall(lhs,\"foo\",arg1,arg2)\n                // lhs+rhs => lhs.plus(rhs)\n                // Integer.plus(Integer) => DefaultGroovyMethods.plus\n                // lhs || rhs => lhs.or(rhs)\n                MethodCallExpression call = (MethodCallExpression) exp;\n\n                Expression objExp;\n                if (call.isImplicitThis() && visitingClosureBody && !isLocalVariableExpression(call.getObjectExpression()))\n                    objExp = CLOSURE_THIS;\n                else\n                    objExp = transform(call.getObjectExpression());\n\n                Expression arg1 = call.getMethod();\n                Expression arg2 = transformArguments(call.getArguments());\n\n                if (call.getObjectExpression() instanceof VariableExpression && ((VariableExpression) call.getObjectExpression()).getName().equals(\"super\")) {\n                    if (clazz == null) {\n                        throw new IllegalStateException(\"owning class not defined\");\n                    }\n                    return makeCheckedCall(\"checkedSuperCall\", new ClassExpression(clazz), objExp, arg1, arg2);\n                } else {\n                    return makeCheckedCall(\"checkedCall\",\n                            objExp,\n                            boolExp(call.isSafe()),\n                            boolExp(call.isSpreadSafe()),\n                            arg1,\n                            arg2);\n                }\n            }\n            \n            if (exp instanceof StaticMethodCallExpression && interceptMethodCall) {\n                /*\n                    Groovy doesn't use StaticMethodCallExpression as much as it could in compilation.\n                    For example, \"Math.max(1,2)\" results in a regular MethodCallExpression.\n\n                    Static import handling uses StaticMethodCallExpression, and so are some\n                    ASTTransformations like ToString,EqualsAndHashCode, etc.\n                 */\n                StaticMethodCallExpression call = (StaticMethodCallExpression) exp;\n                return makeCheckedCall(\"checkedStaticCall\",\n                            new ClassExpression(call.getOwnerType()),\n                            new ConstantExpression(call.getMethod()),\n                            transformArguments(call.getArguments())\n                    );\n            }\n\n            if (exp instanceof MethodPointerExpression && interceptMethodCall) {\n                MethodPointerExpression mpe = (MethodPointerExpression) exp;\n                return new ConstructorCallExpression(\n                        new ClassNode(SandboxedMethodClosure.class),\n                        new ArgumentListExpression(mpe.getExpression(), mpe.getMethodName())\n                );\n            }\n\n            if (exp instanceof ConstructorCallExpression && interceptConstructor) {\n                if (!((ConstructorCallExpression) exp).isSpecialCall()) {\n                    // creating a new instance, like \"new Foo(...)\"\n                    return makeCheckedCall(\"checkedConstructor\",\n                            new ClassExpression(exp.getType()),\n                            transformArguments(((ConstructorCallExpression) exp).getArguments())\n                    );\n                } else {\n                    // we can't really intercept constructor calling super(...) or this(...),\n                    // since it has to be the first method call in a constructor.\n                    // but see SECURITY-582 fix above\n                }\n            }\n\n            if (exp instanceof AttributeExpression && interceptAttribute) {\n                AttributeExpression ae = (AttributeExpression) exp;\n                return makeCheckedCall(\"checkedGetAttribute\",\n                    transform(ae.getObjectExpression()),\n                    boolExp(ae.isSafe()),\n                    boolExp(ae.isSpreadSafe()),\n                    transform(ae.getProperty())\n                );\n            }\n\n            if (exp instanceof PropertyExpression && interceptProperty) {\n                PropertyExpression pe = (PropertyExpression) exp;\n                return makeCheckedCall(\"checkedGetProperty\",\n                    transformObjectExpression(pe),\n                    boolExp(pe.isSafe()),\n                    boolExp(pe.isSpreadSafe()),\n                    transform(pe.getProperty())\n                );\n            }\n\n            if (exp instanceof VariableExpression && interceptProperty) {\n                VariableExpression vexp = (VariableExpression) exp;\n                if (isLocalVariable(vexp.getName()) || vexp.getName().equals(\"this\") || vexp.getName().equals(\"super\")) {\n                    // We don't care what sandboxed code does to itself until it starts interacting with outside world\n                    return super.transform(exp);\n                } else {\n                    // if the variable is not in-scope local variable, it gets treated as a property access with implicit this.\n                    // see AsmClassGenerator.visitVariableExpression and processClassVariable.\n                    PropertyExpression pexp = new PropertyExpression(VariableExpression.THIS_EXPRESSION, vexp.getName());\n                    pexp.setImplicitThis(true);\n                    withLoc(exp,pexp);\n                    return transform(pexp);\n                }\n            }\n\n            if (exp instanceof DeclarationExpression) {\n                handleDeclarations((DeclarationExpression) exp);\n            }\n\n            if (exp instanceof BinaryExpression) {\n                BinaryExpression be = (BinaryExpression) exp;\n                // this covers everything from a+b to a=b\n                if (ofType(be.getOperation().getType(),ASSIGNMENT_OPERATOR)) {\n                    // simple assignment like '=' as well as compound assignments like \"+=\",\"-=\", etc.\n\n                    // How we dispatch this depends on the type of left expression.\n                    // \n                    // What can be LHS?\n                    // according to AsmClassGenerator, PropertyExpression, AttributeExpression, FieldExpression, VariableExpression\n\n                    Expression lhs = be.getLeftExpression();\n                    if (lhs instanceof VariableExpression) {\n                        VariableExpression vexp = (VariableExpression) lhs;\n                        if (isLocalVariable(vexp.getName()) || vexp.getName().equals(\"this\") || vexp.getName().equals(\"super\")) {\n                            // We don't care what sandboxed code does to itself until it starts interacting with outside world\n                            return super.transform(exp);\n                        } else {\n                            // if the variable is not in-scope local variable, it gets treated as a property access with implicit this.\n                            // see AsmClassGenerator.visitVariableExpression and processClassVariable.\n                            PropertyExpression pexp = new PropertyExpression(VariableExpression.THIS_EXPRESSION, vexp.getName());\n                            pexp.setImplicitThis(true);\n                            pexp.setSourcePosition(vexp);\n\n                            lhs = pexp;\n                        }\n                    } // no else here\n                    if (lhs instanceof PropertyExpression) {\n                        PropertyExpression pe = (PropertyExpression) lhs;\n                        String name = null;\n                        if (lhs instanceof AttributeExpression) {\n                            if (interceptAttribute)\n                                name = \"checkedSetAttribute\";\n                        } else {\n                            Expression receiver = pe.getObjectExpression();\n                            if (receiver instanceof VariableExpression && ((VariableExpression) receiver).getName().equals(\"this\")) {\n                                FieldNode field = clazz != null ? clazz.getField(pe.getPropertyAsString()) : null;\n                                if (field != null) { // could also verify that it is final, but not necessary\n                                    // cf. BinaryExpression.transformExpression; super.transform(exp) transforms the LHS to checkedGetProperty\n                                    return new BinaryExpression(lhs, be.getOperation(), transform(be.getRightExpression()));\n                                } // else this is a property which we need to check\n                            }\n                            if (interceptProperty)\n                                name = \"checkedSetProperty\";\n                        }\n                        if (name==null) // not intercepting?\n                            return super.transform(exp);\n\n                        return makeCheckedCall(name,\n                                transformObjectExpression(pe),\n                                pe.getProperty(),\n                                boolExp(pe.isSafe()),\n                                boolExp(pe.isSpreadSafe()),\n                                intExp(be.getOperation().getType()),\n                                transform(be.getRightExpression())\n                        );\n                    } else\n                    if (lhs instanceof FieldExpression) {\n                        // while javadoc of FieldExpression isn't very clear,\n                        // AsmClassGenerator maps this to GETSTATIC/SETSTATIC/GETFIELD/SETFIELD access.\n                        // not sure how we can intercept this, so skipping this for now\n                        return super.transform(exp);\n                    } else\n                    if (lhs instanceof BinaryExpression) {\n                        BinaryExpression lbe = (BinaryExpression) lhs;\n                        if (lbe.getOperation().getType()==Types.LEFT_SQUARE_BRACKET && interceptArray) {// expression of the form \"x[y] = z\"\n                            return makeCheckedCall(\"checkedSetArray\",\n                                    transform(lbe.getLeftExpression()),\n                                    transform(lbe.getRightExpression()),\n                                    intExp(be.getOperation().getType()),\n                                    transform(be.getRightExpression())\n                            );\n                        }\n                    } else\n                        throw new AssertionError(\"Unexpected LHS of an assignment: \" + lhs.getClass());\n                }\n                if (be.getOperation().getType()==Types.LEFT_SQUARE_BRACKET) {// array reference\n                    if (interceptArray)\n                        return makeCheckedCall(\"checkedGetArray\",\n                                transform(be.getLeftExpression()),\n                                transform(be.getRightExpression())\n                        );\n                } else\n                if (be.getOperation().getType()==Types.KEYWORD_INSTANCEOF) {// instanceof operator\n                    return super.transform(exp);\n                } else\n                if (Ops.isLogicalOperator(be.getOperation().getType())) {\n                    return super.transform(exp);\n                } else\n                if (be.getOperation().getType()==Types.KEYWORD_IN) {// membership operator: JENKINS-28154\n                    // This requires inverted operand order:\n                    // \"a in [...]\" -> \"[...].isCase(a)\"\n                    if (interceptMethodCall)\n                        return makeCheckedCall(\"checkedCall\",\n                                transform(be.getRightExpression()),\n                                boolExp(false),\n                                boolExp(false),\n                                stringExp(\"isCase\"),\n                                transform(be.getLeftExpression())\n\n                        );\n                } else\n                if (Ops.isRegexpComparisonOperator(be.getOperation().getType())) {\n                    if (interceptMethodCall)\n                        return makeCheckedCall(\"checkedStaticCall\",\n                                classExp(ScriptBytecodeAdapterClass),\n                                stringExp(Ops.binaryOperatorMethods(be.getOperation().getType())),\n                                transform(be.getLeftExpression()),\n                                transform(be.getRightExpression())\n                        );\n                } else\n                if (Ops.isComparisionOperator(be.getOperation().getType())) {\n                    if (interceptMethodCall) {\n                        return makeCheckedCall(\"checkedComparison\",\n                                transform(be.getLeftExpression()),\n                                intExp(be.getOperation().getType()),\n                                transform(be.getRightExpression())\n                        );\n                    }\n                } else\n                if (interceptMethodCall) {\n                    // normally binary operators like a+b\n                    // TODO: check what other weird binary operators land here\n                    return makeCheckedCall(\"checkedBinaryOp\",\n                            transform(be.getLeftExpression()),\n                            intExp(be.getOperation().getType()),\n                            transform(be.getRightExpression())\n                    );\n                }\n            }\n\n            if (exp instanceof PostfixExpression) {\n                PostfixExpression pe = (PostfixExpression) exp;\n                return prefixPostfixExp(exp, pe.getExpression(), pe.getOperation(), \"Postfix\");\n            }\n            if (exp instanceof PrefixExpression) {\n                PrefixExpression pe = (PrefixExpression) exp;\n                return prefixPostfixExp(exp, pe.getExpression(), pe.getOperation(), \"Prefix\");\n            }\n\n            if (exp instanceof CastExpression) {\n                CastExpression ce = (CastExpression) exp;\n                return makeCheckedCall(\"checkedCast\",\n                        classExp(exp.getType()),\n                        transform(ce.getExpression()),\n                        boolExp(ce.isIgnoringAutoboxing()),\n                        boolExp(ce.isCoerce()),\n                        boolExp(ce.isStrict())\n                );\n            }\n\n            return super.transform(exp);\n        }\n\n        private Expression prefixPostfixExp(Expression whole, Expression atom, Token opToken, String mode) {\n            String op = opToken.getText().equals(\"++\") ? \"next\" : \"previous\";\n\n            // a[b]++\n            if (atom instanceof BinaryExpression && ((BinaryExpression) atom).getOperation().getType()==Types.LEFT_SQUARE_BRACKET && interceptArray) {\n                return makeCheckedCall(\"checked\" + mode + \"Array\",\n                        transform(((BinaryExpression) atom).getLeftExpression()),\n                        transform(((BinaryExpression) atom).getRightExpression()),\n                        stringExp(op)\n                );\n            }\n\n            // a++\n            if (atom instanceof VariableExpression) {\n                VariableExpression ve = (VariableExpression) atom;\n                if (isLocalVariable(ve.getName())) {\n                    if (mode.equals(\"Postfix\")) {\n                        // a trick to rewrite a++ without introducing a new local variable\n                        //     a++ -> [a,a=a.next()][0]\n                        return transform(withLoc(whole,new BinaryExpression(\n                                new ListExpression(Arrays.asList(\n                                    atom,\n                                    new BinaryExpression(atom, ASSIGNMENT_OP,\n                                        withLoc(atom,new MethodCallExpression(atom,op,EMPTY_ARGUMENTS)))\n                                )),\n                                new Token(Types.LEFT_SQUARE_BRACKET, \"[\", -1,-1),\n                                new ConstantExpression(0)\n                        )));\n                    } else {\n                        // ++a -> a=a.next()\n                        return transform(withLoc(whole,new BinaryExpression(atom,ASSIGNMENT_OP,\n                                withLoc(atom,new MethodCallExpression(atom,op,EMPTY_ARGUMENTS)))\n                        ));\n                    }\n                } else {\n                    // if the variable is not in-scope local variable, it gets treated as a property access with implicit this.\n                    // see AsmClassGenerator.visitVariableExpression and processClassVariable.\n                    PropertyExpression pexp = new PropertyExpression(VariableExpression.THIS_EXPRESSION, ve.getName());\n                    pexp.setImplicitThis(true);\n                    pexp.setSourcePosition(atom);\n\n                    atom = pexp;\n                    // fall through to the \"a.b++\" case below\n                }\n            }\n\n            // a.b++\n            if (atom instanceof PropertyExpression && interceptProperty) {\n                PropertyExpression pe = (PropertyExpression) atom;\n                return makeCheckedCall(\"checked\" + mode + \"Property\",\n                        transformObjectExpression(pe),\n                        pe.getProperty(),\n                        boolExp(pe.isSafe()),\n                        boolExp(pe.isSpreadSafe()),\n                        stringExp(op)\n                );\n            }\n\n            return whole;\n        }\n\n        /**\n         * Decorates an {@link ASTNode} by copying source location from another node.\n         */\n        private <T extends ASTNode> T withLoc(ASTNode src, T t) {\n            t.setSourcePosition(src);\n            return t;\n        }\n\n        /**\n         * See {@link #visitingClosureBody} for the details of what this method is about.\n         */\n        private Expression transformObjectExpression(PropertyExpression exp) {\n            if (exp.isImplicitThis() && visitingClosureBody && !isLocalVariableExpression(exp.getObjectExpression())) {\n                return CLOSURE_THIS;\n            } else {\n                return transform(exp.getObjectExpression());\n            }\n        }\n\n        private boolean isLocalVariableExpression(Expression exp) {\n            if (exp != null && exp instanceof VariableExpression) {\n                return isLocalVariable(((VariableExpression) exp).getName());\n            }\n\n            return false;\n        }\n\n        ConstantExpression boolExp(boolean v) {\n            return v ? ConstantExpression.PRIM_TRUE : ConstantExpression.PRIM_FALSE;\n        }\n\n        ConstantExpression intExp(int v) {\n            return new ConstantExpression(v,true);\n        }\n\n        ClassExpression classExp(ClassNode c) {\n            return new ClassExpression(c);\n        }\n\n        ConstantExpression stringExp(String v) {\n            return new ConstantExpression(v);\n        }\n\n        @Override\n        public void visitExpressionStatement(ExpressionStatement es) {\n            Expression exp = es.getExpression();\n            if (exp instanceof DeclarationExpression) {\n                DeclarationExpression de = (DeclarationExpression) exp;\n                Expression leftExpression = de.getLeftExpression();\n                if (leftExpression instanceof VariableExpression) {\n                    // Only cast and transform if the RHS is *not* an EmptyExpression, i.e., \"String foo;\" would not be cast/transformed.\n                    if (!(de.getRightExpression() instanceof EmptyExpression) &&\n                            mightBePositionalArgumentConstructor((VariableExpression) leftExpression)) {\n                        CastExpression ce = new CastExpression(leftExpression.getType(), de.getRightExpression());\n                        ce.setCoerce(true);\n                        es.setExpression(transform(new DeclarationExpression(leftExpression, de.getOperation(), ce)));\n                        return;\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"not supporting tuples yet\"); // cf. \"Unexpected LHS of an assignment\" above\n                }\n            }\n            super.visitExpressionStatement(es);\n        }\n\n        @Override\n        protected SourceUnit getSourceUnit() {\n            return sourceUnit;\n        }\n    }\n\n    /**\n     * Checks if a {@link DeclarationExpression#getVariableExpression} might induce {@link DefaultTypeTransformation#castToType} to call a constructor.\n     * If so, {@link Checker#checkedCast} should be run.\n     * Will be false for example if the declared type is an array, {@code abstract}, or unspecified (just {@code def}).\n     * Not yet supporting {@link DeclarationExpression#getTupleExpression} on LHS;\n     * and currently ignoring {@link DeclarationExpression#getRightExpression} though some might not possibly be arrays, {@link Collection}s, or {@link Map}s.\n     */\n    public static boolean mightBePositionalArgumentConstructor(VariableExpression ve) {\n        ClassNode type = ve.getType();\n        if (type.isArray()) {\n            return false; // do not care about componentType\n        }\n        Class clazz;\n        try {\n            clazz = type.getTypeClass();\n        } catch (GroovyBugError x) {\n            return false; // \"ClassNode#getTypeClass for \u2026 is called before the type class is set\" when assigning to a type defined in Groovy source\n        }\n        return clazz != null && clazz != Object.class && !Modifier.isAbstract(clazz.getModifiers());\n    }\n\n    static final Token ASSIGNMENT_OP = new Token(Types.ASSIGN, \"=\", -1, -1);\n\n    static final ClassNode checkerClass = new ClassNode(Checker.class);\n    static final ClassNode ScriptBytecodeAdapterClass = new ClassNode(ScriptBytecodeAdapter.class);\n\n    /**\n     * Expression that accesses the closure object itself from within the closure.\n     *\n     * Currently a hacky \"asWritable().getOwner()\"\n     */\n    static final Expression CLOSURE_THIS;\n\n    static {\n        MethodCallExpression aw = new MethodCallExpression(new VariableExpression(\"this\"),\"asWritable\",EMPTY_ARGUMENTS);\n        aw.setImplicitThis(true);\n\n        CLOSURE_THIS = new MethodCallExpression(aw,\"getOwner\",EMPTY_ARGUMENTS);\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-53": {
    "vul_id": "VUL4J-53",
    "cve_id": "CVE-2018-1999044",
    "project": "jenkinsci_jenkins",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl core -Dtest=hudson.scheduler.CronTabTest#testLongMonths",
    "test_all_cmd": "mvn test -pl core",
    "human_patch_url": "https://github.com/jenkinsci/jenkins/commit/e5046911c57e60a1d6d8aca9b21bd9093b0f3763",
    "vulnerable_files": [
      {
        "file_path": "core/src/main/java/hudson/scheduler/CronTab.java",
        "file_name": "CronTab.java",
        "vulnerable_code": "/*\n * The MIT License\n * \n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, InfraDNA, Inc.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.scheduler;\n\nimport antlr.ANTLRException;\n\nimport java.io.StringReader;\nimport java.util.Calendar;\nimport java.util.TimeZone;\nimport java.util.GregorianCalendar;\nimport java.util.Locale;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static java.util.Calendar.*;\nimport javax.annotation.CheckForNull;\n\n/**\n * Table for driving scheduled tasks.\n *\n * @author Kohsuke Kawaguchi\n */\npublic final class CronTab {\n    /**\n     * bits[0]: minutes\n     * bits[1]: hours\n     * bits[2]: days\n     * bits[3]: months\n     *\n     * false:not scheduled &lt;-> true scheduled\n     */\n    final long[] bits = new long[4];\n\n    int dayOfWeek;\n\n    /**\n     * Textual representation.\n     */\n    private String spec;\n\n    /**\n     * Optional timezone string for calendar \n     */\n    private @CheckForNull String specTimezone;\n\n    public CronTab(String format) throws ANTLRException {\n        this(format,null);\n    }\n\n    public CronTab(String format, Hash hash) throws ANTLRException {\n        this(format,1,hash);\n    }\n    \n    /**\n     * @deprecated as of 1.448\n     *      Use {@link #CronTab(String, int, Hash)}\n     */\n    @Deprecated\n    public CronTab(String format, int line) throws ANTLRException {\n        set(format, line, null);\n    }\n\n    /**\n     * @param hash\n     *      Used to spread out token like \"@daily\". Null to preserve the legacy behaviour\n     *      of not spreading it out at all.\n     */\n    public CronTab(String format, int line, Hash hash) throws ANTLRException {\n        this(format, line, hash, null);\n    }\n\n    /**\n     * @param timezone\n     *      Used to schedule cron in a different timezone. Null to use the default system \n     *      timezone\n     * @since 1.615\n     */\n    public CronTab(String format, int line, Hash hash, @CheckForNull String timezone) throws ANTLRException {\n        set(format, line, hash, timezone);\n    }\n    \n    private void set(String format, int line, Hash hash) throws ANTLRException {\n        set(format, line, hash, null);\n    }\n\n    /**\n     * @since 1.615\n     */\n    private void set(String format, int line, Hash hash, String timezone) throws ANTLRException {\n        CrontabLexer lexer = new CrontabLexer(new StringReader(format));\n        lexer.setLine(line);\n        CrontabParser parser = new CrontabParser(lexer);\n        parser.setHash(hash);\n        spec = format;\n        specTimezone = timezone;\n\n        parser.startRule(this);\n        if((dayOfWeek&(1<<7))!=0) {\n            dayOfWeek |= 1; // copy bit 7 over to bit 0\n            dayOfWeek &= ~(1<<7); // clear bit 7 or CalendarField#ceil will return an invalid value 7\n        }\n    }\n\n\n    /**\n     * Returns true if the given calendar matches\n     */\n    boolean check(Calendar cal) {\n\n        Calendar checkCal = cal;\n\n        if(specTimezone != null && !specTimezone.isEmpty()) {\n            Calendar tzCal = Calendar.getInstance(TimeZone.getTimeZone(specTimezone));\n            tzCal.setTime(cal.getTime());\n            checkCal = tzCal;\n        }\n\n        if(!checkBits(bits[0],checkCal.get(MINUTE)))\n            return false;\n        if(!checkBits(bits[1],checkCal.get(HOUR_OF_DAY)))\n            return false;\n        if(!checkBits(bits[2],checkCal.get(DAY_OF_MONTH)))\n            return false;\n        if(!checkBits(bits[3],checkCal.get(MONTH)+1))\n            return false;\n        if(!checkBits(dayOfWeek,checkCal.get(Calendar.DAY_OF_WEEK)-1))\n            return false;\n\n        return true;\n    }\n\n    private static abstract class CalendarField {\n        /**\n         * {@link Calendar} field ID.\n         */\n        final int field;\n        /**\n         * Lower field is a calendar field whose value needs to be reset when we change the value in this field.\n         * For example, if we modify the value in HOUR, MINUTES must be reset.\n         */\n        final CalendarField lowerField;\n        /**\n         * Whether this field is 0-origin or 1-origin differs between Crontab and {@link Calendar},\n         * so this field adjusts that. If crontab is 1 origin and calendar is 0 origin,  this field is 1\n         * that is the value is {@code (cronOrigin-calendarOrigin)}\n         */\n        final int offset;\n        /**\n         * When we reset this field, we set the field to this value.\n         * For example, resetting {@link Calendar#DAY_OF_MONTH} means setting it to 1.\n         */\n        final int min;\n        /**\n         * If this calendar field has other aliases such that a change in this field\n         * modifies other field values, then true.\n         */\n        final boolean redoAdjustmentIfModified;\n\n        /**\n         * What is this field? Useful for debugging\n         */\n        @SuppressWarnings(\"unused\")\n        private final String displayName;\n\n        private CalendarField(String displayName, int field, int min, int offset, boolean redoAdjustmentIfModified, CalendarField lowerField) {\n            this.displayName = displayName;\n            this.field = field;\n            this.min = min;\n            this.redoAdjustmentIfModified= redoAdjustmentIfModified;\n            this.lowerField = lowerField;\n            this.offset = offset;\n        }\n\n        /**\n         * Gets the current value of this field in the given calendar.\n         */\n        int valueOf(Calendar c) {\n            return c.get(field)+offset;\n        }\n\n        void addTo(Calendar c, int i) {\n            c.add(field,i);\n        }\n\n        void setTo(Calendar c, int i) {\n            c.set(field,i-offset);\n        }\n\n        void clear(Calendar c) {\n            setTo(c, min);\n        }\n\n        /**\n         * Given the value 'n' (which represents the current value), finds the smallest x such that:\n         *  1) x matches the specified {@link CronTab} (as far as this field is concerned.)\n         *  2) x>=n   (inclusive)\n         *\n         * If there's no such bit, return -1. Note that if 'n' already matches the crontab, the same n will be returned.\n         */\n        private int ceil(CronTab c, int n) {\n            long bits = bits(c);\n            while ((bits|(1L<<n))!=bits) {\n                if (n>60)   return -1;\n                n++;\n            }\n            return n;\n        }\n\n        /**\n         * Given a bit mask, finds the first bit that's on, and return its index.\n         */\n        private int first(CronTab c) {\n            return ceil(c,0);\n        }\n\n        private int floor(CronTab c, int n) {\n            long bits = bits(c);\n            while ((bits|(1L<<n))!=bits) {\n                if (n==0)   return -1;\n                n--;\n            }\n            return n;\n        }\n\n        private int last(CronTab c) {\n            return floor(c,63);\n        }\n\n        /**\n         * Extracts the bit masks from the given {@link CronTab} that matches this field.\n         */\n        abstract long bits(CronTab c);\n\n        /**\n         * Increment the next field.\n         */\n        abstract void rollUp(Calendar cal, int i);\n\n        private static final CalendarField MINUTE       = new CalendarField(\"minute\", Calendar.MINUTE,        0, 0, false, null) {\n            long bits(CronTab c) { return c.bits[0]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.HOUR_OF_DAY,i); }\n        };\n        private static final CalendarField HOUR         = new CalendarField(\"hour\", Calendar.HOUR_OF_DAY,   0, 0, false, MINUTE) {\n            long bits(CronTab c) { return c.bits[1]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.DAY_OF_MONTH,i); }\n        };\n        private static final CalendarField DAY_OF_MONTH = new CalendarField(\"day\", Calendar.DAY_OF_MONTH,  1, 0, true,  HOUR) {\n            long bits(CronTab c) { return c.bits[2]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.MONTH,i); }\n        };\n        private static final CalendarField MONTH        = new CalendarField(\"month\", Calendar.MONTH,         1, 1, false, DAY_OF_MONTH) {\n            long bits(CronTab c) { return c.bits[3]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.YEAR,i); }\n        };\n        private static final CalendarField DAY_OF_WEEK  = new CalendarField(\"dow\", Calendar.DAY_OF_WEEK,   1,-1, true,  HOUR) {\n            long bits(CronTab c) { return c.dayOfWeek; }\n            void rollUp(Calendar cal, int i) {\n                cal.add(Calendar.DAY_OF_WEEK, 7 * i);\n            }\n\n            @Override\n            void setTo(Calendar c, int i) {\n                int v = i-offset;\n                int was = c.get(field);\n                c.set(field,v);\n                final int firstDayOfWeek = c.getFirstDayOfWeek();\n                if (v < firstDayOfWeek && was >= firstDayOfWeek) {\n                    // in crontab, the first DoW is always Sunday, but in Java, it can be Monday or in theory arbitrary other days.\n                    // When first DoW is 1/2 Monday, calendar points to 1/2 Monday, setting the DoW to Sunday makes\n                    // the calendar moves forward to 1/8 Sunday, instead of 1/1 Sunday. So we need to compensate that effect here.\n                    addTo(c,-7);\n                } else if (was < firstDayOfWeek && firstDayOfWeek <= v) {\n                    // If we wrap the other way around, we need to adjust in the opposite direction of above.\n                    addTo(c, 7);\n                }\n            }\n        };\n\n        private static final CalendarField[] ADJUST_ORDER = {\n            MONTH, DAY_OF_MONTH, DAY_OF_WEEK, HOUR, MINUTE\n        };\n    }\n\n\n    /**\n     * Computes the nearest future timestamp that matches this cron tab.\n     * <p>\n     * More precisely, given the time 't', computes another smallest time x such that:\n     *\n     * <ul>\n     * <li>x \u2265 t (inclusive)\n     * <li>x matches this crontab\n     * </ul>\n     *\n     * <p>\n     * Note that if t already matches this cron, it's returned as is.\n     */\n    public Calendar ceil(long t) {\n        Calendar cal = new GregorianCalendar(Locale.US);\n        cal.setTimeInMillis(t);\n        return ceil(cal);\n    }\n\n    /**\n     * See {@link #ceil(long)}.\n     *\n     * This method modifies the given calendar and returns the same object.\n     *\n     * @throws RareOrImpossibleDateException if the date isn't hit in the 2 years after it indicates an impossible\n     * (e.g. Jun 31) date, or at least a date too rare to be useful. This addresses JENKINS-41864 and was added in 2.49\n     */\n    public Calendar ceil(Calendar cal) {\n        Calendar twoYearsFuture = (Calendar) cal.clone();\n        twoYearsFuture.add(Calendar.YEAR, 2);\n        OUTER:\n        while (true) {\n            if (cal.compareTo(twoYearsFuture) > 0) {\n                // we went too far into the future\n                throw new RareOrImpossibleDateException();\n            }\n            for (CalendarField f : CalendarField.ADJUST_ORDER) {\n                int cur = f.valueOf(cal);\n                int next = f.ceil(this,cur);\n                if (cur==next)  continue;   // this field is already in a good shape. move on to next\n\n                // we are modifying this field, so clear all the lower level fields\n                for (CalendarField l=f.lowerField; l!=null; l=l.lowerField)\n                    l.clear(cal);\n\n                if (next<0) {\n                    // we need to roll over to the next field.\n                    f.rollUp(cal, 1);\n                    f.setTo(cal,f.first(this));\n                    // since higher order field is affected by this, we need to restart from all over\n                    continue OUTER;\n                } else {\n                    f.setTo(cal,next);\n                    if (f.redoAdjustmentIfModified)\n                        continue OUTER; // when we modify DAY_OF_MONTH and DAY_OF_WEEK, do it all over from the top\n                }\n            }\n            return cal; // all fields adjusted\n        }\n    }\n\n    /**\n     * Computes the nearest past timestamp that matched this cron tab.\n     * <p>\n     * More precisely, given the time 't', computes another smallest time x such that:\n     *\n     * <ul>\n     * <li>x &lt;= t (inclusive)\n     * <li>x matches this crontab\n     * </ul>\n     *\n     * <p>\n     * Note that if t already matches this cron, it's returned as is.\n     */\n    public Calendar floor(long t) {\n        Calendar cal = new GregorianCalendar(Locale.US);\n        cal.setTimeInMillis(t);\n        return floor(cal);\n    }\n\n    /**\n     * See {@link #floor(long)}\n     *\n     * This method modifies the given calendar and returns the same object.\n     *\n     * @throws RareOrImpossibleDateException if the date isn't hit in the 2 years before it indicates an impossible\n     * (e.g. Jun 31) date, or at least a date too rare to be useful. This addresses JENKINS-41864 and was added in 2.49\n     */\n    public Calendar floor(Calendar cal) {\n        Calendar twoYearsAgo = (Calendar) cal.clone();\n        twoYearsAgo.add(Calendar.YEAR, -2);\n\n        OUTER:\n        while (true) {\n            if (cal.compareTo(twoYearsAgo) < 0) {\n                // we went too far into the past\n                throw new RareOrImpossibleDateException();\n            }\n            for (CalendarField f : CalendarField.ADJUST_ORDER) {\n                int cur = f.valueOf(cal);\n                int next = f.floor(this,cur);\n                if (cur==next)  continue;   // this field is already in a good shape. move on to next\n\n                // we are modifying this field, so clear all the lower level fields\n                for (CalendarField l=f.lowerField; l!=null; l=l.lowerField)\n                    l.clear(cal);\n\n                if (next<0) {\n                    // we need to borrow from the next field.\n                    f.rollUp(cal,-1);\n                    // the problem here, in contrast with the ceil method, is that\n                    // the maximum value of the field is not always a fixed value (that is, day of month)\n                    // so we zero-clear all the lower fields, set the desired value +1,\n                    f.setTo(cal,f.last(this));\n                    f.addTo(cal,1);\n                    // then subtract a minute to achieve maximum values on all the lower fields,\n                    // with the desired value in 'f'\n                    CalendarField.MINUTE.addTo(cal,-1);\n                    // since higher order field is affected by this, we need to restart from all over\n                    continue OUTER;\n                } else {\n                    f.setTo(cal,next);\n                    f.addTo(cal,1);\n                    CalendarField.MINUTE.addTo(cal,-1);\n                    if (f.redoAdjustmentIfModified)\n                        continue OUTER; // when we modify DAY_OF_MONTH and DAY_OF_WEEK, do it all over from the top\n                }\n            }\n            return cal; // all fields adjusted\n        }\n    }\n\n    void set(String format, Hash hash) throws ANTLRException {\n        set(format,1,hash);\n    }\n\n    /**\n     * Returns true if n-th bit is on.\n     */\n    private boolean checkBits(long bitMask, int n) {\n        return (bitMask|(1L<<n))==bitMask;\n    }\n\n    public String toString() {\n        return super.toString()+\"[\"+\n            toString(\"minute\",bits[0])+','+\n            toString(\"hour\",bits[1])+','+\n            toString(\"dayOfMonth\",bits[2])+','+\n            toString(\"month\",bits[3])+','+\n            toString(\"dayOfWeek\",dayOfWeek)+']';\n    }\n\n    private String toString(String key, long bit) {\n        return key+'='+Long.toHexString(bit);\n    }\n\n    /**\n     * Checks if this crontab entry looks reasonable,\n     * and if not, return an warning message.\n     *\n     * <p>\n     * The point of this method is to catch syntactically correct\n     * but semantically suspicious combinations, like\n     * \"* 0 * * *\"\n     */\n    public @CheckForNull String checkSanity() {\n        OUTER: for (int i = 0; i < 5; i++) {\n            long bitMask = (i<4)?bits[i]:(long)dayOfWeek;\n            for( int j=BaseParser.LOWER_BOUNDS[i]; j<=BaseParser.UPPER_BOUNDS[i]; j++ ) {\n                if(!checkBits(bitMask,j)) {\n                    // this rank has a sparse entry.\n                    // if we have a sparse rank, one of them better be the left-most.\n                    if(i>0)\n                        return Messages.CronTab_do_you_really_mean_every_minute_when_you(spec, \"H \" + spec.substring(spec.indexOf(' ') + 1));\n                    // once we find a sparse rank, upper ranks don't matter\n                    break OUTER;\n                }\n            }\n        }\n\n        int daysOfMonth = 0;\n        for (int i = 1; i < 31; i++) {\n            if (checkBits(bits[2], i)) {\n                daysOfMonth++;\n            }\n        }\n        if (daysOfMonth > 5 && daysOfMonth < 28) { // a bit arbitrary\n            return Messages.CronTab_short_cycles_in_the_day_of_month_field_w();\n        }\n\n        String hashified = hashify(spec);\n        if (hashified != null) {\n            return Messages.CronTab_spread_load_evenly_by_using_rather_than_(hashified, spec);\n        }\n\n        return null;\n    }\n\n    /**\n     * Checks a prospective crontab specification to see if it could benefit from balanced hashes.\n     * @param spec a (legal) spec\n     * @return a similar spec that uses a hash, if such a transformation is necessary; null if it is OK as is\n     * @since 1.510\n     */\n    public static @CheckForNull String hashify(String spec) {\n        if (spec.contains(\"H\")) {\n            // if someone is already using H, presumably he knows what it is, so a warning is likely false positive\n            return null;\n        } else if (spec.startsWith(\"*/\")) {// \"*/15 ....\" (every N minutes) to hash\n            return \"H\" + spec.substring(1);\n        } else if (spec.matches(\"\\\\d+ .+\")) {// \"0 ...\" (certain minute) to hash\n            return \"H \" + spec.substring(spec.indexOf(' ') + 1);\n        } else {\n            Matcher m = Pattern.compile(\"0(,(\\\\d+)(,\\\\d+)*)( .+)\").matcher(spec);\n            if (m.matches()) { // 0,15,30,45 to H/15\n                int period = Integer.parseInt(m.group(2));\n                if (period > 0) {\n                    StringBuilder b = new StringBuilder();\n                    for (int i = period; i < 60; i += period) {\n                        b.append(',').append(i);\n                    }\n                    if (b.toString().equals(m.group(1))) {\n                        return \"H/\" + period + m.group(4);\n                    }\n                }\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Returns the configured time zone, or null if none is configured\n     *\n     * @return the configured time zone, or null if none is configured\n     * @since 2.54\n     */\n    @CheckForNull public TimeZone getTimeZone() {\n        if (this.specTimezone == null) {\n            return null;\n        }\n        return TimeZone.getTimeZone(this.specTimezone);\n    }\n}\n",
        "human_patch_code": "/*\n * The MIT License\n * \n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, InfraDNA, Inc.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.scheduler;\n\nimport antlr.ANTLRException;\n\nimport java.io.StringReader;\nimport java.util.Calendar;\nimport java.util.TimeZone;\nimport java.util.GregorianCalendar;\nimport java.util.Locale;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static java.util.Calendar.*;\nimport javax.annotation.CheckForNull;\n\n/**\n * Table for driving scheduled tasks.\n *\n * @author Kohsuke Kawaguchi\n */\npublic final class CronTab {\n    /**\n     * bits[0]: minutes\n     * bits[1]: hours\n     * bits[2]: days\n     * bits[3]: months\n     *\n     * false:not scheduled &lt;-> true scheduled\n     */\n    final long[] bits = new long[4];\n\n    int dayOfWeek;\n\n    /**\n     * Textual representation.\n     */\n    private String spec;\n\n    /**\n     * Optional timezone string for calendar \n     */\n    private @CheckForNull String specTimezone;\n\n    public CronTab(String format) throws ANTLRException {\n        this(format,null);\n    }\n\n    public CronTab(String format, Hash hash) throws ANTLRException {\n        this(format,1,hash);\n    }\n    \n    /**\n     * @deprecated as of 1.448\n     *      Use {@link #CronTab(String, int, Hash)}\n     */\n    @Deprecated\n    public CronTab(String format, int line) throws ANTLRException {\n        set(format, line, null);\n    }\n\n    /**\n     * @param hash\n     *      Used to spread out token like \"@daily\". Null to preserve the legacy behaviour\n     *      of not spreading it out at all.\n     */\n    public CronTab(String format, int line, Hash hash) throws ANTLRException {\n        this(format, line, hash, null);\n    }\n\n    /**\n     * @param timezone\n     *      Used to schedule cron in a different timezone. Null to use the default system \n     *      timezone\n     * @since 1.615\n     */\n    public CronTab(String format, int line, Hash hash, @CheckForNull String timezone) throws ANTLRException {\n        set(format, line, hash, timezone);\n    }\n    \n    private void set(String format, int line, Hash hash) throws ANTLRException {\n        set(format, line, hash, null);\n    }\n\n    /**\n     * @since 1.615\n     */\n    private void set(String format, int line, Hash hash, String timezone) throws ANTLRException {\n        CrontabLexer lexer = new CrontabLexer(new StringReader(format));\n        lexer.setLine(line);\n        CrontabParser parser = new CrontabParser(lexer);\n        parser.setHash(hash);\n        spec = format;\n        specTimezone = timezone;\n\n        parser.startRule(this);\n        if((dayOfWeek&(1<<7))!=0) {\n            dayOfWeek |= 1; // copy bit 7 over to bit 0\n            dayOfWeek &= ~(1<<7); // clear bit 7 or CalendarField#ceil will return an invalid value 7\n        }\n    }\n\n\n    /**\n     * Returns true if the given calendar matches\n     */\n    boolean check(Calendar cal) {\n\n        Calendar checkCal = cal;\n\n        if(specTimezone != null && !specTimezone.isEmpty()) {\n            Calendar tzCal = Calendar.getInstance(TimeZone.getTimeZone(specTimezone));\n            tzCal.setTime(cal.getTime());\n            checkCal = tzCal;\n        }\n\n        if(!checkBits(bits[0],checkCal.get(MINUTE)))\n            return false;\n        if(!checkBits(bits[1],checkCal.get(HOUR_OF_DAY)))\n            return false;\n        if(!checkBits(bits[2],checkCal.get(DAY_OF_MONTH)))\n            return false;\n        if(!checkBits(bits[3],checkCal.get(MONTH)+1))\n            return false;\n        if(!checkBits(dayOfWeek,checkCal.get(Calendar.DAY_OF_WEEK)-1))\n            return false;\n\n        return true;\n    }\n\n    private static abstract class CalendarField {\n        /**\n         * {@link Calendar} field ID.\n         */\n        final int field;\n        /**\n         * Lower field is a calendar field whose value needs to be reset when we change the value in this field.\n         * For example, if we modify the value in HOUR, MINUTES must be reset.\n         */\n        final CalendarField lowerField;\n        /**\n         * Whether this field is 0-origin or 1-origin differs between Crontab and {@link Calendar},\n         * so this field adjusts that. If crontab is 1 origin and calendar is 0 origin,  this field is 1\n         * that is the value is {@code (cronOrigin-calendarOrigin)}\n         */\n        final int offset;\n        /**\n         * When we reset this field, we set the field to this value.\n         * For example, resetting {@link Calendar#DAY_OF_MONTH} means setting it to 1.\n         */\n        final int min;\n        /**\n         * If this calendar field has other aliases such that a change in this field\n         * modifies other field values, then true.\n         */\n        final boolean redoAdjustmentIfModified;\n\n        /**\n         * What is this field? Useful for debugging\n         */\n        @SuppressWarnings(\"unused\")\n        private final String displayName;\n\n        private CalendarField(String displayName, int field, int min, int offset, boolean redoAdjustmentIfModified, CalendarField lowerField) {\n            this.displayName = displayName;\n            this.field = field;\n            this.min = min;\n            this.redoAdjustmentIfModified= redoAdjustmentIfModified;\n            this.lowerField = lowerField;\n            this.offset = offset;\n        }\n\n        /**\n         * Gets the current value of this field in the given calendar.\n         */\n        int valueOf(Calendar c) {\n            return c.get(field)+offset;\n        }\n\n        void addTo(Calendar c, int i) {\n            c.add(field,i);\n        }\n\n        void setTo(Calendar c, int i) {\n            c.set(field,Math.min(i-offset, c.getActualMaximum(field)));\n        }\n\n        void clear(Calendar c) {\n            setTo(c, min);\n        }\n\n        /**\n         * Given the value 'n' (which represents the current value), finds the smallest x such that:\n         *  1) x matches the specified {@link CronTab} (as far as this field is concerned.)\n         *  2) x>=n   (inclusive)\n         *\n         * If there's no such bit, return -1. Note that if 'n' already matches the crontab, the same n will be returned.\n         */\n        private int ceil(CronTab c, int n) {\n            long bits = bits(c);\n            while ((bits|(1L<<n))!=bits) {\n                if (n>60)   return -1;\n                n++;\n            }\n            return n;\n        }\n\n        /**\n         * Given a bit mask, finds the first bit that's on, and return its index.\n         */\n        private int first(CronTab c) {\n            return ceil(c,0);\n        }\n\n        private int floor(CronTab c, int n) {\n            long bits = bits(c);\n            while ((bits|(1L<<n))!=bits) {\n                if (n==0)   return -1;\n                n--;\n            }\n            return n;\n        }\n\n        private int last(CronTab c) {\n            return floor(c,63);\n        }\n\n        /**\n         * Extracts the bit masks from the given {@link CronTab} that matches this field.\n         */\n        abstract long bits(CronTab c);\n\n        /**\n         * Increment the next field.\n         */\n        abstract void rollUp(Calendar cal, int i);\n\n        private static final CalendarField MINUTE       = new CalendarField(\"minute\", Calendar.MINUTE,        0, 0, false, null) {\n            long bits(CronTab c) { return c.bits[0]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.HOUR_OF_DAY,i); }\n        };\n        private static final CalendarField HOUR         = new CalendarField(\"hour\", Calendar.HOUR_OF_DAY,   0, 0, false, MINUTE) {\n            long bits(CronTab c) { return c.bits[1]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.DAY_OF_MONTH,i); }\n        };\n        private static final CalendarField DAY_OF_MONTH = new CalendarField(\"day\", Calendar.DAY_OF_MONTH,  1, 0, true,  HOUR) {\n            long bits(CronTab c) { return c.bits[2]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.MONTH,i); }\n        };\n        private static final CalendarField MONTH        = new CalendarField(\"month\", Calendar.MONTH,         1, 1, false, DAY_OF_MONTH) {\n            long bits(CronTab c) { return c.bits[3]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.YEAR,i); }\n        };\n        private static final CalendarField DAY_OF_WEEK  = new CalendarField(\"dow\", Calendar.DAY_OF_WEEK,   1,-1, true,  HOUR) {\n            long bits(CronTab c) { return c.dayOfWeek; }\n            void rollUp(Calendar cal, int i) {\n                cal.add(Calendar.DAY_OF_WEEK, 7 * i);\n            }\n\n            @Override\n            void setTo(Calendar c, int i) {\n                int v = i-offset;\n                int was = c.get(field);\n                c.set(field,v);\n                final int firstDayOfWeek = c.getFirstDayOfWeek();\n                if (v < firstDayOfWeek && was >= firstDayOfWeek) {\n                    // in crontab, the first DoW is always Sunday, but in Java, it can be Monday or in theory arbitrary other days.\n                    // When first DoW is 1/2 Monday, calendar points to 1/2 Monday, setting the DoW to Sunday makes\n                    // the calendar moves forward to 1/8 Sunday, instead of 1/1 Sunday. So we need to compensate that effect here.\n                    addTo(c,-7);\n                } else if (was < firstDayOfWeek && firstDayOfWeek <= v) {\n                    // If we wrap the other way around, we need to adjust in the opposite direction of above.\n                    addTo(c, 7);\n                }\n            }\n        };\n\n        private static final CalendarField[] ADJUST_ORDER = {\n            MONTH, DAY_OF_MONTH, DAY_OF_WEEK, HOUR, MINUTE\n        };\n    }\n\n\n    /**\n     * Computes the nearest future timestamp that matches this cron tab.\n     * <p>\n     * More precisely, given the time 't', computes another smallest time x such that:\n     *\n     * <ul>\n     * <li>x \u2265 t (inclusive)\n     * <li>x matches this crontab\n     * </ul>\n     *\n     * <p>\n     * Note that if t already matches this cron, it's returned as is.\n     */\n    public Calendar ceil(long t) {\n        Calendar cal = new GregorianCalendar(Locale.US);\n        cal.setTimeInMillis(t);\n        return ceil(cal);\n    }\n\n    /**\n     * See {@link #ceil(long)}.\n     *\n     * This method modifies the given calendar and returns the same object.\n     *\n     * @throws RareOrImpossibleDateException if the date isn't hit in the 2 years after it indicates an impossible\n     * (e.g. Jun 31) date, or at least a date too rare to be useful. This addresses JENKINS-41864 and was added in 2.49\n     */\n    public Calendar ceil(Calendar cal) {\n        Calendar twoYearsFuture = (Calendar) cal.clone();\n        twoYearsFuture.add(Calendar.YEAR, 2);\n        OUTER:\n        while (true) {\n            if (cal.compareTo(twoYearsFuture) > 0) {\n                // we went too far into the future\n                throw new RareOrImpossibleDateException();\n            }\n            for (CalendarField f : CalendarField.ADJUST_ORDER) {\n                int cur = f.valueOf(cal);\n                int next = f.ceil(this,cur);\n                if (cur==next)  continue;   // this field is already in a good shape. move on to next\n\n                // we are modifying this field, so clear all the lower level fields\n                for (CalendarField l=f.lowerField; l!=null; l=l.lowerField)\n                    l.clear(cal);\n\n                if (next<0) {\n                    // we need to roll over to the next field.\n                    f.rollUp(cal, 1);\n                    f.setTo(cal,f.first(this));\n                    // since higher order field is affected by this, we need to restart from all over\n                    continue OUTER;\n                } else {\n                    f.setTo(cal,next);\n                    if (f.redoAdjustmentIfModified)\n                        continue OUTER; // when we modify DAY_OF_MONTH and DAY_OF_WEEK, do it all over from the top\n                }\n            }\n            return cal; // all fields adjusted\n        }\n    }\n\n    /**\n     * Computes the nearest past timestamp that matched this cron tab.\n     * <p>\n     * More precisely, given the time 't', computes another smallest time x such that:\n     *\n     * <ul>\n     * <li>x &lt;= t (inclusive)\n     * <li>x matches this crontab\n     * </ul>\n     *\n     * <p>\n     * Note that if t already matches this cron, it's returned as is.\n     */\n    public Calendar floor(long t) {\n        Calendar cal = new GregorianCalendar(Locale.US);\n        cal.setTimeInMillis(t);\n        return floor(cal);\n    }\n\n    /**\n     * See {@link #floor(long)}\n     *\n     * This method modifies the given calendar and returns the same object.\n     *\n     * @throws RareOrImpossibleDateException if the date isn't hit in the 2 years before it indicates an impossible\n     * (e.g. Jun 31) date, or at least a date too rare to be useful. This addresses JENKINS-41864 and was added in 2.49\n     */\n    public Calendar floor(Calendar cal) {\n        Calendar twoYearsAgo = (Calendar) cal.clone();\n        twoYearsAgo.add(Calendar.YEAR, -2);\n\n        OUTER:\n        while (true) {\n            if (cal.compareTo(twoYearsAgo) < 0) {\n                // we went too far into the past\n                throw new RareOrImpossibleDateException();\n            }\n            for (CalendarField f : CalendarField.ADJUST_ORDER) {\n                int cur = f.valueOf(cal);\n                int next = f.floor(this,cur);\n                if (cur==next)  continue;   // this field is already in a good shape. move on to next\n\n                // we are modifying this field, so clear all the lower level fields\n                for (CalendarField l=f.lowerField; l!=null; l=l.lowerField)\n                    l.clear(cal);\n\n                if (next<0) {\n                    // we need to borrow from the next field.\n                    f.rollUp(cal,-1);\n                    // the problem here, in contrast with the ceil method, is that\n                    // the maximum value of the field is not always a fixed value (that is, day of month)\n                    // so we zero-clear all the lower fields, set the desired value +1,\n                    f.setTo(cal,f.last(this));\n                    f.addTo(cal,1);\n                    // then subtract a minute to achieve maximum values on all the lower fields,\n                    // with the desired value in 'f'\n                    CalendarField.MINUTE.addTo(cal,-1);\n                    // since higher order field is affected by this, we need to restart from all over\n                    continue OUTER;\n                } else {\n                    f.setTo(cal,next);\n                    f.addTo(cal,1);\n                    CalendarField.MINUTE.addTo(cal,-1);\n                    if (f.redoAdjustmentIfModified)\n                        continue OUTER; // when we modify DAY_OF_MONTH and DAY_OF_WEEK, do it all over from the top\n                }\n            }\n            return cal; // all fields adjusted\n        }\n    }\n\n    void set(String format, Hash hash) throws ANTLRException {\n        set(format,1,hash);\n    }\n\n    /**\n     * Returns true if n-th bit is on.\n     */\n    private boolean checkBits(long bitMask, int n) {\n        return (bitMask|(1L<<n))==bitMask;\n    }\n\n    public String toString() {\n        return super.toString()+\"[\"+\n            toString(\"minute\",bits[0])+','+\n            toString(\"hour\",bits[1])+','+\n            toString(\"dayOfMonth\",bits[2])+','+\n            toString(\"month\",bits[3])+','+\n            toString(\"dayOfWeek\",dayOfWeek)+']';\n    }\n\n    private String toString(String key, long bit) {\n        return key+'='+Long.toHexString(bit);\n    }\n\n    /**\n     * Checks if this crontab entry looks reasonable,\n     * and if not, return an warning message.\n     *\n     * <p>\n     * The point of this method is to catch syntactically correct\n     * but semantically suspicious combinations, like\n     * \"* 0 * * *\"\n     */\n    public @CheckForNull String checkSanity() {\n        OUTER: for (int i = 0; i < 5; i++) {\n            long bitMask = (i<4)?bits[i]:(long)dayOfWeek;\n            for( int j=BaseParser.LOWER_BOUNDS[i]; j<=BaseParser.UPPER_BOUNDS[i]; j++ ) {\n                if(!checkBits(bitMask,j)) {\n                    // this rank has a sparse entry.\n                    // if we have a sparse rank, one of them better be the left-most.\n                    if(i>0)\n                        return Messages.CronTab_do_you_really_mean_every_minute_when_you(spec, \"H \" + spec.substring(spec.indexOf(' ') + 1));\n                    // once we find a sparse rank, upper ranks don't matter\n                    break OUTER;\n                }\n            }\n        }\n\n        int daysOfMonth = 0;\n        for (int i = 1; i < 31; i++) {\n            if (checkBits(bits[2], i)) {\n                daysOfMonth++;\n            }\n        }\n        if (daysOfMonth > 5 && daysOfMonth < 28) { // a bit arbitrary\n            return Messages.CronTab_short_cycles_in_the_day_of_month_field_w();\n        }\n\n        String hashified = hashify(spec);\n        if (hashified != null) {\n            return Messages.CronTab_spread_load_evenly_by_using_rather_than_(hashified, spec);\n        }\n\n        return null;\n    }\n\n    /**\n     * Checks a prospective crontab specification to see if it could benefit from balanced hashes.\n     * @param spec a (legal) spec\n     * @return a similar spec that uses a hash, if such a transformation is necessary; null if it is OK as is\n     * @since 1.510\n     */\n    public static @CheckForNull String hashify(String spec) {\n        if (spec.contains(\"H\")) {\n            // if someone is already using H, presumably he knows what it is, so a warning is likely false positive\n            return null;\n        } else if (spec.startsWith(\"*/\")) {// \"*/15 ....\" (every N minutes) to hash\n            return \"H\" + spec.substring(1);\n        } else if (spec.matches(\"\\\\d+ .+\")) {// \"0 ...\" (certain minute) to hash\n            return \"H \" + spec.substring(spec.indexOf(' ') + 1);\n        } else {\n            Matcher m = Pattern.compile(\"0(,(\\\\d+)(,\\\\d+)*)( .+)\").matcher(spec);\n            if (m.matches()) { // 0,15,30,45 to H/15\n                int period = Integer.parseInt(m.group(2));\n                if (period > 0) {\n                    StringBuilder b = new StringBuilder();\n                    for (int i = period; i < 60; i += period) {\n                        b.append(',').append(i);\n                    }\n                    if (b.toString().equals(m.group(1))) {\n                        return \"H/\" + period + m.group(4);\n                    }\n                }\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Returns the configured time zone, or null if none is configured\n     *\n     * @return the configured time zone, or null if none is configured\n     * @since 2.54\n     */\n    @CheckForNull public TimeZone getTimeZone() {\n        if (this.specTimezone == null) {\n            return null;\n        }\n        return TimeZone.getTimeZone(this.specTimezone);\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-55": {
    "vul_id": "VUL4J-55",
    "cve_id": "CVE-2018-1000864",
    "project": "jenkinsci_jenkins",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl core -Dtest=hudson.scheduler.CronTabTest#testCeilLongMonths",
    "test_all_cmd": "mvn test -pl core",
    "human_patch_url": "https://github.com/jenkinsci/jenkins/commit/73afa0ca786a87f05b5433e2e38f863826fcad17",
    "vulnerable_files": [
      {
        "file_path": "core/src/main/java/hudson/scheduler/CronTab.java",
        "file_name": "CronTab.java",
        "vulnerable_code": "/*\n * The MIT License\n * \n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, InfraDNA, Inc.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.scheduler;\n\nimport antlr.ANTLRException;\n\nimport java.io.StringReader;\nimport java.util.Calendar;\nimport java.util.TimeZone;\nimport java.util.GregorianCalendar;\nimport java.util.Locale;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static java.util.Calendar.*;\nimport javax.annotation.CheckForNull;\n\n/**\n * Table for driving scheduled tasks.\n *\n * @author Kohsuke Kawaguchi\n */\npublic final class CronTab {\n    /**\n     * bits[0]: minutes\n     * bits[1]: hours\n     * bits[2]: days\n     * bits[3]: months\n     *\n     * false:not scheduled &lt;-> true scheduled\n     */\n    final long[] bits = new long[4];\n\n    int dayOfWeek;\n\n    /**\n     * Textual representation.\n     */\n    private String spec;\n\n    /**\n     * Optional timezone string for calendar \n     */\n    private @CheckForNull String specTimezone;\n\n    public CronTab(String format) throws ANTLRException {\n        this(format,null);\n    }\n\n    public CronTab(String format, Hash hash) throws ANTLRException {\n        this(format,1,hash);\n    }\n    \n    /**\n     * @deprecated as of 1.448\n     *      Use {@link #CronTab(String, int, Hash)}\n     */\n    @Deprecated\n    public CronTab(String format, int line) throws ANTLRException {\n        set(format, line, null);\n    }\n\n    /**\n     * @param hash\n     *      Used to spread out token like \"@daily\". Null to preserve the legacy behaviour\n     *      of not spreading it out at all.\n     */\n    public CronTab(String format, int line, Hash hash) throws ANTLRException {\n        this(format, line, hash, null);\n    }\n\n    /**\n     * @param timezone\n     *      Used to schedule cron in a different timezone. Null to use the default system \n     *      timezone\n     * @since 1.615\n     */\n    public CronTab(String format, int line, Hash hash, @CheckForNull String timezone) throws ANTLRException {\n        set(format, line, hash, timezone);\n    }\n    \n    private void set(String format, int line, Hash hash) throws ANTLRException {\n        set(format, line, hash, null);\n    }\n\n    /**\n     * @since 1.615\n     */\n    private void set(String format, int line, Hash hash, String timezone) throws ANTLRException {\n        CrontabLexer lexer = new CrontabLexer(new StringReader(format));\n        lexer.setLine(line);\n        CrontabParser parser = new CrontabParser(lexer);\n        parser.setHash(hash);\n        spec = format;\n        specTimezone = timezone;\n\n        parser.startRule(this);\n        if((dayOfWeek&(1<<7))!=0) {\n            dayOfWeek |= 1; // copy bit 7 over to bit 0\n            dayOfWeek &= ~(1<<7); // clear bit 7 or CalendarField#ceil will return an invalid value 7\n        }\n    }\n\n\n    /**\n     * Returns true if the given calendar matches\n     */\n    boolean check(Calendar cal) {\n\n        Calendar checkCal = cal;\n\n        if(specTimezone != null && !specTimezone.isEmpty()) {\n            Calendar tzCal = Calendar.getInstance(TimeZone.getTimeZone(specTimezone));\n            tzCal.setTime(cal.getTime());\n            checkCal = tzCal;\n        }\n\n        if(!checkBits(bits[0],checkCal.get(MINUTE)))\n            return false;\n        if(!checkBits(bits[1],checkCal.get(HOUR_OF_DAY)))\n            return false;\n        if(!checkBits(bits[2],checkCal.get(DAY_OF_MONTH)))\n            return false;\n        if(!checkBits(bits[3],checkCal.get(MONTH)+1))\n            return false;\n        if(!checkBits(dayOfWeek,checkCal.get(Calendar.DAY_OF_WEEK)-1))\n            return false;\n\n        return true;\n    }\n\n    private static abstract class CalendarField {\n        /**\n         * {@link Calendar} field ID.\n         */\n        final int field;\n        /**\n         * Lower field is a calendar field whose value needs to be reset when we change the value in this field.\n         * For example, if we modify the value in HOUR, MINUTES must be reset.\n         */\n        final CalendarField lowerField;\n        /**\n         * Whether this field is 0-origin or 1-origin differs between Crontab and {@link Calendar},\n         * so this field adjusts that. If crontab is 1 origin and calendar is 0 origin,  this field is 1\n         * that is the value is {@code (cronOrigin-calendarOrigin)}\n         */\n        final int offset;\n        /**\n         * When we reset this field, we set the field to this value.\n         * For example, resetting {@link Calendar#DAY_OF_MONTH} means setting it to 1.\n         */\n        final int min;\n        /**\n         * If this calendar field has other aliases such that a change in this field\n         * modifies other field values, then true.\n         */\n        final boolean redoAdjustmentIfModified;\n\n        /**\n         * What is this field? Useful for debugging\n         */\n        @SuppressWarnings(\"unused\")\n        private final String displayName;\n\n        private CalendarField(String displayName, int field, int min, int offset, boolean redoAdjustmentIfModified, CalendarField lowerField) {\n            this.displayName = displayName;\n            this.field = field;\n            this.min = min;\n            this.redoAdjustmentIfModified= redoAdjustmentIfModified;\n            this.lowerField = lowerField;\n            this.offset = offset;\n        }\n\n        /**\n         * Gets the current value of this field in the given calendar.\n         */\n        int valueOf(Calendar c) {\n            return c.get(field)+offset;\n        }\n\n        void addTo(Calendar c, int i) {\n            c.add(field,i);\n        }\n\n        void setTo(Calendar c, int i) {\n            c.set(field,Math.min(i-offset, c.getActualMaximum(field)));\n        }\n\n        void clear(Calendar c) {\n            setTo(c, min);\n        }\n\n        /**\n         * Given the value 'n' (which represents the current value), finds the smallest x such that:\n         *  1) x matches the specified {@link CronTab} (as far as this field is concerned.)\n         *  2) x>=n   (inclusive)\n         *\n         * If there's no such bit, return -1. Note that if 'n' already matches the crontab, the same n will be returned.\n         */\n        private int ceil(CronTab c, int n) {\n            long bits = bits(c);\n            while ((bits|(1L<<n))!=bits) {\n                if (n>60)   return -1;\n                n++;\n            }\n            return n;\n        }\n\n        /**\n         * Given a bit mask, finds the first bit that's on, and return its index.\n         */\n        private int first(CronTab c) {\n            return ceil(c,0);\n        }\n\n        private int floor(CronTab c, int n) {\n            long bits = bits(c);\n            while ((bits|(1L<<n))!=bits) {\n                if (n==0)   return -1;\n                n--;\n            }\n            return n;\n        }\n\n        private int last(CronTab c) {\n            return floor(c,63);\n        }\n\n        /**\n         * Extracts the bit masks from the given {@link CronTab} that matches this field.\n         */\n        abstract long bits(CronTab c);\n\n        /**\n         * Increment the next field.\n         */\n        abstract void rollUp(Calendar cal, int i);\n\n        private static final CalendarField MINUTE       = new CalendarField(\"minute\", Calendar.MINUTE,        0, 0, false, null) {\n            long bits(CronTab c) { return c.bits[0]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.HOUR_OF_DAY,i); }\n        };\n        private static final CalendarField HOUR         = new CalendarField(\"hour\", Calendar.HOUR_OF_DAY,   0, 0, false, MINUTE) {\n            long bits(CronTab c) { return c.bits[1]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.DAY_OF_MONTH,i); }\n        };\n        private static final CalendarField DAY_OF_MONTH = new CalendarField(\"day\", Calendar.DAY_OF_MONTH,  1, 0, true,  HOUR) {\n            long bits(CronTab c) { return c.bits[2]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.MONTH,i); }\n        };\n        private static final CalendarField MONTH        = new CalendarField(\"month\", Calendar.MONTH,         1, 1, false, DAY_OF_MONTH) {\n            long bits(CronTab c) { return c.bits[3]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.YEAR,i); }\n        };\n        private static final CalendarField DAY_OF_WEEK  = new CalendarField(\"dow\", Calendar.DAY_OF_WEEK,   1,-1, true,  HOUR) {\n            long bits(CronTab c) { return c.dayOfWeek; }\n            void rollUp(Calendar cal, int i) {\n                cal.add(Calendar.DAY_OF_WEEK, 7 * i);\n            }\n\n            @Override\n            void setTo(Calendar c, int i) {\n                int v = i-offset;\n                int was = c.get(field);\n                c.set(field,v);\n                final int firstDayOfWeek = c.getFirstDayOfWeek();\n                if (v < firstDayOfWeek && was >= firstDayOfWeek) {\n                    // in crontab, the first DoW is always Sunday, but in Java, it can be Monday or in theory arbitrary other days.\n                    // When first DoW is 1/2 Monday, calendar points to 1/2 Monday, setting the DoW to Sunday makes\n                    // the calendar moves forward to 1/8 Sunday, instead of 1/1 Sunday. So we need to compensate that effect here.\n                    addTo(c,-7);\n                } else if (was < firstDayOfWeek && firstDayOfWeek <= v) {\n                    // If we wrap the other way around, we need to adjust in the opposite direction of above.\n                    addTo(c, 7);\n                }\n            }\n        };\n\n        private static final CalendarField[] ADJUST_ORDER = {\n            MONTH, DAY_OF_MONTH, DAY_OF_WEEK, HOUR, MINUTE\n        };\n    }\n\n\n    /**\n     * Computes the nearest future timestamp that matches this cron tab.\n     * <p>\n     * More precisely, given the time 't', computes another smallest time x such that:\n     *\n     * <ul>\n     * <li>x \u2265 t (inclusive)\n     * <li>x matches this crontab\n     * </ul>\n     *\n     * <p>\n     * Note that if t already matches this cron, it's returned as is.\n     */\n    public Calendar ceil(long t) {\n        Calendar cal = new GregorianCalendar(Locale.US);\n        cal.setTimeInMillis(t);\n        return ceil(cal);\n    }\n\n    /**\n     * See {@link #ceil(long)}.\n     *\n     * This method modifies the given calendar and returns the same object.\n     *\n     * @throws RareOrImpossibleDateException if the date isn't hit in the 2 years after it indicates an impossible\n     * (e.g. Jun 31) date, or at least a date too rare to be useful. This addresses JENKINS-41864 and was added in 2.49\n     */\n    public Calendar ceil(Calendar cal) {\n        Calendar twoYearsFuture = (Calendar) cal.clone();\n        twoYearsFuture.add(Calendar.YEAR, 2);\n        OUTER:\n        while (true) {\n            if (cal.compareTo(twoYearsFuture) > 0) {\n                // we went too far into the future\n                throw new RareOrImpossibleDateException();\n            }\n            for (CalendarField f : CalendarField.ADJUST_ORDER) {\n                int cur = f.valueOf(cal);\n                int next = f.ceil(this,cur);\n                if (cur==next)  continue;   // this field is already in a good shape. move on to next\n\n                // we are modifying this field, so clear all the lower level fields\n                for (CalendarField l=f.lowerField; l!=null; l=l.lowerField)\n                    l.clear(cal);\n\n                if (next<0) {\n                    // we need to roll over to the next field.\n                    f.rollUp(cal, 1);\n                    f.setTo(cal,f.first(this));\n                    // since higher order field is affected by this, we need to restart from all over\n                    continue OUTER;\n                } else {\n                    f.setTo(cal,next);\n                    if (f.redoAdjustmentIfModified)\n                        continue OUTER; // when we modify DAY_OF_MONTH and DAY_OF_WEEK, do it all over from the top\n                }\n            }\n            return cal; // all fields adjusted\n        }\n    }\n\n    /**\n     * Computes the nearest past timestamp that matched this cron tab.\n     * <p>\n     * More precisely, given the time 't', computes another smallest time x such that:\n     *\n     * <ul>\n     * <li>x &lt;= t (inclusive)\n     * <li>x matches this crontab\n     * </ul>\n     *\n     * <p>\n     * Note that if t already matches this cron, it's returned as is.\n     */\n    public Calendar floor(long t) {\n        Calendar cal = new GregorianCalendar(Locale.US);\n        cal.setTimeInMillis(t);\n        return floor(cal);\n    }\n\n    /**\n     * See {@link #floor(long)}\n     *\n     * This method modifies the given calendar and returns the same object.\n     *\n     * @throws RareOrImpossibleDateException if the date isn't hit in the 2 years before it indicates an impossible\n     * (e.g. Jun 31) date, or at least a date too rare to be useful. This addresses JENKINS-41864 and was added in 2.49\n     */\n    public Calendar floor(Calendar cal) {\n        Calendar twoYearsAgo = (Calendar) cal.clone();\n        twoYearsAgo.add(Calendar.YEAR, -2);\n\n        OUTER:\n        while (true) {\n            if (cal.compareTo(twoYearsAgo) < 0) {\n                // we went too far into the past\n                throw new RareOrImpossibleDateException();\n            }\n            for (CalendarField f : CalendarField.ADJUST_ORDER) {\n                int cur = f.valueOf(cal);\n                int next = f.floor(this,cur);\n                if (cur==next)  continue;   // this field is already in a good shape. move on to next\n\n                // we are modifying this field, so clear all the lower level fields\n                for (CalendarField l=f.lowerField; l!=null; l=l.lowerField)\n                    l.clear(cal);\n\n                if (next<0) {\n                    // we need to borrow from the next field.\n                    f.rollUp(cal,-1);\n                    // the problem here, in contrast with the ceil method, is that\n                    // the maximum value of the field is not always a fixed value (that is, day of month)\n                    // so we zero-clear all the lower fields, set the desired value +1,\n                    f.setTo(cal,f.last(this));\n                    f.addTo(cal,1);\n                    // then subtract a minute to achieve maximum values on all the lower fields,\n                    // with the desired value in 'f'\n                    CalendarField.MINUTE.addTo(cal,-1);\n                    // since higher order field is affected by this, we need to restart from all over\n                    continue OUTER;\n                } else {\n                    f.setTo(cal,next);\n                    f.addTo(cal,1);\n                    CalendarField.MINUTE.addTo(cal,-1);\n                    if (f.redoAdjustmentIfModified)\n                        continue OUTER; // when we modify DAY_OF_MONTH and DAY_OF_WEEK, do it all over from the top\n                }\n            }\n            return cal; // all fields adjusted\n        }\n    }\n\n    void set(String format, Hash hash) throws ANTLRException {\n        set(format,1,hash);\n    }\n\n    /**\n     * Returns true if n-th bit is on.\n     */\n    private boolean checkBits(long bitMask, int n) {\n        return (bitMask|(1L<<n))==bitMask;\n    }\n\n    public String toString() {\n        return super.toString()+\"[\"+\n            toString(\"minute\",bits[0])+','+\n            toString(\"hour\",bits[1])+','+\n            toString(\"dayOfMonth\",bits[2])+','+\n            toString(\"month\",bits[3])+','+\n            toString(\"dayOfWeek\",dayOfWeek)+']';\n    }\n\n    private String toString(String key, long bit) {\n        return key+'='+Long.toHexString(bit);\n    }\n\n    /**\n     * Checks if this crontab entry looks reasonable,\n     * and if not, return an warning message.\n     *\n     * <p>\n     * The point of this method is to catch syntactically correct\n     * but semantically suspicious combinations, like\n     * \"* 0 * * *\"\n     */\n    public @CheckForNull String checkSanity() {\n        OUTER: for (int i = 0; i < 5; i++) {\n            long bitMask = (i<4)?bits[i]:(long)dayOfWeek;\n            for( int j=BaseParser.LOWER_BOUNDS[i]; j<=BaseParser.UPPER_BOUNDS[i]; j++ ) {\n                if(!checkBits(bitMask,j)) {\n                    // this rank has a sparse entry.\n                    // if we have a sparse rank, one of them better be the left-most.\n                    if(i>0)\n                        return Messages.CronTab_do_you_really_mean_every_minute_when_you(spec, \"H \" + spec.substring(spec.indexOf(' ') + 1));\n                    // once we find a sparse rank, upper ranks don't matter\n                    break OUTER;\n                }\n            }\n        }\n\n        int daysOfMonth = 0;\n        for (int i = 1; i < 31; i++) {\n            if (checkBits(bits[2], i)) {\n                daysOfMonth++;\n            }\n        }\n        if (daysOfMonth > 5 && daysOfMonth < 28) { // a bit arbitrary\n            return Messages.CronTab_short_cycles_in_the_day_of_month_field_w();\n        }\n\n        String hashified = hashify(spec);\n        if (hashified != null) {\n            return Messages.CronTab_spread_load_evenly_by_using_rather_than_(hashified, spec);\n        }\n\n        return null;\n    }\n\n    /**\n     * Checks a prospective crontab specification to see if it could benefit from balanced hashes.\n     * @param spec a (legal) spec\n     * @return a similar spec that uses a hash, if such a transformation is necessary; null if it is OK as is\n     * @since 1.510\n     */\n    public static @CheckForNull String hashify(String spec) {\n        if (spec.contains(\"H\")) {\n            // if someone is already using H, presumably he knows what it is, so a warning is likely false positive\n            return null;\n        } else if (spec.startsWith(\"*/\")) {// \"*/15 ....\" (every N minutes) to hash\n            return \"H\" + spec.substring(1);\n        } else if (spec.matches(\"\\\\d+ .+\")) {// \"0 ...\" (certain minute) to hash\n            return \"H \" + spec.substring(spec.indexOf(' ') + 1);\n        } else {\n            Matcher m = Pattern.compile(\"0(,(\\\\d+)(,\\\\d+)*)( .+)\").matcher(spec);\n            if (m.matches()) { // 0,15,30,45 to H/15\n                int period = Integer.parseInt(m.group(2));\n                if (period > 0) {\n                    StringBuilder b = new StringBuilder();\n                    for (int i = period; i < 60; i += period) {\n                        b.append(',').append(i);\n                    }\n                    if (b.toString().equals(m.group(1))) {\n                        return \"H/\" + period + m.group(4);\n                    }\n                }\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Returns the configured time zone, or null if none is configured\n     *\n     * @return the configured time zone, or null if none is configured\n     * @since 2.54\n     */\n    @CheckForNull public TimeZone getTimeZone() {\n        if (this.specTimezone == null) {\n            return null;\n        }\n        return TimeZone.getTimeZone(this.specTimezone);\n    }\n}\n",
        "human_patch_code": "/*\n * The MIT License\n * \n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, InfraDNA, Inc.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.scheduler;\n\nimport antlr.ANTLRException;\n\nimport java.io.StringReader;\nimport java.util.Calendar;\nimport java.util.TimeZone;\nimport java.util.GregorianCalendar;\nimport java.util.Locale;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static java.util.Calendar.*;\nimport javax.annotation.CheckForNull;\n\n/**\n * Table for driving scheduled tasks.\n *\n * @author Kohsuke Kawaguchi\n */\npublic final class CronTab {\n    /**\n     * bits[0]: minutes\n     * bits[1]: hours\n     * bits[2]: days\n     * bits[3]: months\n     *\n     * false:not scheduled &lt;-> true scheduled\n     */\n    final long[] bits = new long[4];\n\n    int dayOfWeek;\n\n    /**\n     * Textual representation.\n     */\n    private String spec;\n\n    /**\n     * Optional timezone string for calendar \n     */\n    private @CheckForNull String specTimezone;\n\n    public CronTab(String format) throws ANTLRException {\n        this(format,null);\n    }\n\n    public CronTab(String format, Hash hash) throws ANTLRException {\n        this(format,1,hash);\n    }\n    \n    /**\n     * @deprecated as of 1.448\n     *      Use {@link #CronTab(String, int, Hash)}\n     */\n    @Deprecated\n    public CronTab(String format, int line) throws ANTLRException {\n        set(format, line, null);\n    }\n\n    /**\n     * @param hash\n     *      Used to spread out token like \"@daily\". Null to preserve the legacy behaviour\n     *      of not spreading it out at all.\n     */\n    public CronTab(String format, int line, Hash hash) throws ANTLRException {\n        this(format, line, hash, null);\n    }\n\n    /**\n     * @param timezone\n     *      Used to schedule cron in a different timezone. Null to use the default system \n     *      timezone\n     * @since 1.615\n     */\n    public CronTab(String format, int line, Hash hash, @CheckForNull String timezone) throws ANTLRException {\n        set(format, line, hash, timezone);\n    }\n    \n    private void set(String format, int line, Hash hash) throws ANTLRException {\n        set(format, line, hash, null);\n    }\n\n    /**\n     * @since 1.615\n     */\n    private void set(String format, int line, Hash hash, String timezone) throws ANTLRException {\n        CrontabLexer lexer = new CrontabLexer(new StringReader(format));\n        lexer.setLine(line);\n        CrontabParser parser = new CrontabParser(lexer);\n        parser.setHash(hash);\n        spec = format;\n        specTimezone = timezone;\n\n        parser.startRule(this);\n        if((dayOfWeek&(1<<7))!=0) {\n            dayOfWeek |= 1; // copy bit 7 over to bit 0\n            dayOfWeek &= ~(1<<7); // clear bit 7 or CalendarField#ceil will return an invalid value 7\n        }\n    }\n\n\n    /**\n     * Returns true if the given calendar matches\n     */\n    boolean check(Calendar cal) {\n\n        Calendar checkCal = cal;\n\n        if(specTimezone != null && !specTimezone.isEmpty()) {\n            Calendar tzCal = Calendar.getInstance(TimeZone.getTimeZone(specTimezone));\n            tzCal.setTime(cal.getTime());\n            checkCal = tzCal;\n        }\n\n        if(!checkBits(bits[0],checkCal.get(MINUTE)))\n            return false;\n        if(!checkBits(bits[1],checkCal.get(HOUR_OF_DAY)))\n            return false;\n        if(!checkBits(bits[2],checkCal.get(DAY_OF_MONTH)))\n            return false;\n        if(!checkBits(bits[3],checkCal.get(MONTH)+1))\n            return false;\n        if(!checkBits(dayOfWeek,checkCal.get(Calendar.DAY_OF_WEEK)-1))\n            return false;\n\n        return true;\n    }\n\n    private static abstract class CalendarField {\n        /**\n         * {@link Calendar} field ID.\n         */\n        final int field;\n        /**\n         * Lower field is a calendar field whose value needs to be reset when we change the value in this field.\n         * For example, if we modify the value in HOUR, MINUTES must be reset.\n         */\n        final CalendarField lowerField;\n        /**\n         * Whether this field is 0-origin or 1-origin differs between Crontab and {@link Calendar},\n         * so this field adjusts that. If crontab is 1 origin and calendar is 0 origin,  this field is 1\n         * that is the value is {@code (cronOrigin-calendarOrigin)}\n         */\n        final int offset;\n        /**\n         * When we reset this field, we set the field to this value.\n         * For example, resetting {@link Calendar#DAY_OF_MONTH} means setting it to 1.\n         */\n        final int min;\n        /**\n         * If this calendar field has other aliases such that a change in this field\n         * modifies other field values, then true.\n         */\n        final boolean redoAdjustmentIfModified;\n\n        /**\n         * What is this field? Useful for debugging\n         */\n        @SuppressWarnings(\"unused\")\n        private final String displayName;\n\n        private CalendarField(String displayName, int field, int min, int offset, boolean redoAdjustmentIfModified, CalendarField lowerField) {\n            this.displayName = displayName;\n            this.field = field;\n            this.min = min;\n            this.redoAdjustmentIfModified= redoAdjustmentIfModified;\n            this.lowerField = lowerField;\n            this.offset = offset;\n        }\n\n        /**\n         * Gets the current value of this field in the given calendar.\n         */\n        int valueOf(Calendar c) {\n            return c.get(field)+offset;\n        }\n\n        void addTo(Calendar c, int i) {\n            c.add(field,i);\n        }\n\n        void setTo(Calendar c, int i) {\n            c.set(field,Math.min(i-offset, c.getActualMaximum(field)));\n        }\n\n        void clear(Calendar c) {\n            setTo(c, min);\n        }\n\n        /**\n         * Given the value 'n' (which represents the current value), finds the smallest x such that:\n         *  1) x matches the specified {@link CronTab} (as far as this field is concerned.)\n         *  2) x>=n   (inclusive)\n         *\n         * If there's no such bit, return -1. Note that if 'n' already matches the crontab, the same n will be returned.\n         */\n        private int ceil(CronTab c, int n) {\n            long bits = bits(c);\n            while ((bits|(1L<<n))!=bits) {\n                if (n>60)   return -1;\n                n++;\n            }\n            return n;\n        }\n\n        /**\n         * Given a bit mask, finds the first bit that's on, and return its index.\n         */\n        private int first(CronTab c) {\n            return ceil(c,0);\n        }\n\n        private int floor(CronTab c, int n) {\n            long bits = bits(c);\n            while ((bits|(1L<<n))!=bits) {\n                if (n==0)   return -1;\n                n--;\n            }\n            return n;\n        }\n\n        private int last(CronTab c) {\n            return floor(c,63);\n        }\n\n        /**\n         * Extracts the bit masks from the given {@link CronTab} that matches this field.\n         */\n        abstract long bits(CronTab c);\n\n        /**\n         * Increment the next field.\n         */\n        abstract void rollUp(Calendar cal, int i);\n\n        private static final CalendarField MINUTE       = new CalendarField(\"minute\", Calendar.MINUTE,        0, 0, false, null) {\n            long bits(CronTab c) { return c.bits[0]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.HOUR_OF_DAY,i); }\n        };\n        private static final CalendarField HOUR         = new CalendarField(\"hour\", Calendar.HOUR_OF_DAY,   0, 0, false, MINUTE) {\n            long bits(CronTab c) { return c.bits[1]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.DAY_OF_MONTH,i); }\n        };\n        private static final CalendarField DAY_OF_MONTH = new CalendarField(\"day\", Calendar.DAY_OF_MONTH,  1, 0, true,  HOUR) {\n            long bits(CronTab c) { return c.bits[2]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.MONTH,i); }\n        };\n        private static final CalendarField MONTH        = new CalendarField(\"month\", Calendar.MONTH,         1, 1, false, DAY_OF_MONTH) {\n            long bits(CronTab c) { return c.bits[3]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.YEAR,i); }\n        };\n        private static final CalendarField DAY_OF_WEEK  = new CalendarField(\"dow\", Calendar.DAY_OF_WEEK,   1,-1, true,  HOUR) {\n            long bits(CronTab c) { return c.dayOfWeek; }\n            void rollUp(Calendar cal, int i) {\n                cal.add(Calendar.DAY_OF_WEEK, 7 * i);\n            }\n\n            @Override\n            void setTo(Calendar c, int i) {\n                int v = i-offset;\n                int was = c.get(field);\n                c.set(field,v);\n                final int firstDayOfWeek = c.getFirstDayOfWeek();\n                if (v < firstDayOfWeek && was >= firstDayOfWeek) {\n                    // in crontab, the first DoW is always Sunday, but in Java, it can be Monday or in theory arbitrary other days.\n                    // When first DoW is 1/2 Monday, calendar points to 1/2 Monday, setting the DoW to Sunday makes\n                    // the calendar moves forward to 1/8 Sunday, instead of 1/1 Sunday. So we need to compensate that effect here.\n                    addTo(c,-7);\n                } else if (was < firstDayOfWeek && firstDayOfWeek <= v) {\n                    // If we wrap the other way around, we need to adjust in the opposite direction of above.\n                    addTo(c, 7);\n                }\n            }\n        };\n\n        private static final CalendarField[] ADJUST_ORDER = {\n            MONTH, DAY_OF_MONTH, DAY_OF_WEEK, HOUR, MINUTE\n        };\n    }\n\n\n    /**\n     * Computes the nearest future timestamp that matches this cron tab.\n     * <p>\n     * More precisely, given the time 't', computes another smallest time x such that:\n     *\n     * <ul>\n     * <li>x \u2265 t (inclusive)\n     * <li>x matches this crontab\n     * </ul>\n     *\n     * <p>\n     * Note that if t already matches this cron, it's returned as is.\n     */\n    public Calendar ceil(long t) {\n        Calendar cal = new GregorianCalendar(Locale.US);\n        cal.setTimeInMillis(t);\n        return ceil(cal);\n    }\n\n    /**\n     * See {@link #ceil(long)}.\n     *\n     * This method modifies the given calendar and returns the same object.\n     *\n     * @throws RareOrImpossibleDateException if the date isn't hit in the 2 years after it indicates an impossible\n     * (e.g. Jun 31) date, or at least a date too rare to be useful. This addresses JENKINS-41864 and was added in 2.49\n     */\n    public Calendar ceil(Calendar cal) {\n        Calendar twoYearsFuture = (Calendar) cal.clone();\n        twoYearsFuture.add(Calendar.YEAR, 2);\n        OUTER:\n        while (true) {\n            if (cal.compareTo(twoYearsFuture) > 0) {\n                // we went too far into the future\n                throw new RareOrImpossibleDateException();\n            }\n            for (CalendarField f : CalendarField.ADJUST_ORDER) {\n                int cur = f.valueOf(cal);\n                int next = f.ceil(this,cur);\n                if (cur==next)  continue;   // this field is already in a good shape. move on to next\n\n                // we are modifying this field, so clear all the lower level fields\n                for (CalendarField l=f.lowerField; l!=null; l=l.lowerField)\n                    l.clear(cal);\n\n                if (next<0) {\n                    // we need to roll over to the next field.\n                    f.rollUp(cal, 1);\n                    f.setTo(cal,f.first(this));\n                    // since higher order field is affected by this, we need to restart from all over\n                    continue OUTER;\n                } else {\n                    f.setTo(cal,next);\n                    //check if value was actually set\n                    if (f.valueOf(cal) != next) {\n                        // we need to roll over to the next field.\n                        f.rollUp(cal, 1);\n                        f.setTo(cal,f.first(this));\n                        // since higher order field is affected by this, we need to restart from all over\n                        continue OUTER;\n                    }\n                    if (f.redoAdjustmentIfModified)\n                        continue OUTER; // when we modify DAY_OF_MONTH and DAY_OF_WEEK, do it all over from the top\n                }\n            }\n            return cal; // all fields adjusted\n        }\n    }\n\n    /**\n     * Computes the nearest past timestamp that matched this cron tab.\n     * <p>\n     * More precisely, given the time 't', computes another smallest time x such that:\n     *\n     * <ul>\n     * <li>x &lt;= t (inclusive)\n     * <li>x matches this crontab\n     * </ul>\n     *\n     * <p>\n     * Note that if t already matches this cron, it's returned as is.\n     */\n    public Calendar floor(long t) {\n        Calendar cal = new GregorianCalendar(Locale.US);\n        cal.setTimeInMillis(t);\n        return floor(cal);\n    }\n\n    /**\n     * See {@link #floor(long)}\n     *\n     * This method modifies the given calendar and returns the same object.\n     *\n     * @throws RareOrImpossibleDateException if the date isn't hit in the 2 years before it indicates an impossible\n     * (e.g. Jun 31) date, or at least a date too rare to be useful. This addresses JENKINS-41864 and was added in 2.49\n     */\n    public Calendar floor(Calendar cal) {\n        Calendar twoYearsAgo = (Calendar) cal.clone();\n        twoYearsAgo.add(Calendar.YEAR, -2);\n\n        OUTER:\n        while (true) {\n            if (cal.compareTo(twoYearsAgo) < 0) {\n                // we went too far into the past\n                throw new RareOrImpossibleDateException();\n            }\n            for (CalendarField f : CalendarField.ADJUST_ORDER) {\n                int cur = f.valueOf(cal);\n                int next = f.floor(this,cur);\n                if (cur==next)  continue;   // this field is already in a good shape. move on to next\n\n                // we are modifying this field, so clear all the lower level fields\n                for (CalendarField l=f.lowerField; l!=null; l=l.lowerField)\n                    l.clear(cal);\n\n                if (next<0) {\n                    // we need to borrow from the next field.\n                    f.rollUp(cal,-1);\n                    // the problem here, in contrast with the ceil method, is that\n                    // the maximum value of the field is not always a fixed value (that is, day of month)\n                    // so we zero-clear all the lower fields, set the desired value +1,\n                    f.setTo(cal,f.last(this));\n                    f.addTo(cal,1);\n                    // then subtract a minute to achieve maximum values on all the lower fields,\n                    // with the desired value in 'f'\n                    CalendarField.MINUTE.addTo(cal,-1);\n                    // since higher order field is affected by this, we need to restart from all over\n                    continue OUTER;\n                } else {\n                    f.setTo(cal,next);\n                    f.addTo(cal,1);\n                    CalendarField.MINUTE.addTo(cal,-1);\n                    if (f.redoAdjustmentIfModified)\n                        continue OUTER; // when we modify DAY_OF_MONTH and DAY_OF_WEEK, do it all over from the top\n                }\n            }\n            return cal; // all fields adjusted\n        }\n    }\n\n    void set(String format, Hash hash) throws ANTLRException {\n        set(format,1,hash);\n    }\n\n    /**\n     * Returns true if n-th bit is on.\n     */\n    private boolean checkBits(long bitMask, int n) {\n        return (bitMask|(1L<<n))==bitMask;\n    }\n\n    public String toString() {\n        return super.toString()+\"[\"+\n            toString(\"minute\",bits[0])+','+\n            toString(\"hour\",bits[1])+','+\n            toString(\"dayOfMonth\",bits[2])+','+\n            toString(\"month\",bits[3])+','+\n            toString(\"dayOfWeek\",dayOfWeek)+']';\n    }\n\n    private String toString(String key, long bit) {\n        return key+'='+Long.toHexString(bit);\n    }\n\n    /**\n     * Checks if this crontab entry looks reasonable,\n     * and if not, return an warning message.\n     *\n     * <p>\n     * The point of this method is to catch syntactically correct\n     * but semantically suspicious combinations, like\n     * \"* 0 * * *\"\n     */\n    public @CheckForNull String checkSanity() {\n        OUTER: for (int i = 0; i < 5; i++) {\n            long bitMask = (i<4)?bits[i]:(long)dayOfWeek;\n            for( int j=BaseParser.LOWER_BOUNDS[i]; j<=BaseParser.UPPER_BOUNDS[i]; j++ ) {\n                if(!checkBits(bitMask,j)) {\n                    // this rank has a sparse entry.\n                    // if we have a sparse rank, one of them better be the left-most.\n                    if(i>0)\n                        return Messages.CronTab_do_you_really_mean_every_minute_when_you(spec, \"H \" + spec.substring(spec.indexOf(' ') + 1));\n                    // once we find a sparse rank, upper ranks don't matter\n                    break OUTER;\n                }\n            }\n        }\n\n        int daysOfMonth = 0;\n        for (int i = 1; i < 31; i++) {\n            if (checkBits(bits[2], i)) {\n                daysOfMonth++;\n            }\n        }\n        if (daysOfMonth > 5 && daysOfMonth < 28) { // a bit arbitrary\n            return Messages.CronTab_short_cycles_in_the_day_of_month_field_w();\n        }\n\n        String hashified = hashify(spec);\n        if (hashified != null) {\n            return Messages.CronTab_spread_load_evenly_by_using_rather_than_(hashified, spec);\n        }\n\n        return null;\n    }\n\n    /**\n     * Checks a prospective crontab specification to see if it could benefit from balanced hashes.\n     * @param spec a (legal) spec\n     * @return a similar spec that uses a hash, if such a transformation is necessary; null if it is OK as is\n     * @since 1.510\n     */\n    public static @CheckForNull String hashify(String spec) {\n        if (spec.contains(\"H\")) {\n            // if someone is already using H, presumably he knows what it is, so a warning is likely false positive\n            return null;\n        } else if (spec.startsWith(\"*/\")) {// \"*/15 ....\" (every N minutes) to hash\n            return \"H\" + spec.substring(1);\n        } else if (spec.matches(\"\\\\d+ .+\")) {// \"0 ...\" (certain minute) to hash\n            return \"H \" + spec.substring(spec.indexOf(' ') + 1);\n        } else {\n            Matcher m = Pattern.compile(\"0(,(\\\\d+)(,\\\\d+)*)( .+)\").matcher(spec);\n            if (m.matches()) { // 0,15,30,45 to H/15\n                int period = Integer.parseInt(m.group(2));\n                if (period > 0) {\n                    StringBuilder b = new StringBuilder();\n                    for (int i = period; i < 60; i += period) {\n                        b.append(',').append(i);\n                    }\n                    if (b.toString().equals(m.group(1))) {\n                        return \"H/\" + period + m.group(4);\n                    }\n                }\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Returns the configured time zone, or null if none is configured\n     *\n     * @return the configured time zone, or null if none is configured\n     * @since 2.54\n     */\n    @CheckForNull public TimeZone getTimeZone() {\n        if (this.specTimezone == null) {\n            return null;\n        }\n        return TimeZone.getTimeZone(this.specTimezone);\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-56": {
    "vul_id": "VUL4J-56",
    "cve_id": "CVE-2018-1000056",
    "project": "jenkinsci_junit-plugin",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=hudson.tasks.junit.JUnitResultArchiverTest#testXxe",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/jenkinsci/junit-plugin/commit/15f39fc49d9f25bca872badb48e708a8bb815ea7",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/hudson/tasks/junit/SuiteResult.java",
        "file_name": "SuiteResult.java",
        "vulnerable_code": "/*\n * The MIT License\n *\n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, Erik Ramfelt, Xavier Le Vourch, Tom Huybrechts, Yahoo!, Inc., Victor Garcia\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.tasks.junit;\n\nimport hudson.tasks.test.PipelineTestDetails;\nimport hudson.tasks.test.TestObject;\nimport hudson.util.io.ParserConfigurator;\nimport org.dom4j.Document;\nimport org.dom4j.DocumentException;\nimport org.dom4j.Element;\nimport org.dom4j.io.SAXReader;\nimport org.jenkinsci.plugins.workflow.graph.FlowNode;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.export.ExportedBean;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Result of one test suite.\n *\n * <p>\n * The notion of \"test suite\" is rather arbitrary in JUnit ant task.\n * It's basically one invocation of junit.\n *\n * <p>\n * This object is really only used as a part of the persisted\n * object tree.\n *\n * @author Kohsuke Kawaguchi\n */\n@ExportedBean\npublic final class SuiteResult implements Serializable {\n    private static final Logger LOGGER = Logger.getLogger(SuiteResult.class.getName());\n    private final String file;\n    private final String name;\n    private final String stdout;\n    private final String stderr;\n    private float duration;\n    /**\n     * The 'timestamp' attribute of  the test suite.\n     * AFAICT, this is not a required attribute in XML, so the value may be null.\n     */\n    private String timestamp;\n    /**\n     * Optional ID attribute of a test suite. E.g., Eclipse plug-ins tests always have the name 'tests' but a different id.\n     **/\n    private String id;\n\n    /**\n     * Optional time attribute of a test suite. E.g., Suites can use their own time attribute or the sum of their cases' times as before.\n     **/\n    private String time;\n\n    /**\n     * Optional {@link FlowNode#getId()} this suite was generated in.\n     */\n    private String nodeId;\n\n    private final List<String> enclosingBlocks = new ArrayList<>();\n\n    private final List<String> enclosingBlockNames = new ArrayList<>();\n\n    /**\n     * All test cases.\n     */\n    private final List<CaseResult> cases = new ArrayList<CaseResult>();\n    private transient Map<String, CaseResult> casesByName;\n    private transient hudson.tasks.junit.TestResult parent;\n\n    @Deprecated\n    SuiteResult(String name, String stdout, String stderr) {\n        this(name, stdout, stderr, null);\n    }\n\n    /**\n     * @since 1.22\n     */\n    SuiteResult(String name, String stdout, String stderr, @CheckForNull PipelineTestDetails pipelineTestDetails) {\n        this.name = name;\n        this.stderr = stderr;\n        this.stdout = stdout;\n        // runId is generally going to be not null, but we only care about it if both it and nodeId are not null.\n        if (pipelineTestDetails != null && pipelineTestDetails.getNodeId() != null) {\n            this.nodeId = pipelineTestDetails.getNodeId();\n            this.enclosingBlocks.addAll(pipelineTestDetails.getEnclosingBlocks());\n            this.enclosingBlockNames.addAll(pipelineTestDetails.getEnclosingBlockNames());\n        } else {\n            this.nodeId = null;\n        }\n        this.file = null;\n    }\n\n    private synchronized Map<String, CaseResult> casesByName() {\n        if (casesByName == null) {\n            casesByName = new HashMap<>();\n            for (CaseResult c : cases) {\n                casesByName.put(c.getTransformedTestName(), c);\n            }\n        }\n        return casesByName;\n    }\n\n    /**\n     * Passed to {@link ParserConfigurator}.\n     *\n     * @since 1.416\n     * @deprecated with no replacement.\n     */\n    @Deprecated\n    public static class SuiteResultParserConfigurationContext {\n        public final File xmlReport;\n\n        SuiteResultParserConfigurationContext(File xmlReport) {\n            this.xmlReport = xmlReport;\n        }\n    }\n\n    /**\n     * Parses the JUnit XML file into {@link SuiteResult}s.\n     * This method returns a collection, as a single XML may have multiple &lt;testsuite>\n     * elements wrapped into the top-level &lt;testsuites>.\n     */\n    static List<SuiteResult> parse(File xmlReport, boolean keepLongStdio, PipelineTestDetails pipelineTestDetails)\n            throws DocumentException, IOException, InterruptedException {\n        List<SuiteResult> r = new ArrayList<SuiteResult>();\n\n        // parse into DOM\n        SAXReader saxReader = new SAXReader();\n        saxReader.setEntityResolver(new XMLEntityResolver());\n\n        FileInputStream xmlReportStream = new FileInputStream(xmlReport);\n        try {\n            Document result = saxReader.read(xmlReportStream);\n            Element root = result.getRootElement();\n\n            parseSuite(xmlReport, keepLongStdio, r, root, pipelineTestDetails);\n        } finally {\n            xmlReportStream.close();\n        }\n\n        return r;\n    }\n\n    private static void parseSuite(File xmlReport, boolean keepLongStdio, List<SuiteResult> r, Element root,\n                                   PipelineTestDetails pipelineTestDetails) throws DocumentException, IOException {\n        // nested test suites\n        @SuppressWarnings(\"unchecked\")\n        List<Element> testSuites = (List<Element>) root.elements(\"testsuite\");\n        for (Element suite : testSuites)\n            parseSuite(xmlReport, keepLongStdio, r, suite, pipelineTestDetails);\n\n        // child test cases\n        // FIXME: do this also if no testcases!\n        if (root.element(\"testcase\") != null || root.element(\"error\") != null)\n            r.add(new SuiteResult(xmlReport, root, keepLongStdio, pipelineTestDetails));\n    }\n\n    /**\n     * @param xmlReport A JUnit XML report file whose top level element is 'testsuite'.\n     * @param suite     The parsed result of {@code xmlReport}\n     */\n    private SuiteResult(File xmlReport, Element suite, boolean keepLongStdio, @CheckForNull PipelineTestDetails pipelineTestDetails)\n            throws DocumentException, IOException {\n        this.file = xmlReport.getAbsolutePath();\n        String name = suite.attributeValue(\"name\");\n        if (name == null)\n            // some user reported that name is null in their environment.\n            // see http://www.nabble.com/Unexpected-Null-Pointer-Exception-in-Hudson-1.131-tf4314802.html\n            name = '(' + xmlReport.getName() + ')';\n        else {\n            String pkg = suite.attributeValue(\"package\");\n            if (pkg != null && pkg.length() > 0) name = pkg + '.' + name;\n        }\n        this.name = TestObject.safe(name);\n        this.timestamp = suite.attributeValue(\"timestamp\");\n        this.id = suite.attributeValue(\"id\");\n        if (pipelineTestDetails != null && pipelineTestDetails.getNodeId() != null) {\n            this.nodeId = pipelineTestDetails.getNodeId();\n            this.enclosingBlocks.addAll(pipelineTestDetails.getEnclosingBlocks());\n            this.enclosingBlockNames.addAll(pipelineTestDetails.getEnclosingBlockNames());\n        }\n\n        // check for test suite time attribute\n        if ((this.time = suite.attributeValue(\"time\")) != null) {\n            duration = new TimeToFloat(this.time).parse();\n        }\n\n        Element ex = suite.element(\"error\");\n        if (ex != null) {\n            // according to junit-noframes.xsl l.229, this happens when the test class failed to load\n            addCase(new CaseResult(this, suite, \"<init>\", keepLongStdio));\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        List<Element> testCases = (List<Element>) suite.elements(\"testcase\");\n        for (Element e : testCases) {\n            // https://issues.jenkins-ci.org/browse/JENKINS-1233 indicates that\n            // when <testsuites> is present, we are better off using @classname on the\n            // individual testcase class.\n\n            // https://issues.jenkins-ci.org/browse/JENKINS-1463 indicates that\n            // @classname may not exist in individual testcase elements. We now\n            // also test if the testsuite element has a package name that can be used\n            // as the class name instead of the file name which is default.\n            String classname = e.attributeValue(\"classname\");\n            if (classname == null) {\n                classname = suite.attributeValue(\"name\");\n            }\n\n            // https://issues.jenkins-ci.org/browse/JENKINS-1233 and\n            // http://www.nabble.com/difference-in-junit-publisher-and-ant-junitreport-tf4308604.html#a12265700\n            // are at odds with each other --- when both are present,\n            // one wants to use @name from <testsuite>,\n            // the other wants to use @classname from <testcase>.\n\n            addCase(new CaseResult(this, e, classname, keepLongStdio));\n        }\n\n        String stdout = CaseResult.possiblyTrimStdio(cases, keepLongStdio, suite.elementText(\"system-out\"));\n        String stderr = CaseResult.possiblyTrimStdio(cases, keepLongStdio, suite.elementText(\"system-err\"));\n        if (stdout == null && stderr == null) {\n            // Surefire never puts stdout/stderr in the XML. Instead, it goes to a separate file (when ${maven.test.redirectTestOutputToFile}).\n            Matcher m = SUREFIRE_FILENAME.matcher(xmlReport.getName());\n            if (m.matches()) {\n                // look for ***-output.txt from TEST-***.xml\n                File mavenOutputFile = new File(xmlReport.getParentFile(), m.group(1) + \"-output.txt\");\n                if (mavenOutputFile.exists()) {\n                    try {\n                        stdout = CaseResult.possiblyTrimStdio(cases, keepLongStdio, mavenOutputFile);\n                    } catch (IOException e) {\n                        throw new IOException(\"Failed to read \" + mavenOutputFile, e);\n                    }\n                }\n            }\n        }\n\n        this.stdout = stdout;\n        this.stderr = stderr;\n    }\n\n    /*package*/ void addCase(CaseResult cr) {\n        cases.add(cr);\n        casesByName().put(cr.getTransformedTestName(), cr);\n\n        //if suite time was not specified use sum of the cases' times\n        if( !hasTimeAttr() ){\n            duration += cr.getDuration();\n        }\n    }\n\n    /**\n     * Returns true if the time attribute is present in this Suite.\n     */\n    private boolean hasTimeAttr() {\n        return time != null;\n    }\n\n    @Exported(visibility=9)\n    public String getName() {\n        return name;\n    }\n\n    @Exported(visibility=9)\n    public float getDuration() {\n        return duration;\n    }\n\n    /**\n     * The possibly-null {@link FlowNode#id} this suite was generated in.\n     *\n     * @since 1.22\n     */\n    @Exported(visibility=9)\n    @CheckForNull\n    public String getNodeId() {\n        return nodeId;\n    }\n\n    /**\n     * The possibly-empty list of {@link FlowNode#id}s for enclosing blocks within which this suite was generated.\n     *\n     * @since 1.22\n     */\n    @Exported(visibility=9)\n    @Nonnull\n    public List<String> getEnclosingBlocks() {\n        if (enclosingBlocks != null) {\n            return Collections.unmodifiableList(enclosingBlocks);\n        } else {\n            return Collections.emptyList();\n        }\n    }\n\n    /**\n     * The possibly-empty list of display names of enclosing blocks within which this suite was generated.\n     *\n     * @since 1.22\n     */\n    @Exported(visibility=9)\n    @Nonnull\n    public List<String> getEnclosingBlockNames() {\n        if (enclosingBlockNames != null) {\n            return Collections.unmodifiableList(enclosingBlockNames);\n        } else {\n            return Collections.emptyList();\n        }\n    }\n\n    /**\n     * The stdout of this test.\n     *\n     * @return the stdout of this test.\n     * @since 1.281\n     * @see CaseResult#getStdout()\n     */\n    @Exported\n    public String getStdout() {\n        return stdout;\n    }\n\n    /**\n     * The stderr of this test.\n     *\n     * @return the stderr of this test.\n     * @since 1.281\n     * @see CaseResult#getStderr()\n     */\n    @Exported\n    public String getStderr() {\n        return stderr;\n    }\n\n    /**\n     * The absolute path to the original test report. OS-dependent.\n     *\n     * @return the sabsolute path to the original test report.\n     */\n    public String getFile() {\n\t\treturn file;\n\t}\n\n\tpublic hudson.tasks.junit.TestResult getParent() {\n        return parent;\n    }\n\n    @Exported(visibility=9)\n    public String getTimestamp() {\n        return timestamp;\n    }\n\n    @Exported(visibility=9)\n    public String getId() {\n        return id;\n    }\n\n    @Exported(inline=true,visibility=9)\n    public List<CaseResult> getCases() {\n        return cases;\n    }\n\n    public SuiteResult getPreviousResult() {\n        hudson.tasks.test.TestResult pr = parent.getPreviousResult();\n        if(pr==null)    return null;\n        if(pr instanceof hudson.tasks.junit.TestResult)\n            return ((hudson.tasks.junit.TestResult)pr).getSuite(name);\n        return null;\n    }\n\n    /**\n     * Returns the {@link CaseResult} whose {@link CaseResult#getDisplayName()}\n     * is the same as the given string.\n     * <p>\n     * Note that test name needs not be unique.\n     * </p>\n     *\n     * @param name The case name.\n     *\n     * @return the {@link CaseResult} with the provided name.\n     */\n    public CaseResult getCase(String name) {\n        return casesByName().get(name);\n    }\n\n\tpublic Set<String> getClassNames() {\n\t\tSet<String> result = new HashSet<String>();\n\t\tfor (CaseResult c : cases) {\n\t\t\tresult.add(c.getClassName());\n\t\t}\n\t\treturn result;\n\t}\n\n    /** KLUGE. We have to call this to prevent freeze()\n     * from calling c.freeze() on all its children,\n     * because that in turn calls c.getOwner(),\n     * which requires a non-null parent.\n     * @param parent\n     */\n    void setParent(hudson.tasks.junit.TestResult parent) {\n        this.parent = parent;\n    }\n\n    /*package*/ boolean freeze(hudson.tasks.junit.TestResult owner) {\n        if(this.parent!=null)\n            return false;   // already frozen\n\n        this.parent = owner;\n        for (CaseResult c : cases)\n            c.freeze(this);\n        return true;\n    }\n\n    private static final long serialVersionUID = 1L;\n\n    private static final Pattern SUREFIRE_FILENAME = Pattern.compile(\"TEST-(.+)\\\\.xml\");\n\n    /**\n     * Merges another SuiteResult into this one.\n     * \n     * @param sr the SuiteResult to merge into this one\n     */\n    public void merge(SuiteResult sr) {\n        if (sr.hasTimeAttr() ^ hasTimeAttr()){\n            LOGGER.warning(\"Merging of suiteresults with incompatible time attribute may lead to incorrect durations in reports.( \"+getFile()+\", \"+sr.getFile()+\")\");\n        }\n        if (hasTimeAttr()) {\n            duration += sr.getDuration();\n        }\n        for (CaseResult cr : sr.getCases()) {\n            addCase(cr);\n            cr.replaceParent(this);\n        }\n    }\n}\n",
        "human_patch_code": "/*\n * The MIT License\n *\n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, Erik Ramfelt, Xavier Le Vourch, Tom Huybrechts, Yahoo!, Inc., Victor Garcia\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.tasks.junit;\n\nimport hudson.tasks.test.PipelineTestDetails;\nimport hudson.tasks.test.TestObject;\nimport hudson.util.io.ParserConfigurator;\nimport org.dom4j.Document;\nimport org.dom4j.DocumentException;\nimport org.dom4j.Element;\nimport org.dom4j.io.SAXReader;\nimport org.jenkinsci.plugins.workflow.graph.FlowNode;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.export.ExportedBean;\nimport org.xml.sax.SAXException;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Result of one test suite.\n *\n * <p>\n * The notion of \"test suite\" is rather arbitrary in JUnit ant task.\n * It's basically one invocation of junit.\n *\n * <p>\n * This object is really only used as a part of the persisted\n * object tree.\n *\n * @author Kohsuke Kawaguchi\n */\n@ExportedBean\npublic final class SuiteResult implements Serializable {\n    private static final Logger LOGGER = Logger.getLogger(SuiteResult.class.getName());\n    private final String file;\n    private final String name;\n    private final String stdout;\n    private final String stderr;\n    private float duration;\n    /**\n     * The 'timestamp' attribute of  the test suite.\n     * AFAICT, this is not a required attribute in XML, so the value may be null.\n     */\n    private String timestamp;\n    /**\n     * Optional ID attribute of a test suite. E.g., Eclipse plug-ins tests always have the name 'tests' but a different id.\n     **/\n    private String id;\n\n    /**\n     * Optional time attribute of a test suite. E.g., Suites can use their own time attribute or the sum of their cases' times as before.\n     **/\n    private String time;\n\n    /**\n     * Optional {@link FlowNode#getId()} this suite was generated in.\n     */\n    private String nodeId;\n\n    private final List<String> enclosingBlocks = new ArrayList<>();\n\n    private final List<String> enclosingBlockNames = new ArrayList<>();\n\n    /**\n     * All test cases.\n     */\n    private final List<CaseResult> cases = new ArrayList<CaseResult>();\n    private transient Map<String, CaseResult> casesByName;\n    private transient hudson.tasks.junit.TestResult parent;\n\n    @Deprecated\n    SuiteResult(String name, String stdout, String stderr) {\n        this(name, stdout, stderr, null);\n    }\n\n    /**\n     * @since 1.22\n     */\n    SuiteResult(String name, String stdout, String stderr, @CheckForNull PipelineTestDetails pipelineTestDetails) {\n        this.name = name;\n        this.stderr = stderr;\n        this.stdout = stdout;\n        // runId is generally going to be not null, but we only care about it if both it and nodeId are not null.\n        if (pipelineTestDetails != null && pipelineTestDetails.getNodeId() != null) {\n            this.nodeId = pipelineTestDetails.getNodeId();\n            this.enclosingBlocks.addAll(pipelineTestDetails.getEnclosingBlocks());\n            this.enclosingBlockNames.addAll(pipelineTestDetails.getEnclosingBlockNames());\n        } else {\n            this.nodeId = null;\n        }\n        this.file = null;\n    }\n\n    private synchronized Map<String, CaseResult> casesByName() {\n        if (casesByName == null) {\n            casesByName = new HashMap<>();\n            for (CaseResult c : cases) {\n                casesByName.put(c.getTransformedTestName(), c);\n            }\n        }\n        return casesByName;\n    }\n\n    /**\n     * Passed to {@link ParserConfigurator}.\n     *\n     * @since 1.416\n     * @deprecated with no replacement.\n     */\n    @Deprecated\n    public static class SuiteResultParserConfigurationContext {\n        public final File xmlReport;\n\n        SuiteResultParserConfigurationContext(File xmlReport) {\n            this.xmlReport = xmlReport;\n        }\n    }\n\n    /**\n     * Parses the JUnit XML file into {@link SuiteResult}s.\n     * This method returns a collection, as a single XML may have multiple &lt;testsuite>\n     * elements wrapped into the top-level &lt;testsuites>.\n     */\n    static List<SuiteResult> parse(File xmlReport, boolean keepLongStdio, PipelineTestDetails pipelineTestDetails)\n            throws DocumentException, IOException, InterruptedException {\n        List<SuiteResult> r = new ArrayList<SuiteResult>();\n\n        // parse into DOM\n        SAXReader saxReader = new SAXReader();\n        \n        //source: https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet => SAXReader\n        // setFeatureQuietly(saxReader, \"http://apache.org/xml/features/disallow-doctype-decl\", true);\n        // setFeatureQuietly(saxReader, \"http://xml.org/sax/features/external-parameter-entities\", false);\n\n        // only that seems to let the initial feature of testng namespace being loaded locally\n        setFeatureQuietly(saxReader, \"http://xml.org/sax/features/external-general-entities\", false);\n\n        saxReader.setEntityResolver(new XMLEntityResolver());\n\n        FileInputStream xmlReportStream = new FileInputStream(xmlReport);\n        try {\n            Document result = saxReader.read(xmlReportStream);\n            Element root = result.getRootElement();\n\n            parseSuite(xmlReport, keepLongStdio, r, root, pipelineTestDetails);\n        } finally {\n            xmlReportStream.close();\n        }\n\n        return r;\n    }\n\n    private static void setFeatureQuietly(SAXReader reader, String feature, boolean value) {\n        try {\n            reader.setFeature(feature, value);\n        }\n        catch (SAXException ignored) {\n            // ignore and continue in case the feature cannot be changed\n        }\n    }\n\n    private static void parseSuite(File xmlReport, boolean keepLongStdio, List<SuiteResult> r, Element root,\n                                   PipelineTestDetails pipelineTestDetails) throws DocumentException, IOException {\n        // nested test suites\n        @SuppressWarnings(\"unchecked\")\n        List<Element> testSuites = (List<Element>) root.elements(\"testsuite\");\n        for (Element suite : testSuites)\n            parseSuite(xmlReport, keepLongStdio, r, suite, pipelineTestDetails);\n\n        // child test cases\n        // FIXME: do this also if no testcases!\n        if (root.element(\"testcase\") != null || root.element(\"error\") != null)\n            r.add(new SuiteResult(xmlReport, root, keepLongStdio, pipelineTestDetails));\n    }\n\n    /**\n     * @param xmlReport A JUnit XML report file whose top level element is 'testsuite'.\n     * @param suite     The parsed result of {@code xmlReport}\n     */\n    private SuiteResult(File xmlReport, Element suite, boolean keepLongStdio, @CheckForNull PipelineTestDetails pipelineTestDetails)\n            throws DocumentException, IOException {\n        this.file = xmlReport.getAbsolutePath();\n        String name = suite.attributeValue(\"name\");\n        if (name == null)\n            // some user reported that name is null in their environment.\n            // see http://www.nabble.com/Unexpected-Null-Pointer-Exception-in-Hudson-1.131-tf4314802.html\n            name = '(' + xmlReport.getName() + ')';\n        else {\n            String pkg = suite.attributeValue(\"package\");\n            if (pkg != null && pkg.length() > 0) name = pkg + '.' + name;\n        }\n        this.name = TestObject.safe(name);\n        this.timestamp = suite.attributeValue(\"timestamp\");\n        this.id = suite.attributeValue(\"id\");\n        if (pipelineTestDetails != null && pipelineTestDetails.getNodeId() != null) {\n            this.nodeId = pipelineTestDetails.getNodeId();\n            this.enclosingBlocks.addAll(pipelineTestDetails.getEnclosingBlocks());\n            this.enclosingBlockNames.addAll(pipelineTestDetails.getEnclosingBlockNames());\n        }\n\n        // check for test suite time attribute\n        if ((this.time = suite.attributeValue(\"time\")) != null) {\n            duration = new TimeToFloat(this.time).parse();\n        }\n\n        Element ex = suite.element(\"error\");\n        if (ex != null) {\n            // according to junit-noframes.xsl l.229, this happens when the test class failed to load\n            addCase(new CaseResult(this, suite, \"<init>\", keepLongStdio));\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        List<Element> testCases = (List<Element>) suite.elements(\"testcase\");\n        for (Element e : testCases) {\n            // https://issues.jenkins-ci.org/browse/JENKINS-1233 indicates that\n            // when <testsuites> is present, we are better off using @classname on the\n            // individual testcase class.\n\n            // https://issues.jenkins-ci.org/browse/JENKINS-1463 indicates that\n            // @classname may not exist in individual testcase elements. We now\n            // also test if the testsuite element has a package name that can be used\n            // as the class name instead of the file name which is default.\n            String classname = e.attributeValue(\"classname\");\n            if (classname == null) {\n                classname = suite.attributeValue(\"name\");\n            }\n\n            // https://issues.jenkins-ci.org/browse/JENKINS-1233 and\n            // http://www.nabble.com/difference-in-junit-publisher-and-ant-junitreport-tf4308604.html#a12265700\n            // are at odds with each other --- when both are present,\n            // one wants to use @name from <testsuite>,\n            // the other wants to use @classname from <testcase>.\n\n            addCase(new CaseResult(this, e, classname, keepLongStdio));\n        }\n\n        String stdout = CaseResult.possiblyTrimStdio(cases, keepLongStdio, suite.elementText(\"system-out\"));\n        String stderr = CaseResult.possiblyTrimStdio(cases, keepLongStdio, suite.elementText(\"system-err\"));\n        if (stdout == null && stderr == null) {\n            // Surefire never puts stdout/stderr in the XML. Instead, it goes to a separate file (when ${maven.test.redirectTestOutputToFile}).\n            Matcher m = SUREFIRE_FILENAME.matcher(xmlReport.getName());\n            if (m.matches()) {\n                // look for ***-output.txt from TEST-***.xml\n                File mavenOutputFile = new File(xmlReport.getParentFile(), m.group(1) + \"-output.txt\");\n                if (mavenOutputFile.exists()) {\n                    try {\n                        stdout = CaseResult.possiblyTrimStdio(cases, keepLongStdio, mavenOutputFile);\n                    } catch (IOException e) {\n                        throw new IOException(\"Failed to read \" + mavenOutputFile, e);\n                    }\n                }\n            }\n        }\n\n        this.stdout = stdout;\n        this.stderr = stderr;\n    }\n\n    /*package*/ void addCase(CaseResult cr) {\n        cases.add(cr);\n        casesByName().put(cr.getTransformedTestName(), cr);\n\n        //if suite time was not specified use sum of the cases' times\n        if( !hasTimeAttr() ){\n            duration += cr.getDuration();\n        }\n    }\n\n    /**\n     * Returns true if the time attribute is present in this Suite.\n     */\n    private boolean hasTimeAttr() {\n        return time != null;\n    }\n\n    @Exported(visibility=9)\n    public String getName() {\n        return name;\n    }\n\n    @Exported(visibility=9)\n    public float getDuration() {\n        return duration;\n    }\n\n    /**\n     * The possibly-null {@link FlowNode#id} this suite was generated in.\n     *\n     * @since 1.22\n     */\n    @Exported(visibility=9)\n    @CheckForNull\n    public String getNodeId() {\n        return nodeId;\n    }\n\n    /**\n     * The possibly-empty list of {@link FlowNode#id}s for enclosing blocks within which this suite was generated.\n     *\n     * @since 1.22\n     */\n    @Exported(visibility=9)\n    @Nonnull\n    public List<String> getEnclosingBlocks() {\n        if (enclosingBlocks != null) {\n            return Collections.unmodifiableList(enclosingBlocks);\n        } else {\n            return Collections.emptyList();\n        }\n    }\n\n    /**\n     * The possibly-empty list of display names of enclosing blocks within which this suite was generated.\n     *\n     * @since 1.22\n     */\n    @Exported(visibility=9)\n    @Nonnull\n    public List<String> getEnclosingBlockNames() {\n        if (enclosingBlockNames != null) {\n            return Collections.unmodifiableList(enclosingBlockNames);\n        } else {\n            return Collections.emptyList();\n        }\n    }\n\n    /**\n     * The stdout of this test.\n     *\n     * @return the stdout of this test.\n     * @since 1.281\n     * @see CaseResult#getStdout()\n     */\n    @Exported\n    public String getStdout() {\n        return stdout;\n    }\n\n    /**\n     * The stderr of this test.\n     *\n     * @return the stderr of this test.\n     * @since 1.281\n     * @see CaseResult#getStderr()\n     */\n    @Exported\n    public String getStderr() {\n        return stderr;\n    }\n\n    /**\n     * The absolute path to the original test report. OS-dependent.\n     *\n     * @return the sabsolute path to the original test report.\n     */\n    public String getFile() {\n\t\treturn file;\n\t}\n\n\tpublic hudson.tasks.junit.TestResult getParent() {\n        return parent;\n    }\n\n    @Exported(visibility=9)\n    public String getTimestamp() {\n        return timestamp;\n    }\n\n    @Exported(visibility=9)\n    public String getId() {\n        return id;\n    }\n\n    @Exported(inline=true,visibility=9)\n    public List<CaseResult> getCases() {\n        return cases;\n    }\n\n    public SuiteResult getPreviousResult() {\n        hudson.tasks.test.TestResult pr = parent.getPreviousResult();\n        if(pr==null)    return null;\n        if(pr instanceof hudson.tasks.junit.TestResult)\n            return ((hudson.tasks.junit.TestResult)pr).getSuite(name);\n        return null;\n    }\n\n    /**\n     * Returns the {@link CaseResult} whose {@link CaseResult#getDisplayName()}\n     * is the same as the given string.\n     * <p>\n     * Note that test name needs not be unique.\n     * </p>\n     *\n     * @param name The case name.\n     *\n     * @return the {@link CaseResult} with the provided name.\n     */\n    public CaseResult getCase(String name) {\n        return casesByName().get(name);\n    }\n\n\tpublic Set<String> getClassNames() {\n\t\tSet<String> result = new HashSet<String>();\n\t\tfor (CaseResult c : cases) {\n\t\t\tresult.add(c.getClassName());\n\t\t}\n\t\treturn result;\n\t}\n\n    /** KLUGE. We have to call this to prevent freeze()\n     * from calling c.freeze() on all its children,\n     * because that in turn calls c.getOwner(),\n     * which requires a non-null parent.\n     * @param parent\n     */\n    void setParent(hudson.tasks.junit.TestResult parent) {\n        this.parent = parent;\n    }\n\n    /*package*/ boolean freeze(hudson.tasks.junit.TestResult owner) {\n        if(this.parent!=null)\n            return false;   // already frozen\n\n        this.parent = owner;\n        for (CaseResult c : cases)\n            c.freeze(this);\n        return true;\n    }\n\n    private static final long serialVersionUID = 1L;\n\n    private static final Pattern SUREFIRE_FILENAME = Pattern.compile(\"TEST-(.+)\\\\.xml\");\n\n    /**\n     * Merges another SuiteResult into this one.\n     * \n     * @param sr the SuiteResult to merge into this one\n     */\n    public void merge(SuiteResult sr) {\n        if (sr.hasTimeAttr() ^ hasTimeAttr()){\n            LOGGER.warning(\"Merging of suiteresults with incompatible time attribute may lead to incorrect durations in reports.( \"+getFile()+\", \"+sr.getFile()+\")\");\n        }\n        if (hasTimeAttr()) {\n            duration += sr.getDuration();\n        }\n        for (CaseResult cr : sr.getCases()) {\n            addCase(cr);\n            cr.replaceParent(this);\n        }\n    }\n}\n"
      },
      {
        "file_path": "src/main/java/hudson/tasks/junit/XMLEntityResolver.java",
        "file_name": "XMLEntityResolver.java",
        "vulnerable_code": "/*\n * The MIT License\n * \n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, Jorg Heymans\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.tasks.junit;\n\nimport org.xml.sax.EntityResolver;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * As the name suggest: a resolver for XML entities.\n *\n * <p>\n * Basically, it provides the possibility to intercept online DTD lookups\n * and instead do offline lookup by redirecting to a local directory where\n * .dtd's are stored\n *\n * (useful when parsing testng-results.xml - which points to testng.org)\n *\n * @author Mikael Carneholm\n */\npublic class XMLEntityResolver implements EntityResolver {\n\n    private static final String TESTNG_NAMESPACE = \"http://testng.org/\";\n\n    /**\n     * Intercepts the lookup of publicId, systemId\n     */\n    public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {\n        if (systemId != null) {\n            if (LOGGER.isLoggable(Level.FINE)) {\n                LOGGER.fine(\"Will try to resolve systemId [\" + systemId + \"]\");\n            }\n            // TestNG system-ids\n            if (systemId.startsWith(TESTNG_NAMESPACE)) {\n                LOGGER.fine(\"It's a TestNG document, will try to lookup DTD in classpath\");\n                String dtdFileName = systemId.substring(TESTNG_NAMESPACE.length());\n\n                URL url = getClass().getClassLoader().getResource(dtdFileName);\n                if (url != null)\n                    return new InputSource(url.toString());\n            }\n        }\n        // Default fallback\n        return null;\n    }\n\n    private static final Logger LOGGER = Logger.getLogger(XMLEntityResolver.class.getName());\n}\n",
        "human_patch_code": "/*\n * The MIT License\n * \n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, Jorg Heymans\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.tasks.junit;\n\nimport org.xml.sax.EntityResolver;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * As the name suggest: a resolver for XML entities.\n *\n * <p>\n * Basically, it provides the possibility to intercept online DTD lookups\n * and instead do offline lookup by redirecting to a local directory where\n * .dtd's are stored\n *\n * (useful when parsing testng-results.xml - which points to testng.org)\n *\n * @author Mikael Carneholm\n */\npublic class XMLEntityResolver implements EntityResolver {\n\n    private static final String TESTNG_NAMESPACE = \"http://testng.org/\";\n\n    /**\n     * Intercepts the lookup of publicId, systemId\n     */\n    public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {\n        if (systemId != null) {\n            if (LOGGER.isLoggable(Level.FINE)) {\n                LOGGER.fine(\"Will try to resolve systemId [\" + systemId + \"]\");\n            }\n            // TestNG system-ids\n            if (systemId.startsWith(TESTNG_NAMESPACE)) {\n                LOGGER.fine(\"It's a TestNG document, will try to lookup DTD in classpath\");\n                String dtdFileName = systemId.substring(TESTNG_NAMESPACE.length());\n\n                URL url = getClass().getClassLoader().getResource(dtdFileName);\n                if (url != null)\n                    return new InputSource(url.toString());\n            }\n        }\n        // Default fallback\n        return new InputSource();\n    }\n\n    private static final Logger LOGGER = Logger.getLogger(XMLEntityResolver.class.getName());\n}\n"
      }
    ],
    "file_count": 2
  },
  "VUL4J-57": {
    "vul_id": "VUL4J-57",
    "cve_id": "CVE-2018-1000089",
    "project": "jenkinsci_pipeline-build-step-plugin",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=org.jenkinsci.plugins.workflow.support.steps.build.BuildTriggerStepTest#permissions",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/jenkinsci/pipeline-build-step-plugin/commit/3dfefdec1f7b2a4ee0ef8902afdea720b1572cb3",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/workflow/support/steps/build/BuildTriggerStepExecution.java",
        "file_name": "BuildTriggerStepExecution.java",
        "vulnerable_code": "package org.jenkinsci.plugins.workflow.support.steps.build;\n\nimport com.google.common.base.Function;\nimport com.google.common.collect.Lists;\nimport com.google.inject.Inject;\nimport edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\nimport hudson.AbortException;\nimport hudson.console.ModelHyperlinkNote;\nimport hudson.model.Action;\nimport hudson.model.Cause;\nimport hudson.model.CauseAction;\nimport hudson.model.Computer;\nimport hudson.model.Describable;\nimport hudson.model.Executor;\nimport hudson.model.Item;\nimport hudson.model.Job;\nimport hudson.model.ParameterDefinition;\nimport hudson.model.ParameterValue;\nimport hudson.model.ParametersAction;\nimport hudson.model.ParametersDefinitionProperty;\nimport hudson.model.Queue;\nimport hudson.model.Result;\nimport hudson.model.Run;\nimport hudson.model.TaskListener;\nimport hudson.model.queue.QueueTaskFuture;\nimport hudson.model.queue.ScheduleResult;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport jenkins.model.Jenkins;\nimport jenkins.model.ParameterizedJobMixIn;\nimport org.jenkinsci.plugins.workflow.actions.LabelAction;\nimport org.jenkinsci.plugins.workflow.graph.FlowNode;\nimport org.jenkinsci.plugins.workflow.steps.AbstractStepExecutionImpl;\nimport org.jenkinsci.plugins.workflow.steps.StepContext;\nimport org.jenkinsci.plugins.workflow.steps.StepContextParameter;\n\n/**\n * @author Vivek Pandey\n */\npublic class BuildTriggerStepExecution extends AbstractStepExecutionImpl {\n\n    private static final Logger LOGGER = Logger.getLogger(BuildTriggerStepExecution.class.getName());\n\n    @StepContextParameter\n    private transient TaskListener listener;\n    @StepContextParameter private transient Run<?,?> invokingRun;\n    @StepContextParameter private transient FlowNode node;\n\n    @Inject(optional=true) transient BuildTriggerStep step;\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // cannot get from ParameterizedJob back to ParameterizedJobMixIn trivially\n    @Override\n    public boolean start() throws Exception {\n        String job = step.getJob();\n        Item item = Jenkins.getActiveInstance().getItem(job, invokingRun.getParent(), Item.class);\n        if (item == null) {\n            throw new AbortException(\"No item named \" + job + \" found\");\n        }\n        if (step.getWait() && !(item instanceof Job)) {\n            // TODO find some way of allowing ComputedFolders to hook into the listener code\n            throw new AbortException(\"Waiting for non-job items is not supported\");\n        }\n        if (item instanceof ParameterizedJobMixIn.ParameterizedJob) {\n            final ParameterizedJobMixIn.ParameterizedJob project = (ParameterizedJobMixIn.ParameterizedJob) item;\n            listener.getLogger().println(\"Scheduling project: \" + ModelHyperlinkNote.encodeTo(project));\n\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(project.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{project, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            List<ParameterValue> parameters = step.getParameters();\n            if (parameters != null) {\n                parameters = completeDefaultParameters(parameters, (Job) project);\n                actions.add(new ParametersAction(parameters));\n            }\n            Integer quietPeriod = step.getQuietPeriod();\n            // TODO use new convenience method in 1.621\n            if (quietPeriod == null) {\n                quietPeriod = project.getQuietPeriod();\n            }\n            QueueTaskFuture<?> f = new ParameterizedJobMixIn() {\n                @Override\n                protected Job asJob() {\n                    return (Job) project;\n                }\n            }.scheduleBuild2(quietPeriod, actions.toArray(new Action[actions.size()]));\n            if (f == null) {\n                throw new AbortException(\"Failed to trigger build of \" + project.getFullName());\n            }\n        } else if (item instanceof Queue.Task){\n            if (step.getParameters() != null && !step.getParameters().isEmpty()) {\n                throw new AbortException(\"Item type does not support parameters\");\n            }\n            Queue.Task task = (Queue.Task) item;\n            listener.getLogger().println(\"Scheduling item: \" + ModelHyperlinkNote.encodeTo(item));\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(task.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{task, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            Integer quietPeriod = step.getQuietPeriod();\n            if (quietPeriod == null) {\n                try {\n                    Method getQuietPeriod = task.getClass().getMethod(\"getQuietPeriod\");\n                    if (getQuietPeriod.getReturnType().equals(int.class)) {\n                        quietPeriod = (Integer) getQuietPeriod.invoke(task);\n                    }\n                } catch (NoSuchMethodException e) {\n                    // ignore, best effort only\n                } catch (IllegalAccessError | IllegalArgumentException | InvocationTargetException e) {\n                    LOGGER.log(Level.WARNING, \"Could not determine quiet period of \" + item.getFullName(), e);\n                }\n            }\n            if (quietPeriod == null) {\n                quietPeriod = Jenkins.getActiveInstance().getQuietPeriod();\n            }\n            ScheduleResult scheduleResult = Jenkins.getActiveInstance().getQueue().schedule2(task, quietPeriod,actions);\n            if (scheduleResult.isRefused()) {\n                throw new AbortException(\"Failed to trigger build of \" + item.getFullName());\n            }\n        } else {\n            throw new AbortException(\"The item named \" + job + \" is a \"\n                    + (item instanceof Describable\n                    ? ((Describable) item).getDescriptor().getDisplayName()\n                    : item.getClass().getName())\n                    + \" which is not something that can be built\");\n        }\n        if (step.getWait()) {\n            return false;\n        } else {\n            getContext().onSuccess(null);\n            return true;\n        }\n    }\n\n    private List<ParameterValue> completeDefaultParameters(List<ParameterValue> parameters, Job<?,?> project) {\n        List<ParameterValue> completeListOfParameters = Lists.newArrayList(parameters);\n        List<String> names = Lists.transform(parameters, new Function<ParameterValue, String>() {\n            @Override public String apply(ParameterValue input) {\n                return input.getName();\n            }\n        });\n        if (project != null) {\n            ParametersDefinitionProperty pdp = project.getProperty(ParametersDefinitionProperty.class);\n            if (pdp != null) {\n                for (ParameterDefinition pDef : pdp.getParameterDefinitions()) {\n                    if (!names.contains(pDef.getName())) {\n                        ParameterValue defaultP = pDef.getDefaultParameterValue();\n                        if (defaultP != null) {\n                            completeListOfParameters.add(defaultP);\n                        }\n                    }\n                }\n            }\n        }\n        return completeListOfParameters;\n    }\n\n    @SuppressFBWarnings(value=\"RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE\", justification=\"TODO 1.653+ switch to Jenkins.getInstanceOrNull\")\n    @Override\n    public void stop(Throwable cause) {\n        StepContext context = getContext();\n        Jenkins jenkins = Jenkins.getInstance();\n        if (jenkins == null) {\n            context.onFailure(cause);\n            return;\n        }\n\n        boolean interrupted = false;\n\n        Queue q = jenkins.getQueue();\n        // if the build is still in the queue, abort it.\n        // BuildQueueListener will report the failure, so this method shouldn't call getContext().onFailure()\n        for (Queue.Item i : q.getItems()) {\n            for (BuildTriggerAction.Trigger trigger : BuildTriggerAction.triggersFor(i)) {\n                if (trigger.context.equals(context)) {\n                    // Note that it is a little questionable to cancel the queue item in case it has other causes,\n                    // but in the common case that this is the only cause, it is most intuitive to do so.\n                    // The same applies to aborting the actual build once started.\n                    q.cancel(i);\n                    interrupted = true;\n                }\n            }\n        }\n\n        // if there's any in-progress build already, abort that.\n        // when the build is actually aborted, BuildTriggerListener will take notice and report the failure,\n        // so this method shouldn't call getContext().onFailure()\n        for (Computer c : jenkins.getComputers()) {\n            for (Executor e : c.getExecutors()) {\n                interrupted |= maybeInterrupt(e, cause, context);\n            }\n            for (Executor e : c.getOneOffExecutors()) {\n                interrupted |= maybeInterrupt(e, cause, context);\n            }\n        }\n\n        if (!interrupted) {\n            context.onFailure(cause);\n        }\n    }\n    private static boolean maybeInterrupt(Executor e, Throwable cause, StepContext context) {\n        boolean interrupted = false;\n        Queue.Executable exec = e.getCurrentExecutable();\n        if (exec instanceof Run) {\n            for (BuildTriggerAction.Trigger trigger : BuildTriggerAction.triggersFor((Run) exec)) {\n                if (trigger.context.equals(context)) {\n                    e.interrupt(Result.ABORTED, new BuildTriggerCancelledCause(cause));\n                    trigger.interruption = cause;\n                    try {\n                        ((Run) exec).save();\n                    } catch (IOException x) {\n                        LOGGER.log(Level.WARNING, \"failed to save interrupt cause on \" + exec, x);\n                    }\n                    interrupted = true;\n                }\n            }\n        }\n        return interrupted;\n    }\n\n    @Override public String getStatus() {\n        for (Queue.Item i : Queue.getInstance().getItems()) {\n            for (BuildTriggerAction.Trigger trigger : BuildTriggerAction.triggersFor(i)) {\n                if (trigger.context.equals(getContext())) {\n                    return \"waiting to schedule \" + i.task.getFullDisplayName() + \"; blocked: \" + i.getWhy();\n                }\n            }\n        }\n        for (Computer c : Jenkins.getActiveInstance().getComputers()) {\n            for (Executor e : c.getExecutors()) {\n                String r = running(e);\n                if (r != null) {\n                    return r;\n                }\n            }\n            for (Executor e : c.getOneOffExecutors()) {\n                String r = running(e);\n                if (r != null) {\n                    return r;\n                }\n            }\n        }\n        // TODO QueueTaskFuture does not allow us to record the queue item ID\n        return \"unsure what happened to downstream build\";\n    }\n    private @CheckForNull String running(@Nonnull Executor e) {\n        Queue.Executable exec = e.getCurrentExecutable();\n        if (exec instanceof Run) {\n            Run<?,?> run = (Run) exec;\n            for (BuildTriggerAction.Trigger trigger : BuildTriggerAction.triggersFor(run)) {\n                if (trigger.context.equals(getContext())) {\n                    return \"running \" + run;\n                }\n            }\n        }\n        return null;\n    }\n\n    private static final long serialVersionUID = 1L;\n\n}\n",
        "human_patch_code": "package org.jenkinsci.plugins.workflow.support.steps.build;\n\nimport com.google.common.base.Function;\nimport com.google.common.collect.Lists;\nimport com.google.inject.Inject;\nimport edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\nimport hudson.AbortException;\nimport hudson.console.ModelHyperlinkNote;\nimport hudson.model.Action;\nimport hudson.model.Cause;\nimport hudson.model.CauseAction;\nimport hudson.model.Computer;\nimport hudson.model.Describable;\nimport hudson.model.Executor;\nimport hudson.model.Item;\nimport hudson.model.Job;\nimport hudson.model.ParameterDefinition;\nimport hudson.model.ParameterValue;\nimport hudson.model.ParametersAction;\nimport hudson.model.ParametersDefinitionProperty;\nimport hudson.model.Queue;\nimport hudson.model.Result;\nimport hudson.model.Run;\nimport hudson.model.TaskListener;\nimport hudson.model.queue.QueueTaskFuture;\nimport hudson.model.queue.ScheduleResult;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport jenkins.model.Jenkins;\nimport jenkins.model.ParameterizedJobMixIn;\nimport org.jenkinsci.plugins.workflow.actions.LabelAction;\nimport org.jenkinsci.plugins.workflow.graph.FlowNode;\nimport org.jenkinsci.plugins.workflow.steps.AbstractStepExecutionImpl;\nimport org.jenkinsci.plugins.workflow.steps.StepContext;\nimport org.jenkinsci.plugins.workflow.steps.StepContextParameter;\n\npublic class BuildTriggerStepExecution extends AbstractStepExecutionImpl {\n\n    private static final Logger LOGGER = Logger.getLogger(BuildTriggerStepExecution.class.getName());\n\n    @StepContextParameter\n    private transient TaskListener listener;\n    @StepContextParameter private transient Run<?,?> invokingRun;\n    @StepContextParameter private transient FlowNode node;\n\n    @Inject(optional=true) transient BuildTriggerStep step;\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // cannot get from ParameterizedJob back to ParameterizedJobMixIn trivially\n    @Override\n    public boolean start() throws Exception {\n        String job = step.getJob();\n        Item item = Jenkins.getActiveInstance().getItem(job, invokingRun.getParent(), Item.class);\n        if (item == null) {\n            throw new AbortException(\"No item named \" + job + \" found\");\n        }\n        item.checkPermission(Item.BUILD);\n        if (step.getWait() && !(item instanceof Job)) {\n            // TODO find some way of allowing ComputedFolders to hook into the listener code\n            throw new AbortException(\"Waiting for non-job items is not supported\");\n        }\n        if (item instanceof ParameterizedJobMixIn.ParameterizedJob) {\n            final ParameterizedJobMixIn.ParameterizedJob project = (ParameterizedJobMixIn.ParameterizedJob) item;\n            listener.getLogger().println(\"Scheduling project: \" + ModelHyperlinkNote.encodeTo(project));\n\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(project.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{project, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            List<ParameterValue> parameters = step.getParameters();\n            if (parameters != null) {\n                parameters = completeDefaultParameters(parameters, (Job) project);\n                actions.add(new ParametersAction(parameters));\n            }\n            Integer quietPeriod = step.getQuietPeriod();\n            // TODO use new convenience method in 1.621\n            if (quietPeriod == null) {\n                quietPeriod = project.getQuietPeriod();\n            }\n            QueueTaskFuture<?> f = new ParameterizedJobMixIn() {\n                @Override\n                protected Job asJob() {\n                    return (Job) project;\n                }\n            }.scheduleBuild2(quietPeriod, actions.toArray(new Action[actions.size()]));\n            if (f == null) {\n                throw new AbortException(\"Failed to trigger build of \" + project.getFullName());\n            }\n        } else if (item instanceof Queue.Task){\n            if (step.getParameters() != null && !step.getParameters().isEmpty()) {\n                throw new AbortException(\"Item type does not support parameters\");\n            }\n            Queue.Task task = (Queue.Task) item;\n            listener.getLogger().println(\"Scheduling item: \" + ModelHyperlinkNote.encodeTo(item));\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(task.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{task, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            Integer quietPeriod = step.getQuietPeriod();\n            if (quietPeriod == null) {\n                try {\n                    Method getQuietPeriod = task.getClass().getMethod(\"getQuietPeriod\");\n                    if (getQuietPeriod.getReturnType().equals(int.class)) {\n                        quietPeriod = (Integer) getQuietPeriod.invoke(task);\n                    }\n                } catch (NoSuchMethodException e) {\n                    // ignore, best effort only\n                } catch (IllegalAccessError | IllegalArgumentException | InvocationTargetException e) {\n                    LOGGER.log(Level.WARNING, \"Could not determine quiet period of \" + item.getFullName(), e);\n                }\n            }\n            if (quietPeriod == null) {\n                quietPeriod = Jenkins.getActiveInstance().getQuietPeriod();\n            }\n            ScheduleResult scheduleResult = Jenkins.getActiveInstance().getQueue().schedule2(task, quietPeriod,actions);\n            if (scheduleResult.isRefused()) {\n                throw new AbortException(\"Failed to trigger build of \" + item.getFullName());\n            }\n        } else {\n            throw new AbortException(\"The item named \" + job + \" is a \"\n                    + (item instanceof Describable\n                    ? ((Describable) item).getDescriptor().getDisplayName()\n                    : item.getClass().getName())\n                    + \" which is not something that can be built\");\n        }\n        if (step.getWait()) {\n            return false;\n        } else {\n            getContext().onSuccess(null);\n            return true;\n        }\n    }\n\n    private List<ParameterValue> completeDefaultParameters(List<ParameterValue> parameters, Job<?,?> project) {\n        List<ParameterValue> completeListOfParameters = Lists.newArrayList(parameters);\n        List<String> names = Lists.transform(parameters, new Function<ParameterValue, String>() {\n            @Override public String apply(ParameterValue input) {\n                return input.getName();\n            }\n        });\n        if (project != null) {\n            ParametersDefinitionProperty pdp = project.getProperty(ParametersDefinitionProperty.class);\n            if (pdp != null) {\n                for (ParameterDefinition pDef : pdp.getParameterDefinitions()) {\n                    if (!names.contains(pDef.getName())) {\n                        ParameterValue defaultP = pDef.getDefaultParameterValue();\n                        if (defaultP != null) {\n                            completeListOfParameters.add(defaultP);\n                        }\n                    }\n                }\n            }\n        }\n        return completeListOfParameters;\n    }\n\n    @SuppressFBWarnings(value=\"RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE\", justification=\"TODO 1.653+ switch to Jenkins.getInstanceOrNull\")\n    @Override\n    public void stop(Throwable cause) {\n        StepContext context = getContext();\n        Jenkins jenkins = Jenkins.getInstance();\n        if (jenkins == null) {\n            context.onFailure(cause);\n            return;\n        }\n\n        boolean interrupted = false;\n\n        Queue q = jenkins.getQueue();\n        // if the build is still in the queue, abort it.\n        // BuildQueueListener will report the failure, so this method shouldn't call getContext().onFailure()\n        for (Queue.Item i : q.getItems()) {\n            for (BuildTriggerAction.Trigger trigger : BuildTriggerAction.triggersFor(i)) {\n                if (trigger.context.equals(context)) {\n                    // Note that it is a little questionable to cancel the queue item in case it has other causes,\n                    // but in the common case that this is the only cause, it is most intuitive to do so.\n                    // The same applies to aborting the actual build once started.\n                    q.cancel(i);\n                    interrupted = true;\n                }\n            }\n        }\n\n        // if there's any in-progress build already, abort that.\n        // when the build is actually aborted, BuildTriggerListener will take notice and report the failure,\n        // so this method shouldn't call getContext().onFailure()\n        for (Computer c : jenkins.getComputers()) {\n            for (Executor e : c.getExecutors()) {\n                interrupted |= maybeInterrupt(e, cause, context);\n            }\n            for (Executor e : c.getOneOffExecutors()) {\n                interrupted |= maybeInterrupt(e, cause, context);\n            }\n        }\n\n        if (!interrupted) {\n            context.onFailure(cause);\n        }\n    }\n    private static boolean maybeInterrupt(Executor e, Throwable cause, StepContext context) {\n        boolean interrupted = false;\n        Queue.Executable exec = e.getCurrentExecutable();\n        if (exec instanceof Run) {\n            for (BuildTriggerAction.Trigger trigger : BuildTriggerAction.triggersFor((Run) exec)) {\n                if (trigger.context.equals(context)) {\n                    e.interrupt(Result.ABORTED, new BuildTriggerCancelledCause(cause));\n                    trigger.interruption = cause;\n                    try {\n                        ((Run) exec).save();\n                    } catch (IOException x) {\n                        LOGGER.log(Level.WARNING, \"failed to save interrupt cause on \" + exec, x);\n                    }\n                    interrupted = true;\n                }\n            }\n        }\n        return interrupted;\n    }\n\n    @Override public String getStatus() {\n        for (Queue.Item i : Queue.getInstance().getItems()) {\n            for (BuildTriggerAction.Trigger trigger : BuildTriggerAction.triggersFor(i)) {\n                if (trigger.context.equals(getContext())) {\n                    return \"waiting to schedule \" + i.task.getFullDisplayName() + \"; blocked: \" + i.getWhy();\n                }\n            }\n        }\n        for (Computer c : Jenkins.getActiveInstance().getComputers()) {\n            for (Executor e : c.getExecutors()) {\n                String r = running(e);\n                if (r != null) {\n                    return r;\n                }\n            }\n            for (Executor e : c.getOneOffExecutors()) {\n                String r = running(e);\n                if (r != null) {\n                    return r;\n                }\n            }\n        }\n        // TODO QueueTaskFuture does not allow us to record the queue item ID\n        return \"unsure what happened to downstream build\";\n    }\n    private @CheckForNull String running(@Nonnull Executor e) {\n        Queue.Executable exec = e.getCurrentExecutable();\n        if (exec instanceof Run) {\n            Run<?,?> run = (Run) exec;\n            for (BuildTriggerAction.Trigger trigger : BuildTriggerAction.triggersFor(run)) {\n                if (trigger.context.equals(getContext())) {\n                    return \"running \" + run;\n                }\n            }\n        }\n        return null;\n    }\n\n    private static final long serialVersionUID = 1L;\n\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-58": {
    "vul_id": "VUL4J-58",
    "cve_id": "CVE-2018-1000111",
    "project": "jenkinsci_subversion-plugin",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=hudson.scm.SubversionStatusTest",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/jenkinsci/subversion-plugin/commit/25f6afbb02a5863f363b0a2f664ac717ace743b4",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/hudson/scm/SubversionRepositoryStatus.java",
        "file_name": "SubversionRepositoryStatus.java",
        "vulnerable_code": "package hudson.scm;\n\nimport static java.util.logging.Level.FINE;\nimport static java.util.logging.Level.FINER;\nimport static java.util.logging.Level.WARNING;\nimport static javax.servlet.http.HttpServletResponse.SC_OK;\n\nimport hudson.Extension;\nimport hudson.ExtensionList;\nimport hudson.ExtensionPoint;\nimport hudson.model.AbstractModelObject;\nimport hudson.model.AbstractProject;\nimport hudson.model.Job;\nimport hudson.scm.SubversionSCM.ModuleLocation;\nimport hudson.scm.SubversionSCM.SvnInfo;\nimport hudson.triggers.SCMTrigger;\nimport hudson.util.QueryParameterMap;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.servlet.ServletException;\n\nimport jenkins.model.Jenkins;\nimport jenkins.triggers.SCMTriggerItem;\nimport org.apache.commons.io.IOUtils;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\n\nimport org.tmatesoft.svn.core.SVNCancelException;\nimport org.tmatesoft.svn.core.SVNURL;\nimport org.tmatesoft.svn.core.SVNException;\n\n/**\n * Per repository status.\n * <p>\n * Receives post-commit hook notifications.\n *\n * @author Kohsuke Kawaguchi\n * @see SubversionStatus\n */\npublic class SubversionRepositoryStatus extends AbstractModelObject {\n    public final UUID uuid;\n\n    public SubversionRepositoryStatus(UUID uuid) {\n        this.uuid = uuid;\n    }\n\n    public String getDisplayName() {\n        return uuid.toString();\n    }\n\n    public String getSearchUrl() {\n        return uuid.toString();\n    }\n    \n    static interface JobProvider {\n        @SuppressWarnings(\"rawtypes\")\n        List<Job> getAllJobs();\n    }\n\n    /**\n     * An extension point to allow things other than jobs to listen for repository status updates.\n     */\n    public static abstract class Listener implements ExtensionPoint {\n\n        /**\n         * Called when a post-commit hook notification has been received.\n         * @param uuid the UUID of the repository against which the hook was received.\n         * @param revision the revision (if known) or {@code -1} if unknown.\n         * @return {@code true} if a match for the UUID was found and something was scheduled as a result.\n         */\n        public abstract boolean onNotify(UUID uuid, long revision, Set<String> affectedPaths);\n    }\n    \n    private static Method IS_IGNORE_POST_COMMIT_HOOKS_METHOD;\n    \n    /**\n     * Notify the commit to this repository.\n     *\n     * <p>\n     * Because this URL is not guarded, we can't really trust the data that's sent to us. But we intentionally\n     * don't protect this URL to simplify <tt>post-commit</tt> script set up.\n     */\n    public void doNotifyCommit(StaplerRequest req, StaplerResponse rsp) throws ServletException, IOException {\n        requirePOST();\n\n        // compute the affected paths\n        Set<String> affectedPath = new HashSet<String>();\n        String line;\n        BufferedReader r = new BufferedReader(req.getReader());\n        \n        try {\n\t        while((line=r.readLine())!=null) {\n\t        \tif (LOGGER.isLoggable(FINER)) {\n\t        \t\tLOGGER.finer(\"Reading line: \"+line);\n\t        \t}\n\t            affectedPath.add(line.substring(4));\n\t            if (line.startsWith(\"svnlook changed --revision \")) {\n\t                String msg = \"Expecting the output from the svnlook command but instead you just sent me the svnlook invocation command line: \" + line;\n\t                LOGGER.warning(msg);\n\t                throw new IllegalArgumentException(msg);\n\t            }\n\t        }\n        } finally {\n        \tIOUtils.closeQuietly(r);\n        }\n\n        if(LOGGER.isLoggable(FINE))\n            LOGGER.fine(\"Change reported to Subversion repository \"+uuid+\" on \"+affectedPath);\n\n        // we can't reliably use req.getParameter() as it can try to parse the payload, which we've already consumed above.\n        // servlet container relies on Content-type to decide if it wants to parse the payload or not, and at least\n        // in case of Jetty, it doesn't check if the payload is\n        QueryParameterMap query = new QueryParameterMap(req);\n        String revParam = query.get(\"rev\");\n        if (revParam == null) {\n            revParam = req.getHeader(\"X-Hudson-Subversion-Revision\");\n        }\n\n        long rev = -1;\n        if (revParam != null) {\n            rev = Long.parseLong(revParam);\n        }\n\n        boolean listenerDidSomething = false;\n        for (Listener listener : ExtensionList.lookup(Listener.class)) {\n            try {\n                if (listener.onNotify(uuid, rev, affectedPath)) {\n                    listenerDidSomething = true;\n                }\n            } catch (Throwable t) {\n                LOGGER.log(WARNING, \"Listener \" + listener.getClass().getName() + \" threw an uncaught exception\", t);\n            }\n        }\n\n        if (!listenerDidSomething) LOGGER.log(Level.WARNING, \"No interest in change to repository UUID {0} found\", uuid);\n\n        rsp.setStatus(SC_OK);\n    }\n\n    private static class SubversionRepoUUIDAndRootPath {\n        public final UUID uuid;\n        public final String rootPath;\n\n        public SubversionRepoUUIDAndRootPath(UUID uuid, String rootPath) {\n            this.uuid = uuid;\n            this.rootPath = rootPath;\n        }\n    }\n\n    @Extension\n    public static class JobTriggerListenerImpl extends Listener {\n\n        private Map<String, UUID> remoteUUIDCache = new HashMap<String, UUID>();\n\n        private JobProvider jobProvider = new JobProvider() {\n            @SuppressWarnings(\"rawtypes\")\n            public List<Job> getAllJobs() {\n                return Jenkins.getInstance().getAllItems(Job.class);\n            }\n        };\n\n        // for tests\n        void setJobProvider(JobProvider jobProvider) {\n            this.jobProvider = jobProvider;\n        }\n\n        private SubversionRepoUUIDAndRootPath remoteUUIDAndRootPathFromCacheOrFromSVN(Job job, SCM scm, ModuleLocation moduleLocation, String urlFromConfiguration) throws SVNException {\n            SubversionRepoUUIDAndRootPath uuidAndRootPath = null;\n            for (Map.Entry<String, UUID> e : remoteUUIDCache.entrySet()) {\n                String remoteRepoRootURL = e.getKey();\n                String remoteRepoRootURLWithSlash = remoteRepoRootURL + \"/\";\n                if (urlFromConfiguration.startsWith(remoteRepoRootURLWithSlash) || urlFromConfiguration.equals(remoteRepoRootURL)) {\n                    UUID uuid = e.getValue();\n                    String rootPath = SVNURL.parseURIDecoded(e.getKey()).getPath();\n                    uuidAndRootPath = new SubversionRepoUUIDAndRootPath(uuid, rootPath);\n\n                    LOGGER.finer(\"Using cached uuid for module location \" + urlFromConfiguration + \" of job \"+ job);\n                    break;\n                }\n            }\n\n            if (uuidAndRootPath == null) {\n                if (LOGGER.isLoggable(FINER)) {\n                    LOGGER.finer(\"Could not find \" + urlFromConfiguration + \" in \" + remoteUUIDCache.keySet());\n                }\n                UUID remoteUUID = moduleLocation.getUUID(job, scm);\n                SVNURL repositoryRoot = moduleLocation.getRepositoryRoot(job, scm);\n                remoteUUIDCache.put(repositoryRoot.toString(), remoteUUID);\n                uuidAndRootPath = new SubversionRepoUUIDAndRootPath(remoteUUID, repositoryRoot.getPath());\n            }\n            return uuidAndRootPath;\n        }\n\n        boolean doModuleLocationHasAPathFromAffectedPath(String configuredRepoFullPath, String rootRepoPath, Set<String> affectedPath) {\n            boolean containsAnAffectedPath = false;\n            if (configuredRepoFullPath.startsWith(rootRepoPath)) {\n                String remainingRepoPath = configuredRepoFullPath.substring(rootRepoPath.length());\n                if (remainingRepoPath.startsWith(\"/\")) remainingRepoPath=remainingRepoPath.substring(1);\n                String remainingRepoPathSlash = remainingRepoPath + '/';\n\n                for (String path : affectedPath) {\n                    if (path.equals(remainingRepoPath) /*for files*/ || \n                            path.startsWith(remainingRepoPathSlash) /*for dirs*/ ||\n                            remainingRepoPath.length() == 0 /*when someone is checking out the whole repo (that is, configuredRepoFullPath==rootRepoPath)*/) {\n                        // this project is possibly changed. poll now.\n                        // if any of the data we used was bogus, the trigger will not detect a change\n                        containsAnAffectedPath = true;\n                        break;\n                    }\n                }\n            }\n            return containsAnAffectedPath;\n        }\n\n        private void scheduleImediatePollingOfJob(Job job, SCMTrigger trigger, List<SvnInfo> infos) {\n            LOGGER.fine(\"Scheduling the immediate polling of \" + job);\n\n            final RevisionParameterAction[] actions;\n            if (infos.isEmpty()) {\n                actions = new RevisionParameterAction[0];\n            } else {\n                actions = new RevisionParameterAction[] { new RevisionParameterAction(infos) };\n            }\n\n            trigger.run(actions);\n        }\n\n        @Override\n        public boolean onNotify(UUID uuid, long rev, Set<String> affectedPath) {\n            boolean scmFound = false, triggerFound = false, uuidFound = false, pathFound = false;\n            LOGGER.fine(\"Starting subversion locations checks for all jobs\");\n            for (Job p : this.jobProvider.getAllJobs()) {\n                SCMTriggerItem scmTriggerItem = SCMTriggerItem.SCMTriggerItems.asSCMTriggerItem(p);\n                if (scmTriggerItem == null) {\n                    continue;\n                }\n                if (p instanceof AbstractProject && ((AbstractProject) p).isDisabled()) {\n                    continue;\n                }\n                String jobName = p.getName();\n                SCMS: for (SCM scm : scmTriggerItem.getSCMs()) {\n                    if (scm instanceof SubversionSCM) scmFound = true; else continue;\n\n                    SCMTrigger trigger = scmTriggerItem.getSCMTrigger();\n                    if (trigger!=null && !doesIgnorePostCommitHooks(trigger)) triggerFound = true; else continue;\n\n                    SubversionSCM sscm = (SubversionSCM) scm;\n\n                    List<SvnInfo> infos = new ArrayList<SvnInfo>();\n\n                    try {\n                        boolean projectMatches = false;\n                        for (ModuleLocation loc : sscm.getProjectLocations(p)) {\n                            String urlFromConfiguration = loc.getURL();\n                            //LOGGER.log(WARNING, \"Checking uuid for module location + \" + loc + \" of job \"+ p + \" (urlFromConfiguration : \" + urlFromConfiguration + \")\");\n                        \n                            try {\n                                SubversionRepoUUIDAndRootPath uuidAndRootPath = this.remoteUUIDAndRootPathFromCacheOrFromSVN(p, sscm, loc, urlFromConfiguration);\n                                UUID remoteUUID = uuidAndRootPath.uuid;\n                                if (remoteUUID.equals(uuid)) uuidFound = true; else continue;\n\n                                String configuredRepoFullPath = loc.getSVNURL().getPath();\n                                String rootRepoPath = uuidAndRootPath.rootPath;\n                                if (this.doModuleLocationHasAPathFromAffectedPath(configuredRepoFullPath, rootRepoPath, affectedPath)) {\n                                    projectMatches = true;\n                                    pathFound = true;\n                                }\n\n                                if ( rev != -1 ) {\n                                    infos.add(new SvnInfo(loc.getURL(), rev));\n                                }\n                            } catch (SVNCancelException e) {\n                                LOGGER.log(WARNING, \"Failed to handle Subversion commit notification (was trying to access \" + urlFromConfiguration + \" of job \" + jobName + \"). If you are using svn:externals feature ensure that the credentials of the externals are added on the Additional Credentials field\", e);\n                            } catch (SVNException e) {\n                                LOGGER.log(WARNING, \"Failed to handle Subversion commit notification (was trying to access \" + urlFromConfiguration + \" of job \" + jobName + \")\", e);\n                            }\n                            \n                            if (projectMatches) {\n                                this.scheduleImediatePollingOfJob(p, trigger, infos);\n                                break SCMS;\n                            }\n                        }\n                    } catch(IOException e) {\n                        LOGGER.log(WARNING, \"Failed to handle Subversion commit notification (getting module locations failed for job \" + jobName + \")\", e);\n                    }\n                }\n            }\n            LOGGER.fine(\"Ended subversion locations checks for all jobs\");\n\n            if (!scmFound)          LOGGER.warning(\"No subversion jobs found\");\n            else if (!triggerFound) LOGGER.warning(\"No subversion jobs using SCM polling or all jobs using SCM polling are ignoring post-commit hooks\");\n            else if (!uuidFound)    LOGGER.warning(\"No subversion jobs using repository: \" + uuid);\n            else if (!pathFound)    LOGGER.fine(\"No jobs found matching the modified files\");\n\n            return scmFound;\n        }\n    }\n    \n    private static boolean doesIgnorePostCommitHooks(SCMTrigger trigger) {\n        if (IS_IGNORE_POST_COMMIT_HOOKS_METHOD == null)\n            return false;\n        \n        try {\n            return (Boolean)IS_IGNORE_POST_COMMIT_HOOKS_METHOD.invoke(trigger, (Object[])null);\n        } catch (Exception e) {\n            LOGGER.log(WARNING,\"Failure when calling isIgnorePostCommitHooks\",e);\n            return false;\n        }\n    }\n\n    static {\n        try {\n            IS_IGNORE_POST_COMMIT_HOOKS_METHOD = SCMTrigger.class.getMethod(\"isIgnorePostCommitHooks\", (Class[])null);\n        } catch (Exception e) {\n            // we're running in an older Jenkins version which doesn't have this method\n        }\n    }\n\n    private static final Logger LOGGER = Logger.getLogger(SubversionRepositoryStatus.class.getName());\n}\n",
        "human_patch_code": "package hudson.scm;\n\nimport static java.util.logging.Level.FINE;\nimport static java.util.logging.Level.FINER;\nimport static java.util.logging.Level.WARNING;\nimport static javax.servlet.http.HttpServletResponse.SC_OK;\n\nimport hudson.Extension;\nimport hudson.ExtensionList;\nimport hudson.ExtensionPoint;\nimport hudson.model.AbstractProject;\nimport hudson.model.Job;\nimport hudson.scm.SubversionSCM.ModuleLocation;\nimport hudson.scm.SubversionSCM.SvnInfo;\nimport hudson.triggers.SCMTrigger;\nimport hudson.util.QueryParameterMap;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.servlet.ServletException;\n\nimport jenkins.model.Jenkins;\nimport jenkins.triggers.SCMTriggerItem;\nimport org.apache.commons.io.IOUtils;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\n\nimport org.kohsuke.stapler.interceptor.RequirePOST;\nimport org.tmatesoft.svn.core.SVNCancelException;\nimport org.tmatesoft.svn.core.SVNURL;\nimport org.tmatesoft.svn.core.SVNException;\n\n/**\n * Per repository status.\n * <p>\n * Receives post-commit hook notifications.\n *\n * @author Kohsuke Kawaguchi\n * @see SubversionStatus\n */\npublic class SubversionRepositoryStatus {\n    public final UUID uuid;\n\n    public SubversionRepositoryStatus(UUID uuid) {\n        this.uuid = uuid;\n    }\n\n    public String getDisplayName() {\n        return uuid.toString();\n    }\n\n    static interface JobProvider {\n        @SuppressWarnings(\"rawtypes\")\n        List<Job> getAllJobs();\n    }\n\n    /**\n     * An extension point to allow things other than jobs to listen for repository status updates.\n     */\n    public static abstract class Listener implements ExtensionPoint {\n\n        /**\n         * Called when a post-commit hook notification has been received.\n         * @param uuid the UUID of the repository against which the hook was received.\n         * @param revision the revision (if known) or {@code -1} if unknown.\n         * @return {@code true} if a match for the UUID was found and something was scheduled as a result.\n         */\n        public abstract boolean onNotify(UUID uuid, long revision, Set<String> affectedPaths);\n    }\n    \n    private static Method IS_IGNORE_POST_COMMIT_HOOKS_METHOD;\n    \n    /**\n     * Notify the commit to this repository.\n     *\n     * <p>\n     * Because this URL is not guarded, we can't really trust the data that's sent to us. But we intentionally\n     * don't protect this URL to simplify <tt>post-commit</tt> script set up.\n     */\n    @RequirePOST\n    public void doNotifyCommit(StaplerRequest req, StaplerResponse rsp) throws ServletException, IOException {\n        // compute the affected paths\n        Set<String> affectedPath = new HashSet<String>();\n        String line;\n        BufferedReader r = new BufferedReader(req.getReader());\n        \n        try {\n\t        while((line=r.readLine())!=null) {\n\t        \tif (LOGGER.isLoggable(FINER)) {\n\t        \t\tLOGGER.finer(\"Reading line: \"+line);\n\t        \t}\n\t            affectedPath.add(line.substring(4));\n\t            if (line.startsWith(\"svnlook changed --revision \")) {\n\t                String msg = \"Expecting the output from the svnlook command but instead you just sent me the svnlook invocation command line: \" + line;\n\t                LOGGER.warning(msg);\n\t                throw new IllegalArgumentException(msg);\n\t            }\n\t        }\n        } finally {\n        \tIOUtils.closeQuietly(r);\n        }\n\n        if(LOGGER.isLoggable(FINE))\n            LOGGER.fine(\"Change reported to Subversion repository \"+uuid+\" on \"+affectedPath);\n\n        // we can't reliably use req.getParameter() as it can try to parse the payload, which we've already consumed above.\n        // servlet container relies on Content-type to decide if it wants to parse the payload or not, and at least\n        // in case of Jetty, it doesn't check if the payload is\n        QueryParameterMap query = new QueryParameterMap(req);\n        String revParam = query.get(\"rev\");\n        if (revParam == null) {\n            revParam = req.getHeader(\"X-Hudson-Subversion-Revision\");\n        }\n\n        long rev = -1;\n        if (revParam != null) {\n            rev = Long.parseLong(revParam);\n        }\n\n        boolean listenerDidSomething = false;\n        for (Listener listener : ExtensionList.lookup(Listener.class)) {\n            try {\n                if (listener.onNotify(uuid, rev, affectedPath)) {\n                    listenerDidSomething = true;\n                }\n            } catch (Throwable t) {\n                LOGGER.log(WARNING, \"Listener \" + listener.getClass().getName() + \" threw an uncaught exception\", t);\n            }\n        }\n\n        if (!listenerDidSomething) LOGGER.log(Level.WARNING, \"No interest in change to repository UUID {0} found\", uuid);\n\n        rsp.setStatus(SC_OK);\n    }\n\n    private static class SubversionRepoUUIDAndRootPath {\n        public final UUID uuid;\n        public final String rootPath;\n\n        public SubversionRepoUUIDAndRootPath(UUID uuid, String rootPath) {\n            this.uuid = uuid;\n            this.rootPath = rootPath;\n        }\n    }\n\n    @Extension\n    public static class JobTriggerListenerImpl extends Listener {\n\n        private Map<String, UUID> remoteUUIDCache = new HashMap<String, UUID>();\n\n        private JobProvider jobProvider = new JobProvider() {\n            @SuppressWarnings(\"rawtypes\")\n            public List<Job> getAllJobs() {\n                return Jenkins.getInstance().getAllItems(Job.class);\n            }\n        };\n\n        // for tests\n        void setJobProvider(JobProvider jobProvider) {\n            this.jobProvider = jobProvider;\n        }\n\n        private SubversionRepoUUIDAndRootPath remoteUUIDAndRootPathFromCacheOrFromSVN(Job job, SCM scm, ModuleLocation moduleLocation, String urlFromConfiguration) throws SVNException {\n            SubversionRepoUUIDAndRootPath uuidAndRootPath = null;\n            for (Map.Entry<String, UUID> e : remoteUUIDCache.entrySet()) {\n                String remoteRepoRootURL = e.getKey();\n                String remoteRepoRootURLWithSlash = remoteRepoRootURL + \"/\";\n                if (urlFromConfiguration.startsWith(remoteRepoRootURLWithSlash) || urlFromConfiguration.equals(remoteRepoRootURL)) {\n                    UUID uuid = e.getValue();\n                    String rootPath = SVNURL.parseURIDecoded(e.getKey()).getPath();\n                    uuidAndRootPath = new SubversionRepoUUIDAndRootPath(uuid, rootPath);\n\n                    LOGGER.finer(\"Using cached uuid for module location \" + urlFromConfiguration + \" of job \"+ job);\n                    break;\n                }\n            }\n\n            if (uuidAndRootPath == null) {\n                if (LOGGER.isLoggable(FINER)) {\n                    LOGGER.finer(\"Could not find \" + urlFromConfiguration + \" in \" + remoteUUIDCache.keySet());\n                }\n                UUID remoteUUID = moduleLocation.getUUID(job, scm);\n                SVNURL repositoryRoot = moduleLocation.getRepositoryRoot(job, scm);\n                remoteUUIDCache.put(repositoryRoot.toString(), remoteUUID);\n                uuidAndRootPath = new SubversionRepoUUIDAndRootPath(remoteUUID, repositoryRoot.getPath());\n            }\n            return uuidAndRootPath;\n        }\n\n        boolean doModuleLocationHasAPathFromAffectedPath(String configuredRepoFullPath, String rootRepoPath, Set<String> affectedPath) {\n            boolean containsAnAffectedPath = false;\n            if (configuredRepoFullPath.startsWith(rootRepoPath)) {\n                String remainingRepoPath = configuredRepoFullPath.substring(rootRepoPath.length());\n                if (remainingRepoPath.startsWith(\"/\")) remainingRepoPath=remainingRepoPath.substring(1);\n                String remainingRepoPathSlash = remainingRepoPath + '/';\n\n                for (String path : affectedPath) {\n                    if (path.equals(remainingRepoPath) /*for files*/ || \n                            path.startsWith(remainingRepoPathSlash) /*for dirs*/ ||\n                            remainingRepoPath.length() == 0 /*when someone is checking out the whole repo (that is, configuredRepoFullPath==rootRepoPath)*/) {\n                        // this project is possibly changed. poll now.\n                        // if any of the data we used was bogus, the trigger will not detect a change\n                        containsAnAffectedPath = true;\n                        break;\n                    }\n                }\n            }\n            return containsAnAffectedPath;\n        }\n\n        private void scheduleImediatePollingOfJob(Job job, SCMTrigger trigger, List<SvnInfo> infos) {\n            LOGGER.fine(\"Scheduling the immediate polling of \" + job);\n\n            final RevisionParameterAction[] actions;\n            if (infos.isEmpty()) {\n                actions = new RevisionParameterAction[0];\n            } else {\n                actions = new RevisionParameterAction[] { new RevisionParameterAction(infos) };\n            }\n\n            trigger.run(actions);\n        }\n\n        @Override\n        public boolean onNotify(UUID uuid, long rev, Set<String> affectedPath) {\n            boolean scmFound = false, triggerFound = false, uuidFound = false, pathFound = false;\n            LOGGER.fine(\"Starting subversion locations checks for all jobs\");\n            for (Job p : this.jobProvider.getAllJobs()) {\n                SCMTriggerItem scmTriggerItem = SCMTriggerItem.SCMTriggerItems.asSCMTriggerItem(p);\n                if (scmTriggerItem == null) {\n                    continue;\n                }\n                if (p instanceof AbstractProject && ((AbstractProject) p).isDisabled()) {\n                    continue;\n                }\n                String jobName = p.getName();\n                SCMS: for (SCM scm : scmTriggerItem.getSCMs()) {\n                    if (scm instanceof SubversionSCM) scmFound = true; else continue;\n\n                    SCMTrigger trigger = scmTriggerItem.getSCMTrigger();\n                    if (trigger!=null && !doesIgnorePostCommitHooks(trigger)) triggerFound = true; else continue;\n\n                    SubversionSCM sscm = (SubversionSCM) scm;\n\n                    List<SvnInfo> infos = new ArrayList<SvnInfo>();\n\n                    try {\n                        boolean projectMatches = false;\n                        for (ModuleLocation loc : sscm.getProjectLocations(p)) {\n                            String urlFromConfiguration = loc.getURL();\n                            //LOGGER.log(WARNING, \"Checking uuid for module location + \" + loc + \" of job \"+ p + \" (urlFromConfiguration : \" + urlFromConfiguration + \")\");\n                        \n                            try {\n                                SubversionRepoUUIDAndRootPath uuidAndRootPath = this.remoteUUIDAndRootPathFromCacheOrFromSVN(p, sscm, loc, urlFromConfiguration);\n                                UUID remoteUUID = uuidAndRootPath.uuid;\n                                if (remoteUUID.equals(uuid)) uuidFound = true; else continue;\n\n                                String configuredRepoFullPath = loc.getSVNURL().getPath();\n                                String rootRepoPath = uuidAndRootPath.rootPath;\n                                if (this.doModuleLocationHasAPathFromAffectedPath(configuredRepoFullPath, rootRepoPath, affectedPath)) {\n                                    projectMatches = true;\n                                    pathFound = true;\n                                }\n\n                                if ( rev != -1 ) {\n                                    infos.add(new SvnInfo(loc.getURL(), rev));\n                                }\n                            } catch (SVNCancelException e) {\n                                LOGGER.log(WARNING, \"Failed to handle Subversion commit notification (was trying to access \" + urlFromConfiguration + \" of job \" + jobName + \"). If you are using svn:externals feature ensure that the credentials of the externals are added on the Additional Credentials field\", e);\n                            } catch (SVNException e) {\n                                LOGGER.log(WARNING, \"Failed to handle Subversion commit notification (was trying to access \" + urlFromConfiguration + \" of job \" + jobName + \")\", e);\n                            }\n                            \n                            if (projectMatches) {\n                                this.scheduleImediatePollingOfJob(p, trigger, infos);\n                                break SCMS;\n                            }\n                        }\n                    } catch(IOException e) {\n                        LOGGER.log(WARNING, \"Failed to handle Subversion commit notification (getting module locations failed for job \" + jobName + \")\", e);\n                    }\n                }\n            }\n            LOGGER.fine(\"Ended subversion locations checks for all jobs\");\n\n            if (!scmFound)          LOGGER.warning(\"No subversion jobs found\");\n            else if (!triggerFound) LOGGER.warning(\"No subversion jobs using SCM polling or all jobs using SCM polling are ignoring post-commit hooks\");\n            else if (!uuidFound)    LOGGER.warning(\"No subversion jobs using repository: \" + uuid);\n            else if (!pathFound)    LOGGER.fine(\"No jobs found matching the modified files\");\n\n            return scmFound;\n        }\n    }\n    \n    private static boolean doesIgnorePostCommitHooks(SCMTrigger trigger) {\n        if (IS_IGNORE_POST_COMMIT_HOOKS_METHOD == null)\n            return false;\n        \n        try {\n            return (Boolean)IS_IGNORE_POST_COMMIT_HOOKS_METHOD.invoke(trigger, (Object[])null);\n        } catch (Exception e) {\n            LOGGER.log(WARNING,\"Failure when calling isIgnorePostCommitHooks\",e);\n            return false;\n        }\n    }\n\n    static {\n        try {\n            IS_IGNORE_POST_COMMIT_HOOKS_METHOD = SCMTrigger.class.getMethod(\"isIgnorePostCommitHooks\", (Class[])null);\n        } catch (Exception e) {\n            // we're running in an older Jenkins version which doesn't have this method\n        }\n    }\n\n    private static final Logger LOGGER = Logger.getLogger(SubversionRepositoryStatus.class.getName());\n}\n"
      },
      {
        "file_path": "src/main/java/hudson/scm/SubversionStatus.java",
        "file_name": "SubversionStatus.java",
        "vulnerable_code": "/*\n * The MIT License\n *\n * Copyright (c) 2004-2009, Sun Microsystems, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.scm;\n\nimport hudson.Extension;\nimport hudson.model.AbstractModelObject;\nimport hudson.model.UnprotectedRootAction;\n\nimport java.util.regex.Pattern;\nimport java.util.UUID;\n\n/**\n * Receives the push notification of commits from repository.\n * Opened up for untrusted access.\n *\n * @author Kohsuke Kawaguchi\n */\n@Extension\npublic class SubversionStatus extends AbstractModelObject implements UnprotectedRootAction {\n    public String getDisplayName() {\n        return \"Subversion\";\n    }\n\n    public String getSearchUrl() {\n        return getUrlName();\n    }\n\n    public String getIconFileName() {\n        // TODO\n        return null;\n    }\n\n    public String getUrlName() {\n        return \"subversion\";\n    }\n\n    public SubversionRepositoryStatus getDynamic(String uuid) {\n        if(UUID_PATTERN.matcher(uuid).matches())\n            return new SubversionRepositoryStatus(UUID.fromString(uuid));\n        return null;\n    }\n\n    private static final Pattern UUID_PATTERN = Pattern.compile(\"\\\\p{XDigit}{8}-\\\\p{XDigit}{4}-\\\\p{XDigit}{4}-\\\\p{XDigit}{4}-\\\\p{XDigit}{12}\");\n}\n",
        "human_patch_code": "/*\n * The MIT License\n *\n * Copyright (c) 2004-2009, Sun Microsystems, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.scm;\n\nimport hudson.Extension;\nimport hudson.model.UnprotectedRootAction;\n\nimport java.util.regex.Pattern;\nimport java.util.UUID;\n\n/**\n * Receives the push notification of commits from repository.\n * Opened up for untrusted access.\n *\n * @author Kohsuke Kawaguchi\n */\n@Extension\npublic class SubversionStatus implements UnprotectedRootAction {\n    public String getDisplayName() {\n        return \"Subversion\";\n    }\n\n    public String getIconFileName() {\n        // TODO\n        return null;\n    }\n\n    public String getUrlName() {\n        return \"subversion\";\n    }\n\n    public SubversionRepositoryStatus getDynamic(String uuid) {\n        if(UUID_PATTERN.matcher(uuid).matches())\n            return new SubversionRepositoryStatus(UUID.fromString(uuid));\n        return null;\n    }\n\n    private static final Pattern UUID_PATTERN = Pattern.compile(\"\\\\p{XDigit}{8}-\\\\p{XDigit}{4}-\\\\p{XDigit}{4}-\\\\p{XDigit}{4}-\\\\p{XDigit}{12}\");\n}\n"
      }
    ],
    "file_count": 2
  },
  "VUL4J-59": {
    "vul_id": "VUL4J-59",
    "cve_id": "CVE-2015-6748",
    "project": "jhy_jsoup",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=org.jsoup.parser.XmlTreeBuilderTest#testDoesHandleEOFInTag",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/jhy/jsoup/commit/4edb78991f8d0bf87dafde5e01ccd8922065c9b2",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "file_name": "TokeniserState.java",
        "vulnerable_code": "package org.jsoup.parser;\n\nimport java.util.Arrays;\n\n/**\n * States and transition activations for the Tokeniser.\n */\nenum TokeniserState {\n    Data {\n        // in data state, gather characters until a character reference or tag is found\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '&':\n                    t.advanceTransition(CharacterReferenceInData);\n                    break;\n                case '<':\n                    t.advanceTransition(TagOpen);\n                    break;\n                case nullChar:\n                    t.error(this); // NOT replacement character (oddly?)\n                    t.emit(r.consume());\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeData();\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    CharacterReferenceInData {\n        // from & in data\n        void read(Tokeniser t, CharacterReader r) {\n            char[] c = t.consumeCharacterReference(null, false);\n            if (c == null)\n                t.emit('&');\n            else\n                t.emit(c);\n            t.transition(Data);\n        }\n    },\n    Rcdata {\n        /// handles data in title, textarea etc\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '&':\n                    t.advanceTransition(CharacterReferenceInRcdata);\n                    break;\n                case '<':\n                    t.advanceTransition(RcdataLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeToAny('&', '<', nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    CharacterReferenceInRcdata {\n        void read(Tokeniser t, CharacterReader r) {\n            char[] c = t.consumeCharacterReference(null, false);\n            if (c == null)\n                t.emit('&');\n            else\n                t.emit(c);\n            t.transition(Rcdata);\n        }\n    },\n    Rawtext {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '<':\n                    t.advanceTransition(RawtextLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeToAny('<', nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    ScriptData {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '<':\n                    t.advanceTransition(ScriptDataLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeToAny('<', nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    PLAINTEXT {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeTo(nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    TagOpen {\n        // from < in data\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '!':\n                    t.advanceTransition(MarkupDeclarationOpen);\n                    break;\n                case '/':\n                    t.advanceTransition(EndTagOpen);\n                    break;\n                case '?':\n                    t.advanceTransition(BogusComment);\n                    break;\n                default:\n                    if (r.matchesLetter()) {\n                        t.createTagPending(true);\n                        t.transition(TagName);\n                    } else {\n                        t.error(this);\n                        t.emit('<'); // char that got us here\n                        t.transition(Data);\n                    }\n                    break;\n            }\n        }\n    },\n    EndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.emit(\"</\");\n                t.transition(Data);\n            } else if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.transition(TagName);\n            } else if (r.matches('>')) {\n                t.error(this);\n                t.advanceTransition(Data);\n            } else {\n                t.error(this);\n                t.advanceTransition(BogusComment);\n            }\n        }\n    },\n    TagName {\n        // from < or </ in data, will have start or end tag pending\n        void read(Tokeniser t, CharacterReader r) {\n            // previous TagOpen state did NOT consume, will have a letter char in current\n            //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n            String tagName = r.consumeTagName().toLowerCase();\n            t.tagPending.appendTagName(tagName);\n\n            switch (r.consume()) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar: // replacement\n                    t.tagPending.appendTagName(replacementStr);\n                    break;\n                case eof: // should emit pending tag?\n                    t.eofError(this);\n                    t.transition(Data);\n                // no default, as covered with above consumeToAny\n            }\n        }\n    },\n    RcdataLessthanSign {\n        // from < in rcdata\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(RCDATAEndTagOpen);\n            } else if (r.matchesLetter() && t.appropriateEndTagName() != null && !r.containsIgnoreCase(\"</\" + t.appropriateEndTagName())) {\n                // diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than\n                // consuming to EOF; break out here\n                t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName());\n                t.emitTagPending();\n                r.unconsume(); // undo \"<\"\n                t.transition(Data);\n            } else {\n                t.emit(\"<\");\n                t.transition(Rcdata);\n            }\n        }\n    },\n    RCDATAEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.tagPending.appendTagName(Character.toLowerCase(r.current()));\n                t.dataBuffer.append(Character.toLowerCase(r.current()));\n                t.advanceTransition(RCDATAEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(Rcdata);\n            }\n        }\n    },\n    RCDATAEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name.toLowerCase());\n                t.dataBuffer.append(name);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    if (t.isAppropriateEndTagToken())\n                        t.transition(BeforeAttributeName);\n                    else\n                        anythingElse(t, r);\n                    break;\n                case '/':\n                    if (t.isAppropriateEndTagToken())\n                        t.transition(SelfClosingStartTag);\n                    else\n                        anythingElse(t, r);\n                    break;\n                case '>':\n                    if (t.isAppropriateEndTagToken()) {\n                        t.emitTagPending();\n                        t.transition(Data);\n                    }\n                    else\n                        anythingElse(t, r);\n                    break;\n                default:\n                    anythingElse(t, r);\n            }\n        }\n\n        private void anythingElse(Tokeniser t, CharacterReader r) {\n            t.emit(\"</\" + t.dataBuffer.toString());\n            r.unconsume();\n            t.transition(Rcdata);\n        }\n    },\n    RawtextLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(RawtextEndTagOpen);\n            } else {\n                t.emit('<');\n                t.transition(Rawtext);\n            }\n        }\n    },\n    RawtextEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.transition(RawtextEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(Rawtext);\n            }\n        }\n    },\n    RawtextEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataEndTag(t, r, Rawtext);\n        }\n    },\n    ScriptDataLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.consume()) {\n                case '/':\n                    t.createTempBuffer();\n                    t.transition(ScriptDataEndTagOpen);\n                    break;\n                case '!':\n                    t.emit(\"<!\");\n                    t.transition(ScriptDataEscapeStart);\n                    break;\n                default:\n                    t.emit(\"<\");\n                    r.unconsume();\n                    t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.transition(ScriptDataEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(ScriptData);\n            }\n\n        }\n    },\n    ScriptDataEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataEndTag(t, r, ScriptData);\n        }\n    },\n    ScriptDataEscapeStart {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('-')) {\n                t.emit('-');\n                t.advanceTransition(ScriptDataEscapeStartDash);\n            } else {\n                t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEscapeStartDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('-')) {\n                t.emit('-');\n                t.advanceTransition(ScriptDataEscapedDashDash);\n            } else {\n                t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEscaped {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            switch (r.current()) {\n                case '-':\n                    t.emit('-');\n                    t.advanceTransition(ScriptDataEscapedDash);\n                    break;\n                case '<':\n                    t.advanceTransition(ScriptDataEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                default:\n                    String data = r.consumeToAny('-', '<', nullChar);\n                    t.emit(data);\n            }\n        }\n    },\n    ScriptDataEscapedDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.transition(ScriptDataEscapedDashDash);\n                    break;\n                case '<':\n                    t.transition(ScriptDataEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataEscaped);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedDashDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    break;\n                case '<':\n                    t.transition(ScriptDataEscapedLessthanSign);\n                    break;\n                case '>':\n                    t.emit(c);\n                    t.transition(ScriptData);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataEscaped);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTempBuffer();\n                t.dataBuffer.append(Character.toLowerCase(r.current()));\n                t.emit(\"<\" + r.current());\n                t.advanceTransition(ScriptDataDoubleEscapeStart);\n            } else if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(ScriptDataEscapedEndTagOpen);\n            } else {\n                t.emit('<');\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.tagPending.appendTagName(Character.toLowerCase(r.current()));\n                t.dataBuffer.append(r.current());\n                t.advanceTransition(ScriptDataEscapedEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataEndTag(t, r, ScriptDataEscaped);\n        }\n    },\n    ScriptDataDoubleEscapeStart {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataDoubleEscapeTag(t, r, ScriptDataDoubleEscaped, ScriptDataEscaped);\n        }\n    },\n    ScriptDataDoubleEscaped {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.current();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.advanceTransition(ScriptDataDoubleEscapedDash);\n                    break;\n                case '<':\n                    t.emit(c);\n                    t.advanceTransition(ScriptDataDoubleEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    String data = r.consumeToAny('-', '<', nullChar);\n                    t.emit(data);\n            }\n        }\n    },\n    ScriptDataDoubleEscapedDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscapedDashDash);\n                    break;\n                case '<':\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataDoubleEscaped);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscaped);\n            }\n        }\n    },\n    ScriptDataDoubleEscapedDashDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    break;\n                case '<':\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscapedLessthanSign);\n                    break;\n                case '>':\n                    t.emit(c);\n                    t.transition(ScriptData);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataDoubleEscaped);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscaped);\n            }\n        }\n    },\n    ScriptDataDoubleEscapedLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.emit('/');\n                t.createTempBuffer();\n                t.advanceTransition(ScriptDataDoubleEscapeEnd);\n            } else {\n                t.transition(ScriptDataDoubleEscaped);\n            }\n        }\n    },\n    ScriptDataDoubleEscapeEnd {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataDoubleEscapeTag(t,r, ScriptDataEscaped, ScriptDataDoubleEscaped);\n        }\n    },\n    BeforeAttributeName {\n        // from tagname <xxx\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; // ignore whitespace\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: // A-Z, anything else\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n            }\n        }\n    },\n    AttributeName {\n        // from before attribute name\n        void read(Tokeniser t, CharacterReader r) {\n            String name = r.consumeToAnySorted(attributeNameCharsSorted);\n            t.tagPending.appendAttributeName(name.toLowerCase());\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(AfterAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '=':\n                    t.transition(BeforeAttributeValue);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeName(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                    t.error(this);\n                    t.tagPending.appendAttributeName(c);\n                // no default, as covered in consumeToAny\n            }\n        }\n    },\n    AfterAttributeName {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    // ignore\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '=':\n                    t.transition(BeforeAttributeValue);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeName(replacementChar);\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: // A-Z, anything else\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n            }\n        }\n    },\n    BeforeAttributeValue {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    // ignore\n                    break;\n                case '\"':\n                    t.transition(AttributeValue_doubleQuoted);\n                    break;\n                case '&':\n                    r.unconsume();\n                    t.transition(AttributeValue_unquoted);\n                    break;\n                case '\\'':\n                    t.transition(AttributeValue_singleQuoted);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    t.transition(AttributeValue_unquoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case '<':\n                case '=':\n                case '`':\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(c);\n                    t.transition(AttributeValue_unquoted);\n                    break;\n                default:\n                    r.unconsume();\n                    t.transition(AttributeValue_unquoted);\n            }\n        }\n    },\n    AttributeValue_doubleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            String value = r.consumeToAnySorted(attributeDoubleValueCharsSorted);\n            if (value.length() > 0)\n                t.tagPending.appendAttributeValue(value);\n\n            char c = r.consume();\n            switch (c) {\n                case '\"':\n                    t.transition(AfterAttributeValue_quoted);\n                    break;\n                case '&':\n                    char[] ref = t.consumeCharacterReference('\"', true);\n                    if (ref != null)\n                        t.tagPending.appendAttributeValue(ref);\n                    else\n                        t.tagPending.appendAttributeValue('&');\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                // no default, handled in consume to any above\n            }\n        }\n    },\n    AttributeValue_singleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            String value = r.consumeToAnySorted(attributeSingleValueCharsSorted);\n            if (value.length() > 0)\n                t.tagPending.appendAttributeValue(value);\n\n            char c = r.consume();\n            switch (c) {\n                case '\\'':\n                    t.transition(AfterAttributeValue_quoted);\n                    break;\n                case '&':\n                    char[] ref = t.consumeCharacterReference('\\'', true);\n                    if (ref != null)\n                        t.tagPending.appendAttributeValue(ref);\n                    else\n                        t.tagPending.appendAttributeValue('&');\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                // no default, handled in consume to any above\n            }\n        }\n    },\n    AttributeValue_unquoted {\n        void read(Tokeniser t, CharacterReader r) {\n            String value = r.consumeToAny('\\t', '\\n', '\\r', '\\f', ' ', '&', '>', nullChar, '\"', '\\'', '<', '=', '`');\n            if (value.length() > 0)\n                t.tagPending.appendAttributeValue(value);\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '&':\n                    char[] ref = t.consumeCharacterReference('>', true);\n                    if (ref != null)\n                        t.tagPending.appendAttributeValue(ref);\n                    else\n                        t.tagPending.appendAttributeValue('&');\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                case '`':\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(c);\n                    break;\n                // no default, handled in consume to any above\n            }\n\n        }\n    },\n    // CharacterReferenceInAttributeValue state handled inline\n    AfterAttributeValue_quoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    r.unconsume();\n                    t.transition(BeforeAttributeName);\n            }\n\n        }\n    },\n    SelfClosingStartTag {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.tagPending.selfClosing = true;\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.transition(BeforeAttributeName);\n            }\n        }\n    },\n    BogusComment {\n        void read(Tokeniser t, CharacterReader r) {\n            // todo: handle bogus comment starting from eof. when does that trigger?\n            // rewind to capture character that lead us here\n            r.unconsume();\n            Token.Comment comment = new Token.Comment();\n            comment.bogus = true;\n            comment.data.append(r.consumeTo('>'));\n            // todo: replace nullChar with replaceChar\n            t.emit(comment);\n            t.advanceTransition(Data);\n        }\n    },\n    MarkupDeclarationOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchConsume(\"--\")) {\n                t.createCommentPending();\n                t.transition(CommentStart);\n            } else if (r.matchConsumeIgnoreCase(\"DOCTYPE\")) {\n                t.transition(Doctype);\n            } else if (r.matchConsume(\"[CDATA[\")) {\n                // todo: should actually check current namepspace, and only non-html allows cdata. until namespace\n                // is implemented properly, keep handling as cdata\n                //} else if (!t.currentNodeInHtmlNS() && r.matchConsume(\"[CDATA[\")) {\n                t.transition(CdataSection);\n            } else {\n                t.error(this);\n                t.advanceTransition(BogusComment); // advance so this character gets in bogus comment data's rewind\n            }\n        }\n    },\n    CommentStart {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.transition(CommentStartDash);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    CommentStartDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.transition(CommentStartDash);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    Comment {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.current();\n            switch (c) {\n                case '-':\n                    t.advanceTransition(CommentEndDash);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.commentPending.data.append(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(r.consumeToAny('-', nullChar));\n            }\n        }\n    },\n    CommentEndDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.transition(CommentEnd);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append('-').append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append('-').append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    CommentEnd {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(\"--\").append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case '!':\n                    t.error(this);\n                    t.transition(CommentEndBang);\n                    break;\n                case '-':\n                    t.error(this);\n                    t.commentPending.data.append('-');\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.commentPending.data.append(\"--\").append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    CommentEndBang {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.commentPending.data.append(\"--!\");\n                    t.transition(CommentEndDash);\n                    break;\n                case '>':\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(\"--!\").append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(\"--!\").append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    Doctype {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeDoctypeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    // note: fall through to > case\n                case '>': // catch invalid <!DOCTYPE>\n                    t.error(this);\n                    t.createDoctypePending();\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.transition(BeforeDoctypeName);\n            }\n        }\n    },\n    BeforeDoctypeName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createDoctypePending();\n                t.transition(DoctypeName);\n                return;\n            }\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; // ignore whitespace\n                case nullChar:\n                    t.error(this);\n                    t.createDoctypePending();\n                    t.doctypePending.name.append(replacementChar);\n                    t.transition(DoctypeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.createDoctypePending();\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.createDoctypePending();\n                    t.doctypePending.name.append(c);\n                    t.transition(DoctypeName);\n            }\n        }\n    },\n    DoctypeName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.doctypePending.name.append(name.toLowerCase());\n                return;\n            }\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(AfterDoctypeName);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.name.append(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.name.append(c);\n            }\n        }\n    },\n    AfterDoctypeName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.doctypePending.forceQuirks = true;\n                t.emitDoctypePending();\n                t.transition(Data);\n                return;\n            }\n            if (r.matchesAny('\\t', '\\n', '\\r', '\\f', ' '))\n                r.advance(); // ignore whitespace\n            else if (r.matches('>')) {\n                t.emitDoctypePending();\n                t.advanceTransition(Data);\n            } else if (r.matchConsumeIgnoreCase(\"PUBLIC\")) {\n                t.transition(AfterDoctypePublicKeyword);\n            } else if (r.matchConsumeIgnoreCase(\"SYSTEM\")) {\n                t.transition(AfterDoctypeSystemKeyword);\n            } else {\n                t.error(this);\n                t.doctypePending.forceQuirks = true;\n                t.advanceTransition(BogusDoctype);\n            }\n\n        }\n    },\n    AfterDoctypePublicKeyword {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeDoctypePublicIdentifier);\n                    break;\n                case '\"':\n                    t.error(this);\n                    // set public id to empty string\n                    t.transition(DoctypePublicIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    // set public id to empty string\n                    t.transition(DoctypePublicIdentifier_singleQuoted);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    BeforeDoctypePublicIdentifier {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '\"':\n                    // set public id to empty string\n                    t.transition(DoctypePublicIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    // set public id to empty string\n                    t.transition(DoctypePublicIdentifier_singleQuoted);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    DoctypePublicIdentifier_doubleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\"':\n                    t.transition(AfterDoctypePublicIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.publicIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.publicIdentifier.append(c);\n            }\n        }\n    },\n    DoctypePublicIdentifier_singleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\'':\n                    t.transition(AfterDoctypePublicIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.publicIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.publicIdentifier.append(c);\n            }\n        }\n    },\n    AfterDoctypePublicIdentifier {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BetweenDoctypePublicAndSystemIdentifiers);\n                    break;\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\"':\n                    t.error(this);\n                    // system id empty\n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    // system id empty\n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    BetweenDoctypePublicAndSystemIdentifiers {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\"':\n                    t.error(this);\n                    // system id empty\n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    // system id empty\n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    AfterDoctypeSystemKeyword {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeDoctypeSystemIdentifier);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\"':\n                    t.error(this);\n                    // system id empty\n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    // system id empty\n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n            }\n        }\n    },\n    BeforeDoctypeSystemIdentifier {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '\"':\n                    // set system id to empty string\n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    // set public id to empty string\n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    DoctypeSystemIdentifier_doubleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\"':\n                    t.transition(AfterDoctypeSystemIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.systemIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.systemIdentifier.append(c);\n            }\n        }\n    },\n    DoctypeSystemIdentifier_singleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\'':\n                    t.transition(AfterDoctypeSystemIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.systemIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.systemIdentifier.append(c);\n            }\n        }\n    },\n    AfterDoctypeSystemIdentifier {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.transition(BogusDoctype);\n                    // NOT force quirks\n            }\n        }\n    },\n    BogusDoctype {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    // ignore char\n                    break;\n            }\n        }\n    },\n    CdataSection {\n        void read(Tokeniser t, CharacterReader r) {\n            String data = r.consumeTo(\"]]>\");\n            t.emit(data);\n            r.matchConsume(\"]]>\");\n            t.transition(Data);\n        }\n    };\n\n\n    abstract void read(Tokeniser t, CharacterReader r);\n\n    static final char nullChar = '\\u0000';\n    private static final char[] attributeSingleValueCharsSorted = new char[]{'\\'', '&', nullChar};\n    private static final char[] attributeDoubleValueCharsSorted = new char[]{'\"', '&', nullChar};\n    private static final char[] attributeNameCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '/', '=', '>', nullChar, '\"', '\\'', '<'};\n\n    private static final char replacementChar = Tokeniser.replacementChar;\n    private static final String replacementStr = String.valueOf(Tokeniser.replacementChar);\n    private static final char eof = CharacterReader.EOF;\n\n    static {\n        Arrays.sort(attributeSingleValueCharsSorted);\n        Arrays.sort(attributeDoubleValueCharsSorted);\n        Arrays.sort(attributeNameCharsSorted);\n    }\n\n    /**\n     * Handles RawtextEndTagName, ScriptDataEndTagName, and ScriptDataEscapedEndTagName. Same body impl, just\n     * different else exit transitions.\n     */\n    private static void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition) {\n        if (r.matchesLetter()) {\n            String name = r.consumeLetterSequence();\n            t.tagPending.appendTagName(name.toLowerCase());\n            t.dataBuffer.append(name);\n            return;\n        }\n\n        boolean needsExitTransition = false;\n        if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.dataBuffer.append(c);\n                    needsExitTransition = true;\n            }\n        } else {\n            needsExitTransition = true;\n        }\n\n        if (needsExitTransition) {\n            t.emit(\"</\" + t.dataBuffer.toString());\n            t.transition(elseTransition);\n        }\n    }\n\n    private static void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback) {\n        if (r.matchesLetter()) {\n            String name = r.consumeLetterSequence();\n            t.dataBuffer.append(name.toLowerCase());\n            t.emit(name);\n            return;\n        }\n\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\r':\n            case '\\f':\n            case ' ':\n            case '/':\n            case '>':\n                if (t.dataBuffer.toString().equals(\"script\"))\n                    t.transition(primary);\n                else\n                    t.transition(fallback);\n                t.emit(c);\n                break;\n            default:\n                r.unconsume();\n                t.transition(fallback);\n        }\n    }\n}\n",
        "human_patch_code": "package org.jsoup.parser;\n\nimport java.util.Arrays;\n\n/**\n * States and transition activations for the Tokeniser.\n */\nenum TokeniserState {\n    Data {\n        // in data state, gather characters until a character reference or tag is found\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '&':\n                    t.advanceTransition(CharacterReferenceInData);\n                    break;\n                case '<':\n                    t.advanceTransition(TagOpen);\n                    break;\n                case nullChar:\n                    t.error(this); // NOT replacement character (oddly?)\n                    t.emit(r.consume());\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeData();\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    CharacterReferenceInData {\n        // from & in data\n        void read(Tokeniser t, CharacterReader r) {\n            char[] c = t.consumeCharacterReference(null, false);\n            if (c == null)\n                t.emit('&');\n            else\n                t.emit(c);\n            t.transition(Data);\n        }\n    },\n    Rcdata {\n        /// handles data in title, textarea etc\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '&':\n                    t.advanceTransition(CharacterReferenceInRcdata);\n                    break;\n                case '<':\n                    t.advanceTransition(RcdataLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeToAny('&', '<', nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    CharacterReferenceInRcdata {\n        void read(Tokeniser t, CharacterReader r) {\n            char[] c = t.consumeCharacterReference(null, false);\n            if (c == null)\n                t.emit('&');\n            else\n                t.emit(c);\n            t.transition(Rcdata);\n        }\n    },\n    Rawtext {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '<':\n                    t.advanceTransition(RawtextLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeToAny('<', nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    ScriptData {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '<':\n                    t.advanceTransition(ScriptDataLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeToAny('<', nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    PLAINTEXT {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeTo(nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    TagOpen {\n        // from < in data\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '!':\n                    t.advanceTransition(MarkupDeclarationOpen);\n                    break;\n                case '/':\n                    t.advanceTransition(EndTagOpen);\n                    break;\n                case '?':\n                    t.advanceTransition(BogusComment);\n                    break;\n                default:\n                    if (r.matchesLetter()) {\n                        t.createTagPending(true);\n                        t.transition(TagName);\n                    } else {\n                        t.error(this);\n                        t.emit('<'); // char that got us here\n                        t.transition(Data);\n                    }\n                    break;\n            }\n        }\n    },\n    EndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.emit(\"</\");\n                t.transition(Data);\n            } else if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.transition(TagName);\n            } else if (r.matches('>')) {\n                t.error(this);\n                t.advanceTransition(Data);\n            } else {\n                t.error(this);\n                t.advanceTransition(BogusComment);\n            }\n        }\n    },\n    TagName {\n        // from < or </ in data, will have start or end tag pending\n        void read(Tokeniser t, CharacterReader r) {\n            // previous TagOpen state did NOT consume, will have a letter char in current\n            //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n            String tagName = r.consumeTagName().toLowerCase();\n            t.tagPending.appendTagName(tagName);\n\n            switch (r.consume()) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar: // replacement\n                    t.tagPending.appendTagName(replacementStr);\n                    break;\n                case eof: // should emit pending tag?\n                    t.eofError(this);\n                    t.transition(Data);\n                // no default, as covered with above consumeToAny\n            }\n        }\n    },\n    RcdataLessthanSign {\n        // from < in rcdata\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(RCDATAEndTagOpen);\n            } else if (r.matchesLetter() && t.appropriateEndTagName() != null && !r.containsIgnoreCase(\"</\" + t.appropriateEndTagName())) {\n                // diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than\n                // consuming to EOF; break out here\n                t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName());\n                t.emitTagPending();\n                r.unconsume(); // undo \"<\"\n                t.transition(Data);\n            } else {\n                t.emit(\"<\");\n                t.transition(Rcdata);\n            }\n        }\n    },\n    RCDATAEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.tagPending.appendTagName(Character.toLowerCase(r.current()));\n                t.dataBuffer.append(Character.toLowerCase(r.current()));\n                t.advanceTransition(RCDATAEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(Rcdata);\n            }\n        }\n    },\n    RCDATAEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name.toLowerCase());\n                t.dataBuffer.append(name);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    if (t.isAppropriateEndTagToken())\n                        t.transition(BeforeAttributeName);\n                    else\n                        anythingElse(t, r);\n                    break;\n                case '/':\n                    if (t.isAppropriateEndTagToken())\n                        t.transition(SelfClosingStartTag);\n                    else\n                        anythingElse(t, r);\n                    break;\n                case '>':\n                    if (t.isAppropriateEndTagToken()) {\n                        t.emitTagPending();\n                        t.transition(Data);\n                    }\n                    else\n                        anythingElse(t, r);\n                    break;\n                default:\n                    anythingElse(t, r);\n            }\n        }\n\n        private void anythingElse(Tokeniser t, CharacterReader r) {\n            t.emit(\"</\" + t.dataBuffer.toString());\n            r.unconsume();\n            t.transition(Rcdata);\n        }\n    },\n    RawtextLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(RawtextEndTagOpen);\n            } else {\n                t.emit('<');\n                t.transition(Rawtext);\n            }\n        }\n    },\n    RawtextEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.transition(RawtextEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(Rawtext);\n            }\n        }\n    },\n    RawtextEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataEndTag(t, r, Rawtext);\n        }\n    },\n    ScriptDataLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.consume()) {\n                case '/':\n                    t.createTempBuffer();\n                    t.transition(ScriptDataEndTagOpen);\n                    break;\n                case '!':\n                    t.emit(\"<!\");\n                    t.transition(ScriptDataEscapeStart);\n                    break;\n                default:\n                    t.emit(\"<\");\n                    r.unconsume();\n                    t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.transition(ScriptDataEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(ScriptData);\n            }\n\n        }\n    },\n    ScriptDataEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataEndTag(t, r, ScriptData);\n        }\n    },\n    ScriptDataEscapeStart {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('-')) {\n                t.emit('-');\n                t.advanceTransition(ScriptDataEscapeStartDash);\n            } else {\n                t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEscapeStartDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('-')) {\n                t.emit('-');\n                t.advanceTransition(ScriptDataEscapedDashDash);\n            } else {\n                t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEscaped {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            switch (r.current()) {\n                case '-':\n                    t.emit('-');\n                    t.advanceTransition(ScriptDataEscapedDash);\n                    break;\n                case '<':\n                    t.advanceTransition(ScriptDataEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                default:\n                    String data = r.consumeToAny('-', '<', nullChar);\n                    t.emit(data);\n            }\n        }\n    },\n    ScriptDataEscapedDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.transition(ScriptDataEscapedDashDash);\n                    break;\n                case '<':\n                    t.transition(ScriptDataEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataEscaped);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedDashDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    break;\n                case '<':\n                    t.transition(ScriptDataEscapedLessthanSign);\n                    break;\n                case '>':\n                    t.emit(c);\n                    t.transition(ScriptData);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataEscaped);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTempBuffer();\n                t.dataBuffer.append(Character.toLowerCase(r.current()));\n                t.emit(\"<\" + r.current());\n                t.advanceTransition(ScriptDataDoubleEscapeStart);\n            } else if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(ScriptDataEscapedEndTagOpen);\n            } else {\n                t.emit('<');\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.tagPending.appendTagName(Character.toLowerCase(r.current()));\n                t.dataBuffer.append(r.current());\n                t.advanceTransition(ScriptDataEscapedEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataEndTag(t, r, ScriptDataEscaped);\n        }\n    },\n    ScriptDataDoubleEscapeStart {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataDoubleEscapeTag(t, r, ScriptDataDoubleEscaped, ScriptDataEscaped);\n        }\n    },\n    ScriptDataDoubleEscaped {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.current();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.advanceTransition(ScriptDataDoubleEscapedDash);\n                    break;\n                case '<':\n                    t.emit(c);\n                    t.advanceTransition(ScriptDataDoubleEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    String data = r.consumeToAny('-', '<', nullChar);\n                    t.emit(data);\n            }\n        }\n    },\n    ScriptDataDoubleEscapedDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscapedDashDash);\n                    break;\n                case '<':\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataDoubleEscaped);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscaped);\n            }\n        }\n    },\n    ScriptDataDoubleEscapedDashDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    break;\n                case '<':\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscapedLessthanSign);\n                    break;\n                case '>':\n                    t.emit(c);\n                    t.transition(ScriptData);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataDoubleEscaped);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscaped);\n            }\n        }\n    },\n    ScriptDataDoubleEscapedLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.emit('/');\n                t.createTempBuffer();\n                t.advanceTransition(ScriptDataDoubleEscapeEnd);\n            } else {\n                t.transition(ScriptDataDoubleEscaped);\n            }\n        }\n    },\n    ScriptDataDoubleEscapeEnd {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataDoubleEscapeTag(t,r, ScriptDataEscaped, ScriptDataDoubleEscaped);\n        }\n    },\n    BeforeAttributeName {\n        // from tagname <xxx\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; // ignore whitespace\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: // A-Z, anything else\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n            }\n        }\n    },\n    AttributeName {\n        // from before attribute name\n        void read(Tokeniser t, CharacterReader r) {\n            String name = r.consumeToAnySorted(attributeNameCharsSorted);\n            t.tagPending.appendAttributeName(name.toLowerCase());\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(AfterAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '=':\n                    t.transition(BeforeAttributeValue);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeName(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                    t.error(this);\n                    t.tagPending.appendAttributeName(c);\n                // no default, as covered in consumeToAny\n            }\n        }\n    },\n    AfterAttributeName {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    // ignore\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '=':\n                    t.transition(BeforeAttributeValue);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeName(replacementChar);\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: // A-Z, anything else\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n            }\n        }\n    },\n    BeforeAttributeValue {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    // ignore\n                    break;\n                case '\"':\n                    t.transition(AttributeValue_doubleQuoted);\n                    break;\n                case '&':\n                    r.unconsume();\n                    t.transition(AttributeValue_unquoted);\n                    break;\n                case '\\'':\n                    t.transition(AttributeValue_singleQuoted);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    t.transition(AttributeValue_unquoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case '<':\n                case '=':\n                case '`':\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(c);\n                    t.transition(AttributeValue_unquoted);\n                    break;\n                default:\n                    r.unconsume();\n                    t.transition(AttributeValue_unquoted);\n            }\n        }\n    },\n    AttributeValue_doubleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            String value = r.consumeToAnySorted(attributeDoubleValueCharsSorted);\n            if (value.length() > 0)\n                t.tagPending.appendAttributeValue(value);\n\n            char c = r.consume();\n            switch (c) {\n                case '\"':\n                    t.transition(AfterAttributeValue_quoted);\n                    break;\n                case '&':\n                    char[] ref = t.consumeCharacterReference('\"', true);\n                    if (ref != null)\n                        t.tagPending.appendAttributeValue(ref);\n                    else\n                        t.tagPending.appendAttributeValue('&');\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                // no default, handled in consume to any above\n            }\n        }\n    },\n    AttributeValue_singleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            String value = r.consumeToAnySorted(attributeSingleValueCharsSorted);\n            if (value.length() > 0)\n                t.tagPending.appendAttributeValue(value);\n\n            char c = r.consume();\n            switch (c) {\n                case '\\'':\n                    t.transition(AfterAttributeValue_quoted);\n                    break;\n                case '&':\n                    char[] ref = t.consumeCharacterReference('\\'', true);\n                    if (ref != null)\n                        t.tagPending.appendAttributeValue(ref);\n                    else\n                        t.tagPending.appendAttributeValue('&');\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                // no default, handled in consume to any above\n            }\n        }\n    },\n    AttributeValue_unquoted {\n        void read(Tokeniser t, CharacterReader r) {\n            String value = r.consumeToAny('\\t', '\\n', '\\r', '\\f', ' ', '&', '>', nullChar, '\"', '\\'', '<', '=', '`');\n            if (value.length() > 0)\n                t.tagPending.appendAttributeValue(value);\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '&':\n                    char[] ref = t.consumeCharacterReference('>', true);\n                    if (ref != null)\n                        t.tagPending.appendAttributeValue(ref);\n                    else\n                        t.tagPending.appendAttributeValue('&');\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                case '`':\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(c);\n                    break;\n                // no default, handled in consume to any above\n            }\n\n        }\n    },\n    // CharacterReferenceInAttributeValue state handled inline\n    AfterAttributeValue_quoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    r.unconsume();\n                    t.transition(BeforeAttributeName);\n            }\n\n        }\n    },\n    SelfClosingStartTag {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.tagPending.selfClosing = true;\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.transition(BeforeAttributeName);\n            }\n        }\n    },\n    BogusComment {\n        void read(Tokeniser t, CharacterReader r) {\n            // todo: handle bogus comment starting from eof. when does that trigger?\n            // rewind to capture character that lead us here\n            r.unconsume();\n            Token.Comment comment = new Token.Comment();\n            comment.bogus = true;\n            comment.data.append(r.consumeTo('>'));\n            // todo: replace nullChar with replaceChar\n            t.emit(comment);\n            t.advanceTransition(Data);\n        }\n    },\n    MarkupDeclarationOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchConsume(\"--\")) {\n                t.createCommentPending();\n                t.transition(CommentStart);\n            } else if (r.matchConsumeIgnoreCase(\"DOCTYPE\")) {\n                t.transition(Doctype);\n            } else if (r.matchConsume(\"[CDATA[\")) {\n                // todo: should actually check current namepspace, and only non-html allows cdata. until namespace\n                // is implemented properly, keep handling as cdata\n                //} else if (!t.currentNodeInHtmlNS() && r.matchConsume(\"[CDATA[\")) {\n                t.transition(CdataSection);\n            } else {\n                t.error(this);\n                t.advanceTransition(BogusComment); // advance so this character gets in bogus comment data's rewind\n            }\n        }\n    },\n    CommentStart {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.transition(CommentStartDash);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    CommentStartDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.transition(CommentStartDash);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    Comment {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.current();\n            switch (c) {\n                case '-':\n                    t.advanceTransition(CommentEndDash);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.commentPending.data.append(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(r.consumeToAny('-', nullChar));\n            }\n        }\n    },\n    CommentEndDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.transition(CommentEnd);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append('-').append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append('-').append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    CommentEnd {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(\"--\").append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case '!':\n                    t.error(this);\n                    t.transition(CommentEndBang);\n                    break;\n                case '-':\n                    t.error(this);\n                    t.commentPending.data.append('-');\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.commentPending.data.append(\"--\").append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    CommentEndBang {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.commentPending.data.append(\"--!\");\n                    t.transition(CommentEndDash);\n                    break;\n                case '>':\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(\"--!\").append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(\"--!\").append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    Doctype {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeDoctypeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    // note: fall through to > case\n                case '>': // catch invalid <!DOCTYPE>\n                    t.error(this);\n                    t.createDoctypePending();\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.transition(BeforeDoctypeName);\n            }\n        }\n    },\n    BeforeDoctypeName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createDoctypePending();\n                t.transition(DoctypeName);\n                return;\n            }\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; // ignore whitespace\n                case nullChar:\n                    t.error(this);\n                    t.createDoctypePending();\n                    t.doctypePending.name.append(replacementChar);\n                    t.transition(DoctypeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.createDoctypePending();\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.createDoctypePending();\n                    t.doctypePending.name.append(c);\n                    t.transition(DoctypeName);\n            }\n        }\n    },\n    DoctypeName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.doctypePending.name.append(name.toLowerCase());\n                return;\n            }\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(AfterDoctypeName);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.name.append(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.name.append(c);\n            }\n        }\n    },\n    AfterDoctypeName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.doctypePending.forceQuirks = true;\n                t.emitDoctypePending();\n                t.transition(Data);\n                return;\n            }\n            if (r.matchesAny('\\t', '\\n', '\\r', '\\f', ' '))\n                r.advance(); // ignore whitespace\n            else if (r.matches('>')) {\n                t.emitDoctypePending();\n                t.advanceTransition(Data);\n            } else if (r.matchConsumeIgnoreCase(\"PUBLIC\")) {\n                t.transition(AfterDoctypePublicKeyword);\n            } else if (r.matchConsumeIgnoreCase(\"SYSTEM\")) {\n                t.transition(AfterDoctypeSystemKeyword);\n            } else {\n                t.error(this);\n                t.doctypePending.forceQuirks = true;\n                t.advanceTransition(BogusDoctype);\n            }\n\n        }\n    },\n    AfterDoctypePublicKeyword {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeDoctypePublicIdentifier);\n                    break;\n                case '\"':\n                    t.error(this);\n                    // set public id to empty string\n                    t.transition(DoctypePublicIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    // set public id to empty string\n                    t.transition(DoctypePublicIdentifier_singleQuoted);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    BeforeDoctypePublicIdentifier {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '\"':\n                    // set public id to empty string\n                    t.transition(DoctypePublicIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    // set public id to empty string\n                    t.transition(DoctypePublicIdentifier_singleQuoted);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    DoctypePublicIdentifier_doubleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\"':\n                    t.transition(AfterDoctypePublicIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.publicIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.publicIdentifier.append(c);\n            }\n        }\n    },\n    DoctypePublicIdentifier_singleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\'':\n                    t.transition(AfterDoctypePublicIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.publicIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.publicIdentifier.append(c);\n            }\n        }\n    },\n    AfterDoctypePublicIdentifier {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BetweenDoctypePublicAndSystemIdentifiers);\n                    break;\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\"':\n                    t.error(this);\n                    // system id empty\n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    // system id empty\n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    BetweenDoctypePublicAndSystemIdentifiers {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\"':\n                    t.error(this);\n                    // system id empty\n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    // system id empty\n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    AfterDoctypeSystemKeyword {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeDoctypeSystemIdentifier);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\"':\n                    t.error(this);\n                    // system id empty\n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    // system id empty\n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n            }\n        }\n    },\n    BeforeDoctypeSystemIdentifier {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '\"':\n                    // set system id to empty string\n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    // set public id to empty string\n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    DoctypeSystemIdentifier_doubleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\"':\n                    t.transition(AfterDoctypeSystemIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.systemIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.systemIdentifier.append(c);\n            }\n        }\n    },\n    DoctypeSystemIdentifier_singleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\'':\n                    t.transition(AfterDoctypeSystemIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.systemIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.systemIdentifier.append(c);\n            }\n        }\n    },\n    AfterDoctypeSystemIdentifier {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.transition(BogusDoctype);\n                    // NOT force quirks\n            }\n        }\n    },\n    BogusDoctype {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    // ignore char\n                    break;\n            }\n        }\n    },\n    CdataSection {\n        void read(Tokeniser t, CharacterReader r) {\n            String data = r.consumeTo(\"]]>\");\n            t.emit(data);\n            r.matchConsume(\"]]>\");\n            t.transition(Data);\n        }\n    };\n\n\n    abstract void read(Tokeniser t, CharacterReader r);\n\n    static final char nullChar = '\\u0000';\n    private static final char[] attributeSingleValueCharsSorted = new char[]{'\\'', '&', nullChar};\n    private static final char[] attributeDoubleValueCharsSorted = new char[]{'\"', '&', nullChar};\n    private static final char[] attributeNameCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '/', '=', '>', nullChar, '\"', '\\'', '<'};\n\n    private static final char replacementChar = Tokeniser.replacementChar;\n    private static final String replacementStr = String.valueOf(Tokeniser.replacementChar);\n    private static final char eof = CharacterReader.EOF;\n\n    static {\n        Arrays.sort(attributeSingleValueCharsSorted);\n        Arrays.sort(attributeDoubleValueCharsSorted);\n        Arrays.sort(attributeNameCharsSorted);\n    }\n\n    /**\n     * Handles RawtextEndTagName, ScriptDataEndTagName, and ScriptDataEscapedEndTagName. Same body impl, just\n     * different else exit transitions.\n     */\n    private static void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition) {\n        if (r.matchesLetter()) {\n            String name = r.consumeLetterSequence();\n            t.tagPending.appendTagName(name.toLowerCase());\n            t.dataBuffer.append(name);\n            return;\n        }\n\n        boolean needsExitTransition = false;\n        if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.dataBuffer.append(c);\n                    needsExitTransition = true;\n            }\n        } else {\n            needsExitTransition = true;\n        }\n\n        if (needsExitTransition) {\n            t.emit(\"</\" + t.dataBuffer.toString());\n            t.transition(elseTransition);\n        }\n    }\n\n    private static void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback) {\n        if (r.matchesLetter()) {\n            String name = r.consumeLetterSequence();\n            t.dataBuffer.append(name.toLowerCase());\n            t.emit(name);\n            return;\n        }\n\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\r':\n            case '\\f':\n            case ' ':\n            case '/':\n            case '>':\n                if (t.dataBuffer.toString().equals(\"script\"))\n                    t.transition(primary);\n                else\n                    t.transition(fallback);\n                t.emit(c);\n                break;\n            default:\n                r.unconsume();\n                t.transition(fallback);\n        }\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-60": {
    "vul_id": "VUL4J-60",
    "cve_id": "CVE-2016-10006",
    "project": "nahsra_antisamy",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=org.owasp.validator.html.test.AntiSamyTest#testIssue2",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/nahsra/antisamy/commit/7313931dc3c0d1377b010f07faef2063dd359a36",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/org/owasp/validator/html/scan/MagicSAXFilter.java",
        "file_name": "MagicSAXFilter.java",
        "vulnerable_code": "/*\n * Copyright (c) 2007-2011, Arshan Dabirsiaghi, Jason Li\n * \n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n * \n * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n * Neither the name of OWASP nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.owasp.validator.html.scan;\n\nimport java.util.*;\nimport java.util.regex.Pattern;\n\nimport org.apache.xerces.util.AugmentationsImpl;\nimport org.apache.xerces.util.XMLAttributesImpl;\nimport org.apache.xerces.util.XMLStringBuffer;\nimport org.apache.xerces.xni.Augmentations;\nimport org.apache.xerces.xni.QName;\nimport org.apache.xerces.xni.XMLAttributes;\nimport org.apache.xerces.xni.XMLString;\nimport org.apache.xerces.xni.XNIException;\nimport org.apache.xerces.xni.parser.XMLDocumentFilter;\nimport org.cyberneko.html.filters.DefaultFilter;\nimport org.owasp.validator.css.CssScanner;\nimport org.owasp.validator.css.ExternalCssScanner;\nimport org.owasp.validator.html.CleanResults;\nimport org.owasp.validator.html.InternalPolicy;\nimport org.owasp.validator.html.Policy;\nimport org.owasp.validator.html.ScanException;\nimport org.owasp.validator.html.model.Attribute;\nimport org.owasp.validator.html.model.Tag;\nimport org.owasp.validator.html.util.ErrorMessageUtil;\nimport org.owasp.validator.html.util.HTMLEntityEncoder;\n\n/**\n * Implementation of an HTML-filter that adheres to an AntiSamy policy. This\n * filter is SAX-based which means it is much more memory-efficient and also a\n * bit faster than the DOM-based implementation.\n */\npublic class MagicSAXFilter extends DefaultFilter implements XMLDocumentFilter {\n\n    private static enum Ops {\n        CSS, FILTER, REMOVE, TRUNCATE, KEEP\n    }\n\tprivate final Stack<Ops> operations = new Stack<Ops>();\n\tprivate List<String> errorMessages = new ArrayList<String>();\n\tprivate StringBuffer cssContent = null;\n\tprivate XMLAttributes cssAttributes = null;\n\tprivate CssScanner cssScanner = null;\n\tprivate InternalPolicy policy;\n\tprivate ResourceBundle messages;\n\n\tprivate boolean isNofollowAnchors;\n\tprivate boolean isValidateParamAsEmbed;\n\tprivate boolean inCdata = false;\n    // From policy\n    private boolean preserveComments;\n    private int maxInputSize;\n    private boolean externalCssScanner;\n\n    public MagicSAXFilter(ResourceBundle messages) {\n\t\tthis.messages = messages;\n    }\n\n    public void reset(InternalPolicy instance){\n        this.policy = instance;\n        isNofollowAnchors = policy.isNofollowAnchors();\n        isValidateParamAsEmbed = policy.isValidateParamAsEmbed();\n        preserveComments = policy.isPreserveComments();\n        maxInputSize = policy.getMaxInputSize();\n        externalCssScanner = policy.isEmbedStyleSheets();\n        operations.clear();\n        errorMessages.clear();\n        cssContent = null;\n        cssAttributes = null;\n        cssScanner = null;\n        inCdata = false;\n\n    }\n\n\tpublic void characters(XMLString text, Augmentations augs) throws XNIException {\n        //noinspection StatementWithEmptyBody\n        Ops topOp = peekTop();\n        //noinspection StatementWithEmptyBody\n        if (topOp ==  Ops.REMOVE) {\n\t\t\t// content is removed altogether\n\t\t} else if (topOp == Ops.CSS) {\n\t\t\t// we record the style element's text content\n\t\t\t// to filter it later\n\t\t\tcssContent.append(text.ch, text.offset, text.length);\n\t\t} else {\n\t\t\t// pass through all character content.\n\t\t\tif ( inCdata ) {\n\t\t\t\tString encoded = HTMLEntityEncoder.htmlEntityEncode(text.toString());\n                addError(ErrorMessageUtil.ERROR_CDATA_FOUND, new Object[]{encoded});\n\t\t\t}\n\t\t\tsuper.characters(text, augs);\n\t\t}\n\t}\n\n    private static final Pattern conditionalDirectives =\n            Pattern.compile(\"<?!?\\\\[\\\\s*(?:end)?if[^]]*\\\\]>?\");\n\n    public void comment(XMLString text, Augmentations augs) throws XNIException {\n\n\t\tif (preserveComments) {\n\t\t\tString value = text.toString();\n\t\t\t// Strip conditional directives regardless of the\n\t\t\t// PRESERVE_COMMENTS setting.\n\t\t\tif (value != null) {\n                value = conditionalDirectives.matcher(value).replaceAll(\"\");\n\t\t\t\tsuper.comment(new XMLString(value.toCharArray(), 0, value.length()), augs);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void doctypeDecl(String root, String publicId, String systemId, Augmentations augs) throws XNIException {\n\t\t// user supplied doctypes are ignored\n\t}\n\n\tpublic void emptyElement(QName element, XMLAttributes attributes, Augmentations augs) throws XNIException {\n\t\tthis.startElement(element, attributes, augs);\n\t\tthis.endElement(element, augs);\n\t}\n\n    private Ops peekTop(){\n         return operations.empty() ? null : operations.peek();\n    }\n\n\tpublic void endElement(QName element, Augmentations augs) throws XNIException {\n        Ops topOp = peekTop();\n        if (Ops.REMOVE == topOp) {\n\t\t\t// content is removed altogether\n\t\t\toperations.pop();\n\t\t} else if (Ops.FILTER == topOp) {\n\t\t\t// content is removed, but child nodes not\n\t\t\toperations.pop();\n\t\t} else if (Ops.CSS == topOp) {\n\t\t\toperations.pop();\n\t\t\t// now scan the CSS.\n\t\t\tCssScanner cssScanner = makeCssScanner();\n\t\t\ttry {\n\t\t\t\tCleanResults results = cssScanner.scanStyleSheet(cssContent.toString(), maxInputSize);\n\t\t\t\t// report all errors found\n\t\t\t\terrorMessages.addAll(results.getErrorMessages());\n\t\t\t\t/*\n\t\t\t\t * If IE gets an empty style tag, i.e. <style/> it will break\n\t\t\t\t * all CSS on the page. I wish I was kidding. So, if after\n\t\t\t\t * validation no CSS properties are left, we would normally be\n\t\t\t\t * left with an empty style tag and break all CSS. To prevent\n\t\t\t\t * that, we have this check.\n\t\t\t\t */\n                //noinspection StatementWithEmptyBody\n                if (results.getCleanHTML() == null || results.getCleanHTML().equals(\"\")) {\n\t\t\t\t\t// we do not generate empty style elements\n\t\t\t\t} else {\n\t\t\t\t\t// XMLAttributes attributes = new XMLAttributesImpl();\n\t\t\t\t\t// attributes.addAttribute(makeSimpleQname(\"type\"), \"CDATA\",\n\t\t\t\t\t// \"text/css\");\n\t\t\t\t\t// start the CSS element\n\n\t\t\t\t\tsuper.startElement(element, cssAttributes, new AugmentationsImpl());\n\t\t\t\t\t// send the cleaned content\n\t\t\t\t\tsuper.characters(new XMLStringBuffer(results.getCleanHTML()), new AugmentationsImpl());\n\t\t\t\t\t// end the CSS element\n\t\t\t\t\tsuper.endElement(element, augs);\n\t\t\t\t}\n\t\t\t} catch (ScanException e) {\n\t\t\t\t// if the CSS is unscannable, we report the error, but skip the\n\t\t\t\t// style element\n\t\t\t\taddError(ErrorMessageUtil.ERROR_CSS_TAG_MALFORMED, new Object[] {\n\t\t\t\t\tHTMLEntityEncoder.htmlEntityEncode(cssContent.toString())\n\t\t\t\t});\n\t\t\t} finally {\n\t\t\t\t// reset the string buffer to allow fresh recording of next\n\t\t\t\t// style tag\n\t\t\t\tcssContent = null;\n\t\t\t\tcssAttributes = null;\n\t\t\t}\n\t\t} else {\n\t\t\t// keep or truncate means the end-tag stays intact\n\t\t\toperations.pop();\n\t\t\tsuper.endElement(element, augs);\n\t\t}\n\t}\n\n\tprivate CssScanner makeCssScanner() {\n\t\tif (cssScanner == null) {\n            cssScanner = externalCssScanner ? new ExternalCssScanner(policy, messages) : new CssScanner(policy, messages);\n\t\t}\n\t\treturn cssScanner;\n\t}\n\n\tpublic void processingInstruction(String target, XMLString data, Augmentations augs) throws XNIException {\n\t\t// processing instructions are being removed\n\t}\n\t\n\tpublic void startCDATA(Augmentations augs) throws XNIException {\n\t\tinCdata = true;\n\t\tsuper.startCDATA(augs);\n\t}\n\t\n\tpublic void endCDATA(Augmentations augs) throws XNIException {\n\t\tinCdata = false;\n\t\tsuper.endCDATA(augs);\n\t}\n\n\tpublic void startElement(QName element, XMLAttributes attributes, Augmentations augs) throws XNIException {\n\t\t// see if we have a policy for this tag.\n        String tagNameLowerCase = element.localpart.toLowerCase();\n        Tag tag = policy.getTagByLowercaseName(tagNameLowerCase);\n\n\t\t/*\n\t\t * Handle the automatic translation of <param> to nested <embed> for IE.\n\t\t * This is only if the \"validateParamAsEmbed\" directive is enabled.\n\t\t */\n\t\tboolean masqueradingParam = false;\n\t\tString embedName = null;\n\t\tString embedValue = null;\n\t\tif (tag == null && isValidateParamAsEmbed && \"param\".equals(tagNameLowerCase)) {\n\t\t\tTag embedPolicy = policy.getEmbedTag();\n\t\t\tif (embedPolicy != null && embedPolicy.isAction( Policy.ACTION_VALIDATE)) {\n\t\t\t\ttag = embedPolicy;// Constants.BASIC_PARAM_TAG_RULE;\n\t\t\t\tmasqueradingParam = true;\n\t\t\t\t// take <param name=x value=y> and turn into\n\t\t\t\t// <embed x=y></embed>\n\t\t\t\tembedName = attributes.getValue(\"name\");\n\t\t\t\tembedValue = attributes.getValue(\"value\");\n\t\t\t\tXMLAttributes masqueradingAttrs = new XMLAttributesImpl();\n\t\t\t\tmasqueradingAttrs.addAttribute(makeSimpleQname(embedName), \"CDATA\", embedValue);\n\t\t\t\tattributes = masqueradingAttrs;\n\t\t\t}\n\t\t}\n\n\t\tXMLAttributes validattributes = new XMLAttributesImpl();\n        Ops topOp = peekTop();\n        if (Ops.REMOVE == topOp || Ops.CSS == topOp) {\n\t\t\t// we are in removal-mode, so remove this tag as well\n\t\t\t// we also remove all child elements of a style element\n\t\t\tthis.operations.push( Ops.REMOVE);\n\t\t} else if ((tag == null && policy.isEncodeUnknownTag()) || (tag != null && tag.isAction( \"encode\" ))) {\n\t\t\tString name = \"<\" + element.localpart + \">\";\n\t\t\tsuper.characters( new XMLString( name.toCharArray(), 0, name.length() ), augs );\n\t\t\tthis.operations.push(Ops.FILTER);\n\t\t} else if (tag == null) {\n\t\t\taddError( ErrorMessageUtil.ERROR_TAG_NOT_IN_POLICY,\n                      new Object[]{ HTMLEntityEncoder.htmlEntityEncode( element.localpart ) } );\n\t\t\tthis.operations.push(Ops.FILTER);\n\t\t} else if (tag.isAction( \"filter\")) {\n\t\t\taddError(ErrorMessageUtil.ERROR_TAG_FILTERED, new Object[] {\n\t\t\t\tHTMLEntityEncoder.htmlEntityEncode(element.localpart)\n\t\t\t});\n\t\t\tthis.operations.push(Ops.FILTER);\n\t\t} else if (tag.isAction( \"validate\")) {\n\n\t\t\tboolean isStyle = \"style\".endsWith(element.localpart);\n\n\t\t\tif (isStyle) {\n\t\t\t\tthis.operations.push(Ops.CSS);\n\t\t\t\tcssContent = new StringBuffer();\n\t\t\t\tcssAttributes = attributes;\n\t\t\t} else {\n\t\t\t\t// validate all attributes, we need to do this now to find out\n\t\t\t\t// how to deal with the element\n\t\t\t\tboolean removeTag = false;\n\t\t\t\tboolean filterTag = false;\n\t\t\t\tfor (int i = 0; i < attributes.getLength(); i++) {\n\t\t\t\t\tString name = attributes.getQName(i);\n\t\t\t\t\tString value = attributes.getValue(i);\n\t\t\t\t\tString nameLower = name.toLowerCase();\n\t\t\t\t\tAttribute attribute = tag.getAttributeByName(nameLower);\n\t\t\t\t\tif (attribute == null) {\n\t\t\t\t\t\t// no policy defined, perhaps it is a global attribute\n\t\t\t\t\t\tattribute = policy.getGlobalAttributeByName(nameLower);\n\t\t\t\t\t}\n\t\t\t\t\t// boolean isAttributeValid = false;\n\t\t\t\t\tif (\"style\".equalsIgnoreCase(name)) {\n\t\t\t\t\t\tCssScanner styleScanner = makeCssScanner();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tCleanResults cr = styleScanner.scanInlineStyle(value, element.localpart, maxInputSize);\n\t\t\t\t\t\t\tattributes.setValue(i, cr.getCleanHTML());\n\t\t\t\t\t\t\tvalidattributes.addAttribute(makeSimpleQname(name), \"CDATA\", cr.getCleanHTML());\n\t\t\t\t\t\t\terrorMessages.addAll(cr.getErrorMessages());\n\t\t\t\t\t\t} catch (ScanException e) {\n\t\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_CSS_ATTRIBUTE_MALFORMED, new Object[] {\n\t\t\t\t\t\t\t\t\telement.localpart, HTMLEntityEncoder.htmlEntityEncode(value)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (attribute != null) {\n\t\t\t\t\t\t// validate the values against the policy\n\t\t\t\t\t\tboolean isValid = false;\n                        if (attribute.containsAllowedValue(value.toLowerCase())) {\n                            validattributes.addAttribute(makeSimpleQname(name), \"CDATA\", value);\n                            isValid = true;\n                        }\n\n\n                        if (!isValid) {\n                            isValid = attribute.matchesAllowedExpression(value);\n                            if (isValid) {\n                                validattributes.addAttribute(makeSimpleQname(name), \"CDATA\", value);\n                            }\n                        }\n\n\n                        // if value or regexp matched, attribute is already\n\t\t\t\t\t\t// copied, but what happens if not\n\t\t\t\t\t\tif (!isValid && \"removeTag\".equals(attribute.getOnInvalid())) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_ATTRIBUTE_INVALID_REMOVED,\n\t\t\t\t\t\t\t\tnew Object[] { tag.getName(), HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value) });\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tremoveTag = true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if (!isValid && (\"filterTag\".equals(attribute.getOnInvalid()) || masqueradingParam)) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_ATTRIBUTE_CAUSE_FILTER, \n\t\t\t\t\t\t\t\tnew Object[] { tag.getName(), HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value) });\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfilterTag = true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if (!isValid) {\n\t\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_ATTRIBUTE_INVALID, new Object[] { tag.getName(), HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value) });\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} else { // attribute == null\n\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_ATTRIBUTE_NOT_IN_POLICY, new Object[] {\n\t\t\t\t\t\t\t\telement.localpart, HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value)\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (masqueradingParam) {\n\t\t\t\t\t\t\tfilterTag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (removeTag) {\n\t\t\t\t\tthis.operations.push(Ops.REMOVE);\n\t\t\t\t} else if (filterTag) {\n\t\t\t\t\tthis.operations.push(Ops.FILTER);\n\t\t\t\t} else {\n\n\t\t\t\t\tif (isNofollowAnchors && \"a\".equals(element.localpart)) {\n\t\t\t\t\t\tvalidattributes.addAttribute(makeSimpleQname(\"rel\"), \"CDATA\", \"nofollow\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (masqueradingParam) {\n\t\t\t\t\t\tvalidattributes = new XMLAttributesImpl();\n\t\t\t\t\t\tvalidattributes.addAttribute(makeSimpleQname(\"name\"), \"CDATA\", embedName);\n\t\t\t\t\t\tvalidattributes.addAttribute(makeSimpleQname(\"value\"), \"CDATA\", embedValue);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.operations.push(Ops.KEEP);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (tag.isAction( \"truncate\")) {\n\t\t\tthis.operations.push(Ops.TRUNCATE);\n\t\t} else {\n\t\t\t// no options left, so the tag will be removed\n\t\t\taddError(ErrorMessageUtil.ERROR_TAG_DISALLOWED, new Object[] {\n\t\t\t\tHTMLEntityEncoder.htmlEntityEncode(element.localpart)\n\t\t\t});\n\t\t\tthis.operations.push(Ops.REMOVE);\n\t\t}\n\t\t// now we know exactly what to do, let's do it\n\t\tif ( Ops.TRUNCATE.equals( operations.peek() )) {\n\t\t\t// copy the element, but remove all attributes\n\t\t\tsuper.startElement(element, new XMLAttributesImpl(), augs);\n\t\t} else if ( Ops.KEEP.equals(operations.peek())) {\n\t\t\t// copy the element, but only copy accepted attributes\n\t\t\tsuper.startElement(element, validattributes, augs);\n\t\t}\n\t}\n\n\tprivate QName makeSimpleQname(String name) {\n\t\treturn new QName(\"\", name, name, \"\");\n\t}\n\n\tprivate void addError(String errorKey, Object[] objs) {\n\t\terrorMessages.add(ErrorMessageUtil.getMessage(messages, errorKey, objs));\n\t}\n\n\tpublic List<String> getErrorMessages() {\n\t\treturn errorMessages;\n\t}\n\n}\n",
        "human_patch_code": "/*\n * Copyright (c) 2007-2011, Arshan Dabirsiaghi, Jason Li\n * \n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n * \n * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n * Neither the name of OWASP nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.owasp.validator.html.scan;\n\nimport java.util.*;\nimport java.util.regex.Pattern;\n\nimport org.apache.xerces.util.AugmentationsImpl;\nimport org.apache.xerces.util.XMLAttributesImpl;\nimport org.apache.xerces.util.XMLStringBuffer;\nimport org.apache.xerces.xni.Augmentations;\nimport org.apache.xerces.xni.QName;\nimport org.apache.xerces.xni.XMLAttributes;\nimport org.apache.xerces.xni.XMLString;\nimport org.apache.xerces.xni.XNIException;\nimport org.apache.xerces.xni.parser.XMLDocumentFilter;\nimport org.cyberneko.html.filters.DefaultFilter;\nimport org.owasp.validator.css.CssScanner;\nimport org.owasp.validator.css.ExternalCssScanner;\nimport org.owasp.validator.html.CleanResults;\nimport org.owasp.validator.html.InternalPolicy;\nimport org.owasp.validator.html.Policy;\nimport org.owasp.validator.html.ScanException;\nimport org.owasp.validator.html.model.Attribute;\nimport org.owasp.validator.html.model.Tag;\nimport org.owasp.validator.html.util.ErrorMessageUtil;\nimport org.owasp.validator.html.util.HTMLEntityEncoder;\n\n/**\n * Implementation of an HTML-filter that adheres to an AntiSamy policy. This\n * filter is SAX-based which means it is much more memory-efficient and also a\n * bit faster than the DOM-based implementation.\n */\npublic class MagicSAXFilter extends DefaultFilter implements XMLDocumentFilter {\n\n    private static enum Ops {\n        CSS, FILTER, REMOVE, TRUNCATE, KEEP\n    }\n\tprivate final Stack<Ops> operations = new Stack<Ops>();\n\tprivate List<String> errorMessages = new ArrayList<String>();\n\tprivate StringBuffer cssContent = null;\n\tprivate XMLAttributes cssAttributes = null;\n\tprivate CssScanner cssScanner = null;\n\tprivate InternalPolicy policy;\n\tprivate ResourceBundle messages;\n\n\tprivate boolean isNofollowAnchors;\n\tprivate boolean isValidateParamAsEmbed;\n\tprivate boolean inCdata = false;\n    // From policy\n    private boolean preserveComments;\n    private int maxInputSize;\n    private boolean externalCssScanner;\n\n    public MagicSAXFilter(ResourceBundle messages) {\n\t\tthis.messages = messages;\n    }\n\n    public void reset(InternalPolicy instance){\n        this.policy = instance;\n        isNofollowAnchors = policy.isNofollowAnchors();\n        isValidateParamAsEmbed = policy.isValidateParamAsEmbed();\n        preserveComments = policy.isPreserveComments();\n        maxInputSize = policy.getMaxInputSize();\n        externalCssScanner = policy.isEmbedStyleSheets();\n        operations.clear();\n        errorMessages.clear();\n        cssContent = null;\n        cssAttributes = null;\n        cssScanner = null;\n        inCdata = false;\n\n    }\n\n\tpublic void characters(XMLString text, Augmentations augs) throws XNIException {\n        //noinspection StatementWithEmptyBody\n        Ops topOp = peekTop();\n        //noinspection StatementWithEmptyBody\n        if (topOp ==  Ops.REMOVE) {\n\t\t\t// content is removed altogether\n\t\t} else if (topOp == Ops.CSS) {\n\t\t\t// we record the style element's text content\n\t\t\t// to filter it later\n\t\t\tcssContent.append(text.ch, text.offset, text.length);\n\t\t} else {\n\t\t\t// pass through all character content.\n\t\t\tif ( inCdata ) {\n\t\t\t\tString encoded = HTMLEntityEncoder.htmlEntityEncode(text.toString());\n                addError(ErrorMessageUtil.ERROR_CDATA_FOUND, new Object[]{encoded});\n\t\t\t}\n\t\t\tsuper.characters(text, augs);\n\t\t}\n\t}\n\n    private static final Pattern conditionalDirectives =\n            Pattern.compile(\"<?!?\\\\[\\\\s*(?:end)?if[^]]*\\\\]>?\");\n\n    public void comment(XMLString text, Augmentations augs) throws XNIException {\n\n\t\tif (preserveComments) {\n\t\t\tString value = text.toString();\n\t\t\t// Strip conditional directives regardless of the\n\t\t\t// PRESERVE_COMMENTS setting.\n\t\t\tif (value != null) {\n                value = conditionalDirectives.matcher(value).replaceAll(\"\");\n\t\t\t\tsuper.comment(new XMLString(value.toCharArray(), 0, value.length()), augs);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void doctypeDecl(String root, String publicId, String systemId, Augmentations augs) throws XNIException {\n\t\t// user supplied doctypes are ignored\n\t}\n\n\tpublic void emptyElement(QName element, XMLAttributes attributes, Augmentations augs) throws XNIException {\n\t\tthis.startElement(element, attributes, augs);\n\t\tthis.endElement(element, augs);\n\t}\n\n    private Ops peekTop(){\n         return operations.empty() ? null : operations.peek();\n    }\n\n\tpublic void endElement(QName element, Augmentations augs) throws XNIException {\n        Ops topOp = peekTop();\n        if (Ops.REMOVE == topOp) {\n\t\t\t// content is removed altogether\n\t\t\toperations.pop();\n\t\t} else if (Ops.FILTER == topOp) {\n\t\t\t// content is removed, but child nodes not\n\t\t\toperations.pop();\n\t\t} else if (Ops.CSS == topOp) {\n\t\t\toperations.pop();\n\t\t\t// now scan the CSS.\n\t\t\tCssScanner cssScanner = makeCssScanner();\n\t\t\ttry {\n\t\t\t\tCleanResults results = cssScanner.scanStyleSheet(cssContent.toString(), maxInputSize);\n\t\t\t\t// report all errors found\n\t\t\t\terrorMessages.addAll(results.getErrorMessages());\n\t\t\t\t/*\n\t\t\t\t * If IE gets an empty style tag, i.e. <style/> it will break\n\t\t\t\t * all CSS on the page. I wish I was kidding. So, if after\n\t\t\t\t * validation no CSS properties are left, we would normally be\n\t\t\t\t * left with an empty style tag and break all CSS. To prevent\n\t\t\t\t * that, we have this check.\n\t\t\t\t */\n                //noinspection StatementWithEmptyBody\n                if (results.getCleanHTML() == null || results.getCleanHTML().equals(\"\")) {\n\t\t\t\t\t// we do not generate empty style elements\n\t\t\t\t} else {\n\t\t\t\t\t// XMLAttributes attributes = new XMLAttributesImpl();\n\t\t\t\t\t// attributes.addAttribute(makeSimpleQname(\"type\"), \"CDATA\",\n\t\t\t\t\t// \"text/css\");\n\t\t\t\t\t// start the CSS element\n\n\t\t\t\t\tsuper.startElement(element, cssAttributes, new AugmentationsImpl());\n\t\t\t\t\t// send the cleaned content\n\t\t\t\t\tsuper.characters(new XMLStringBuffer(results.getCleanHTML()), new AugmentationsImpl());\n\t\t\t\t\t// end the CSS element\n\t\t\t\t\tsuper.endElement(element, augs);\n\t\t\t\t}\n\t\t\t} catch (ScanException e) {\n\t\t\t\t// if the CSS is unscannable, we report the error, but skip the\n\t\t\t\t// style element\n\t\t\t\taddError(ErrorMessageUtil.ERROR_CSS_TAG_MALFORMED, new Object[] {\n\t\t\t\t\tHTMLEntityEncoder.htmlEntityEncode(cssContent.toString())\n\t\t\t\t});\n\t\t\t} finally {\n\t\t\t\t// reset the string buffer to allow fresh recording of next\n\t\t\t\t// style tag\n\t\t\t\tcssContent = null;\n\t\t\t\tcssAttributes = null;\n\t\t\t}\n\t\t} else {\n\t\t\t// keep or truncate means the end-tag stays intact\n\t\t\toperations.pop();\n\t\t\tsuper.endElement(element, augs);\n\t\t}\n\t}\n\n\tprivate CssScanner makeCssScanner() {\n\t\tif (cssScanner == null) {\n            cssScanner = externalCssScanner ? new ExternalCssScanner(policy, messages) : new CssScanner(policy, messages);\n\t\t}\n\t\treturn cssScanner;\n\t}\n\n\tpublic void processingInstruction(String target, XMLString data, Augmentations augs) throws XNIException {\n\t\t// processing instructions are being removed\n\t}\n\t\n\tpublic void startCDATA(Augmentations augs) throws XNIException {\n\t\tinCdata = true;\n\t\tsuper.startCDATA(augs);\n\t}\n\t\n\tpublic void endCDATA(Augmentations augs) throws XNIException {\n\t\tinCdata = false;\n\t\tsuper.endCDATA(augs);\n\t}\n\n\tpublic void startElement(QName element, XMLAttributes attributes, Augmentations augs) throws XNIException {\n\t\t// see if we have a policy for this tag.\n        String tagNameLowerCase = element.localpart.toLowerCase();\n        Tag tag = policy.getTagByLowercaseName(tagNameLowerCase);\n\n\t\t/*\n\t\t * Handle the automatic translation of <param> to nested <embed> for IE.\n\t\t * This is only if the \"validateParamAsEmbed\" directive is enabled.\n\t\t */\n\t\tboolean masqueradingParam = false;\n\t\tString embedName = null;\n\t\tString embedValue = null;\n\t\tif (tag == null && isValidateParamAsEmbed && \"param\".equals(tagNameLowerCase)) {\n\t\t\tTag embedPolicy = policy.getEmbedTag();\n\t\t\tif (embedPolicy != null && embedPolicy.isAction( Policy.ACTION_VALIDATE)) {\n\t\t\t\ttag = embedPolicy;// Constants.BASIC_PARAM_TAG_RULE;\n\t\t\t\tmasqueradingParam = true;\n\t\t\t\t// take <param name=x value=y> and turn into\n\t\t\t\t// <embed x=y></embed>\n\t\t\t\tembedName = attributes.getValue(\"name\");\n\t\t\t\tembedValue = attributes.getValue(\"value\");\n\t\t\t\tXMLAttributes masqueradingAttrs = new XMLAttributesImpl();\n\t\t\t\tmasqueradingAttrs.addAttribute(makeSimpleQname(embedName), \"CDATA\", embedValue);\n\t\t\t\tattributes = masqueradingAttrs;\n\t\t\t}\n\t\t}\n\n\t\tXMLAttributes validattributes = new XMLAttributesImpl();\n        Ops topOp = peekTop();\n        if (Ops.REMOVE == topOp || Ops.CSS == topOp) {\n\t\t\t// we are in removal-mode, so remove this tag as well\n\t\t\t// we also remove all child elements of a style element\n\t\t\tthis.operations.push( Ops.REMOVE);\n\t\t} else if ((tag == null && policy.isEncodeUnknownTag()) || (tag != null && tag.isAction( \"encode\" ))) {\n\t\t\tString name = \"<\" + element.localpart + \">\";\n\t\t\tsuper.characters( new XMLString( name.toCharArray(), 0, name.length() ), augs );\n\t\t\tthis.operations.push(Ops.FILTER);\n\t\t} else if (tag == null) {\n\t\t\taddError( ErrorMessageUtil.ERROR_TAG_NOT_IN_POLICY,\n                      new Object[]{ HTMLEntityEncoder.htmlEntityEncode( element.localpart ) } );\n\t\t\tthis.operations.push(Ops.FILTER);\n\t\t} else if (tag.isAction( \"filter\")) {\n\t\t\taddError(ErrorMessageUtil.ERROR_TAG_FILTERED, new Object[] {\n\t\t\t\tHTMLEntityEncoder.htmlEntityEncode(element.localpart)\n\t\t\t});\n\t\t\tthis.operations.push(Ops.FILTER);\n\t\t} else if (tag.isAction( \"validate\")) {\n\n\t\t\tboolean isStyle = \"style\".endsWith(element.localpart);\n\n\t\t\t\t// validate all attributes, we need to do this now to find out\n\t\t\t\t// how to deal with the element\n\t\t\t\tboolean removeTag = false;\n\t\t\t\tboolean filterTag = false;\n\t\t\t\tfor (int i = 0; i < attributes.getLength(); i++) {\n\t\t\t\t\tString name = attributes.getQName(i);\n\t\t\t\t\tString value = attributes.getValue(i);\n\t\t\t\t\tString nameLower = name.toLowerCase();\n\t\t\t\t\tAttribute attribute = tag.getAttributeByName(nameLower);\n\t\t\t\t\tif (attribute == null) {\n\t\t\t\t\t\t// no policy defined, perhaps it is a global attribute\n\t\t\t\t\t\tattribute = policy.getGlobalAttributeByName(nameLower);\n\t\t\t\t\t}\n\t\t\t\t\t// boolean isAttributeValid = false;\n\t\t\t\t\tif (\"style\".equalsIgnoreCase(name)) {\n\t\t\t\t\t\tCssScanner styleScanner = makeCssScanner();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tCleanResults cr = styleScanner.scanInlineStyle(value, element.localpart, maxInputSize);\n\t\t\t\t\t\t\tattributes.setValue(i, cr.getCleanHTML());\n\t\t\t\t\t\t\tvalidattributes.addAttribute(makeSimpleQname(name), \"CDATA\", cr.getCleanHTML());\n\t\t\t\t\t\t\terrorMessages.addAll(cr.getErrorMessages());\n\t\t\t\t\t\t} catch (ScanException e) {\n\t\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_CSS_ATTRIBUTE_MALFORMED, new Object[] {\n\t\t\t\t\t\t\t\t\telement.localpart, HTMLEntityEncoder.htmlEntityEncode(value)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (attribute != null) {\n\t\t\t\t\t\t// validate the values against the policy\n\t\t\t\t\t\tboolean isValid = false;\n                        if (attribute.containsAllowedValue(value.toLowerCase())) {\n                            validattributes.addAttribute(makeSimpleQname(name), \"CDATA\", value);\n                            isValid = true;\n                        }\n\n\n                        if (!isValid) {\n                            isValid = attribute.matchesAllowedExpression(value);\n                            if (isValid) {\n                                validattributes.addAttribute(makeSimpleQname(name), \"CDATA\", value);\n                            }\n                        }\n\n\n                        // if value or regexp matched, attribute is already\n\t\t\t\t\t\t// copied, but what happens if not\n\t\t\t\t\t\tif (!isValid && \"removeTag\".equals(attribute.getOnInvalid())) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_ATTRIBUTE_INVALID_REMOVED,\n\t\t\t\t\t\t\t\tnew Object[] { tag.getName(), HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value) });\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tremoveTag = true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if (!isValid && (\"filterTag\".equals(attribute.getOnInvalid()) || masqueradingParam)) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_ATTRIBUTE_CAUSE_FILTER, \n\t\t\t\t\t\t\t\tnew Object[] { tag.getName(), HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value) });\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfilterTag = true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if (!isValid) {\n\t\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_ATTRIBUTE_INVALID, new Object[] { tag.getName(), HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value) });\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} else { // attribute == null\n\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_ATTRIBUTE_NOT_IN_POLICY, new Object[] {\n\t\t\t\t\t\t\t\telement.localpart, HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value)\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (masqueradingParam) {\n\t\t\t\t\t\t\tfilterTag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (removeTag) {\n\t\t\t\t\tthis.operations.push(Ops.REMOVE);\n\t\t\t\t} else if (isStyle) {\n\t\t\t\t\tthis.operations.push(Ops.CSS);\n\t\t\t\t\tcssContent = new StringBuffer();\n\t\t\t\t\tcssAttributes = validattributes;\n\t\t\t\t} else if (filterTag) {\n\t\t\t\t\tthis.operations.push(Ops.FILTER);\n\t\t\t\t} else {\n\n\t\t\t\t\tif (isNofollowAnchors && \"a\".equals(element.localpart)) {\n\t\t\t\t\t\tvalidattributes.addAttribute(makeSimpleQname(\"rel\"), \"CDATA\", \"nofollow\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (masqueradingParam) {\n\t\t\t\t\t\tvalidattributes = new XMLAttributesImpl();\n\t\t\t\t\t\tvalidattributes.addAttribute(makeSimpleQname(\"name\"), \"CDATA\", embedName);\n\t\t\t\t\t\tvalidattributes.addAttribute(makeSimpleQname(\"value\"), \"CDATA\", embedValue);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.operations.push(Ops.KEEP);\n\t\t\t\t}\n\t\t\t\n\t\t} else if (tag.isAction( \"truncate\")) {\n\t\t\tthis.operations.push(Ops.TRUNCATE);\n\t\t} else {\n\t\t\t// no options left, so the tag will be removed\n\t\t\taddError(ErrorMessageUtil.ERROR_TAG_DISALLOWED, new Object[] {\n\t\t\t\tHTMLEntityEncoder.htmlEntityEncode(element.localpart)\n\t\t\t});\n\t\t\tthis.operations.push(Ops.REMOVE);\n\t\t}\n\t\t// now we know exactly what to do, let's do it\n\t\tif ( Ops.TRUNCATE.equals( operations.peek() )) {\n\t\t\t// copy the element, but remove all attributes\n\t\t\tsuper.startElement(element, new XMLAttributesImpl(), augs);\n\t\t} else if ( Ops.KEEP.equals(operations.peek())) {\n\t\t\t// copy the element, but only copy accepted attributes\n\t\t\tsuper.startElement(element, validattributes, augs);\n\t\t}\n\t}\n\n\tprivate QName makeSimpleQname(String name) {\n\t\treturn new QName(\"\", name, name, \"\");\n\t}\n\n\tprivate void addError(String errorKey, Object[] objs) {\n\t\terrorMessages.add(ErrorMessageUtil.getMessage(messages, errorKey, objs));\n\t}\n\n\tpublic List<String> getErrorMessages() {\n\t\treturn errorMessages;\n\t}\n\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-61": {
    "vul_id": "VUL4J-61",
    "cve_id": "CVE-2018-1000820",
    "project": "neo4j-contrib_neo4j-apoc-procedures",
    "build_system": "Gradle",
    "compile_cmd": "./gradlew compileTestJava",
    "test_cmd": "./gradlew test --tests apoc.load.XmlTest.testLoadXmlPreventXXEVulnerabilityThrowsQueryExecutionException",
    "test_all_cmd": "./gradlew test",
    "human_patch_url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/45bc09c8bd7f17283e2a7e85ce3f02cb4be4fd1a",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/apoc/load/Xml.java",
        "file_name": "Xml.java",
        "vulnerable_code": "package apoc.load;\n\nimport apoc.util.FileUtils;\nimport apoc.result.MapResult;\nimport apoc.result.NodeResult;\nimport apoc.util.Util;\nimport org.apache.commons.lang3.StringUtils;\nimport org.neo4j.graphdb.GraphDatabaseService;\nimport org.neo4j.graphdb.Label;\nimport org.neo4j.graphdb.RelationshipType;\nimport org.neo4j.logging.Log;\nimport org.neo4j.procedure.*;\nimport org.w3c.dom.CharacterData;\nimport org.w3c.dom.*;\n\nimport javax.xml.namespace.QName;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.*;\nimport java.util.stream.Stream;\n\nimport static apoc.util.Util.cleanUrl;\nimport static javax.xml.stream.XMLStreamConstants.*;\n\npublic class Xml {\n\n    public static final XMLInputFactory FACTORY = XMLInputFactory.newFactory();\n\n    @Context\n    public GraphDatabaseService db;\n\n    @Context\n    public Log log;\n\n    @Procedure\n    @Description(\"apoc.load.xml('http://example.com/test.xml', 'xPath',config, false) YIELD value as doc CREATE (p:Person) SET p.name = doc.name load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _childrenx fields.\")\n    public Stream<MapResult> xml(@Name(\"url\") String url, @Name(value = \"path\", defaultValue = \"/\") String path, @Name(value = \"config\",defaultValue = \"{}\") Map<String, Object> config, @Name(value = \"simple\", defaultValue = \"false\") boolean simpleMode) throws Exception {\n        return xmlXpathToMapResult(url, simpleMode, path ,config);\n    }\n\n    @Procedure(deprecatedBy = \"apoc.load.xml\")\n    @Deprecated\n    @Description(\"apoc.load.xmlSimple('http://example.com/test.xml') YIELD value as doc CREATE (p:Person) SET p.name = doc.name load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _children fields. This method does intentionally not work with XML mixed content.\")\n    public Stream<MapResult> xmlSimple(@Name(\"url\") String url) throws Exception {\n        return xmlToMapResult(url, true);\n    }\n\n    private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n        if (config == null) config = Collections.emptyMap();\n        boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n        List<MapResult> result = new ArrayList<>();\n        try {\n            DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n            documentBuilderFactory.setNamespaceAware(true);\n            documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n            DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n\n            FileUtils.checkReadAllowed(url);\n\n            Map<String, Object> headers = (Map) config.getOrDefault( \"headers\", Collections.emptyMap() );\n\n            Document doc = documentBuilder.parse(Util.openInputStream(url, headers, null));\n            XPathFactory xPathFactory = XPathFactory.newInstance();\n\n            XPath xPath = xPathFactory.newXPath();\n\n            path = StringUtils.isEmpty(path) ? \"/\" : path;\n            XPathExpression xPathExpression = xPath.compile(path);\n            NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n\n            for (int i = 0; i < nodeList.getLength(); i++) {\n                final Deque<Map<String, Object>> stack = new LinkedList<>();\n\n                handleNode(stack, nodeList.item(i), simpleMode);\n                for (int index = 0; index < stack.size(); index++) {\n                    result.add(new MapResult(stack.pollFirst()));\n                }\n            }\n        }\n        catch (FileNotFoundException e){\n            if(!failOnError)\n                return Stream.of(new MapResult(Collections.emptyMap()));\n            else\n                throw new FileNotFoundException(e.getMessage());\n        }\n        catch (Exception e){\n            if(!failOnError)\n                return Stream.of(new MapResult(Collections.emptyMap()));\n            else\n                throw new Exception(e);\n        }\n        return result.stream();\n    }\n\n    private Stream<MapResult> xmlToMapResult(@Name(\"url\") String url, boolean simpleMode) {\n        try {\n            XMLStreamReader reader = getXMLStreamReaderFromUrl(url);\n            final Deque<Map<String, Object>> stack = new LinkedList<>();\n            do {\n                handleXmlEvent(stack, reader, simpleMode);\n            } while (proceedReader(reader));\n\n            return Stream.of(new MapResult(stack.getFirst()));\n        } catch (IOException | XMLStreamException e) {\n            throw new RuntimeException(\"Can't read url \" + cleanUrl(url) + \" as XML\", e);\n        }\n    }\n\n    private XMLStreamReader getXMLStreamReaderFromUrl(String url) throws IOException, XMLStreamException {\n        FileUtils.checkReadAllowed(url);\n        URLConnection urlConnection = new URL(url).openConnection();\n        FACTORY.setProperty(XMLInputFactory.IS_COALESCING, true);\n        return FACTORY.createXMLStreamReader(urlConnection.getInputStream());\n    }\n\n\n    private boolean proceedReader(XMLStreamReader reader) throws XMLStreamException {\n        if (reader.hasNext()) {\n            do {\n                reader.next();\n            } while (reader.isWhiteSpace());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    private void handleXmlEvent(Deque<Map<String, Object>> stack, XMLStreamReader reader, boolean simpleMode) throws XMLStreamException {\n\n        Map<String, Object> elementMap;\n        switch (reader.getEventType()) {\n            case START_DOCUMENT:\n            case END_DOCUMENT:\n                // intentionally empty\n                break;\n            case START_ELEMENT:\n                int attributes = reader.getAttributeCount();\n                elementMap = new LinkedHashMap<>(attributes + 3);\n                elementMap.put(\"_type\", reader.getLocalName());\n                for (int a = 0; a < attributes; a++) {\n                    elementMap.put(reader.getAttributeLocalName(a), reader.getAttributeValue(a));\n                }\n                if (!stack.isEmpty()) {\n                    final Map<String, Object> last = stack.getLast();\n                    String key = simpleMode ? \"_\" + reader.getLocalName() : \"_children\";\n                    amendToList(last, key, elementMap);\n                }\n                stack.addLast(elementMap);\n                break;\n\n            case END_ELEMENT:\n                elementMap = stack.size() > 1 ? stack.removeLast() : stack.getLast();\n\n                // maintain compatibility with previous implementation:\n                // if we only have text childs, return them in \"_text\" and not in \"_children\"\n                Object children = elementMap.get(\"_children\");\n                if (children != null) {\n                    if ((children instanceof String) || collectionIsAllStrings(children)) {\n                        elementMap.put(\"_text\", children);\n                        elementMap.remove(\"_children\");\n                    }\n                }\n                break;\n\n            case CHARACTERS:\n                final String text = reader.getText().trim();\n                if (!text.isEmpty()) {\n                    Map<String, Object> map = stack.getLast();\n                    amendToList(map, \"_children\", text);\n                }\n                break;\n            default:\n                throw new RuntimeException(\"dunno know how to handle xml event type \" + reader.getEventType());\n        }\n    }\n\n    private void handleNode(Deque<Map<String, Object>> stack, Node node, boolean simpleMode) {\n\n        // Handle document node\n        if (node.getNodeType() == Node.DOCUMENT_NODE) {\n            NodeList children = node.getChildNodes();\n            for (int i = 0; i < children.getLength(); i++) {\n                if (children.item(i).getLocalName() != null) {\n                    handleNode(stack, children.item(i), simpleMode);\n                    return;\n                }\n            }\n        }\n\n        Map<String, Object> elementMap = new LinkedHashMap<>();\n        handleTypeAndAttributes(node, elementMap);\n\n        // Set children\n        NodeList children = node.getChildNodes();\n        int count = 0;\n        for (int i = 0; i < children.getLength(); i++) {\n            Node child = children.item(i);\n\n            // This is to deal with text between xml tags for example new line characters\n            if (child.getNodeType() != Node.TEXT_NODE && child.getNodeType() != Node.CDATA_SECTION_NODE) {\n                handleNode(stack, child, simpleMode);\n                count++;\n            } else {\n                // Deal with text nodes\n                handleTextNode(child, elementMap);\n            }\n        }\n\n        if (children.getLength() > 1) {\n            if (!stack.isEmpty()) {\n                List<Object> nodeChildren = new ArrayList<>();\n                for (int i = 0; i < count; i++) {\n                    nodeChildren.add(stack.pollLast());\n                }\n                String key = simpleMode ? \"_\" + node.getLocalName() : \"_children\";\n                Collections.reverse(nodeChildren);\n                if (nodeChildren.size() > 0) {\n                    // Before adding the children we need to handle mixed text\n                    Object text = elementMap.get(\"_text\");\n                    if (text instanceof List) {\n                        for (Object element : (List) text) {\n                            nodeChildren.add(element);\n                        }\n                        elementMap.remove(\"_text\");\n                    }\n\n                    elementMap.put(key, nodeChildren);\n                }\n            }\n        }\n\n        if (!elementMap.isEmpty()) {\n            stack.addLast(elementMap);\n        }\n    }\n\n    /**\n     * Collects type and attributes for the node\n     *\n     * @param node\n     * @param elementMap\n     */\n    private void handleTypeAndAttributes(Node node, Map<String, Object> elementMap) {\n        // Set type\n        if (node.getLocalName() != null) {\n            elementMap.put(\"_type\", node.getLocalName());\n        }\n\n        // Set the attributes\n        if (node.getAttributes() != null) {\n            NamedNodeMap attributeMap = node.getAttributes();\n            for (int i = 0; i < attributeMap.getLength(); i++) {\n                Node attribute = attributeMap.item(i);\n                elementMap.put(attribute.getNodeName(), attribute.getNodeValue());\n            }\n        }\n    }\n\n    /**\n     * Handle TEXT nodes and CDATA nodes\n     *\n     * @param node\n     * @param elementMap\n     */\n    private void handleTextNode(Node node, Map<String, Object> elementMap) {\n        Object text = \"\";\n        int nodeType = node.getNodeType();\n        switch (nodeType) {\n            case Node.TEXT_NODE:\n                text = normalizeText(node.getNodeValue());\n                break;\n            case Node.CDATA_SECTION_NODE:\n                text = normalizeText(((CharacterData) node).getData());\n                break;\n            default:\n                break;\n        }\n\n        // If the text is valid ...\n        if (!StringUtils.isEmpty(text.toString())) {\n            // We check if we have already collected some text previously\n            Object previousText = elementMap.get(\"_text\");\n            if (previousText != null) {\n                // If we just have a \"_text\" key than we need to collect to a List\n                text = Arrays.asList(previousText.toString(), text);\n            }\n            elementMap.put(\"_text\", text);\n        }\n    }\n\n    /**\n     * Remove trailing whitespaces and new line characters\n     *\n     * @param text\n     * @return\n     */\n    private String normalizeText(String text) {\n        String[] tokens = StringUtils.split(text, \"\\n\");\n        for (int i = 0; i < tokens.length; i++) {\n            tokens[i] = tokens[i].trim();\n        }\n\n        return StringUtils.join(tokens, \" \").trim();\n    }\n\n    private boolean collectionIsAllStrings(Object collection) {\n        if (collection instanceof Collection) {\n            return ((Collection<Object>) collection).stream().allMatch(o -> o instanceof String);\n        } else {\n            return false;\n        }\n    }\n\n    private void amendToList(Map<String, Object> map, String key, Object value) {\n        final Object element = map.get(key);\n        if (element == null) {\n            map.put(key, value);\n        } else {\n            if (element instanceof List) {\n                ((List) element).add(value);\n            } else {\n                List<Object> list = new LinkedList<>();\n                list.add(element);\n                list.add(value);\n                map.put(key, list);\n            }\n        }\n    }\n\n    public static class ParentAndChildPair {\n        private org.neo4j.graphdb.Node parent;\n        private org.neo4j.graphdb.Node previousChild=null;\n\n        public ParentAndChildPair(org.neo4j.graphdb.Node parent) {\n            this.parent = parent;\n        }\n\n        public org.neo4j.graphdb.Node getParent() {\n            return parent;\n        }\n\n        public void setParent(org.neo4j.graphdb.Node parent) {\n            this.parent = parent;\n        }\n\n        public org.neo4j.graphdb.Node getPreviousChild() {\n            return previousChild;\n        }\n\n        public void setPreviousChild(org.neo4j.graphdb.Node previousChild) {\n            this.previousChild = previousChild;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            ParentAndChildPair that = (ParentAndChildPair) o;\n            return parent.equals(that.parent);\n        }\n\n        @Override\n        public int hashCode() {\n            return parent.hashCode();\n        }\n    }\n\n    private static class XmlImportConfig {\n\n        private boolean createNextWordRelationship = false;\n\n        public boolean isCreateNextWordRelationship() {\n            return createNextWordRelationship;\n        }\n\n        public XmlImportConfig(Map<String,Object> config) {\n            Boolean _createNextWordRelationship = (Boolean) config.get(\"createNextWordRelationships\");\n            if (_createNextWordRelationship!=null) {\n                createNextWordRelationship = _createNextWordRelationship;\n            }\n        }\n\n    }\n\n    @Procedure(mode = Mode.WRITE, value = \"apoc.xml.import\")\n    public Stream<NodeResult> importToGraph(@Name(\"url\") String url, @Name(value=\"config\", defaultValue = \"{}\") Map<String, Object> config) throws IOException, XMLStreamException {\n        final XMLStreamReader xml = getXMLStreamReaderFromUrl(url);\n\n        XmlImportConfig importConfig = new XmlImportConfig(config);\n        //TODO: make labels, reltypes and magic properties configurable\n\n        // stores parents and their most recent child\n        Deque<ParentAndChildPair> parents = new ArrayDeque<>();\n        org.neo4j.graphdb.Node root = db.createNode(Label.label(\"XmlDocument\"));\n        setPropertyIfNotNull(root, \"_xmlVersion\", xml.getVersion());\n        setPropertyIfNotNull(root, \"_xmlEncoding\", xml.getEncoding());\n        root.setProperty(\"url\", url);\n        parents.push(new ParentAndChildPair(root));\n        org.neo4j.graphdb.Node last = root;\n        org.neo4j.graphdb.Node lastWord = root;\n\n        while (xml.hasNext()) {\n            xml.next();\n\n            switch (xml.getEventType()) {\n                case XMLStreamConstants.START_DOCUMENT:\n                    // xmlsteamreader starts off by definition at START_DOCUMENT prior to call next() - so ignore this one\n                    break;\n\n                case XMLStreamConstants.PROCESSING_INSTRUCTION:\n                    org.neo4j.graphdb.Node pi = db.createNode(Label.label(\"XmlProcessingInstruction\"));\n                    pi.setProperty(\"_piData\", xml.getPIData());\n                    pi.setProperty(\"_piTarget\", xml.getPITarget());\n                    last = connectWithParent(pi, parents.peek(), last);\n                    break;\n\n                case XMLStreamConstants.START_ELEMENT:\n                    final QName qName = xml.getName();\n                    final org.neo4j.graphdb.Node tag = db.createNode(Label.label(\"XmlTag\"));\n                    tag.setProperty(\"_name\", qName.getLocalPart());\n                    for (int i=0; i<xml.getAttributeCount(); i++) {\n                        tag.setProperty(xml.getAttributeLocalName(i), xml.getAttributeValue(i));\n                    }\n\n                    last = connectWithParent(tag, parents.peek(), last);\n                    parents.push(new ParentAndChildPair(tag));\n                    break;\n\n                case XMLStreamConstants.CHARACTERS:\n                    String text = xml.getText().trim();\n                    String[] words = text.split(\"\\\\s\");\n                    for (int i = 0; i < words.length; i++) {\n                        final String currentWord = words[i];\n                        if (!currentWord.isEmpty()) {\n                            org.neo4j.graphdb.Node word = db.createNode(Label.label(\"XmlWord\"));\n                            word.setProperty(\"text\", currentWord);\n                            last = connectWithParent(word, parents.peek(), last);\n                            if (importConfig.isCreateNextWordRelationship()) {\n                                lastWord.createRelationshipTo(word, RelationshipType.withName(\"NEXT_WORD\"));\n                                lastWord = word;\n                            }\n                        }\n                    }\n                    break;\n\n                case XMLStreamConstants.END_ELEMENT:\n                    ParentAndChildPair parent = parents.pop();\n                    if (parent.getPreviousChild()!=null) {\n                        parent.getPreviousChild().createRelationshipTo(parent.getParent(), RelationshipType.withName(\"LAST_CHILD_OF\"));\n                    }\n                    break;\n\n                case XMLStreamConstants.END_DOCUMENT:\n                    parents.pop();\n                    break;\n\n                case XMLStreamConstants.COMMENT:\n                case XMLStreamConstants.SPACE:\n                    // intentionally do nothing\n                    break;\n                default:\n                    log.warn(\"xml file contains a {} type structure - ignoring this.\", xml.getEventType());\n            }\n\n        }\n        if (!parents.isEmpty()) {\n            throw new IllegalStateException(\"non empty parents\");\n        }\n        return Stream.of(new NodeResult(root));\n    }\n\n    private void setPropertyIfNotNull(org.neo4j.graphdb.Node root, String propertyKey, Object value) {\n        if (value!=null) {\n            root.setProperty(propertyKey, value);\n        }\n    }\n\n    private org.neo4j.graphdb.Node connectWithParent(org.neo4j.graphdb.Node thisNode, ParentAndChildPair parentAndChildPair, org.neo4j.graphdb.Node last) {\n        final org.neo4j.graphdb.Node parent = parentAndChildPair.getParent();\n        final org.neo4j.graphdb.Node previousChild = parentAndChildPair.getPreviousChild();\n\n        last.createRelationshipTo(thisNode, RelationshipType.withName(\"NEXT\"));\n        thisNode.createRelationshipTo(parent, RelationshipType.withName(\"IS_CHILD_OF\"));\n        if (previousChild ==null) {\n            thisNode.createRelationshipTo(parent, RelationshipType.withName(\"FIRST_CHILD_OF\"));\n        } else {\n            previousChild.createRelationshipTo(thisNode, RelationshipType.withName(\"NEXT_SIBLING\"));\n        }\n        parentAndChildPair.setPreviousChild(thisNode);\n        last = thisNode;\n        return last;\n    }\n}\n",
        "human_patch_code": "package apoc.load;\n\nimport apoc.util.FileUtils;\nimport apoc.result.MapResult;\nimport apoc.result.NodeResult;\nimport apoc.util.Util;\nimport org.apache.commons.lang3.StringUtils;\nimport org.neo4j.graphdb.GraphDatabaseService;\nimport org.neo4j.graphdb.Label;\nimport org.neo4j.graphdb.RelationshipType;\nimport org.neo4j.logging.Log;\nimport org.neo4j.procedure.*;\nimport org.w3c.dom.CharacterData;\nimport org.w3c.dom.*;\n\nimport javax.xml.namespace.QName;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.*;\nimport java.util.stream.Stream;\n\nimport static apoc.util.Util.cleanUrl;\nimport static javax.xml.stream.XMLStreamConstants.*;\n\npublic class Xml {\n\n    public static final XMLInputFactory FACTORY = XMLInputFactory.newFactory();\n\n    @Context\n    public GraphDatabaseService db;\n\n    @Context\n    public Log log;\n\n    @Procedure\n    @Description(\"apoc.load.xml('http://example.com/test.xml', 'xPath',config, false) YIELD value as doc CREATE (p:Person) SET p.name = doc.name load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _childrenx fields.\")\n    public Stream<MapResult> xml(@Name(\"url\") String url, @Name(value = \"path\", defaultValue = \"/\") String path, @Name(value = \"config\",defaultValue = \"{}\") Map<String, Object> config, @Name(value = \"simple\", defaultValue = \"false\") boolean simpleMode) throws Exception {\n        return xmlXpathToMapResult(url, simpleMode, path ,config);\n    }\n\n    @Procedure(deprecatedBy = \"apoc.load.xml\")\n    @Deprecated\n    @Description(\"apoc.load.xmlSimple('http://example.com/test.xml') YIELD value as doc CREATE (p:Person) SET p.name = doc.name load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _children fields. This method does intentionally not work with XML mixed content.\")\n    public Stream<MapResult> xmlSimple(@Name(\"url\") String url) throws Exception {\n        return xmlToMapResult(url, true);\n    }\n\n    private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n        if (config == null) config = Collections.emptyMap();\n        boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n        List<MapResult> result = new ArrayList<>();\n        try {\n            DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n            documentBuilderFactory.setNamespaceAware(true);\n            documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n            documentBuilderFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n\n            FileUtils.checkReadAllowed(url);\n\n            Map<String, Object> headers = (Map) config.getOrDefault( \"headers\", Collections.emptyMap() );\n\n            Document doc = documentBuilder.parse(Util.openInputStream(url, headers, null));\n            XPathFactory xPathFactory = XPathFactory.newInstance();\n\n            XPath xPath = xPathFactory.newXPath();\n\n            path = StringUtils.isEmpty(path) ? \"/\" : path;\n            XPathExpression xPathExpression = xPath.compile(path);\n            NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n\n            for (int i = 0; i < nodeList.getLength(); i++) {\n                final Deque<Map<String, Object>> stack = new LinkedList<>();\n\n                handleNode(stack, nodeList.item(i), simpleMode);\n                for (int index = 0; index < stack.size(); index++) {\n                    result.add(new MapResult(stack.pollFirst()));\n                }\n            }\n        }\n        catch (FileNotFoundException e){\n            if(!failOnError)\n                return Stream.of(new MapResult(Collections.emptyMap()));\n            else\n                throw new FileNotFoundException(e.getMessage());\n        }\n        catch (Exception e){\n            if(!failOnError)\n                return Stream.of(new MapResult(Collections.emptyMap()));\n            else\n                throw new Exception(e);\n        }\n        return result.stream();\n    }\n\n    private Stream<MapResult> xmlToMapResult(@Name(\"url\") String url, boolean simpleMode) {\n        try {\n            XMLStreamReader reader = getXMLStreamReaderFromUrl(url);\n            final Deque<Map<String, Object>> stack = new LinkedList<>();\n            do {\n                handleXmlEvent(stack, reader, simpleMode);\n            } while (proceedReader(reader));\n\n            return Stream.of(new MapResult(stack.getFirst()));\n        } catch (IOException | XMLStreamException e) {\n            throw new RuntimeException(\"Can't read url \" + cleanUrl(url) + \" as XML\", e);\n        }\n    }\n\n    private XMLStreamReader getXMLStreamReaderFromUrl(String url) throws IOException, XMLStreamException {\n        FileUtils.checkReadAllowed(url);\n        URLConnection urlConnection = new URL(url).openConnection();\n        FACTORY.setProperty(XMLInputFactory.IS_COALESCING, true);\n        return FACTORY.createXMLStreamReader(urlConnection.getInputStream());\n    }\n\n\n    private boolean proceedReader(XMLStreamReader reader) throws XMLStreamException {\n        if (reader.hasNext()) {\n            do {\n                reader.next();\n            } while (reader.isWhiteSpace());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    private void handleXmlEvent(Deque<Map<String, Object>> stack, XMLStreamReader reader, boolean simpleMode) throws XMLStreamException {\n\n        Map<String, Object> elementMap;\n        switch (reader.getEventType()) {\n            case START_DOCUMENT:\n            case END_DOCUMENT:\n                // intentionally empty\n                break;\n            case START_ELEMENT:\n                int attributes = reader.getAttributeCount();\n                elementMap = new LinkedHashMap<>(attributes + 3);\n                elementMap.put(\"_type\", reader.getLocalName());\n                for (int a = 0; a < attributes; a++) {\n                    elementMap.put(reader.getAttributeLocalName(a), reader.getAttributeValue(a));\n                }\n                if (!stack.isEmpty()) {\n                    final Map<String, Object> last = stack.getLast();\n                    String key = simpleMode ? \"_\" + reader.getLocalName() : \"_children\";\n                    amendToList(last, key, elementMap);\n                }\n                stack.addLast(elementMap);\n                break;\n\n            case END_ELEMENT:\n                elementMap = stack.size() > 1 ? stack.removeLast() : stack.getLast();\n\n                // maintain compatibility with previous implementation:\n                // if we only have text childs, return them in \"_text\" and not in \"_children\"\n                Object children = elementMap.get(\"_children\");\n                if (children != null) {\n                    if ((children instanceof String) || collectionIsAllStrings(children)) {\n                        elementMap.put(\"_text\", children);\n                        elementMap.remove(\"_children\");\n                    }\n                }\n                break;\n\n            case CHARACTERS:\n                final String text = reader.getText().trim();\n                if (!text.isEmpty()) {\n                    Map<String, Object> map = stack.getLast();\n                    amendToList(map, \"_children\", text);\n                }\n                break;\n            default:\n                throw new RuntimeException(\"dunno know how to handle xml event type \" + reader.getEventType());\n        }\n    }\n\n    private void handleNode(Deque<Map<String, Object>> stack, Node node, boolean simpleMode) {\n\n        // Handle document node\n        if (node.getNodeType() == Node.DOCUMENT_NODE) {\n            NodeList children = node.getChildNodes();\n            for (int i = 0; i < children.getLength(); i++) {\n                if (children.item(i).getLocalName() != null) {\n                    handleNode(stack, children.item(i), simpleMode);\n                    return;\n                }\n            }\n        }\n\n        Map<String, Object> elementMap = new LinkedHashMap<>();\n        handleTypeAndAttributes(node, elementMap);\n\n        // Set children\n        NodeList children = node.getChildNodes();\n        int count = 0;\n        for (int i = 0; i < children.getLength(); i++) {\n            Node child = children.item(i);\n\n            // This is to deal with text between xml tags for example new line characters\n            if (child.getNodeType() != Node.TEXT_NODE && child.getNodeType() != Node.CDATA_SECTION_NODE) {\n                handleNode(stack, child, simpleMode);\n                count++;\n            } else {\n                // Deal with text nodes\n                handleTextNode(child, elementMap);\n            }\n        }\n\n        if (children.getLength() > 1) {\n            if (!stack.isEmpty()) {\n                List<Object> nodeChildren = new ArrayList<>();\n                for (int i = 0; i < count; i++) {\n                    nodeChildren.add(stack.pollLast());\n                }\n                String key = simpleMode ? \"_\" + node.getLocalName() : \"_children\";\n                Collections.reverse(nodeChildren);\n                if (nodeChildren.size() > 0) {\n                    // Before adding the children we need to handle mixed text\n                    Object text = elementMap.get(\"_text\");\n                    if (text instanceof List) {\n                        for (Object element : (List) text) {\n                            nodeChildren.add(element);\n                        }\n                        elementMap.remove(\"_text\");\n                    }\n\n                    elementMap.put(key, nodeChildren);\n                }\n            }\n        }\n\n        if (!elementMap.isEmpty()) {\n            stack.addLast(elementMap);\n        }\n    }\n\n    /**\n     * Collects type and attributes for the node\n     *\n     * @param node\n     * @param elementMap\n     */\n    private void handleTypeAndAttributes(Node node, Map<String, Object> elementMap) {\n        // Set type\n        if (node.getLocalName() != null) {\n            elementMap.put(\"_type\", node.getLocalName());\n        }\n\n        // Set the attributes\n        if (node.getAttributes() != null) {\n            NamedNodeMap attributeMap = node.getAttributes();\n            for (int i = 0; i < attributeMap.getLength(); i++) {\n                Node attribute = attributeMap.item(i);\n                elementMap.put(attribute.getNodeName(), attribute.getNodeValue());\n            }\n        }\n    }\n\n    /**\n     * Handle TEXT nodes and CDATA nodes\n     *\n     * @param node\n     * @param elementMap\n     */\n    private void handleTextNode(Node node, Map<String, Object> elementMap) {\n        Object text = \"\";\n        int nodeType = node.getNodeType();\n        switch (nodeType) {\n            case Node.TEXT_NODE:\n                text = normalizeText(node.getNodeValue());\n                break;\n            case Node.CDATA_SECTION_NODE:\n                text = normalizeText(((CharacterData) node).getData());\n                break;\n            default:\n                break;\n        }\n\n        // If the text is valid ...\n        if (!StringUtils.isEmpty(text.toString())) {\n            // We check if we have already collected some text previously\n            Object previousText = elementMap.get(\"_text\");\n            if (previousText != null) {\n                // If we just have a \"_text\" key than we need to collect to a List\n                text = Arrays.asList(previousText.toString(), text);\n            }\n            elementMap.put(\"_text\", text);\n        }\n    }\n\n    /**\n     * Remove trailing whitespaces and new line characters\n     *\n     * @param text\n     * @return\n     */\n    private String normalizeText(String text) {\n        String[] tokens = StringUtils.split(text, \"\\n\");\n        for (int i = 0; i < tokens.length; i++) {\n            tokens[i] = tokens[i].trim();\n        }\n\n        return StringUtils.join(tokens, \" \").trim();\n    }\n\n    private boolean collectionIsAllStrings(Object collection) {\n        if (collection instanceof Collection) {\n            return ((Collection<Object>) collection).stream().allMatch(o -> o instanceof String);\n        } else {\n            return false;\n        }\n    }\n\n    private void amendToList(Map<String, Object> map, String key, Object value) {\n        final Object element = map.get(key);\n        if (element == null) {\n            map.put(key, value);\n        } else {\n            if (element instanceof List) {\n                ((List) element).add(value);\n            } else {\n                List<Object> list = new LinkedList<>();\n                list.add(element);\n                list.add(value);\n                map.put(key, list);\n            }\n        }\n    }\n\n    public static class ParentAndChildPair {\n        private org.neo4j.graphdb.Node parent;\n        private org.neo4j.graphdb.Node previousChild=null;\n\n        public ParentAndChildPair(org.neo4j.graphdb.Node parent) {\n            this.parent = parent;\n        }\n\n        public org.neo4j.graphdb.Node getParent() {\n            return parent;\n        }\n\n        public void setParent(org.neo4j.graphdb.Node parent) {\n            this.parent = parent;\n        }\n\n        public org.neo4j.graphdb.Node getPreviousChild() {\n            return previousChild;\n        }\n\n        public void setPreviousChild(org.neo4j.graphdb.Node previousChild) {\n            this.previousChild = previousChild;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            ParentAndChildPair that = (ParentAndChildPair) o;\n            return parent.equals(that.parent);\n        }\n\n        @Override\n        public int hashCode() {\n            return parent.hashCode();\n        }\n    }\n\n    private static class XmlImportConfig {\n\n        private boolean createNextWordRelationship = false;\n\n        public boolean isCreateNextWordRelationship() {\n            return createNextWordRelationship;\n        }\n\n        public XmlImportConfig(Map<String,Object> config) {\n            Boolean _createNextWordRelationship = (Boolean) config.get(\"createNextWordRelationships\");\n            if (_createNextWordRelationship!=null) {\n                createNextWordRelationship = _createNextWordRelationship;\n            }\n        }\n\n    }\n\n    @Procedure(mode = Mode.WRITE, value = \"apoc.xml.import\")\n    public Stream<NodeResult> importToGraph(@Name(\"url\") String url, @Name(value=\"config\", defaultValue = \"{}\") Map<String, Object> config) throws IOException, XMLStreamException {\n        final XMLStreamReader xml = getXMLStreamReaderFromUrl(url);\n\n        XmlImportConfig importConfig = new XmlImportConfig(config);\n        //TODO: make labels, reltypes and magic properties configurable\n\n        // stores parents and their most recent child\n        Deque<ParentAndChildPair> parents = new ArrayDeque<>();\n        org.neo4j.graphdb.Node root = db.createNode(Label.label(\"XmlDocument\"));\n        setPropertyIfNotNull(root, \"_xmlVersion\", xml.getVersion());\n        setPropertyIfNotNull(root, \"_xmlEncoding\", xml.getEncoding());\n        root.setProperty(\"url\", url);\n        parents.push(new ParentAndChildPair(root));\n        org.neo4j.graphdb.Node last = root;\n        org.neo4j.graphdb.Node lastWord = root;\n\n        while (xml.hasNext()) {\n            xml.next();\n\n            switch (xml.getEventType()) {\n                case XMLStreamConstants.START_DOCUMENT:\n                    // xmlsteamreader starts off by definition at START_DOCUMENT prior to call next() - so ignore this one\n                    break;\n\n                case XMLStreamConstants.PROCESSING_INSTRUCTION:\n                    org.neo4j.graphdb.Node pi = db.createNode(Label.label(\"XmlProcessingInstruction\"));\n                    pi.setProperty(\"_piData\", xml.getPIData());\n                    pi.setProperty(\"_piTarget\", xml.getPITarget());\n                    last = connectWithParent(pi, parents.peek(), last);\n                    break;\n\n                case XMLStreamConstants.START_ELEMENT:\n                    final QName qName = xml.getName();\n                    final org.neo4j.graphdb.Node tag = db.createNode(Label.label(\"XmlTag\"));\n                    tag.setProperty(\"_name\", qName.getLocalPart());\n                    for (int i=0; i<xml.getAttributeCount(); i++) {\n                        tag.setProperty(xml.getAttributeLocalName(i), xml.getAttributeValue(i));\n                    }\n\n                    last = connectWithParent(tag, parents.peek(), last);\n                    parents.push(new ParentAndChildPair(tag));\n                    break;\n\n                case XMLStreamConstants.CHARACTERS:\n                    String text = xml.getText().trim();\n                    String[] words = text.split(\"\\\\s\");\n                    for (int i = 0; i < words.length; i++) {\n                        final String currentWord = words[i];\n                        if (!currentWord.isEmpty()) {\n                            org.neo4j.graphdb.Node word = db.createNode(Label.label(\"XmlWord\"));\n                            word.setProperty(\"text\", currentWord);\n                            last = connectWithParent(word, parents.peek(), last);\n                            if (importConfig.isCreateNextWordRelationship()) {\n                                lastWord.createRelationshipTo(word, RelationshipType.withName(\"NEXT_WORD\"));\n                                lastWord = word;\n                            }\n                        }\n                    }\n                    break;\n\n                case XMLStreamConstants.END_ELEMENT:\n                    ParentAndChildPair parent = parents.pop();\n                    if (parent.getPreviousChild()!=null) {\n                        parent.getPreviousChild().createRelationshipTo(parent.getParent(), RelationshipType.withName(\"LAST_CHILD_OF\"));\n                    }\n                    break;\n\n                case XMLStreamConstants.END_DOCUMENT:\n                    parents.pop();\n                    break;\n\n                case XMLStreamConstants.COMMENT:\n                case XMLStreamConstants.SPACE:\n                    // intentionally do nothing\n                    break;\n                default:\n                    log.warn(\"xml file contains a {} type structure - ignoring this.\", xml.getEventType());\n            }\n\n        }\n        if (!parents.isEmpty()) {\n            throw new IllegalStateException(\"non empty parents\");\n        }\n        return Stream.of(new NodeResult(root));\n    }\n\n    private void setPropertyIfNotNull(org.neo4j.graphdb.Node root, String propertyKey, Object value) {\n        if (value!=null) {\n            root.setProperty(propertyKey, value);\n        }\n    }\n\n    private org.neo4j.graphdb.Node connectWithParent(org.neo4j.graphdb.Node thisNode, ParentAndChildPair parentAndChildPair, org.neo4j.graphdb.Node last) {\n        final org.neo4j.graphdb.Node parent = parentAndChildPair.getParent();\n        final org.neo4j.graphdb.Node previousChild = parentAndChildPair.getPreviousChild();\n\n        last.createRelationshipTo(thisNode, RelationshipType.withName(\"NEXT\"));\n        thisNode.createRelationshipTo(parent, RelationshipType.withName(\"IS_CHILD_OF\"));\n        if (previousChild ==null) {\n            thisNode.createRelationshipTo(parent, RelationshipType.withName(\"FIRST_CHILD_OF\"));\n        } else {\n            previousChild.createRelationshipTo(thisNode, RelationshipType.withName(\"NEXT_SIBLING\"));\n        }\n        parentAndChildPair.setPreviousChild(thisNode);\n        last = thisNode;\n        return last;\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-62": {
    "vul_id": "VUL4J-62",
    "cve_id": "CVE-2018-18389",
    "project": "neo4j_neo4j",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl enterprise/security -Dtest=org.neo4j.server.security.enterprise.auth.integration.bolt.LdapAuthIT#shouldFailLoginWrongPasswordWithLdapOnlyUsingStartTls",
    "test_all_cmd": "mvn failsafe:integration-test",
    "human_patch_url": "https://github.com/neo4j/neo4j/commit/46de5d01ae2741ffe04c36270fc62c6d490f65c9",
    "vulnerable_files": [
      {
        "file_path": "enterprise/security/src/main/java/org/neo4j/server/security/enterprise/auth/LdapRealm.java",
        "file_name": "LdapRealm.java",
        "vulnerable_code": "/*\n * Copyright (c) 2002-2018 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j Enterprise Edition. The included source\n * code can be redistributed and/or modified under the terms of the\n * GNU AFFERO GENERAL PUBLIC LICENSE Version 3\n * (http://www.fsf.org/licensing/licenses/agpl-3.0.html) with the\n * Commons Clause, as found in the associated LICENSE.txt file.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * Neo4j object code can be licensed independently from the source\n * under separate terms from the AGPL. Inquiries can be directed to:\n * licensing@neo4j.com\n *\n * More information is also available at:\n * https://neo4j.com/licensing/\n */\npackage org.neo4j.server.security.enterprise.auth;\n\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.credential.AllowAllCredentialsMatcher;\nimport org.apache.shiro.authz.AuthorizationException;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.cache.Cache;\nimport org.apache.shiro.crypto.hash.SimpleHash;\nimport org.apache.shiro.realm.ldap.DefaultLdapRealm;\nimport org.apache.shiro.realm.ldap.JndiLdapContextFactory;\nimport org.apache.shiro.realm.ldap.LdapContextFactory;\nimport org.apache.shiro.realm.ldap.LdapUtils;\nimport org.apache.shiro.subject.PrincipalCollection;\n\nimport java.io.IOException;\nimport java.net.ConnectException;\nimport java.net.SocketTimeoutException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.naming.AuthenticationException;\nimport javax.naming.CommunicationException;\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport javax.naming.ldap.InitialLdapContext;\nimport javax.naming.ldap.LdapContext;\nimport javax.naming.ldap.StartTlsRequest;\nimport javax.naming.ldap.StartTlsResponse;\n\nimport org.neo4j.graphdb.security.AuthProviderFailedException;\nimport org.neo4j.graphdb.security.AuthProviderTimeoutException;\nimport org.neo4j.graphdb.security.AuthorizationExpiredException;\nimport org.neo4j.internal.kernel.api.security.AuthenticationResult;\nimport org.neo4j.kernel.api.security.AuthToken;\nimport org.neo4j.kernel.api.security.exception.InvalidAuthTokenException;\nimport org.neo4j.kernel.configuration.Config;\nimport org.neo4j.server.security.enterprise.configuration.SecuritySettings;\nimport org.neo4j.server.security.enterprise.log.SecurityLog;\n\nimport static java.lang.String.format;\n\n/**\n * Shiro realm for LDAP based on configuration settings\n */\npublic class LdapRealm extends DefaultLdapRealm implements RealmLifecycle, ShiroAuthorizationInfoProvider\n{\n    private static final String GROUP_DELIMITER = \";\";\n    private static final String KEY_VALUE_DELIMITER = \"=\";\n    private static final String ROLE_DELIMITER = \",\";\n    public static final String LDAP_REALM = \"ldap\";\n\n    private static final String JNDI_LDAP_CONNECT_TIMEOUT = \"com.sun.jndi.ldap.connect.timeout\";\n    private static final String JNDI_LDAP_READ_TIMEOUT = \"com.sun.jndi.ldap.read.timeout\";\n    private static final String JNDI_LDAP_CONNECTION_TIMEOUT_MESSAGE_PART = \"timed out\"; // \"connect timed out\"\n    private static final String JNDI_LDAP_READ_TIMEOUT_MESSAGE_PART = \"timed out\"; // \"LDAP response read timed out\"\n\n    public static final String LDAP_CONNECTION_TIMEOUT_CLIENT_MESSAGE = \"LDAP connection timed out.\";\n    public static final String LDAP_READ_TIMEOUT_CLIENT_MESSAGE = \"LDAP response timed out.\";\n    public static final String LDAP_AUTHORIZATION_FAILURE_CLIENT_MESSAGE = \"LDAP authorization request failed.\";\n    public static final String LDAP_CONNECTION_REFUSED_CLIENT_MESSAGE = \"LDAP connection refused.\";\n\n    private Boolean authenticationEnabled;\n    private Boolean authorizationEnabled;\n    private Boolean useStartTls;\n    private boolean useSAMAccountName;\n    private String userSearchBase;\n    private String userSearchFilter;\n    private List<String> membershipAttributeNames;\n    private Boolean useSystemAccountForAuthorization;\n    private Map<String,Collection<String>> groupToRoleMapping;\n    private final SecurityLog securityLog;\n    private final SecureHasher secureHasher;\n\n    // Parser regex for group-to-role-mapping\n    private static final String KEY_GROUP = \"\\\\s*('(.+)'|\\\"(.+)\\\"|(\\\\S)|(\\\\S.*\\\\S))\\\\s*\";\n    private static final String VALUE_GROUP = \"\\\\s*(.*)\";\n    private Pattern keyValuePattern = Pattern.compile( KEY_GROUP + KEY_VALUE_DELIMITER + VALUE_GROUP );\n\n    public LdapRealm( Config config, SecurityLog securityLog, SecureHasher secureHasher )\n    {\n        super();\n        this.securityLog = securityLog;\n        this.secureHasher = secureHasher;\n        setName( SecuritySettings.LDAP_REALM_NAME );\n        setRolePermissionResolver( PredefinedRolesBuilder.rolePermissionResolver );\n        configureRealm( config );\n        if ( isAuthenticationCachingEnabled() )\n        {\n            setCredentialsMatcher( secureHasher.getHashedCredentialsMatcher() );\n        }\n        else\n        {\n            setCredentialsMatcher( new AllowAllCredentialsMatcher() );\n        }\n    }\n\n    private String withRealm( String template, Object... args )\n    {\n        return \"{LdapRealm}: \" + format( template, args );\n    }\n\n    private String server( JndiLdapContextFactory jndiLdapContextFactory )\n    {\n        return \"'\" + jndiLdapContextFactory.getUrl() + \"'\" +\n                ( useStartTls ? \" using StartTLS\" : \"\" );\n    }\n\n    @Override\n    protected AuthenticationInfo queryForAuthenticationInfo( AuthenticationToken token,\n            LdapContextFactory ldapContextFactory )\n            throws NamingException\n    {\n        if ( authenticationEnabled )\n        {\n            if ( useSAMAccountName )\n            {\n                return queryForAuthenticationInfoSAM( token, ldapContextFactory );\n            }\n            else\n            {\n                String serverString = server( (JndiLdapContextFactory) ldapContextFactory );\n                try\n                {\n                    AuthenticationInfo info =\n                            useStartTls ? queryForAuthenticationInfoUsingStartTls( token, ldapContextFactory )\n                                        : super.queryForAuthenticationInfo( token, ldapContextFactory );\n                    securityLog.debug( withRealm( \"Authenticated user '%s' against %s\", token.getPrincipal(),\n                            serverString ) );\n                    return info;\n                }\n                catch ( Exception e )\n                {\n                    if ( isExceptionAnLdapConnectionTimeout( e ) )\n                    {\n                        throw new AuthProviderTimeoutException( LDAP_CONNECTION_TIMEOUT_CLIENT_MESSAGE, e );\n                    }\n                    else if ( isExceptionAnLdapReadTimeout( e ) )\n                    {\n                        throw new AuthProviderTimeoutException( LDAP_READ_TIMEOUT_CLIENT_MESSAGE, e );\n                    }\n                    else if ( isExceptionConnectionRefused( e ) )\n                    {\n                        throw new AuthProviderFailedException( LDAP_CONNECTION_REFUSED_CLIENT_MESSAGE, e );\n                    }\n                    // This exception will be caught and rethrown by Shiro, and then by us, so we do not need to wrap it here\n                    throw e;\n                }\n            }\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    protected AuthenticationInfo queryForAuthenticationInfoUsingStartTls( AuthenticationToken token,\n            LdapContextFactory ldapContextFactory ) throws NamingException\n    {\n        Object principal = getLdapPrincipal(token);\n        Object credentials = token.getCredentials();\n\n        LdapContext ctx = null;\n\n        try\n        {\n            ctx = getLdapContextUsingStartTls( ldapContextFactory, principal, credentials );\n            return createAuthenticationInfo( token, principal, credentials, ctx );\n        }\n        finally\n        {\n            LdapUtils.closeContext( ctx );\n        }\n    }\n\n    private LdapContext getLdapContextUsingStartTls( LdapContextFactory ldapContextFactory,\n            Object principal, Object credentials ) throws NamingException\n    {\n        JndiLdapContextFactory jndiLdapContextFactory = (JndiLdapContextFactory) ldapContextFactory;\n        Hashtable<String, Object> env = new Hashtable<>();\n        env.put( Context.INITIAL_CONTEXT_FACTORY, jndiLdapContextFactory.getContextFactoryClassName() );\n        env.put( Context.PROVIDER_URL, jndiLdapContextFactory.getUrl() );\n\n        LdapContext ctx = null;\n\n        try\n        {\n            ctx = new InitialLdapContext( env, null );\n\n            StartTlsRequest startTlsRequest = new StartTlsRequest();\n            StartTlsResponse tls = (StartTlsResponse) ctx.extendedOperation( startTlsRequest );\n\n            tls.negotiate();\n\n            ctx.addToEnvironment( Context.SECURITY_AUTHENTICATION,\n                    jndiLdapContextFactory.getAuthenticationMechanism() );\n            ctx.addToEnvironment( Context.SECURITY_PRINCIPAL, principal );\n            ctx.addToEnvironment( Context.SECURITY_CREDENTIALS, credentials );\n\n            return ctx;\n        }\n        catch ( IOException e )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Failed to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), e ) );\n            throw new CommunicationException( e.getMessage() );\n        }\n        catch ( Throwable t )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Unexpected failure to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), t ) );\n            throw t;\n        }\n    }\n\n    @Override\n    protected AuthorizationInfo queryForAuthorizationInfo( PrincipalCollection principals,\n            LdapContextFactory ldapContextFactory ) throws NamingException\n    {\n        if ( authorizationEnabled )\n        {\n            String username = getUsername( principals );\n            if ( username == null )\n            {\n                return null;\n            }\n\n            if ( useSystemAccountForAuthorization )\n            {\n                // Perform context search using the system context\n                LdapContext ldapContext = useStartTls ? getSystemLdapContextUsingStartTls( ldapContextFactory ) :\n                                          ldapContextFactory.getSystemLdapContext();\n\n                Set<String> roleNames;\n                try\n                {\n                    roleNames = findRoleNamesForUser( username, ldapContext );\n                }\n                finally\n                {\n                    LdapUtils.closeContext( ldapContext );\n                }\n\n                return new SimpleAuthorizationInfo( roleNames );\n            }\n            else\n            {\n                // Authorization info is cached during authentication\n                Cache<Object,AuthorizationInfo> authorizationCache = getAuthorizationCache();\n                AuthorizationInfo authorizationInfo = authorizationCache.get( username );\n                if ( authorizationInfo == null )\n                {\n                    // The cached authorization info has expired.\n                    // Since we do not have the subject's credentials we cannot perform a new LDAP search\n                    // for authorization info. Instead we need to fail with a special status,\n                    // so that the client can react by re-authenticating.\n                    throw new AuthorizationExpiredException( \"LDAP authorization info expired.\" );\n                }\n                return authorizationInfo;\n            }\n        }\n        return null;\n    }\n\n    private String getUsername( PrincipalCollection principals )\n    {\n        String username = null;\n        Collection ldapPrincipals = principals.fromRealm( getName() );\n        if ( !ldapPrincipals.isEmpty() )\n        {\n            username = (String) ldapPrincipals.iterator().next();\n        }\n        else if ( useSystemAccountForAuthorization )\n        {\n            username = (String) principals.getPrimaryPrincipal();\n        }\n        return username;\n    }\n\n    private LdapContext getSystemLdapContextUsingStartTls( LdapContextFactory ldapContextFactory )\n            throws NamingException\n    {\n        JndiLdapContextFactory jndiLdapContextFactory = (JndiLdapContextFactory) ldapContextFactory;\n        return getLdapContextUsingStartTls( ldapContextFactory, jndiLdapContextFactory.getSystemUsername(),\n                jndiLdapContextFactory.getSystemPassword() );\n    }\n\n    @Override\n    protected AuthenticationInfo createAuthenticationInfo( AuthenticationToken token, Object ldapPrincipal,\n            Object ldapCredentials, LdapContext ldapContext )\n            throws NamingException\n    {\n        // If authorization is enabled but useSystemAccountForAuthorization is disabled, we should perform\n        // the search for groups directly here while the user's authenticated ldap context is open.\n        if ( authorizationEnabled && !useSystemAccountForAuthorization )\n        {\n            String username = (String) token.getPrincipal();\n            Set<String> roleNames = findRoleNamesForUser( username, ldapContext );\n            cacheAuthorizationInfo( username, roleNames );\n        }\n\n        if ( isAuthenticationCachingEnabled() )\n        {\n            SimpleHash hashedCredentials = secureHasher.hash( ((String) token.getCredentials()).getBytes() );\n            return new ShiroAuthenticationInfo( token.getPrincipal(), hashedCredentials.getBytes(),\n                    hashedCredentials.getSalt(), getName(), AuthenticationResult.SUCCESS );\n        }\n        else\n        {\n            return new ShiroAuthenticationInfo( token.getPrincipal(), getName(), AuthenticationResult.SUCCESS );\n        }\n    }\n\n    @Override\n    public boolean supports( AuthenticationToken token )\n    {\n        return supportsSchemeAndRealm( token );\n    }\n\n    private boolean supportsSchemeAndRealm( AuthenticationToken token )\n    {\n        try\n        {\n            if ( token instanceof ShiroAuthToken )\n            {\n                ShiroAuthToken shiroAuthToken = (ShiroAuthToken) token;\n                return shiroAuthToken.getScheme().equals( AuthToken.BASIC_SCHEME ) &&\n                       (shiroAuthToken.supportsRealm( LDAP_REALM ));\n            }\n            return false;\n        }\n        catch ( InvalidAuthTokenException e )\n        {\n            return false;\n        }\n    }\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo( PrincipalCollection principals )\n    {\n        try\n        {\n            AuthorizationInfo info = super.doGetAuthorizationInfo( principals );\n            securityLog.debug( withRealm( \"Queried for authorization info for user '%s'\",\n                    principals.getPrimaryPrincipal() ) );\n            return info;\n        }\n        catch ( AuthorizationException e )\n        {\n            securityLog.warn( withRealm( \"Failed to get authorization info: '%s' caused by '%s'\",\n                    e.getMessage(), e.getCause().getMessage() ) );\n            return null;\n        }\n    }\n\n    // Unfortunately we need to identify timeouts by looking at the exception messages, which is not very robust.\n    // To make it slightly more robust we look for a key part of the actual message\n    private boolean isExceptionAnLdapReadTimeout( Exception e )\n    {\n        return e instanceof NamingException &&\n               e.getMessage().contains( JNDI_LDAP_READ_TIMEOUT_MESSAGE_PART );\n    }\n\n    private boolean isExceptionAnLdapConnectionTimeout( Exception e )\n    {\n        return e instanceof CommunicationException &&\n               (((CommunicationException) e).getRootCause() instanceof SocketTimeoutException ||\n                ((CommunicationException) e).getRootCause().getMessage().contains(\n                        JNDI_LDAP_CONNECTION_TIMEOUT_MESSAGE_PART ) );\n    }\n\n    private boolean isExceptionConnectionRefused( Exception e )\n    {\n        return e instanceof CommunicationException &&\n                ((CommunicationException) e).getRootCause() instanceof ConnectException;\n    }\n\n    private boolean isAuthorizationExceptionAnLdapReadTimeout( AuthorizationException e )\n    {\n        // Shiro's doGetAuthorizationInfo() wraps a NamingException in an AuthorizationException\n        return e.getCause() != null && e.getCause() instanceof NamingException &&\n               e.getCause().getMessage().contains( JNDI_LDAP_READ_TIMEOUT_MESSAGE_PART );\n    }\n\n    private void cacheAuthorizationInfo( String username, Set<String> roleNames )\n    {\n        // Use the existing authorizationCache in our base class\n        Cache<Object, AuthorizationInfo> authorizationCache = getAuthorizationCache();\n        authorizationCache.put( username, new SimpleAuthorizationInfo( roleNames ) );\n    }\n\n    private void configureRealm( Config config )\n    {\n        JndiLdapContextFactory contextFactory = new JndiLdapContextFactory();\n        Map<String,Object> environment = contextFactory.getEnvironment();\n        Long connectionTimeoutMillis = config.get( SecuritySettings.ldap_connection_timeout ).toMillis();\n        Long readTimeoutMillis = config.get( SecuritySettings.ldap_read_timeout ).toMillis();\n        environment.put( JNDI_LDAP_CONNECT_TIMEOUT, connectionTimeoutMillis.toString() );\n        environment.put( JNDI_LDAP_READ_TIMEOUT, readTimeoutMillis.toString() );\n        contextFactory.setEnvironment( environment );\n        contextFactory.setUrl( parseLdapServerUrl( config.get( SecuritySettings.ldap_server ) ) );\n        contextFactory.setAuthenticationMechanism( config.get( SecuritySettings.ldap_authentication_mechanism ) );\n        contextFactory.setReferral( config.get( SecuritySettings.ldap_referral ) );\n        contextFactory.setSystemUsername( config.get( SecuritySettings.ldap_authorization_system_username ) );\n        contextFactory.setSystemPassword( config.get( SecuritySettings.ldap_authorization_system_password ) );\n        contextFactory.setPoolingEnabled( config.get( SecuritySettings.ldap_authorization_connection_pooling ) );\n\n        setContextFactory( contextFactory );\n\n        String userDnTemplate = config.get( SecuritySettings.ldap_authentication_user_dn_template );\n        if ( userDnTemplate != null )\n        {\n            setUserDnTemplate( userDnTemplate );\n        }\n\n        authenticationEnabled = config.get( SecuritySettings.ldap_authentication_enabled );\n        authorizationEnabled = config.get( SecuritySettings.ldap_authorization_enabled );\n        useStartTls = config.get( SecuritySettings.ldap_use_starttls );\n\n        userSearchBase = config.get( SecuritySettings.ldap_authorization_user_search_base );\n        userSearchFilter = config.get( SecuritySettings.ldap_authorization_user_search_filter );\n        useSAMAccountName = config.get( SecuritySettings.ldap_authentication_use_samaccountname );\n        membershipAttributeNames = config.get( SecuritySettings.ldap_authorization_group_membership_attribute_names );\n        useSystemAccountForAuthorization = config.get( SecuritySettings.ldap_authorization_use_system_account );\n        groupToRoleMapping =\n                parseGroupToRoleMapping( config.get( SecuritySettings.ldap_authorization_group_to_role_mapping ) );\n\n        setAuthenticationCachingEnabled( config.get( SecuritySettings.ldap_authentication_cache_enabled ) );\n        setAuthorizationCachingEnabled( true );\n    }\n\n    private String parseLdapServerUrl( String rawLdapServer )\n    {\n        return (rawLdapServer == null) ? null :\n               rawLdapServer.contains( \"://\" ) ? rawLdapServer : \"ldap://\" + rawLdapServer;\n    }\n\n    private Map<String,Collection<String>> parseGroupToRoleMapping( String groupToRoleMappingString )\n    {\n        Map<String,Collection<String>> map = new HashMap<>();\n\n        if ( groupToRoleMappingString != null )\n        {\n            for ( String groupAndRoles : groupToRoleMappingString.split( GROUP_DELIMITER ) )\n            {\n                if ( !groupAndRoles.isEmpty() )\n                {\n                    Matcher matcher = keyValuePattern.matcher( groupAndRoles );\n                    if ( !(matcher.find() && matcher.groupCount() == 6) )\n                    {\n                        String errorMessage = format( \"Failed to parse setting %s: wrong number of fields\",\n                                SecuritySettings.ldap_authorization_group_to_role_mapping.name() );\n                        throw new IllegalArgumentException( errorMessage );\n                    }\n\n                    String group = matcher.group(2) != null ? matcher.group(2) :\n                                   matcher.group(3) != null ? matcher.group(3) :\n                                   matcher.group(4) != null ? matcher.group(4) :\n                                   matcher.group(5) != null ? matcher.group(5) : \"\";\n\n                    if ( group.isEmpty() )\n                    {\n                        String errorMessage = format( \"Failed to parse setting %s: empty group name\",\n                                SecuritySettings.ldap_authorization_group_to_role_mapping.name() );\n                        throw new IllegalArgumentException( errorMessage );\n                    }\n                    Collection<String> roleList = new ArrayList<>();\n                    for ( String role : matcher.group(6).trim().split( ROLE_DELIMITER ) )\n                    {\n                        if ( !role.isEmpty() )\n                        {\n                            roleList.add( role );\n                        }\n                    }\n                    // We only support case-insensitive comparison of group DNs\n                    map.put( group.toLowerCase(), roleList );\n                }\n            }\n        }\n\n        return map;\n    }\n\n    private AuthenticationInfo queryForAuthenticationInfoSAM(\n            AuthenticationToken token, LdapContextFactory ldapContextFactory ) throws NamingException\n    {\n        Object principal = token.getPrincipal();\n        Object credentials = token.getCredentials();\n\n        LdapContext ctx = null;\n        try\n        {\n            ctx = useStartTls ? getSystemLdapContextUsingStartTls( ldapContextFactory ) :\n                                      ldapContextFactory.getSystemLdapContext();\n            String[] attrs = {\"cn\"};\n            SearchControls searchCtls = new SearchControls( SearchControls.SUBTREE_SCOPE, 1, 0, attrs, false, false );\n            Object[] searchArguments = new Object[]{principal};\n            String filter = \"sAMAccountName={0}\";\n            NamingEnumeration<SearchResult> search = ctx.search( userSearchBase, filter, searchArguments, searchCtls );\n            if ( search.hasMore() )\n            {\n                final SearchResult next = search.next();\n                String loginUser = next.getNameInNamespace();\n                if ( search.hasMore() )\n                {\n                    securityLog.error( \"More than one user matching: \" + principal );\n                    throw new AuthenticationException( \"More than one user matching: \" + principal );\n                }\n                else\n                {\n                    LdapContext ctx2 = ldapContextFactory.getLdapContext( loginUser, credentials );\n                    LdapUtils.closeContext( ctx2 );\n                }\n            }\n            else\n            {\n                throw new AuthenticationException( \"No user matching: \" + principal );\n            }\n            return createAuthenticationInfo( token, principal, credentials, ctx );\n        }\n        finally\n        {\n            LdapUtils.closeContext( ctx );\n        }\n    }\n\n    // TODO: Extract to an LdapAuthorizationStrategy ? This (\"group by attribute\") is one of multiple possible strategies\n    Set<String> findRoleNamesForUser( String username, LdapContext ldapContext ) throws NamingException\n    {\n        Set<String> roleNames = new LinkedHashSet<>();\n\n        SearchControls searchCtls = new SearchControls();\n        searchCtls.setSearchScope( SearchControls.SUBTREE_SCOPE );\n        searchCtls.setReturningAttributes( membershipAttributeNames.toArray( new String[1] ) );\n\n        // Use search argument to prevent potential code injection\n        Object[] searchArguments = new Object[]{username};\n\n        NamingEnumeration result = ldapContext.search( userSearchBase, userSearchFilter, searchArguments, searchCtls );\n\n        if ( result.hasMoreElements() )\n        {\n            SearchResult searchResult = (SearchResult) result.next();\n\n            if ( result.hasMoreElements() )\n            {\n                securityLog.warn(\n                        securityLog.isDebugEnabled() ?\n                        withRealm(\n                            \"LDAP user search for user principal '%s' is ambiguous. The first match that will \" +\n                                            \"be checked for group membership is '%s' but the search also matches '%s'. \" +\n                                            \"Please check your LDAP realm configuration.\",\n                            username, searchResult.toString(), result.next().toString() )\n                        :\n                        withRealm(\n                            \"LDAP user search for user principal '%s' is ambiguous. The search matches more \" +\n                                            \"than one entry. Please check your LDAP realm configuration.\",\n                            username )\n                    );\n            }\n\n            Attributes attributes = searchResult.getAttributes();\n            if ( attributes != null )\n            {\n                NamingEnumeration attributeEnumeration = attributes.getAll();\n                while ( attributeEnumeration.hasMore() )\n                {\n                    Attribute attribute = (Attribute) attributeEnumeration.next();\n                    String attributeId = attribute.getID();\n                    if ( membershipAttributeNames.stream().anyMatch( attributeId::equalsIgnoreCase ) )\n                    {\n                        Collection<String> groupNames = LdapUtils.getAllAttributeValues( attribute );\n                        Collection<String> rolesForGroups = getRoleNamesForGroups( groupNames );\n                        roleNames.addAll( rolesForGroups );\n                    }\n                }\n            }\n        }\n        return roleNames;\n    }\n\n    private void assertValidUserSearchSettings()\n    {\n        boolean proceedWithSearch = true;\n\n        if ( userSearchBase == null || userSearchBase.isEmpty() )\n        {\n            securityLog.error( \"LDAP user search base is empty.\" );\n            proceedWithSearch = false;\n        }\n        if ( userSearchFilter == null || !userSearchFilter.contains( \"{0}\" ) )\n        {\n            securityLog.warn( \"LDAP user search filter does not contain the argument placeholder {0}, \" +\n                    \"so the search result will be independent of the user principal.\" );\n        }\n        if ( membershipAttributeNames == null || membershipAttributeNames.isEmpty() )\n        {\n            // If we don't have any attributes to look for we will never find anything\n            securityLog.error( \"LDAP group membership attribute names are empty. Authorization will not be possible.\" );\n            proceedWithSearch = false;\n        }\n\n        if ( !proceedWithSearch )\n        {\n            throw new IllegalArgumentException( \"Illegal LDAP user search settings, see security log for details.\" );\n        }\n    }\n\n    private Collection<String> getRoleNamesForGroups( Collection<String> groupNames )\n    {\n        Collection<String> roles = new ArrayList<>();\n        for ( String group : groupNames )\n        {\n            Collection<String> rolesForGroup = groupToRoleMapping.get( group.toLowerCase() );\n            if ( rolesForGroup != null )\n            {\n                roles.addAll( rolesForGroup );\n            }\n        }\n        return roles;\n    }\n\n    // Exposed for testing\n    Map<String,Collection<String>> getGroupToRoleMapping()\n    {\n        return groupToRoleMapping;\n    }\n\n    @Override\n    public void initialize()\n    {\n        if ( authorizationEnabled )\n        {\n            // For some combinations of settings we will never find anything\n            assertValidUserSearchSettings();\n        }\n    }\n\n    @Override\n    public void start()\n    {\n    }\n\n    @Override\n    public void stop()\n    {\n    }\n\n    @Override\n    public void shutdown()\n    {\n    }\n\n    @Override\n    public AuthorizationInfo getAuthorizationInfoSnapshot( PrincipalCollection principalCollection )\n    {\n        return getAuthorizationInfo( principalCollection );\n    }\n}\n",
        "human_patch_code": "/*\n * Copyright (c) 2002-2018 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j Enterprise Edition. The included source\n * code can be redistributed and/or modified under the terms of the\n * GNU AFFERO GENERAL PUBLIC LICENSE Version 3\n * (http://www.fsf.org/licensing/licenses/agpl-3.0.html) with the\n * Commons Clause, as found in the associated LICENSE.txt file.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * Neo4j object code can be licensed independently from the source\n * under separate terms from the AGPL. Inquiries can be directed to:\n * licensing@neo4j.com\n *\n * More information is also available at:\n * https://neo4j.com/licensing/\n */\npackage org.neo4j.server.security.enterprise.auth;\n\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.credential.AllowAllCredentialsMatcher;\nimport org.apache.shiro.authz.AuthorizationException;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.cache.Cache;\nimport org.apache.shiro.crypto.hash.SimpleHash;\nimport org.apache.shiro.realm.ldap.DefaultLdapRealm;\nimport org.apache.shiro.realm.ldap.JndiLdapContextFactory;\nimport org.apache.shiro.realm.ldap.LdapContextFactory;\nimport org.apache.shiro.realm.ldap.LdapUtils;\nimport org.apache.shiro.subject.PrincipalCollection;\n\nimport java.io.IOException;\nimport java.net.ConnectException;\nimport java.net.SocketTimeoutException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.naming.AuthenticationException;\nimport javax.naming.CommunicationException;\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport javax.naming.ldap.InitialLdapContext;\nimport javax.naming.ldap.LdapContext;\nimport javax.naming.ldap.StartTlsRequest;\nimport javax.naming.ldap.StartTlsResponse;\n\nimport org.neo4j.graphdb.security.AuthProviderFailedException;\nimport org.neo4j.graphdb.security.AuthProviderTimeoutException;\nimport org.neo4j.graphdb.security.AuthorizationExpiredException;\nimport org.neo4j.internal.kernel.api.security.AuthenticationResult;\nimport org.neo4j.kernel.api.security.AuthToken;\nimport org.neo4j.kernel.api.security.exception.InvalidAuthTokenException;\nimport org.neo4j.kernel.configuration.Config;\nimport org.neo4j.server.security.enterprise.configuration.SecuritySettings;\nimport org.neo4j.server.security.enterprise.log.SecurityLog;\n\nimport static java.lang.String.format;\n\n/**\n * Shiro realm for LDAP based on configuration settings\n */\npublic class LdapRealm extends DefaultLdapRealm implements RealmLifecycle, ShiroAuthorizationInfoProvider\n{\n    private static final String GROUP_DELIMITER = \";\";\n    private static final String KEY_VALUE_DELIMITER = \"=\";\n    private static final String ROLE_DELIMITER = \",\";\n    public static final String LDAP_REALM = \"ldap\";\n\n    private static final String JNDI_LDAP_CONNECT_TIMEOUT = \"com.sun.jndi.ldap.connect.timeout\";\n    private static final String JNDI_LDAP_READ_TIMEOUT = \"com.sun.jndi.ldap.read.timeout\";\n    private static final String JNDI_LDAP_CONNECTION_TIMEOUT_MESSAGE_PART = \"timed out\"; // \"connect timed out\"\n    private static final String JNDI_LDAP_READ_TIMEOUT_MESSAGE_PART = \"timed out\"; // \"LDAP response read timed out\"\n\n    public static final String LDAP_CONNECTION_TIMEOUT_CLIENT_MESSAGE = \"LDAP connection timed out.\";\n    public static final String LDAP_READ_TIMEOUT_CLIENT_MESSAGE = \"LDAP response timed out.\";\n    public static final String LDAP_AUTHORIZATION_FAILURE_CLIENT_MESSAGE = \"LDAP authorization request failed.\";\n    public static final String LDAP_CONNECTION_REFUSED_CLIENT_MESSAGE = \"LDAP connection refused.\";\n\n    private Boolean authenticationEnabled;\n    private Boolean authorizationEnabled;\n    private Boolean useStartTls;\n    private boolean useSAMAccountName;\n    private String userSearchBase;\n    private String userSearchFilter;\n    private List<String> membershipAttributeNames;\n    private Boolean useSystemAccountForAuthorization;\n    private Map<String,Collection<String>> groupToRoleMapping;\n    private final SecurityLog securityLog;\n    private final SecureHasher secureHasher;\n\n    // Parser regex for group-to-role-mapping\n    private static final String KEY_GROUP = \"\\\\s*('(.+)'|\\\"(.+)\\\"|(\\\\S)|(\\\\S.*\\\\S))\\\\s*\";\n    private static final String VALUE_GROUP = \"\\\\s*(.*)\";\n    private Pattern keyValuePattern = Pattern.compile( KEY_GROUP + KEY_VALUE_DELIMITER + VALUE_GROUP );\n\n    public LdapRealm( Config config, SecurityLog securityLog, SecureHasher secureHasher )\n    {\n        super();\n        this.securityLog = securityLog;\n        this.secureHasher = secureHasher;\n        setName( SecuritySettings.LDAP_REALM_NAME );\n        setRolePermissionResolver( PredefinedRolesBuilder.rolePermissionResolver );\n        configureRealm( config );\n        if ( isAuthenticationCachingEnabled() )\n        {\n            setCredentialsMatcher( secureHasher.getHashedCredentialsMatcher() );\n        }\n        else\n        {\n            setCredentialsMatcher( new AllowAllCredentialsMatcher() );\n        }\n    }\n\n    private String withRealm( String template, Object... args )\n    {\n        return \"{LdapRealm}: \" + format( template, args );\n    }\n\n    private String server( JndiLdapContextFactory jndiLdapContextFactory )\n    {\n        return \"'\" + jndiLdapContextFactory.getUrl() + \"'\" +\n                ( useStartTls ? \" using StartTLS\" : \"\" );\n    }\n\n    @Override\n    protected AuthenticationInfo queryForAuthenticationInfo( AuthenticationToken token,\n            LdapContextFactory ldapContextFactory )\n            throws NamingException\n    {\n        if ( authenticationEnabled )\n        {\n            if ( useSAMAccountName )\n            {\n                return queryForAuthenticationInfoSAM( token, ldapContextFactory );\n            }\n            else\n            {\n                String serverString = server( (JndiLdapContextFactory) ldapContextFactory );\n                try\n                {\n                    AuthenticationInfo info =\n                            useStartTls ? queryForAuthenticationInfoUsingStartTls( token, ldapContextFactory )\n                                        : super.queryForAuthenticationInfo( token, ldapContextFactory );\n                    securityLog.debug( withRealm( \"Authenticated user '%s' against %s\", token.getPrincipal(),\n                            serverString ) );\n                    return info;\n                }\n                catch ( Exception e )\n                {\n                    if ( isExceptionAnLdapConnectionTimeout( e ) )\n                    {\n                        throw new AuthProviderTimeoutException( LDAP_CONNECTION_TIMEOUT_CLIENT_MESSAGE, e );\n                    }\n                    else if ( isExceptionAnLdapReadTimeout( e ) )\n                    {\n                        throw new AuthProviderTimeoutException( LDAP_READ_TIMEOUT_CLIENT_MESSAGE, e );\n                    }\n                    else if ( isExceptionConnectionRefused( e ) )\n                    {\n                        throw new AuthProviderFailedException( LDAP_CONNECTION_REFUSED_CLIENT_MESSAGE, e );\n                    }\n                    // This exception will be caught and rethrown by Shiro, and then by us, so we do not need to wrap it here\n                    throw e;\n                }\n            }\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    protected AuthenticationInfo queryForAuthenticationInfoUsingStartTls( AuthenticationToken token,\n            LdapContextFactory ldapContextFactory ) throws NamingException\n    {\n        Object principal = getLdapPrincipal(token);\n        Object credentials = token.getCredentials();\n\n        LdapContext ctx = null;\n\n        try\n        {\n            ctx = getLdapContextUsingStartTls( ldapContextFactory, principal, credentials );\n            return createAuthenticationInfo( token, principal, credentials, ctx );\n        }\n        finally\n        {\n            LdapUtils.closeContext( ctx );\n        }\n    }\n\n    private LdapContext getLdapContextUsingStartTls( LdapContextFactory ldapContextFactory,\n            Object principal, Object credentials ) throws NamingException\n    {\n        JndiLdapContextFactory jndiLdapContextFactory = (JndiLdapContextFactory) ldapContextFactory;\n        Hashtable<String, Object> env = new Hashtable<>();\n        env.put( Context.INITIAL_CONTEXT_FACTORY, jndiLdapContextFactory.getContextFactoryClassName() );\n        env.put( Context.PROVIDER_URL, jndiLdapContextFactory.getUrl() );\n\n        LdapContext ctx = null;\n\n        try\n        {\n            ctx = new InitialLdapContext( env, null );\n\n            StartTlsRequest startTlsRequest = new StartTlsRequest();\n            StartTlsResponse tls = (StartTlsResponse) ctx.extendedOperation( startTlsRequest );\n\n            tls.negotiate();\n\n            ctx.addToEnvironment( Context.SECURITY_AUTHENTICATION,\n                    jndiLdapContextFactory.getAuthenticationMechanism() );\n            ctx.addToEnvironment( Context.SECURITY_PRINCIPAL, principal );\n            ctx.addToEnvironment( Context.SECURITY_CREDENTIALS, credentials );\n\n            // do a lookup of the user to trigger authentication\n            ctx.lookup( principal.toString() );\n\n            return ctx;\n        }\n        catch ( IOException e )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Failed to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), e ) );\n            throw new CommunicationException( e.getMessage() );\n        }\n        catch ( Throwable t )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Unexpected failure to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), t ) );\n            throw t;\n        }\n    }\n\n    @Override\n    protected AuthorizationInfo queryForAuthorizationInfo( PrincipalCollection principals,\n            LdapContextFactory ldapContextFactory ) throws NamingException\n    {\n        if ( authorizationEnabled )\n        {\n            String username = getUsername( principals );\n            if ( username == null )\n            {\n                return null;\n            }\n\n            if ( useSystemAccountForAuthorization )\n            {\n                // Perform context search using the system context\n                LdapContext ldapContext = useStartTls ? getSystemLdapContextUsingStartTls( ldapContextFactory ) :\n                                          ldapContextFactory.getSystemLdapContext();\n\n                Set<String> roleNames;\n                try\n                {\n                    roleNames = findRoleNamesForUser( username, ldapContext );\n                }\n                finally\n                {\n                    LdapUtils.closeContext( ldapContext );\n                }\n\n                return new SimpleAuthorizationInfo( roleNames );\n            }\n            else\n            {\n                // Authorization info is cached during authentication\n                Cache<Object,AuthorizationInfo> authorizationCache = getAuthorizationCache();\n                AuthorizationInfo authorizationInfo = authorizationCache.get( username );\n                if ( authorizationInfo == null )\n                {\n                    // The cached authorization info has expired.\n                    // Since we do not have the subject's credentials we cannot perform a new LDAP search\n                    // for authorization info. Instead we need to fail with a special status,\n                    // so that the client can react by re-authenticating.\n                    throw new AuthorizationExpiredException( \"LDAP authorization info expired.\" );\n                }\n                return authorizationInfo;\n            }\n        }\n        return null;\n    }\n\n    private String getUsername( PrincipalCollection principals )\n    {\n        String username = null;\n        Collection ldapPrincipals = principals.fromRealm( getName() );\n        if ( !ldapPrincipals.isEmpty() )\n        {\n            username = (String) ldapPrincipals.iterator().next();\n        }\n        else if ( useSystemAccountForAuthorization )\n        {\n            username = (String) principals.getPrimaryPrincipal();\n        }\n        return username;\n    }\n\n    private LdapContext getSystemLdapContextUsingStartTls( LdapContextFactory ldapContextFactory )\n            throws NamingException\n    {\n        JndiLdapContextFactory jndiLdapContextFactory = (JndiLdapContextFactory) ldapContextFactory;\n        return getLdapContextUsingStartTls( ldapContextFactory, jndiLdapContextFactory.getSystemUsername(),\n                jndiLdapContextFactory.getSystemPassword() );\n    }\n\n    @Override\n    protected AuthenticationInfo createAuthenticationInfo( AuthenticationToken token, Object ldapPrincipal,\n            Object ldapCredentials, LdapContext ldapContext )\n            throws NamingException\n    {\n        // If authorization is enabled but useSystemAccountForAuthorization is disabled, we should perform\n        // the search for groups directly here while the user's authenticated ldap context is open.\n        if ( authorizationEnabled && !useSystemAccountForAuthorization )\n        {\n            String username = (String) token.getPrincipal();\n            Set<String> roleNames = findRoleNamesForUser( username, ldapContext );\n            cacheAuthorizationInfo( username, roleNames );\n        }\n\n        if ( isAuthenticationCachingEnabled() )\n        {\n            SimpleHash hashedCredentials = secureHasher.hash( ((String) token.getCredentials()).getBytes() );\n            return new ShiroAuthenticationInfo( token.getPrincipal(), hashedCredentials.getBytes(),\n                    hashedCredentials.getSalt(), getName(), AuthenticationResult.SUCCESS );\n        }\n        else\n        {\n            return new ShiroAuthenticationInfo( token.getPrincipal(), getName(), AuthenticationResult.SUCCESS );\n        }\n    }\n\n    @Override\n    public boolean supports( AuthenticationToken token )\n    {\n        return supportsSchemeAndRealm( token );\n    }\n\n    private boolean supportsSchemeAndRealm( AuthenticationToken token )\n    {\n        try\n        {\n            if ( token instanceof ShiroAuthToken )\n            {\n                ShiroAuthToken shiroAuthToken = (ShiroAuthToken) token;\n                return shiroAuthToken.getScheme().equals( AuthToken.BASIC_SCHEME ) &&\n                       (shiroAuthToken.supportsRealm( LDAP_REALM ));\n            }\n            return false;\n        }\n        catch ( InvalidAuthTokenException e )\n        {\n            return false;\n        }\n    }\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo( PrincipalCollection principals )\n    {\n        try\n        {\n            AuthorizationInfo info = super.doGetAuthorizationInfo( principals );\n            securityLog.debug( withRealm( \"Queried for authorization info for user '%s'\",\n                    principals.getPrimaryPrincipal() ) );\n            return info;\n        }\n        catch ( AuthorizationException e )\n        {\n            securityLog.warn( withRealm( \"Failed to get authorization info: '%s' caused by '%s'\",\n                    e.getMessage(), e.getCause().getMessage() ) );\n            return null;\n        }\n    }\n\n    // Unfortunately we need to identify timeouts by looking at the exception messages, which is not very robust.\n    // To make it slightly more robust we look for a key part of the actual message\n    private boolean isExceptionAnLdapReadTimeout( Exception e )\n    {\n        return e instanceof NamingException &&\n               e.getMessage().contains( JNDI_LDAP_READ_TIMEOUT_MESSAGE_PART );\n    }\n\n    private boolean isExceptionAnLdapConnectionTimeout( Exception e )\n    {\n        return e instanceof CommunicationException &&\n               (((CommunicationException) e).getRootCause() instanceof SocketTimeoutException ||\n                ((CommunicationException) e).getRootCause().getMessage().contains(\n                        JNDI_LDAP_CONNECTION_TIMEOUT_MESSAGE_PART ) );\n    }\n\n    private boolean isExceptionConnectionRefused( Exception e )\n    {\n        return e instanceof CommunicationException &&\n                ((CommunicationException) e).getRootCause() instanceof ConnectException;\n    }\n\n    private boolean isAuthorizationExceptionAnLdapReadTimeout( AuthorizationException e )\n    {\n        // Shiro's doGetAuthorizationInfo() wraps a NamingException in an AuthorizationException\n        return e.getCause() != null && e.getCause() instanceof NamingException &&\n               e.getCause().getMessage().contains( JNDI_LDAP_READ_TIMEOUT_MESSAGE_PART );\n    }\n\n    private void cacheAuthorizationInfo( String username, Set<String> roleNames )\n    {\n        // Use the existing authorizationCache in our base class\n        Cache<Object, AuthorizationInfo> authorizationCache = getAuthorizationCache();\n        authorizationCache.put( username, new SimpleAuthorizationInfo( roleNames ) );\n    }\n\n    private void configureRealm( Config config )\n    {\n        JndiLdapContextFactory contextFactory = new JndiLdapContextFactory();\n        Map<String,Object> environment = contextFactory.getEnvironment();\n        Long connectionTimeoutMillis = config.get( SecuritySettings.ldap_connection_timeout ).toMillis();\n        Long readTimeoutMillis = config.get( SecuritySettings.ldap_read_timeout ).toMillis();\n        environment.put( JNDI_LDAP_CONNECT_TIMEOUT, connectionTimeoutMillis.toString() );\n        environment.put( JNDI_LDAP_READ_TIMEOUT, readTimeoutMillis.toString() );\n        contextFactory.setEnvironment( environment );\n        contextFactory.setUrl( parseLdapServerUrl( config.get( SecuritySettings.ldap_server ) ) );\n        contextFactory.setAuthenticationMechanism( config.get( SecuritySettings.ldap_authentication_mechanism ) );\n        contextFactory.setReferral( config.get( SecuritySettings.ldap_referral ) );\n        contextFactory.setSystemUsername( config.get( SecuritySettings.ldap_authorization_system_username ) );\n        contextFactory.setSystemPassword( config.get( SecuritySettings.ldap_authorization_system_password ) );\n        contextFactory.setPoolingEnabled( config.get( SecuritySettings.ldap_authorization_connection_pooling ) );\n\n        setContextFactory( contextFactory );\n\n        String userDnTemplate = config.get( SecuritySettings.ldap_authentication_user_dn_template );\n        if ( userDnTemplate != null )\n        {\n            setUserDnTemplate( userDnTemplate );\n        }\n\n        authenticationEnabled = config.get( SecuritySettings.ldap_authentication_enabled );\n        authorizationEnabled = config.get( SecuritySettings.ldap_authorization_enabled );\n        useStartTls = config.get( SecuritySettings.ldap_use_starttls );\n\n        userSearchBase = config.get( SecuritySettings.ldap_authorization_user_search_base );\n        userSearchFilter = config.get( SecuritySettings.ldap_authorization_user_search_filter );\n        useSAMAccountName = config.get( SecuritySettings.ldap_authentication_use_samaccountname );\n        membershipAttributeNames = config.get( SecuritySettings.ldap_authorization_group_membership_attribute_names );\n        useSystemAccountForAuthorization = config.get( SecuritySettings.ldap_authorization_use_system_account );\n        groupToRoleMapping =\n                parseGroupToRoleMapping( config.get( SecuritySettings.ldap_authorization_group_to_role_mapping ) );\n\n        setAuthenticationCachingEnabled( config.get( SecuritySettings.ldap_authentication_cache_enabled ) );\n        setAuthorizationCachingEnabled( true );\n    }\n\n    private String parseLdapServerUrl( String rawLdapServer )\n    {\n        return (rawLdapServer == null) ? null :\n               rawLdapServer.contains( \"://\" ) ? rawLdapServer : \"ldap://\" + rawLdapServer;\n    }\n\n    private Map<String,Collection<String>> parseGroupToRoleMapping( String groupToRoleMappingString )\n    {\n        Map<String,Collection<String>> map = new HashMap<>();\n\n        if ( groupToRoleMappingString != null )\n        {\n            for ( String groupAndRoles : groupToRoleMappingString.split( GROUP_DELIMITER ) )\n            {\n                if ( !groupAndRoles.isEmpty() )\n                {\n                    Matcher matcher = keyValuePattern.matcher( groupAndRoles );\n                    if ( !(matcher.find() && matcher.groupCount() == 6) )\n                    {\n                        String errorMessage = format( \"Failed to parse setting %s: wrong number of fields\",\n                                SecuritySettings.ldap_authorization_group_to_role_mapping.name() );\n                        throw new IllegalArgumentException( errorMessage );\n                    }\n\n                    String group = matcher.group(2) != null ? matcher.group(2) :\n                                   matcher.group(3) != null ? matcher.group(3) :\n                                   matcher.group(4) != null ? matcher.group(4) :\n                                   matcher.group(5) != null ? matcher.group(5) : \"\";\n\n                    if ( group.isEmpty() )\n                    {\n                        String errorMessage = format( \"Failed to parse setting %s: empty group name\",\n                                SecuritySettings.ldap_authorization_group_to_role_mapping.name() );\n                        throw new IllegalArgumentException( errorMessage );\n                    }\n                    Collection<String> roleList = new ArrayList<>();\n                    for ( String role : matcher.group(6).trim().split( ROLE_DELIMITER ) )\n                    {\n                        if ( !role.isEmpty() )\n                        {\n                            roleList.add( role );\n                        }\n                    }\n                    // We only support case-insensitive comparison of group DNs\n                    map.put( group.toLowerCase(), roleList );\n                }\n            }\n        }\n\n        return map;\n    }\n\n    private AuthenticationInfo queryForAuthenticationInfoSAM(\n            AuthenticationToken token, LdapContextFactory ldapContextFactory ) throws NamingException\n    {\n        Object principal = token.getPrincipal();\n        Object credentials = token.getCredentials();\n\n        LdapContext ctx = null;\n        try\n        {\n            ctx = useStartTls ? getSystemLdapContextUsingStartTls( ldapContextFactory ) :\n                                      ldapContextFactory.getSystemLdapContext();\n            String[] attrs = {\"cn\"};\n            SearchControls searchCtls = new SearchControls( SearchControls.SUBTREE_SCOPE, 1, 0, attrs, false, false );\n            Object[] searchArguments = new Object[]{principal};\n            String filter = \"sAMAccountName={0}\";\n            NamingEnumeration<SearchResult> search = ctx.search( userSearchBase, filter, searchArguments, searchCtls );\n            if ( search.hasMore() )\n            {\n                final SearchResult next = search.next();\n                String loginUser = next.getNameInNamespace();\n                if ( search.hasMore() )\n                {\n                    securityLog.error( \"More than one user matching: \" + principal );\n                    throw new AuthenticationException( \"More than one user matching: \" + principal );\n                }\n                else\n                {\n                    LdapContext ctx2 = ldapContextFactory.getLdapContext( loginUser, credentials );\n                    LdapUtils.closeContext( ctx2 );\n                }\n            }\n            else\n            {\n                throw new AuthenticationException( \"No user matching: \" + principal );\n            }\n            return createAuthenticationInfo( token, principal, credentials, ctx );\n        }\n        finally\n        {\n            LdapUtils.closeContext( ctx );\n        }\n    }\n\n    // TODO: Extract to an LdapAuthorizationStrategy ? This (\"group by attribute\") is one of multiple possible strategies\n    Set<String> findRoleNamesForUser( String username, LdapContext ldapContext ) throws NamingException\n    {\n        Set<String> roleNames = new LinkedHashSet<>();\n\n        SearchControls searchCtls = new SearchControls();\n        searchCtls.setSearchScope( SearchControls.SUBTREE_SCOPE );\n        searchCtls.setReturningAttributes( membershipAttributeNames.toArray( new String[1] ) );\n\n        // Use search argument to prevent potential code injection\n        Object[] searchArguments = new Object[]{username};\n\n        NamingEnumeration result = ldapContext.search( userSearchBase, userSearchFilter, searchArguments, searchCtls );\n\n        if ( result.hasMoreElements() )\n        {\n            SearchResult searchResult = (SearchResult) result.next();\n\n            if ( result.hasMoreElements() )\n            {\n                securityLog.warn(\n                        securityLog.isDebugEnabled() ?\n                        withRealm(\n                            \"LDAP user search for user principal '%s' is ambiguous. The first match that will \" +\n                                            \"be checked for group membership is '%s' but the search also matches '%s'. \" +\n                                            \"Please check your LDAP realm configuration.\",\n                            username, searchResult.toString(), result.next().toString() )\n                        :\n                        withRealm(\n                            \"LDAP user search for user principal '%s' is ambiguous. The search matches more \" +\n                                            \"than one entry. Please check your LDAP realm configuration.\",\n                            username )\n                    );\n            }\n\n            Attributes attributes = searchResult.getAttributes();\n            if ( attributes != null )\n            {\n                NamingEnumeration attributeEnumeration = attributes.getAll();\n                while ( attributeEnumeration.hasMore() )\n                {\n                    Attribute attribute = (Attribute) attributeEnumeration.next();\n                    String attributeId = attribute.getID();\n                    if ( membershipAttributeNames.stream().anyMatch( attributeId::equalsIgnoreCase ) )\n                    {\n                        Collection<String> groupNames = LdapUtils.getAllAttributeValues( attribute );\n                        Collection<String> rolesForGroups = getRoleNamesForGroups( groupNames );\n                        roleNames.addAll( rolesForGroups );\n                    }\n                }\n            }\n        }\n        return roleNames;\n    }\n\n    private void assertValidUserSearchSettings()\n    {\n        boolean proceedWithSearch = true;\n\n        if ( userSearchBase == null || userSearchBase.isEmpty() )\n        {\n            securityLog.error( \"LDAP user search base is empty.\" );\n            proceedWithSearch = false;\n        }\n        if ( userSearchFilter == null || !userSearchFilter.contains( \"{0}\" ) )\n        {\n            securityLog.warn( \"LDAP user search filter does not contain the argument placeholder {0}, \" +\n                    \"so the search result will be independent of the user principal.\" );\n        }\n        if ( membershipAttributeNames == null || membershipAttributeNames.isEmpty() )\n        {\n            // If we don't have any attributes to look for we will never find anything\n            securityLog.error( \"LDAP group membership attribute names are empty. Authorization will not be possible.\" );\n            proceedWithSearch = false;\n        }\n\n        if ( !proceedWithSearch )\n        {\n            throw new IllegalArgumentException( \"Illegal LDAP user search settings, see security log for details.\" );\n        }\n    }\n\n    private Collection<String> getRoleNamesForGroups( Collection<String> groupNames )\n    {\n        Collection<String> roles = new ArrayList<>();\n        for ( String group : groupNames )\n        {\n            Collection<String> rolesForGroup = groupToRoleMapping.get( group.toLowerCase() );\n            if ( rolesForGroup != null )\n            {\n                roles.addAll( rolesForGroup );\n            }\n        }\n        return roles;\n    }\n\n    // Exposed for testing\n    Map<String,Collection<String>> getGroupToRoleMapping()\n    {\n        return groupToRoleMapping;\n    }\n\n    @Override\n    public void initialize()\n    {\n        if ( authorizationEnabled )\n        {\n            // For some combinations of settings we will never find anything\n            assertValidUserSearchSettings();\n        }\n    }\n\n    @Override\n    public void start()\n    {\n    }\n\n    @Override\n    public void stop()\n    {\n    }\n\n    @Override\n    public void shutdown()\n    {\n    }\n\n    @Override\n    public AuthorizationInfo getAuthorizationInfoSnapshot( PrincipalCollection principalCollection )\n    {\n        return getAuthorizationInfo( principalCollection );\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-63": {
    "vul_id": "VUL4J-63",
    "cve_id": "CVE-2018-1000615",
    "project": "opennetworkinglab_onos",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl protocols/ovsdb/rfc -Dtest=org.onosproject.ovsdb.rfc.utils.VersionUtilTest#testVersionCompare",
    "test_all_cmd": "mvn test -pl protocols/ovsdb/rfc",
    "human_patch_url": "https://github.com/opennetworkinglab/onos/commit/1a783729a1d7e0cd59d59a8dd3a73cdd6ac0f30d",
    "vulnerable_files": [
      {
        "file_path": "protocols/ovsdb/rfc/src/main/java/org/onosproject/ovsdb/rfc/utils/VersionUtil.java",
        "file_name": "VersionUtil.java",
        "vulnerable_code": "/*\n * Copyright 2015-present Open Networking Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.onosproject.ovsdb.rfc.utils;\n\n/**\n * Version utility class.\n */\npublic final class VersionUtil {\n\n    /**\n     * Constructs a VersionUtil object. Utility classes should not have a public\n     * or default constructor, otherwise IDE will compile unsuccessfully. This\n     * class should not be instantiated.\n     */\n    private VersionUtil() {\n    }\n\n    public static final String DEFAULT_VERSION_STRING = \"0.0.0\";\n    private static final String FORMAT = \"(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)\";\n\n    /**\n     * Match version by the format.\n     * @param version the version String\n     * @throws IllegalArgumentException this is an illegal argument exception\n     */\n    public static void versionMatch(String version) {\n        if (!version.matches(FORMAT)) {\n            throw new IllegalArgumentException(\"<\" + version\n                    + \"> does not match format \" + FORMAT);\n        }\n    }\n\n    /**\n     * Compare fromVersion and toVersion.\n     * @param fromVersion the initial version\n     * @param toVersion the end of the version\n     * @return an int number\n     */\n    public static int versionCompare(String fromVersion, String toVersion) {\n        String[] fromArr = fromVersion.split(\"\\\\.\");\n        String[] toArr = toVersion.split(\"\\\\.\");\n        int fromFirst = Integer.parseInt(fromArr[0]);\n        int fromMiddle = Integer.parseInt(fromArr[1]);\n        int fromEnd = Integer.parseInt(fromArr[2]);\n        int toFirst = Integer.parseInt(toArr[0]);\n        int toMiddle = Integer.parseInt(toArr[1]);\n        int toEnd = Integer.parseInt(toArr[2]);\n        if (fromFirst - toFirst != 0) {\n            return fromFirst - toFirst;\n        } else if (fromMiddle - toMiddle != 0) {\n            return fromMiddle - toMiddle;\n        } else {\n            return fromEnd - toEnd;\n        }\n    }\n}\n",
        "human_patch_code": "/*\n * Copyright 2015-present Open Networking Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.onosproject.ovsdb.rfc.utils;\n\n/**\n * Version utility class.\n */\npublic final class VersionUtil {\n\n    /**\n     * Constructs a VersionUtil object. Utility classes should not have a public\n     * or default constructor, otherwise IDE will compile unsuccessfully. This\n     * class should not be instantiated.\n     */\n    private VersionUtil() {\n    }\n\n    public static final String DEFAULT_VERSION_STRING = \"0.0.0\";\n    private static final String FORMAT = \"(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)\";\n\n    /**\n     * Match version by the format.\n     * @param version the version String\n     * @throws IllegalArgumentException this is an illegal argument exception\n     */\n    public static void versionMatch(String version) {\n        if (!version.matches(FORMAT)) {\n            throw new IllegalArgumentException(\"<\" + version\n                    + \"> does not match format \" + FORMAT);\n        }\n    }\n\n    /**\n     * Compare fromVersion and toVersion.\n     * @param fromVersion the initial version\n     * @param toVersion the end of the version\n     * @return an int number\n     */\n    public static int versionCompare(String fromVersion, String toVersion) {\n        if (fromVersion == null || toVersion == null) {\n            return -1;\n        }\n        String[] fromArr = fromVersion.split(\"\\\\.\");\n        String[] toArr = toVersion.split(\"\\\\.\");\n        if (fromArr.length != 3 || toArr.length != 3) {\n            return -1;\n        }\n        try {\n            int fromFirst = Integer.parseInt(fromArr[0]);\n            int fromMiddle = Integer.parseInt(fromArr[1]);\n            int fromEnd = Integer.parseInt(fromArr[2]);\n            int toFirst = Integer.parseInt(toArr[0]);\n            int toMiddle = Integer.parseInt(toArr[1]);\n            int toEnd = Integer.parseInt(toArr[2]);\n            if (fromFirst - toFirst != 0) {\n                return fromFirst - toFirst;\n            } else if (fromMiddle - toMiddle != 0) {\n                return fromMiddle - toMiddle;\n            } else {\n                return fromEnd - toEnd;\n            }\n        } catch (NumberFormatException nfe) {\n            return -1;\n        }\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-66": {
    "vul_id": "VUL4J-66",
    "cve_id": "CVE-2020-1695",
    "project": "resteasy_Resteasy",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "cd testsuite;mvn test -Dtest=org.jboss.resteasy.test.mediatype.MediaTypeHeaderTest#testNewLineInHeaderValueIsRejected",
    "test_all_cmd": "cd testsuite;mvn test",
    "human_patch_url": "https://github.com/resteasy/Resteasy/commit/acf15f2a8067f7e4cf5838342cecfa0b78a174fb",
    "vulnerable_files": [
      {
        "file_path": "resteasy-core/src/main/java/org/jboss/resteasy/plugins/delegates/MediaTypeHeaderDelegate.java",
        "file_name": "MediaTypeHeaderDelegate.java",
        "vulnerable_code": "package org.jboss.resteasy.plugins.delegates;\n\nimport org.jboss.resteasy.resteasy_jaxrs.i18n.Messages;\nimport org.jboss.resteasy.util.HeaderParameterParser;\n\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.ext.RuntimeDelegate;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n * @version $Revision: 1 $\n */\npublic class MediaTypeHeaderDelegate implements RuntimeDelegate.HeaderDelegate\n{\n   public static final MediaTypeHeaderDelegate INSTANCE = new MediaTypeHeaderDelegate();\n\n   private static Map<String, MediaType> map = new ConcurrentHashMap<String, MediaType>();\n   private static Map<MediaType, String> reverseMap = new ConcurrentHashMap<MediaType, String>();\n   private static final int MAX_MT_CACHE_SIZE =\n       Integer.getInteger(\"org.jboss.resteasy.max_mediatype_cache_size\", 200);\n\n   public Object fromString(String type) throws IllegalArgumentException\n   {\n      if (type == null) throw new IllegalArgumentException(Messages.MESSAGES.mediaTypeValueNull());\n      return parse(type);\n   }\n\n   protected static boolean isValid(String str)\n   {\n      if (str == null || str.length() == 0) return false;\n      for (int i = 0; i < str.length(); i++) {\n         switch (str.charAt(i))\n         {\n            case '/':\n            case '\\\\':\n            case '?':\n            case ':':\n            case '<':\n            case '>':\n            case ';':\n            case '(':\n            case ')':\n            case '@':\n            case ',':\n            case '[':\n            case ']':\n            case '=':\n               return false;\n            default:\n               break;\n         }\n      }\n      return true;\n   }\n\n   public static MediaType parse(String type)\n   {\n      MediaType result = map.get(type);\n      if (result == null) {\n          result = internalParse(type);\n          final int size = map.size();\n          if (size >= MAX_MT_CACHE_SIZE) {\n              map.clear();\n              reverseMap.clear();\n          }\n          map.put(type, result);\n          reverseMap.put(result, type);\n      }\n      return result;\n   }\n\n   private static MediaType internalParse(String type)\n   {\n      int typeIndex = type.indexOf('/');\n      int paramIndex = type.indexOf(';');\n      String major = null;\n      String subtype = null;\n      if (typeIndex < 0) // possible \"*\"\n      {\n         major = type;\n         if (paramIndex > -1)\n         {\n            major = major.substring(0, paramIndex);\n         }\n         if (!MediaType.MEDIA_TYPE_WILDCARD.equals(major))\n         {\n            throw new IllegalArgumentException(Messages.MESSAGES.failureParsingMediaType(type));\n         }\n         subtype = MediaType.MEDIA_TYPE_WILDCARD;\n      }\n      else\n      {\n         major = type.substring(0, typeIndex);\n         if (paramIndex > -1)\n         {\n            subtype = type.substring(typeIndex + 1, paramIndex);\n         }\n         else\n         {\n            subtype = type.substring(typeIndex + 1);\n         }\n      }\n      if (major.length() < 1 || subtype.length() < 1)\n      {\n         throw new IllegalArgumentException(Messages.MESSAGES.failureParsingMediaType(type));\n      }\n      if (!isValid(major) || !isValid(subtype))\n      {\n         throw new IllegalArgumentException(Messages.MESSAGES.failureParsingMediaType(type));\n      }\n      String params = null;\n      if (paramIndex > -1) params = type.substring(paramIndex + 1);\n      if (params != null && !params.equals(\"\"))\n      {\n         HashMap<String, String> typeParams = new HashMap<String, String>();\n\n         int start = 0;\n\n         while (start < params.length())\n         {\n            start = HeaderParameterParser.setParam(typeParams, params, start);\n         }\n         return new MediaType(major, subtype, typeParams);\n      }\n      else\n      {\n         return new MediaType(major, subtype);\n      }\n   }\n\n   private static final char[] quotedChars = \"()<>@,;:\\\\\\\"/[]?= \\t\\r\\n\".toCharArray();\n\n   public static boolean quoted(String str)\n   {\n      for (int i = 0; i < str.length(); i++)\n      {\n         char c = str.charAt(i);\n         for (char q : quotedChars) {\n            if (c == q) return true;\n         }\n      }\n      return false;\n   }\n\n   public String toString(Object o)\n   {\n      if (o == null) throw new IllegalArgumentException(Messages.MESSAGES.paramNull());\n      MediaType type = (MediaType) o;\n      String result = reverseMap.get(type);\n      if (result == null) {\n          result = internalToString(type);\n          final int size = reverseMap.size();\n          if (size >= MAX_MT_CACHE_SIZE) {\n             reverseMap.clear();\n             map.clear();\n          }\n          reverseMap.put(type, result);\n          map.put(result, type);\n      }\n      return result;\n   }\n\n   private String internalToString(MediaType type)\n   {\n      StringBuilder buf = new StringBuilder();\n\n      buf.append(type.getType().toLowerCase()).append(\"/\").append(type.getSubtype().toLowerCase());\n      if (type.getParameters() == null || type.getParameters().size() == 0) return buf.toString();\n      for (String name : type.getParameters().keySet())\n      {\n         buf.append(';').append(name).append('=');\n         String val = type.getParameters().get(name);\n         if (quoted(val)) buf.append('\"').append(val).append('\"');\n         else buf.append(val);\n      }\n      return buf.toString();\n   }\n}\n",
        "human_patch_code": "package org.jboss.resteasy.plugins.delegates;\n\nimport org.jboss.resteasy.resteasy_jaxrs.i18n.Messages;\nimport org.jboss.resteasy.util.HeaderParameterParser;\n\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.ext.RuntimeDelegate;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n * @version $Revision: 1 $\n */\npublic class MediaTypeHeaderDelegate implements RuntimeDelegate.HeaderDelegate\n{\n   public static final MediaTypeHeaderDelegate INSTANCE = new MediaTypeHeaderDelegate();\n\n   private static Map<String, MediaType> map = new ConcurrentHashMap<String, MediaType>();\n   private static Map<MediaType, String> reverseMap = new ConcurrentHashMap<MediaType, String>();\n   private static final int MAX_MT_CACHE_SIZE =\n       Integer.getInteger(\"org.jboss.resteasy.max_mediatype_cache_size\", 200);\n\n   public Object fromString(String type) throws IllegalArgumentException\n   {\n      if (type == null) throw new IllegalArgumentException(Messages.MESSAGES.mediaTypeValueNull());\n      return parse(type);\n   }\n\n   protected static boolean isValid(String str)\n   {\n      if (str == null || str.length() == 0) return false;\n      for (int i = 0; i < str.length(); i++) {\n         switch (str.charAt(i))\n         {\n            case '/':\n            case '\\\\':\n            case '?':\n            case ':':\n            case '<':\n            case '>':\n            case ';':\n            case '(':\n            case ')':\n            case '@':\n            case ',':\n            case '[':\n            case ']':\n            case '=':\n            case '\\n':\n               return false;\n            default:\n               break;\n         }\n      }\n      return true;\n   }\n\n   public static MediaType parse(String type)\n   {\n      MediaType result = map.get(type);\n      if (result == null) {\n          result = internalParse(type);\n          final int size = map.size();\n          if (size >= MAX_MT_CACHE_SIZE) {\n              map.clear();\n              reverseMap.clear();\n          }\n          map.put(type, result);\n          reverseMap.put(result, type);\n      }\n      return result;\n   }\n\n   private static MediaType internalParse(String type)\n   {\n      int typeIndex = type.indexOf('/');\n      int paramIndex = type.indexOf(';');\n      String major = null;\n      String subtype = null;\n      if (typeIndex < 0) // possible \"*\"\n      {\n         major = type;\n         if (paramIndex > -1)\n         {\n            major = major.substring(0, paramIndex);\n         }\n         if (!MediaType.MEDIA_TYPE_WILDCARD.equals(major))\n         {\n            throw new IllegalArgumentException(Messages.MESSAGES.failureParsingMediaType(type));\n         }\n         subtype = MediaType.MEDIA_TYPE_WILDCARD;\n      }\n      else\n      {\n         major = type.substring(0, typeIndex);\n         if (paramIndex > -1)\n         {\n            subtype = type.substring(typeIndex + 1, paramIndex);\n         }\n         else\n         {\n            subtype = type.substring(typeIndex + 1);\n         }\n      }\n      if (major.length() < 1 || subtype.length() < 1)\n      {\n         throw new IllegalArgumentException(Messages.MESSAGES.failureParsingMediaType(type));\n      }\n      if (!isValid(major) || !isValid(subtype))\n      {\n         throw new IllegalArgumentException(Messages.MESSAGES.failureParsingMediaType(type));\n      }\n      String params = null;\n      if (paramIndex > -1) params = type.substring(paramIndex + 1);\n      if (params != null && !params.equals(\"\"))\n      {\n         HashMap<String, String> typeParams = new HashMap<String, String>();\n\n         int start = 0;\n\n         while (start < params.length())\n         {\n            start = HeaderParameterParser.setParam(typeParams, params, start);\n         }\n         return new MediaType(major, subtype, typeParams);\n      }\n      else\n      {\n         return new MediaType(major, subtype);\n      }\n   }\n\n   private static final char[] quotedChars = \"()<>@,;:\\\\\\\"/[]?= \\t\\r\\n\".toCharArray();\n\n   public static boolean quoted(String str)\n   {\n      for (int i = 0; i < str.length(); i++)\n      {\n         char c = str.charAt(i);\n         for (char q : quotedChars) {\n            if (c == q) return true;\n         }\n      }\n      return false;\n   }\n\n   public String toString(Object o)\n   {\n      if (o == null) throw new IllegalArgumentException(Messages.MESSAGES.paramNull());\n      MediaType type = (MediaType) o;\n      String result = reverseMap.get(type);\n      if (result == null) {\n          result = internalToString(type);\n          final int size = reverseMap.size();\n          if (size >= MAX_MT_CACHE_SIZE) {\n             reverseMap.clear();\n             map.clear();\n          }\n          reverseMap.put(type, result);\n          map.put(result, type);\n      }\n      return result;\n   }\n\n   private String internalToString(MediaType type)\n   {\n      StringBuilder buf = new StringBuilder();\n\n      buf.append(type.getType().toLowerCase()).append(\"/\").append(type.getSubtype().toLowerCase());\n      if (type.getParameters() == null || type.getParameters().size() == 0) return buf.toString();\n      for (String name : type.getParameters().keySet())\n      {\n         buf.append(';').append(name).append('=');\n         String val = type.getParameters().get(name);\n         if (quoted(val)) buf.append('\"').append(val).append('\"');\n         else buf.append(val);\n      }\n      return buf.toString();\n   }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-75": {
    "vul_id": "VUL4J-75",
    "cve_id": "CVE-2016-4977",
    "project": "spring-projects_spring-security-oauth",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl spring-security-oauth2 -Dtest=org.springframework.security.oauth2.provider.endpoint.SpelViewTests",
    "test_all_cmd": "mvn test -pl spring-security-oauth2",
    "human_patch_url": "https://github.com/spring-projects/spring-security-oauth/commit/fff77d3fea477b566bcacfbfc95f85821a2bdc2d",
    "vulnerable_files": [
      {
        "file_path": "spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/endpoint/SpelView.java",
        "file_name": "SpelView.java",
        "vulnerable_code": "/*\n * Copyright 2013-2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage org.springframework.security.oauth2.provider.endpoint;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.springframework.context.expression.MapAccessor;\nimport org.springframework.expression.Expression;\nimport org.springframework.expression.spel.standard.SpelExpressionParser;\nimport org.springframework.expression.spel.support.StandardEvaluationContext;\nimport org.springframework.util.PropertyPlaceholderHelper;\nimport org.springframework.util.PropertyPlaceholderHelper.PlaceholderResolver;\nimport org.springframework.web.servlet.View;\nimport org.springframework.web.servlet.support.ServletUriComponentsBuilder;\n\n/**\n * Simple String template renderer.\n * \n */\nclass SpelView implements View {\n\n\tprivate final String template;\n\n\tprivate final SpelExpressionParser parser = new SpelExpressionParser();\n\n\tprivate final StandardEvaluationContext context = new StandardEvaluationContext();\n\n\tprivate PropertyPlaceholderHelper helper;\n\n\tprivate PlaceholderResolver resolver;\n\n\tpublic SpelView(String template) {\n\t\tthis.template = template;\n\t\tthis.context.addPropertyAccessor(new MapAccessor());\n\t\tthis.helper = new PropertyPlaceholderHelper(\"${\", \"}\");\n\t\tthis.resolver = new PlaceholderResolver() {\n\t\t\tpublic String resolvePlaceholder(String name) {\n\t\t\t\tExpression expression = parser.parseExpression(name);\n\t\t\t\tObject value = expression.getValue(context);\n\t\t\t\treturn value == null ? null : value.toString();\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic String getContentType() {\n\t\treturn \"text/html\";\n\t}\n\n\tpublic void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows Exception {\n\t\tMap<String, Object> map = new HashMap<String, Object>(model);\n\t\tString path = ServletUriComponentsBuilder.fromContextPath(request).build()\n\t\t\t\t.getPath();\n\t\tmap.put(\"path\", (Object) path==null ? \"\" : path);\n\t\tcontext.setRootObject(map);\n\t\tString result = helper.replacePlaceholders(template, resolver);\n\t\tresponse.setContentType(getContentType());\n\t\tresponse.getWriter().append(result);\n\t}\n\n}",
        "human_patch_code": "/*\n * Copyright 2013-2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage org.springframework.security.oauth2.provider.endpoint;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.springframework.context.expression.MapAccessor;\nimport org.springframework.expression.Expression;\nimport org.springframework.expression.spel.standard.SpelExpressionParser;\nimport org.springframework.expression.spel.support.StandardEvaluationContext;\nimport org.springframework.security.oauth2.common.util.RandomValueStringGenerator;\nimport org.springframework.util.PropertyPlaceholderHelper;\nimport org.springframework.util.PropertyPlaceholderHelper.PlaceholderResolver;\nimport org.springframework.web.servlet.View;\nimport org.springframework.web.servlet.support.ServletUriComponentsBuilder;\n\n/**\n * Simple String template renderer.\n * \n */\nclass SpelView implements View {\n\n\tprivate final String template;\n\t\n\tprivate final String prefix;\n\n\tprivate final SpelExpressionParser parser = new SpelExpressionParser();\n\n\tprivate final StandardEvaluationContext context = new StandardEvaluationContext();\n\n\tprivate PlaceholderResolver resolver;\n\n\tpublic SpelView(String template) {\n\t\tthis.template = template;\n\t\tthis.prefix = new RandomValueStringGenerator().generate() + \"{\";\n\t\tthis.context.addPropertyAccessor(new MapAccessor());\n\t\tthis.resolver = new PlaceholderResolver() {\n\t\t\tpublic String resolvePlaceholder(String name) {\n\t\t\t\tExpression expression = parser.parseExpression(name);\n\t\t\t\tObject value = expression.getValue(context);\n\t\t\t\treturn value == null ? null : value.toString();\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic String getContentType() {\n\t\treturn \"text/html\";\n\t}\n\n\tpublic void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows Exception {\n\t\tMap<String, Object> map = new HashMap<String, Object>(model);\n\t\tString path = ServletUriComponentsBuilder.fromContextPath(request).build()\n\t\t\t\t.getPath();\n\t\tmap.put(\"path\", (Object) path==null ? \"\" : path);\n\t\tcontext.setRootObject(map);\n\t\tString maskedTemplate = template.replace(\"${\", prefix);\n\t\tPropertyPlaceholderHelper helper = new PropertyPlaceholderHelper(prefix, \"}\");\n\t\tString result = helper.replacePlaceholders(maskedTemplate, resolver);\n\t\tresult = result.replace(prefix, \"${\");\n\t\tresponse.setContentType(getContentType());\n\t\tresponse.getWriter().append(result);\n\t}\n\n}"
      }
    ],
    "file_count": 1
  },
  "VUL4J-76": {
    "vul_id": "VUL4J-76",
    "cve_id": "CVE-2018-1000850",
    "project": "square_retrofit",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl retrofit -Dtest=retrofit2.RequestFactoryTest",
    "test_all_cmd": "mvn test -pl retrofit",
    "human_patch_url": "https://github.com/square/retrofit/commit/b9a7f6ad72073ddd40254c0058710e87a073047d",
    "vulnerable_files": [
      {
        "file_path": "retrofit/src/main/java/retrofit2/RequestBuilder.java",
        "file_name": "RequestBuilder.java",
        "vulnerable_code": "/*\n * Copyright (C) 2012 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage retrofit2;\n\nimport java.io.IOException;\nimport javax.annotation.Nullable;\nimport okhttp3.FormBody;\nimport okhttp3.Headers;\nimport okhttp3.HttpUrl;\nimport okhttp3.MediaType;\nimport okhttp3.MultipartBody;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okio.Buffer;\nimport okio.BufferedSink;\n\nfinal class RequestBuilder {\n  private static final char[] HEX_DIGITS =\n      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n  private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = \" \\\"<>^`{}|\\\\?#\";\n\n  private final String method;\n\n  private final HttpUrl baseUrl;\n  private @Nullable String relativeUrl;\n  private @Nullable HttpUrl.Builder urlBuilder;\n\n  private final Request.Builder requestBuilder;\n  private @Nullable MediaType contentType;\n\n  private final boolean hasBody;\n  private @Nullable MultipartBody.Builder multipartBuilder;\n  private @Nullable FormBody.Builder formBuilder;\n  private @Nullable RequestBody body;\n\n  RequestBuilder(String method, HttpUrl baseUrl,\n      @Nullable String relativeUrl, @Nullable Headers headers, @Nullable MediaType contentType,\n      boolean hasBody, boolean isFormEncoded, boolean isMultipart) {\n    this.method = method;\n    this.baseUrl = baseUrl;\n    this.relativeUrl = relativeUrl;\n    this.requestBuilder = new Request.Builder();\n    this.contentType = contentType;\n    this.hasBody = hasBody;\n\n    if (headers != null) {\n      requestBuilder.headers(headers);\n    }\n\n    if (isFormEncoded) {\n      // Will be set to 'body' in 'build'.\n      formBuilder = new FormBody.Builder();\n    } else if (isMultipart) {\n      // Will be set to 'body' in 'build'.\n      multipartBuilder = new MultipartBody.Builder();\n      multipartBuilder.setType(MultipartBody.FORM);\n    }\n  }\n\n  void setRelativeUrl(Object relativeUrl) {\n    this.relativeUrl = relativeUrl.toString();\n  }\n\n  void addHeader(String name, String value) {\n    if (\"Content-Type\".equalsIgnoreCase(name)) {\n      try {\n        contentType = MediaType.get(value);\n      } catch (IllegalArgumentException e) {\n        throw new IllegalArgumentException(\"Malformed content type: \" + value, e);\n      }\n    } else {\n      requestBuilder.addHeader(name, value);\n    }\n  }\n\n  void addPathParam(String name, String value, boolean encoded) {\n    if (relativeUrl == null) {\n      // The relative URL is cleared when the first query parameter is set.\n      throw new AssertionError();\n    }\n    relativeUrl = relativeUrl.replace(\"{\" + name + \"}\", canonicalizeForPath(value, encoded));\n  }\n\n  private static String canonicalizeForPath(String input, boolean alreadyEncoded) {\n    int codePoint;\n    for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {\n      codePoint = input.codePointAt(i);\n      if (codePoint < 0x20 || codePoint >= 0x7f\n          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1\n          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {\n        // Slow path: the character at i requires encoding!\n        Buffer out = new Buffer();\n        out.writeUtf8(input, 0, i);\n        canonicalizeForPath(out, input, i, limit, alreadyEncoded);\n        return out.readUtf8();\n      }\n    }\n\n    // Fast path: no characters required encoding.\n    return input;\n  }\n\n  private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,\n      boolean alreadyEncoded) {\n    Buffer utf8Buffer = null; // Lazily allocated.\n    int codePoint;\n    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {\n      codePoint = input.codePointAt(i);\n      if (alreadyEncoded\n          && (codePoint == '\\t' || codePoint == '\\n' || codePoint == '\\f' || codePoint == '\\r')) {\n        // Skip this character.\n      } else if (codePoint < 0x20 || codePoint >= 0x7f\n          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1\n          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {\n        // Percent encode this character.\n        if (utf8Buffer == null) {\n          utf8Buffer = new Buffer();\n        }\n        utf8Buffer.writeUtf8CodePoint(codePoint);\n        while (!utf8Buffer.exhausted()) {\n          int b = utf8Buffer.readByte() & 0xff;\n          out.writeByte('%');\n          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);\n          out.writeByte(HEX_DIGITS[b & 0xf]);\n        }\n      } else {\n        // This character doesn't need encoding. Just copy it over.\n        out.writeUtf8CodePoint(codePoint);\n      }\n    }\n  }\n\n  void addQueryParam(String name, @Nullable String value, boolean encoded) {\n    if (relativeUrl != null) {\n      // Do a one-time combination of the built relative URL and the base URL.\n      urlBuilder = baseUrl.newBuilder(relativeUrl);\n      if (urlBuilder == null) {\n        throw new IllegalArgumentException(\n            \"Malformed URL. Base: \" + baseUrl + \", Relative: \" + relativeUrl);\n      }\n      relativeUrl = null;\n    }\n\n    if (encoded) {\n      //noinspection ConstantConditions Checked to be non-null by above 'if' block.\n      urlBuilder.addEncodedQueryParameter(name, value);\n    } else {\n      //noinspection ConstantConditions Checked to be non-null by above 'if' block.\n      urlBuilder.addQueryParameter(name, value);\n    }\n  }\n\n  @SuppressWarnings(\"ConstantConditions\") // Only called when isFormEncoded was true.\n  void addFormField(String name, String value, boolean encoded) {\n    if (encoded) {\n      formBuilder.addEncoded(name, value);\n    } else {\n      formBuilder.add(name, value);\n    }\n  }\n\n  @SuppressWarnings(\"ConstantConditions\") // Only called when isMultipart was true.\n  void addPart(Headers headers, RequestBody body) {\n    multipartBuilder.addPart(headers, body);\n  }\n\n  @SuppressWarnings(\"ConstantConditions\") // Only called when isMultipart was true.\n  void addPart(MultipartBody.Part part) {\n    multipartBuilder.addPart(part);\n  }\n\n  void setBody(RequestBody body) {\n    this.body = body;\n  }\n\n  Request.Builder get() {\n    HttpUrl url;\n    HttpUrl.Builder urlBuilder = this.urlBuilder;\n    if (urlBuilder != null) {\n      url = urlBuilder.build();\n    } else {\n      // No query parameters triggered builder creation, just combine the relative URL and base URL.\n      //noinspection ConstantConditions Non-null if urlBuilder is null.\n      url = baseUrl.resolve(relativeUrl);\n      if (url == null) {\n        throw new IllegalArgumentException(\n            \"Malformed URL. Base: \" + baseUrl + \", Relative: \" + relativeUrl);\n      }\n    }\n\n    RequestBody body = this.body;\n    if (body == null) {\n      // Try to pull from one of the builders.\n      if (formBuilder != null) {\n        body = formBuilder.build();\n      } else if (multipartBuilder != null) {\n        body = multipartBuilder.build();\n      } else if (hasBody) {\n        // Body is absent, make an empty body.\n        body = RequestBody.create(null, new byte[0]);\n      }\n    }\n\n    MediaType contentType = this.contentType;\n    if (contentType != null) {\n      if (body != null) {\n        body = new ContentTypeOverridingRequestBody(body, contentType);\n      } else {\n        requestBuilder.addHeader(\"Content-Type\", contentType.toString());\n      }\n    }\n\n    return requestBuilder\n        .url(url)\n        .method(method, body);\n  }\n\n  private static class ContentTypeOverridingRequestBody extends RequestBody {\n    private final RequestBody delegate;\n    private final MediaType contentType;\n\n    ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {\n      this.delegate = delegate;\n      this.contentType = contentType;\n    }\n\n    @Override public MediaType contentType() {\n      return contentType;\n    }\n\n    @Override public long contentLength() throws IOException {\n      return delegate.contentLength();\n    }\n\n    @Override public void writeTo(BufferedSink sink) throws IOException {\n      delegate.writeTo(sink);\n    }\n  }\n}\n",
        "human_patch_code": "/*\n * Copyright (C) 2012 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage retrofit2;\n\nimport java.io.IOException;\nimport java.util.regex.Pattern;\nimport javax.annotation.Nullable;\nimport okhttp3.FormBody;\nimport okhttp3.Headers;\nimport okhttp3.HttpUrl;\nimport okhttp3.MediaType;\nimport okhttp3.MultipartBody;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okio.Buffer;\nimport okio.BufferedSink;\n\nfinal class RequestBuilder {\n  private static final char[] HEX_DIGITS =\n      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n  private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = \" \\\"<>^`{}|\\\\?#\";\n\n  /**\n   * Matches strings that contain {@code .} or {@code ..} as a complete path segment. This also\n   * matches dots in their percent-encoded form, {@code %2E}.\n   *\n   * <p>It is okay to have these strings within a larger path segment (like {@code a..z} or {@code\n   * index.html}) but when alone they have a special meaning. A single dot resolves to no path\n   * segment so {@code /one/./three/} becomes {@code /one/three/}. A double-dot pops the preceding\n   * directory, so {@code /one/../three/} becomes {@code /three/}.\n   *\n   * <p>We forbid these in Retrofit paths because they're likely to have the unintended effect.\n   * For example, passing {@code ..} to {@code DELETE /account/book/{isbn}/} yields {@code DELETE\n   * /account/}.\n   */\n  private static final Pattern PATH_TRAVERSAL = Pattern.compile(\"(.*/)?(\\\\.|%2e|%2E){1,2}(/.*)?\");\n\n  private final String method;\n\n  private final HttpUrl baseUrl;\n  private @Nullable String relativeUrl;\n  private @Nullable HttpUrl.Builder urlBuilder;\n\n  private final Request.Builder requestBuilder;\n  private @Nullable MediaType contentType;\n\n  private final boolean hasBody;\n  private @Nullable MultipartBody.Builder multipartBuilder;\n  private @Nullable FormBody.Builder formBuilder;\n  private @Nullable RequestBody body;\n\n  RequestBuilder(String method, HttpUrl baseUrl,\n      @Nullable String relativeUrl, @Nullable Headers headers, @Nullable MediaType contentType,\n      boolean hasBody, boolean isFormEncoded, boolean isMultipart) {\n    this.method = method;\n    this.baseUrl = baseUrl;\n    this.relativeUrl = relativeUrl;\n    this.requestBuilder = new Request.Builder();\n    this.contentType = contentType;\n    this.hasBody = hasBody;\n\n    if (headers != null) {\n      requestBuilder.headers(headers);\n    }\n\n    if (isFormEncoded) {\n      // Will be set to 'body' in 'build'.\n      formBuilder = new FormBody.Builder();\n    } else if (isMultipart) {\n      // Will be set to 'body' in 'build'.\n      multipartBuilder = new MultipartBody.Builder();\n      multipartBuilder.setType(MultipartBody.FORM);\n    }\n  }\n\n  void setRelativeUrl(Object relativeUrl) {\n    this.relativeUrl = relativeUrl.toString();\n  }\n\n  void addHeader(String name, String value) {\n    if (\"Content-Type\".equalsIgnoreCase(name)) {\n      try {\n        contentType = MediaType.get(value);\n      } catch (IllegalArgumentException e) {\n        throw new IllegalArgumentException(\"Malformed content type: \" + value, e);\n      }\n    } else {\n      requestBuilder.addHeader(name, value);\n    }\n  }\n\n  void addPathParam(String name, String value, boolean encoded) {\n    if (relativeUrl == null) {\n      // The relative URL is cleared when the first query parameter is set.\n      throw new AssertionError();\n    }\n    String replacement = canonicalizeForPath(value, encoded);\n    String newRelativeUrl = relativeUrl.replace(\"{\" + name + \"}\", replacement);\n    if (PATH_TRAVERSAL.matcher(newRelativeUrl).matches()) {\n      throw new IllegalArgumentException(\n          \"@Path parameters shouldn't perform path traversal ('.' or '..'): \" + value);\n    }\n    relativeUrl = newRelativeUrl;\n  }\n\n  private static String canonicalizeForPath(String input, boolean alreadyEncoded) {\n    int codePoint;\n    for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {\n      codePoint = input.codePointAt(i);\n      if (codePoint < 0x20 || codePoint >= 0x7f\n          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1\n          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {\n        // Slow path: the character at i requires encoding!\n        Buffer out = new Buffer();\n        out.writeUtf8(input, 0, i);\n        canonicalizeForPath(out, input, i, limit, alreadyEncoded);\n        return out.readUtf8();\n      }\n    }\n\n    // Fast path: no characters required encoding.\n    return input;\n  }\n\n  private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,\n      boolean alreadyEncoded) {\n    Buffer utf8Buffer = null; // Lazily allocated.\n    int codePoint;\n    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {\n      codePoint = input.codePointAt(i);\n      if (alreadyEncoded\n          && (codePoint == '\\t' || codePoint == '\\n' || codePoint == '\\f' || codePoint == '\\r')) {\n        // Skip this character.\n      } else if (codePoint < 0x20 || codePoint >= 0x7f\n          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1\n          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {\n        // Percent encode this character.\n        if (utf8Buffer == null) {\n          utf8Buffer = new Buffer();\n        }\n        utf8Buffer.writeUtf8CodePoint(codePoint);\n        while (!utf8Buffer.exhausted()) {\n          int b = utf8Buffer.readByte() & 0xff;\n          out.writeByte('%');\n          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);\n          out.writeByte(HEX_DIGITS[b & 0xf]);\n        }\n      } else {\n        // This character doesn't need encoding. Just copy it over.\n        out.writeUtf8CodePoint(codePoint);\n      }\n    }\n  }\n\n  void addQueryParam(String name, @Nullable String value, boolean encoded) {\n    if (relativeUrl != null) {\n      // Do a one-time combination of the built relative URL and the base URL.\n      urlBuilder = baseUrl.newBuilder(relativeUrl);\n      if (urlBuilder == null) {\n        throw new IllegalArgumentException(\n            \"Malformed URL. Base: \" + baseUrl + \", Relative: \" + relativeUrl);\n      }\n      relativeUrl = null;\n    }\n\n    if (encoded) {\n      //noinspection ConstantConditions Checked to be non-null by above 'if' block.\n      urlBuilder.addEncodedQueryParameter(name, value);\n    } else {\n      //noinspection ConstantConditions Checked to be non-null by above 'if' block.\n      urlBuilder.addQueryParameter(name, value);\n    }\n  }\n\n  @SuppressWarnings(\"ConstantConditions\") // Only called when isFormEncoded was true.\n  void addFormField(String name, String value, boolean encoded) {\n    if (encoded) {\n      formBuilder.addEncoded(name, value);\n    } else {\n      formBuilder.add(name, value);\n    }\n  }\n\n  @SuppressWarnings(\"ConstantConditions\") // Only called when isMultipart was true.\n  void addPart(Headers headers, RequestBody body) {\n    multipartBuilder.addPart(headers, body);\n  }\n\n  @SuppressWarnings(\"ConstantConditions\") // Only called when isMultipart was true.\n  void addPart(MultipartBody.Part part) {\n    multipartBuilder.addPart(part);\n  }\n\n  void setBody(RequestBody body) {\n    this.body = body;\n  }\n\n  Request.Builder get() {\n    HttpUrl url;\n    HttpUrl.Builder urlBuilder = this.urlBuilder;\n    if (urlBuilder != null) {\n      url = urlBuilder.build();\n    } else {\n      // No query parameters triggered builder creation, just combine the relative URL and base URL.\n      //noinspection ConstantConditions Non-null if urlBuilder is null.\n      url = baseUrl.resolve(relativeUrl);\n      if (url == null) {\n        throw new IllegalArgumentException(\n            \"Malformed URL. Base: \" + baseUrl + \", Relative: \" + relativeUrl);\n      }\n    }\n\n    RequestBody body = this.body;\n    if (body == null) {\n      // Try to pull from one of the builders.\n      if (formBuilder != null) {\n        body = formBuilder.build();\n      } else if (multipartBuilder != null) {\n        body = multipartBuilder.build();\n      } else if (hasBody) {\n        // Body is absent, make an empty body.\n        body = RequestBody.create(null, new byte[0]);\n      }\n    }\n\n    MediaType contentType = this.contentType;\n    if (contentType != null) {\n      if (body != null) {\n        body = new ContentTypeOverridingRequestBody(body, contentType);\n      } else {\n        requestBuilder.addHeader(\"Content-Type\", contentType.toString());\n      }\n    }\n\n    return requestBuilder\n        .url(url)\n        .method(method, body);\n  }\n\n  private static class ContentTypeOverridingRequestBody extends RequestBody {\n    private final RequestBody delegate;\n    private final MediaType contentType;\n\n    ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {\n      this.delegate = delegate;\n      this.contentType = contentType;\n    }\n\n    @Override public MediaType contentType() {\n      return contentType;\n    }\n\n    @Override public long contentLength() throws IOException {\n      return delegate.contentLength();\n    }\n\n    @Override public void writeTo(BufferedSink sink) throws IOException {\n      delegate.writeTo(sink);\n    }\n  }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-77": {
    "vul_id": "VUL4J-77",
    "cve_id": "CVE-2017-1000207",
    "project": "swagger-api_swagger-parser",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn -pl modules/swagger-parser -Dtest=\"io.swagger.parser.util.*\"",
    "test_all_cmd": "mvn test -pl modules/swagger-parser",
    "human_patch_url": "https://github.com/swagger-api/swagger-parser/commit/4c6584306b40de9b2dfa9065c3a438cd918534af",
    "vulnerable_files": [
      {
        "file_path": "modules/swagger-parser/src/main/java/io/swagger/parser/util/DeserializationUtils.java",
        "file_name": "DeserializationUtils.java",
        "vulnerable_code": "package io.swagger.parser.util;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport io.swagger.util.Json;\nimport io.swagger.util.Yaml;\n\nimport java.io.IOException;\n\n/**\n * Created by russellb337 on 7/14/15.\n */\npublic class DeserializationUtils {\n    public static JsonNode deserializeIntoTree(String contents, String fileOrHost) {\n        JsonNode result;\n\n        try {\n            if (isJson(contents)) {\n                result = Json.mapper().readTree(contents);\n            } else {\n                result = readYamlTree(contents);\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"An exception was thrown while trying to deserialize the contents of \" + fileOrHost + \" into a JsonNode tree\", e);\n        }\n\n        return result;\n    }\n\n    public static <T> T deserialize(Object contents, String fileOrHost, Class<T> expectedType) {\n        T result;\n\n        boolean isJson = false;\n\n        if(contents instanceof String && isJson((String)contents)) {\n            isJson = true;\n        }\n\n        try {\n            if (contents instanceof String) {\n                if (isJson) {\n                    result = Json.mapper().readValue((String) contents, expectedType);\n                } else {\n                    result = Yaml.mapper().readValue((String) contents, expectedType);\n                }\n            } else {\n                result = Json.mapper().convertValue(contents, expectedType);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"An exception was thrown while trying to deserialize the contents of \" + fileOrHost + \" into type \" + expectedType, e);\n        }\n\n        return result;\n    }\n\n    private static boolean isJson(String contents) {\n        return contents.toString().trim().startsWith(\"{\");\n    }\n\n    public static JsonNode readYamlTree(String contents) {\n        org.yaml.snakeyaml.Yaml yaml = new org.yaml.snakeyaml.Yaml();\n        return Json.mapper().convertValue(yaml.load(contents), JsonNode.class);\n    }\n\n    public static <T> T readYamlValue(String contents, Class<T> expectedType) {\n        org.yaml.snakeyaml.Yaml yaml = new org.yaml.snakeyaml.Yaml();\n        return Json.mapper().convertValue(yaml.load(contents), expectedType);\n    }\n}\n",
        "human_patch_code": "package io.swagger.parser.util;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport io.swagger.util.Json;\nimport io.swagger.util.Yaml;\nimport org.yaml.snakeyaml.constructor.SafeConstructor;\n\nimport java.io.IOException;\n\n/**\n * Created by russellb337 on 7/14/15.\n */\npublic class DeserializationUtils {\n    public static JsonNode deserializeIntoTree(String contents, String fileOrHost) {\n        JsonNode result;\n\n        try {\n            if (isJson(contents)) {\n                result = Json.mapper().readTree(contents);\n            } else {\n                result = readYamlTree(contents);\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"An exception was thrown while trying to deserialize the contents of \" + fileOrHost + \" into a JsonNode tree\", e);\n        }\n\n        return result;\n    }\n\n    public static <T> T deserialize(Object contents, String fileOrHost, Class<T> expectedType) {\n        T result;\n\n        boolean isJson = false;\n\n        if(contents instanceof String && isJson((String)contents)) {\n            isJson = true;\n        }\n\n        try {\n            if (contents instanceof String) {\n                if (isJson) {\n                    result = Json.mapper().readValue((String) contents, expectedType);\n                } else {\n                    result = Yaml.mapper().readValue((String) contents, expectedType);\n                }\n            } else {\n                result = Json.mapper().convertValue(contents, expectedType);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"An exception was thrown while trying to deserialize the contents of \" + fileOrHost + \" into type \" + expectedType, e);\n        }\n\n        return result;\n    }\n\n    private static boolean isJson(String contents) {\n        return contents.toString().trim().startsWith(\"{\");\n    }\n\n    public static JsonNode readYamlTree(String contents) {\n        org.yaml.snakeyaml.Yaml yaml = new org.yaml.snakeyaml.Yaml(new SafeConstructor());\n        return Json.mapper().convertValue(yaml.load(contents), JsonNode.class);\n    }\n\n    public static <T> T readYamlValue(String contents, Class<T> expectedType) {\n        org.yaml.snakeyaml.Yaml yaml = new org.yaml.snakeyaml.Yaml(new SafeConstructor());\n        return Json.mapper().convertValue(yaml.load(contents), expectedType);\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-78": {
    "vul_id": "VUL4J-78",
    "cve_id": "CVE-2019-10173",
    "project": "x-stream_xstream",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -pl xstream -Dtest=com.thoughtworks.acceptance.SecurityVulnerabilityTest",
    "test_all_cmd": "mvn test -pl xstream",
    "human_patch_url": "https://github.com/x-stream/xstream/commit/f38a1da3ae9491930c2067c12cd2506738b21dab",
    "vulnerable_files": [
      {
        "file_path": "xstream/src/java/com/thoughtworks/xstream/XStream.java",
        "file_name": "XStream.java",
        "vulnerable_code": "/*\n * Copyright (C) 2003, 2004, 2005, 2006 Joe Walnes.\n * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018 XStream Committers.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n * Created on 26. September 2003 by Joe Walnes\n */\npackage com.thoughtworks.xstream;\n\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.NotActiveException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectInputValidation;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.text.DecimalFormatSymbols;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TimeZone;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\n\nimport com.thoughtworks.xstream.converters.ConversionException;\nimport com.thoughtworks.xstream.converters.Converter;\nimport com.thoughtworks.xstream.converters.ConverterLookup;\nimport com.thoughtworks.xstream.converters.ConverterRegistry;\nimport com.thoughtworks.xstream.converters.DataHolder;\nimport com.thoughtworks.xstream.converters.MarshallingContext;\nimport com.thoughtworks.xstream.converters.SingleValueConverter;\nimport com.thoughtworks.xstream.converters.SingleValueConverterWrapper;\nimport com.thoughtworks.xstream.converters.UnmarshallingContext;\nimport com.thoughtworks.xstream.converters.basic.BigDecimalConverter;\nimport com.thoughtworks.xstream.converters.basic.BigIntegerConverter;\nimport com.thoughtworks.xstream.converters.basic.BooleanConverter;\nimport com.thoughtworks.xstream.converters.basic.ByteConverter;\nimport com.thoughtworks.xstream.converters.basic.CharConverter;\nimport com.thoughtworks.xstream.converters.basic.DateConverter;\nimport com.thoughtworks.xstream.converters.basic.DoubleConverter;\nimport com.thoughtworks.xstream.converters.basic.FloatConverter;\nimport com.thoughtworks.xstream.converters.basic.IntConverter;\nimport com.thoughtworks.xstream.converters.basic.LongConverter;\nimport com.thoughtworks.xstream.converters.basic.NullConverter;\nimport com.thoughtworks.xstream.converters.basic.ShortConverter;\nimport com.thoughtworks.xstream.converters.basic.StringBufferConverter;\nimport com.thoughtworks.xstream.converters.basic.StringConverter;\nimport com.thoughtworks.xstream.converters.basic.URIConverter;\nimport com.thoughtworks.xstream.converters.basic.URLConverter;\nimport com.thoughtworks.xstream.converters.collections.ArrayConverter;\nimport com.thoughtworks.xstream.converters.collections.BitSetConverter;\nimport com.thoughtworks.xstream.converters.collections.CharArrayConverter;\nimport com.thoughtworks.xstream.converters.collections.CollectionConverter;\nimport com.thoughtworks.xstream.converters.collections.MapConverter;\nimport com.thoughtworks.xstream.converters.collections.PropertiesConverter;\nimport com.thoughtworks.xstream.converters.collections.SingletonCollectionConverter;\nimport com.thoughtworks.xstream.converters.collections.SingletonMapConverter;\nimport com.thoughtworks.xstream.converters.collections.TreeMapConverter;\nimport com.thoughtworks.xstream.converters.collections.TreeSetConverter;\nimport com.thoughtworks.xstream.converters.extended.ColorConverter;\nimport com.thoughtworks.xstream.converters.extended.DynamicProxyConverter;\nimport com.thoughtworks.xstream.converters.extended.EncodedByteArrayConverter;\nimport com.thoughtworks.xstream.converters.extended.FileConverter;\nimport com.thoughtworks.xstream.converters.extended.FontConverter;\nimport com.thoughtworks.xstream.converters.extended.GregorianCalendarConverter;\nimport com.thoughtworks.xstream.converters.extended.JavaClassConverter;\nimport com.thoughtworks.xstream.converters.extended.JavaFieldConverter;\nimport com.thoughtworks.xstream.converters.extended.JavaMethodConverter;\nimport com.thoughtworks.xstream.converters.extended.LocaleConverter;\nimport com.thoughtworks.xstream.converters.extended.LookAndFeelConverter;\nimport com.thoughtworks.xstream.converters.extended.SqlDateConverter;\nimport com.thoughtworks.xstream.converters.extended.SqlTimeConverter;\nimport com.thoughtworks.xstream.converters.extended.SqlTimestampConverter;\nimport com.thoughtworks.xstream.converters.extended.TextAttributeConverter;\nimport com.thoughtworks.xstream.converters.reflection.ExternalizableConverter;\nimport com.thoughtworks.xstream.converters.reflection.ReflectionConverter;\nimport com.thoughtworks.xstream.converters.reflection.ReflectionProvider;\nimport com.thoughtworks.xstream.converters.reflection.SerializableConverter;\nimport com.thoughtworks.xstream.core.ClassLoaderReference;\nimport com.thoughtworks.xstream.core.DefaultConverterLookup;\nimport com.thoughtworks.xstream.core.JVM;\nimport com.thoughtworks.xstream.core.MapBackedDataHolder;\nimport com.thoughtworks.xstream.core.ReferenceByIdMarshallingStrategy;\nimport com.thoughtworks.xstream.core.ReferenceByXPathMarshallingStrategy;\nimport com.thoughtworks.xstream.core.TreeMarshallingStrategy;\nimport com.thoughtworks.xstream.core.util.CompositeClassLoader;\nimport com.thoughtworks.xstream.core.util.CustomObjectInputStream;\nimport com.thoughtworks.xstream.core.util.CustomObjectOutputStream;\nimport com.thoughtworks.xstream.core.util.SelfStreamingInstanceChecker;\nimport com.thoughtworks.xstream.io.HierarchicalStreamDriver;\nimport com.thoughtworks.xstream.io.HierarchicalStreamReader;\nimport com.thoughtworks.xstream.io.HierarchicalStreamWriter;\nimport com.thoughtworks.xstream.io.StatefulWriter;\nimport com.thoughtworks.xstream.io.xml.XppDriver;\nimport com.thoughtworks.xstream.mapper.AnnotationConfiguration;\nimport com.thoughtworks.xstream.mapper.ArrayMapper;\nimport com.thoughtworks.xstream.mapper.AttributeAliasingMapper;\nimport com.thoughtworks.xstream.mapper.AttributeMapper;\nimport com.thoughtworks.xstream.mapper.CachingMapper;\nimport com.thoughtworks.xstream.mapper.ClassAliasingMapper;\nimport com.thoughtworks.xstream.mapper.DefaultImplementationsMapper;\nimport com.thoughtworks.xstream.mapper.DefaultMapper;\nimport com.thoughtworks.xstream.mapper.DynamicProxyMapper;\nimport com.thoughtworks.xstream.mapper.ElementIgnoringMapper;\nimport com.thoughtworks.xstream.mapper.FieldAliasingMapper;\nimport com.thoughtworks.xstream.mapper.ImmutableTypesMapper;\nimport com.thoughtworks.xstream.mapper.ImplicitCollectionMapper;\nimport com.thoughtworks.xstream.mapper.LocalConversionMapper;\nimport com.thoughtworks.xstream.mapper.Mapper;\nimport com.thoughtworks.xstream.mapper.MapperWrapper;\nimport com.thoughtworks.xstream.mapper.OuterClassMapper;\nimport com.thoughtworks.xstream.mapper.PackageAliasingMapper;\nimport com.thoughtworks.xstream.mapper.SecurityMapper;\nimport com.thoughtworks.xstream.mapper.SystemAttributeAliasingMapper;\nimport com.thoughtworks.xstream.mapper.XStream11XmlFriendlyMapper;\nimport com.thoughtworks.xstream.security.AnyTypePermission;\nimport com.thoughtworks.xstream.security.ArrayTypePermission;\nimport com.thoughtworks.xstream.security.ExplicitTypePermission;\nimport com.thoughtworks.xstream.security.InterfaceTypePermission;\nimport com.thoughtworks.xstream.security.NoPermission;\nimport com.thoughtworks.xstream.security.NoTypePermission;\nimport com.thoughtworks.xstream.security.NullPermission;\nimport com.thoughtworks.xstream.security.PrimitiveTypePermission;\nimport com.thoughtworks.xstream.security.RegExpTypePermission;\nimport com.thoughtworks.xstream.security.TypeHierarchyPermission;\nimport com.thoughtworks.xstream.security.TypePermission;\nimport com.thoughtworks.xstream.security.WildcardTypePermission;\n\n\n/**\n * Simple facade to XStream library, a Java-XML serialization tool.\n * <p>\n * <hr>\n * <b>Example</b><blockquote>\n *\n * <pre>\n * XStream xstream = new XStream();\n * String xml = xstream.toXML(myObject); // serialize to XML\n * Object myObject2 = xstream.fromXML(xml); // deserialize from XML\n * </pre>\n *\n * </blockquote>\n * <hr>\n * \n * <h3>Aliasing classes</h3>\n * \n * <p>\n * To create shorter XML, you can specify aliases for classes using the <code>alias()</code>\n * method. For example, you can shorten all occurrences of element\n * <code>&lt;com.blah.MyThing&gt;</code> to <code>&lt;my-thing&gt;</code> by registering an\n * alias for the class.\n * <p>\n * <hr>\n * <blockquote>\n *\n * <pre>\n * xstream.alias(&quot;my-thing&quot;, MyThing.class);\n * </pre>\n *\n * </blockquote>\n * <hr>\n * \n * <h3>Converters</h3>\n * \n * <p>\n * XStream contains a map of {@link com.thoughtworks.xstream.converters.Converter} instances, each\n * of which acts as a strategy for converting a particular type of class to XML and back again. Out\n * of the box, XStream contains converters for most basic types (String, Date, int, boolean, etc)\n * and collections (Map, List, Set, Properties, etc). For other objects reflection is used to\n * serialize each field recursively.\n * </p>\n * \n * <p>\n * Extra converters can be registered using the <code>registerConverter()</code> method. Some\n * non-standard converters are supplied in the {@link com.thoughtworks.xstream.converters.extended}\n * package and you can create your own by implementing the\n * {@link com.thoughtworks.xstream.converters.Converter} interface.\n * </p>\n * \n * <p>\n * <hr>\n * <b>Example</b><blockquote>\n *\n * <pre>\n * xstream.registerConverter(new SqlTimestampConverter());\n * xstream.registerConverter(new DynamicProxyConverter());\n * </pre>\n *\n * </blockquote>\n * <hr>\n * <p>\n * The converters can be registered with an explicit priority. By default they are registered with \n * XStream.PRIORITY_NORMAL. Converters of same priority will be used in the reverse sequence\n * they have been registered. The default converter, i.e. the converter which will be used if\n * no other registered converter is suitable, can be registered with priority\n * XStream.PRIORITY_VERY_LOW. XStream uses by default the\n * {@link com.thoughtworks.xstream.converters.reflection.ReflectionConverter} as the fallback\n * converter.\n * </p>\n * \n * <p>\n * <hr>\n * <b>Example</b><blockquote>\n *\n * <pre>\n * xstream.registerConverter(new CustomDefaultConverter(), XStream.PRIORITY_VERY_LOW);\n * </pre>\n *\n * </blockquote>\n * <hr>\n * \n * <h3>Object graphs</h3>\n * \n * <p>\n * XStream has support for object graphs; a deserialized object graph will keep references intact,\n * including circular references.\n * </p>\n * \n * <p>\n * XStream can signify references in XML using either relative/absolute XPath or IDs. The mode can be changed using\n * <code>setMode()</code>:\n * </p>\n * \n * <table border='1'>\n * <caption></caption>\n * <tr>\n * <td><code>xstream.setMode(XStream.XPATH_RELATIVE_REFERENCES);</code></td>\n * <td><i>(Default)</i> Uses XPath relative references to signify duplicate references. This produces XML\n * with the least clutter.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.XPATH_ABSOLUTE_REFERENCES);</code></td>\n * <td>Uses XPath absolute references to signify duplicate\n * references. This produces XML with the least clutter.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.SINGLE_NODE_XPATH_RELATIVE_REFERENCES);</code></td>\n * <td>Uses XPath relative references to signify duplicate references. The XPath expression ensures that\n * a single node only is selected always.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES);</code></td>\n * <td>Uses XPath absolute references to signify duplicate references.  The XPath expression ensures that\n * a single node only is selected always.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.ID_REFERENCES);</code></td>\n * <td>Uses ID references to signify duplicate references. In some scenarios, such as when using\n * hand-written XML, this is easier to work with.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.NO_REFERENCES);</code></td>\n * <td>This disables object graph support and treats the object structure like a tree. Duplicate\n * references are treated as two separate objects and circular references cause an exception. This\n * is slightly faster and uses less memory than the other two modes.</td>\n * </tr>\n * </table>\n * <h3>Thread safety</h3>\n * <p>\n * The XStream instance is thread-safe. That is, once the XStream instance has been created and\n * configured, it may be shared across multiple threads allowing objects to be\n * serialized/deserialized concurrently. <em>Note, that this only applies if annotations are not \n * auto-detected on-the-fly.</em>\n * </p>\n * <h3>Implicit collections</h3>\n * \n * <p>\n * To avoid the need for special tags for collections, you can define implicit collections using one\n * of the <code>addImplicitCollection</code> methods.\n * </p>\n *\n * @author Joe Walnes\n * @author J&ouml;rg Schaible\n * @author Mauro Talevi\n * @author Guilherme Silveira\n */\npublic class XStream {\n\n    // CAUTION: The sequence of the fields is intentional for an optimal XML output of a\n    // self-serialization!\n    private ReflectionProvider reflectionProvider;\n    private HierarchicalStreamDriver hierarchicalStreamDriver;\n    private ClassLoaderReference classLoaderReference;\n    private MarshallingStrategy marshallingStrategy;\n    private ConverterLookup converterLookup;\n    private ConverterRegistry converterRegistry;\n    private Mapper mapper;\n\n    private PackageAliasingMapper packageAliasingMapper;\n    private ClassAliasingMapper classAliasingMapper;\n    private FieldAliasingMapper fieldAliasingMapper;\n    private ElementIgnoringMapper elementIgnoringMapper;\n    private AttributeAliasingMapper attributeAliasingMapper;\n    private SystemAttributeAliasingMapper systemAttributeAliasingMapper;\n    private AttributeMapper attributeMapper;\n    private DefaultImplementationsMapper defaultImplementationsMapper;\n    private ImmutableTypesMapper immutableTypesMapper;\n    private ImplicitCollectionMapper implicitCollectionMapper;\n    private LocalConversionMapper localConversionMapper;\n    private SecurityMapper securityMapper;\n    private AnnotationConfiguration annotationConfiguration;\n\n    private transient boolean insecureWarning;\n\n    public static final int NO_REFERENCES = 1001;\n    public static final int ID_REFERENCES = 1002;\n    public static final int XPATH_RELATIVE_REFERENCES = 1003;\n    public static final int XPATH_ABSOLUTE_REFERENCES = 1004;\n    public static final int SINGLE_NODE_XPATH_RELATIVE_REFERENCES = 1005;\n    public static final int SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES = 1006;\n\n    public static final int PRIORITY_VERY_HIGH = 10000;\n    public static final int PRIORITY_NORMAL = 0;\n    public static final int PRIORITY_LOW = -10;\n    public static final int PRIORITY_VERY_LOW = -20;\n\n    private static final String ANNOTATION_MAPPER_TYPE = \"com.thoughtworks.xstream.mapper.AnnotationMapper\";\n    private static final Pattern IGNORE_ALL = Pattern.compile(\".*\");\n\n    /**\n     * Constructs a default XStream.\n     * <p>\n     * The instance will use the {@link XppDriver} as default and tries to determine the best\n     * match for the {@link ReflectionProvider} on its own.\n     * </p>\n     *\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream() {\n        this(null, (Mapper)null, new XppDriver());\n    }\n\n    /**\n     * Constructs an XStream with a special {@link ReflectionProvider}.\n     * <p>\n     * The instance will use the {@link XppDriver} as default.\n     * </p>\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching reflection provider\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream(ReflectionProvider reflectionProvider) {\n        this(reflectionProvider, (Mapper)null, new XppDriver());\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver}.\n     * <p>\n     * The instance will tries to determine the best match for the {@link ReflectionProvider} on\n     * its own.\n     * </p>\n     *\n     * @param hierarchicalStreamDriver the driver instance\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream(HierarchicalStreamDriver hierarchicalStreamDriver) {\n        this(null, (Mapper)null, hierarchicalStreamDriver);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver} and\n     * {@link ReflectionProvider}.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param hierarchicalStreamDriver the driver instance\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver hierarchicalStreamDriver) {\n        this(reflectionProvider, (Mapper)null, hierarchicalStreamDriver);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider} and a prepared {@link Mapper} chain.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default\n     *            chain\n     * @param driver the driver instance\n     * @throws InitializationException in case of an initialization problem\n     * @deprecated As of 1.3, use\n     *             {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoader, Mapper)}\n     *             instead\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, Mapper mapper, HierarchicalStreamDriver driver) {\n        this(reflectionProvider, driver, new CompositeClassLoader(), mapper);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider} and a {@link ClassLoaderReference}.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param driver the driver instance\n     * @param classLoaderReference the reference to the {@link ClassLoader} to use\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.4.5\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoaderReference classLoaderReference) {\n        this(reflectionProvider, driver, classLoaderReference, null);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider} and the {@link ClassLoader} to use.\n     * \n     * @throws InitializationException in case of an initialization problem\n     * @since 1.3\n     * @deprecated As of 1.4.5 use\n     *             {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoaderReference)}\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoader classLoader) {\n        this(reflectionProvider, driver, classLoader, null);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider}, a prepared {@link Mapper} chain and the {@link ClassLoader}\n     * to use.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param driver the driver instance\n     * @param classLoader the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default\n     *            chain\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.3\n     * @deprecated As of 1.4.5 use\n     *             {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoaderReference, Mapper)}\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoader classLoader, Mapper mapper) {\n        this(\n            reflectionProvider, driver, new ClassLoaderReference(classLoader), mapper, new DefaultConverterLookup());\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider}, a prepared {@link Mapper} chain and the\n     * {@link ClassLoaderReference}.\n     * <p>\n     * The {@link ClassLoaderReference} should also be used for the {@link Mapper} chain.\n     * </p>\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param driver the driver instance\n     * @param classLoaderReference the reference to the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default\n     *            chain\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.4.5\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoaderReference classLoaderReference, Mapper mapper) {\n        this(\n            reflectionProvider, driver, classLoaderReference, mapper, new DefaultConverterLookup());\n    }\n    \n    private XStream(\n            ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver, ClassLoaderReference classLoader,\n            Mapper mapper, final DefaultConverterLookup defaultConverterLookup) {\n        this(reflectionProvider, driver, classLoader, mapper, new ConverterLookup() {\n            public Converter lookupConverterForType(Class type) {\n                return defaultConverterLookup.lookupConverterForType(type);\n            }\n        }, new ConverterRegistry() {\n            public void registerConverter(Converter converter, int priority) {\n                defaultConverterLookup.registerConverter(converter, priority);\n            }\n        });\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider}, a prepared {@link Mapper} chain, the\n     * {@link ClassLoaderReference} and an own {@link ConverterLookup} and\n     * {@link ConverterRegistry}.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param driver the driver instance\n     * @param classLoader the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default\n     *            chain\n     * @param converterLookup the instance that is used to lookup the converters\n     * @param converterRegistry an instance to manage the converter instances\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.3\n     * @deprecated As of 1.4.5 use\n     *             {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoaderReference, Mapper, ConverterLookup, ConverterRegistry)}\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoader classLoader, Mapper mapper, ConverterLookup converterLookup,\n        ConverterRegistry converterRegistry) {\n        this(reflectionProvider, driver, new ClassLoaderReference(classLoader), mapper, converterLookup, converterRegistry);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider}, a prepared {@link Mapper} chain, the\n     * {@link ClassLoaderReference} and an own {@link ConverterLookup} and\n     * {@link ConverterRegistry}.\n     * <p>\n     * The ClassLoaderReference should also be used for the Mapper chain. The ConverterLookup\n     * should access the ConverterRegistry if you intent to register {@link Converter} instances\n     * with XStream facade or you are using annotations.\n     * </p>\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param driver the driver instance\n     * @param classLoaderReference the reference to the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default\n     *            chain\n     * @param converterLookup the instance that is used to lookup the converters\n     * @param converterRegistry an instance to manage the converter instances or <em>null</em>\n     *            to prevent any further registry (including annotations)\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.4.5\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoaderReference classLoaderReference, Mapper mapper, ConverterLookup converterLookup,\n        ConverterRegistry converterRegistry) {\n        if (reflectionProvider == null) {\n            reflectionProvider = JVM.newReflectionProvider();\n        }\n        this.reflectionProvider = reflectionProvider;\n        this.hierarchicalStreamDriver = driver;\n        this.classLoaderReference = classLoaderReference;\n        this.converterLookup = converterLookup;\n        this.converterRegistry = converterRegistry;\n        this.mapper = mapper == null ? buildMapper() : mapper;\n\n        setupMappers();\n        setupSecurity();\n        setupAliases();\n        setupDefaultImplementations();\n        setupConverters();\n        setupImmutableTypes();\n        setMode(XPATH_RELATIVE_REFERENCES);\n    }\n\n    private Mapper buildMapper() {\n        Mapper mapper = new DefaultMapper(classLoaderReference);\n        if (useXStream11XmlFriendlyMapper()) {\n            mapper = new XStream11XmlFriendlyMapper(mapper);\n        }\n        mapper = new DynamicProxyMapper(mapper);\n        mapper = new PackageAliasingMapper(mapper);\n        mapper = new ClassAliasingMapper(mapper);\n        mapper = new ElementIgnoringMapper(mapper);\n        mapper = new FieldAliasingMapper(mapper);\n        mapper = new AttributeAliasingMapper(mapper);\n        mapper = new SystemAttributeAliasingMapper(mapper);\n        mapper = new ImplicitCollectionMapper(mapper, reflectionProvider);\n        mapper = new OuterClassMapper(mapper);\n        mapper = new ArrayMapper(mapper);\n        mapper = new DefaultImplementationsMapper(mapper);\n        mapper = new AttributeMapper(mapper, converterLookup, reflectionProvider);\n        if (JVM.isVersion(5)) {\n            mapper = buildMapperDynamically(\n                \"com.thoughtworks.xstream.mapper.EnumMapper\", new Class[]{Mapper.class},\n                new Object[]{mapper});\n        }\n        mapper = new LocalConversionMapper(mapper);\n        mapper = new ImmutableTypesMapper(mapper);\n        if (JVM.isVersion(8)) {\n            mapper = buildMapperDynamically(\"com.thoughtworks.xstream.mapper.LambdaMapper\", new Class[]{Mapper.class},\n                new Object[]{mapper});\n        }\n        mapper = new SecurityMapper(mapper);\n        if (JVM.isVersion(5)) {\n            mapper = buildMapperDynamically(ANNOTATION_MAPPER_TYPE, new Class[]{\n                Mapper.class, ConverterRegistry.class, ConverterLookup.class,\n                ClassLoaderReference.class, ReflectionProvider.class}, new Object[]{\n                mapper, converterRegistry, converterLookup, classLoaderReference,\n                reflectionProvider});\n        }\n        mapper = wrapMapper((MapperWrapper)mapper);\n        mapper = new CachingMapper(mapper);\n        return mapper;\n    }\n\n    private Mapper buildMapperDynamically(String className, Class[] constructorParamTypes,\n        Object[] constructorParamValues) {\n        try {\n            Class type = Class.forName(className, false, classLoaderReference.getReference());\n            Constructor constructor = type.getConstructor(constructorParamTypes);\n            return (Mapper)constructor.newInstance(constructorParamValues);\n        } catch (Exception e) {\n            throw new com.thoughtworks.xstream.InitializationException(\n                \"Could not instantiate mapper : \" + className, e);\n        } catch (LinkageError e) {\n            throw new com.thoughtworks.xstream.InitializationException(\n                \"Could not instantiate mapper : \" + className, e);\n        }\n    }\n\n    protected MapperWrapper wrapMapper(MapperWrapper next) {\n        return next;\n    }\n\n    /**\n     * @deprecated As of 1.4.8\n     */\n    protected boolean useXStream11XmlFriendlyMapper() {\n        return false;\n    }\n\n    private void setupMappers() {\n        packageAliasingMapper = (PackageAliasingMapper)this.mapper\n            .lookupMapperOfType(PackageAliasingMapper.class);\n        classAliasingMapper = (ClassAliasingMapper)this.mapper\n            .lookupMapperOfType(ClassAliasingMapper.class);\n        elementIgnoringMapper = (ElementIgnoringMapper)this.mapper\n            .lookupMapperOfType(ElementIgnoringMapper.class);\n        fieldAliasingMapper = (FieldAliasingMapper)this.mapper\n            .lookupMapperOfType(FieldAliasingMapper.class);\n        attributeMapper = (AttributeMapper)this.mapper\n            .lookupMapperOfType(AttributeMapper.class);\n        attributeAliasingMapper = (AttributeAliasingMapper)this.mapper\n            .lookupMapperOfType(AttributeAliasingMapper.class);\n        systemAttributeAliasingMapper = (SystemAttributeAliasingMapper)this.mapper\n            .lookupMapperOfType(SystemAttributeAliasingMapper.class);\n        implicitCollectionMapper = (ImplicitCollectionMapper)this.mapper\n            .lookupMapperOfType(ImplicitCollectionMapper.class);\n        defaultImplementationsMapper = (DefaultImplementationsMapper)this.mapper\n            .lookupMapperOfType(DefaultImplementationsMapper.class);\n        immutableTypesMapper = (ImmutableTypesMapper)this.mapper\n            .lookupMapperOfType(ImmutableTypesMapper.class);\n        localConversionMapper = (LocalConversionMapper)this.mapper\n            .lookupMapperOfType(LocalConversionMapper.class);\n        securityMapper = (SecurityMapper)this.mapper\n            .lookupMapperOfType(SecurityMapper.class);\n        annotationConfiguration = (AnnotationConfiguration)this.mapper\n            .lookupMapperOfType(AnnotationConfiguration.class);\n    }\n    \n    protected void setupSecurity() {\n        if (securityMapper == null) {\n            return;\n        }\n        \n        addPermission(AnyTypePermission.ANY);\n        insecureWarning = true;\n    }\n\n    /**\n     * Setup the security framework of a XStream instance.\n     * <p>\n     * This method is a pure helper method for XStream 1.4.x. It initializes an XStream instance with a white list of\n     * well-known and simply types of the Java runtime as it is done in XStream 1.5.x by default. This method will do\n     * therefore nothing in XStream 1.5.\n     * </p>\n     * \n     * @param xstream\n     * @since 1.4.10\n     */\n    public static void setupDefaultSecurity(final XStream xstream) {\n        if (xstream.insecureWarning) {\n            xstream.addPermission(NoTypePermission.NONE);\n            xstream.addPermission(NullPermission.NULL);\n            xstream.addPermission(PrimitiveTypePermission.PRIMITIVES);\n            xstream.addPermission(ArrayTypePermission.ARRAYS);\n            xstream.addPermission(InterfaceTypePermission.INTERFACES);\n            xstream.allowTypeHierarchy(Calendar.class);\n            xstream.allowTypeHierarchy(Collection.class);\n            xstream.allowTypeHierarchy(Map.class);\n            xstream.allowTypeHierarchy(Map.Entry.class);\n            xstream.allowTypeHierarchy(Member.class);\n            xstream.allowTypeHierarchy(Number.class);\n            xstream.allowTypeHierarchy(Throwable.class);\n            xstream.allowTypeHierarchy(TimeZone.class);\n\n            Class type = JVM.loadClassForName(\"java.lang.Enum\");\n            if (type != null) {\n                xstream.allowTypeHierarchy(type);\n            }\n            type = JVM.loadClassForName(\"java.nio.file.Path\");\n            if (type != null) {\n                xstream.allowTypeHierarchy(type);\n            }\n\n            final Set types = new HashSet();\n            types.add(BitSet.class);\n            types.add(Charset.class);\n            types.add(Class.class);\n            types.add(Currency.class);\n            types.add(Date.class);\n            types.add(DecimalFormatSymbols.class);\n            types.add(File.class);\n            types.add(Locale.class);\n            types.add(Object.class);\n            types.add(Pattern.class);\n            types.add(StackTraceElement.class);\n            types.add(String.class);\n            types.add(StringBuffer.class);\n            types.add(JVM.loadClassForName(\"java.lang.StringBuilder\"));\n            types.add(URL.class);\n            types.add(URI.class);\n            types.add(JVM.loadClassForName(\"java.util.UUID\"));\n            if (JVM.isSQLAvailable()) {\n                types.add(JVM.loadClassForName(\"java.sql.Timestamp\"));\n                types.add(JVM.loadClassForName(\"java.sql.Time\"));\n                types.add(JVM.loadClassForName(\"java.sql.Date\"));\n            }\n            if (JVM.isVersion(8)) {\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.Clock\"));\n                types.add(JVM.loadClassForName(\"java.time.Duration\"));\n                types.add(JVM.loadClassForName(\"java.time.Instant\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalDate\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalDateTime\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalTime\"));\n                types.add(JVM.loadClassForName(\"java.time.MonthDay\"));\n                types.add(JVM.loadClassForName(\"java.time.OffsetDateTime\"));\n                types.add(JVM.loadClassForName(\"java.time.OffsetTime\"));\n                types.add(JVM.loadClassForName(\"java.time.Period\"));\n                types.add(JVM.loadClassForName(\"java.time.Ser\"));\n                types.add(JVM.loadClassForName(\"java.time.Year\"));\n                types.add(JVM.loadClassForName(\"java.time.YearMonth\"));\n                types.add(JVM.loadClassForName(\"java.time.ZonedDateTime\"));\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.ZoneId\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.HijrahDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.JapaneseDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.JapaneseEra\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.MinguoDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.Ser\"));\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.chrono.Chronology\"));\n                types.add(JVM.loadClassForName(\"java.time.temporal.ValueRange\"));\n                types.add(JVM.loadClassForName(\"java.time.temporal.WeekFields\"));\n            }\n            types.remove(null);\n\n            final Iterator iter = types.iterator();\n            final Class[] classes = new Class[types.size()];\n            for (int i = 0; i < classes.length; ++i) {\n                classes[i] = (Class)iter.next();\n            }\n            xstream.allowTypes(classes);\n        } else {\n            throw new IllegalArgumentException(\"Security framework of XStream instance already initialized\");\n        }\n    }\n\n    protected void setupAliases() {\n        if (classAliasingMapper == null) {\n            return;\n        }\n\n        alias(\"null\", Mapper.Null.class);\n        alias(\"int\", Integer.class);\n        alias(\"float\", Float.class);\n        alias(\"double\", Double.class);\n        alias(\"long\", Long.class);\n        alias(\"short\", Short.class);\n        alias(\"char\", Character.class);\n        alias(\"byte\", Byte.class);\n        alias(\"boolean\", Boolean.class);\n        alias(\"number\", Number.class);\n        alias(\"object\", Object.class);\n        alias(\"big-int\", BigInteger.class);\n        alias(\"big-decimal\", BigDecimal.class);\n\n        alias(\"string-buffer\", StringBuffer.class);\n        alias(\"string\", String.class);\n        alias(\"java-class\", Class.class);\n        alias(\"method\", Method.class);\n        alias(\"constructor\", Constructor.class);\n        alias(\"field\", Field.class);\n        alias(\"date\", Date.class);\n        alias(\"uri\", URI.class);\n        alias(\"url\", URL.class);\n        alias(\"bit-set\", BitSet.class);\n\n        alias(\"map\", Map.class);\n        alias(\"entry\", Map.Entry.class);\n        alias(\"properties\", Properties.class);\n        alias(\"list\", List.class);\n        alias(\"set\", Set.class);\n        alias(\"sorted-set\", SortedSet.class);\n\n        alias(\"linked-list\", LinkedList.class);\n        alias(\"vector\", Vector.class);\n        alias(\"tree-map\", TreeMap.class);\n        alias(\"tree-set\", TreeSet.class);\n        alias(\"hashtable\", Hashtable.class);\n        \n        alias(\"empty-list\", Collections.EMPTY_LIST.getClass());\n        alias(\"empty-map\", Collections.EMPTY_MAP.getClass());\n        alias(\"empty-set\", Collections.EMPTY_SET.getClass());\n        alias(\"singleton-list\", Collections.singletonList(this).getClass());\n        alias(\"singleton-map\", Collections.singletonMap(this, null).getClass());\n        alias(\"singleton-set\", Collections.singleton(this).getClass());\n\n        if (JVM.isAWTAvailable()) {\n            // Instantiating these two classes starts the AWT system, which is undesirable.\n            // Calling loadClass ensures a reference to the class is found but they are not\n            // instantiated.\n            alias(\"awt-color\", JVM.loadClassForName(\"java.awt.Color\", false));\n            alias(\"awt-font\", JVM.loadClassForName(\"java.awt.Font\", false));\n            alias(\"awt-text-attribute\", JVM.loadClassForName(\"java.awt.font.TextAttribute\"));\n        }\n\n        Class type = JVM.loadClassForName(\"javax.activation.ActivationDataFlavor\");\n        if (type != null) {\n            alias(\"activation-data-flavor\", type);\n        }\n\n        if (JVM.isSQLAvailable()) {\n            alias(\"sql-timestamp\", JVM.loadClassForName(\"java.sql.Timestamp\"));\n            alias(\"sql-time\", JVM.loadClassForName(\"java.sql.Time\"));\n            alias(\"sql-date\", JVM.loadClassForName(\"java.sql.Date\"));\n        }\n\n        alias(\"file\", File.class);\n        alias(\"locale\", Locale.class);\n        alias(\"gregorian-calendar\", Calendar.class);\n\n        if (JVM.isVersion(4)) {\n            aliasDynamically(\"auth-subject\", \"javax.security.auth.Subject\");\n            alias(\"linked-hash-map\", JVM.loadClassForName(\"java.util.LinkedHashMap\"));\n            alias(\"linked-hash-set\", JVM.loadClassForName(\"java.util.LinkedHashSet\"));\n            alias(\"trace\", JVM.loadClassForName(\"java.lang.StackTraceElement\"));\n            alias(\"currency\", JVM.loadClassForName(\"java.util.Currency\"));\n            aliasType(\"charset\", JVM.loadClassForName(\"java.nio.charset.Charset\"));\n        }\n\n        if (JVM.isVersion(5)) {\n            aliasDynamically(\"xml-duration\", \"javax.xml.datatype.Duration\");\n            alias(\"concurrent-hash-map\", JVM.loadClassForName(\"java.util.concurrent.ConcurrentHashMap\"));\n            alias(\"enum-set\", JVM.loadClassForName(\"java.util.EnumSet\"));\n            alias(\"enum-map\", JVM.loadClassForName(\"java.util.EnumMap\"));\n            alias(\"string-builder\", JVM.loadClassForName(\"java.lang.StringBuilder\"));\n            alias(\"uuid\", JVM.loadClassForName(\"java.util.UUID\"));\n        }\n        \n        if (JVM.isVersion(7)) {\n            aliasType(\"path\", JVM.loadClassForName(\"java.nio.file.Path\"));\n        }\n\n        if (JVM.isVersion(8)) {\n            alias(\"fixed-clock\", JVM.loadClassForName(\"java.time.Clock$FixedClock\"));\n            alias(\"offset-clock\", JVM.loadClassForName(\"java.time.Clock$OffsetClock\"));\n            alias(\"system-clock\", JVM.loadClassForName(\"java.time.Clock$SystemClock\"));\n            alias(\"tick-clock\", JVM.loadClassForName(\"java.time.Clock$TickClock\"));\n            alias(\"day-of-week\", JVM.loadClassForName(\"java.time.DayOfWeek\"));\n            alias(\"duration\", JVM.loadClassForName(\"java.time.Duration\"));\n            alias(\"instant\", JVM.loadClassForName(\"java.time.Instant\"));\n            alias(\"local-date\", JVM.loadClassForName(\"java.time.LocalDate\"));\n            alias(\"local-date-time\", JVM.loadClassForName(\"java.time.LocalDateTime\"));\n            alias(\"local-time\", JVM.loadClassForName(\"java.time.LocalTime\"));\n            alias(\"month\", JVM.loadClassForName(\"java.time.Month\"));\n            alias(\"month-day\", JVM.loadClassForName(\"java.time.MonthDay\"));\n            alias(\"offset-date-time\", JVM.loadClassForName(\"java.time.OffsetDateTime\"));\n            alias(\"offset-time\", JVM.loadClassForName(\"java.time.OffsetTime\"));\n            alias(\"period\", JVM.loadClassForName(\"java.time.Period\"));\n            alias(\"year\", JVM.loadClassForName(\"java.time.Year\"));\n            alias(\"year-month\", JVM.loadClassForName(\"java.time.YearMonth\"));\n            alias(\"zoned-date-time\", JVM.loadClassForName(\"java.time.ZonedDateTime\"));\n            aliasType(\"zone-id\", JVM.loadClassForName(\"java.time.ZoneId\"));\n            aliasType(\"chronology\", JVM.loadClassForName(\"java.time.chrono.Chronology\"));\n            alias(\"hijrah-date\", JVM.loadClassForName(\"java.time.chrono.HijrahDate\"));\n            alias(\"hijrah-era\", JVM.loadClassForName(\"java.time.chrono.HijrahEra\"));\n            alias(\"japanese-date\", JVM.loadClassForName(\"java.time.chrono.JapaneseDate\"));\n            alias(\"japanese-era\", JVM.loadClassForName(\"java.time.chrono.JapaneseEra\"));\n            alias(\"minguo-date\", JVM.loadClassForName(\"java.time.chrono.MinguoDate\"));\n            alias(\"minguo-era\", JVM.loadClassForName(\"java.time.chrono.MinguoEra\"));\n            alias(\"thai-buddhist-date\", JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistDate\"));\n            alias(\"thai-buddhist-era\", JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistEra\"));\n            alias(\"chrono-field\", JVM.loadClassForName(\"java.time.temporal.ChronoField\"));\n            alias(\"chrono-unit\", JVM.loadClassForName(\"java.time.temporal.ChronoUnit\"));\n            alias(\"iso-field\", JVM.loadClassForName(\"java.time.temporal.IsoFields$Field\"));\n            alias(\"iso-unit\", JVM.loadClassForName(\"java.time.temporal.IsoFields$Unit\"));\n            alias(\"julian-field\", JVM.loadClassForName(\"java.time.temporal.JulianFields$Field\"));\n            alias(\"temporal-value-range\", JVM.loadClassForName(\"java.time.temporal.ValueRange\"));\n            alias(\"week-fields\", JVM.loadClassForName(\"java.time.temporal.WeekFields\"));\n        }\n\n        if (JVM.loadClassForName(\"java.lang.invoke.SerializedLambda\") != null) {\n            aliasDynamically(\"serialized-lambda\", \"java.lang.invoke.SerializedLambda\");\n        }\n    }\n\n    private void aliasDynamically(String alias, String className) {\n        Class type = JVM.loadClassForName(className);\n        if (type != null) {\n            alias(alias, type);\n        }\n    }\n\n    protected void setupDefaultImplementations() {\n        if (defaultImplementationsMapper == null) {\n            return;\n        }\n        addDefaultImplementation(HashMap.class, Map.class);\n        addDefaultImplementation(ArrayList.class, List.class);\n        addDefaultImplementation(HashSet.class, Set.class);\n        addDefaultImplementation(TreeSet.class, SortedSet.class);\n        addDefaultImplementation(GregorianCalendar.class, Calendar.class);\n    }\n\n    protected void setupConverters() {\n        registerConverter(\n            new ReflectionConverter(mapper, reflectionProvider), PRIORITY_VERY_LOW);\n\n        registerConverter(\n            new SerializableConverter(mapper, reflectionProvider, classLoaderReference), PRIORITY_LOW);\n        registerConverter(new ExternalizableConverter(mapper, classLoaderReference), PRIORITY_LOW);\n        registerConverter(new InternalBlackList(), PRIORITY_LOW);\n\n        registerConverter(new NullConverter(), PRIORITY_VERY_HIGH);\n        registerConverter(new IntConverter(), PRIORITY_NORMAL);\n        registerConverter(new FloatConverter(), PRIORITY_NORMAL);\n        registerConverter(new DoubleConverter(), PRIORITY_NORMAL);\n        registerConverter(new LongConverter(), PRIORITY_NORMAL);\n        registerConverter(new ShortConverter(), PRIORITY_NORMAL);\n        registerConverter((Converter)new CharConverter(), PRIORITY_NORMAL);\n        registerConverter(new BooleanConverter(), PRIORITY_NORMAL);\n        registerConverter(new ByteConverter(), PRIORITY_NORMAL);\n\n        registerConverter(new StringConverter(), PRIORITY_NORMAL);\n        registerConverter(new StringBufferConverter(), PRIORITY_NORMAL);\n        registerConverter(new DateConverter(), PRIORITY_NORMAL);\n        registerConverter(new BitSetConverter(), PRIORITY_NORMAL);\n        registerConverter(new URIConverter(), PRIORITY_NORMAL);\n        registerConverter(new URLConverter(), PRIORITY_NORMAL);\n        registerConverter(new BigIntegerConverter(), PRIORITY_NORMAL);\n        registerConverter(new BigDecimalConverter(), PRIORITY_NORMAL);\n\n        registerConverter(new ArrayConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new CharArrayConverter(), PRIORITY_NORMAL);\n        registerConverter(new CollectionConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new MapConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new TreeMapConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new TreeSetConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new SingletonCollectionConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new SingletonMapConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new PropertiesConverter(), PRIORITY_NORMAL);\n        registerConverter((Converter)new EncodedByteArrayConverter(), PRIORITY_NORMAL);\n\n        registerConverter(new FileConverter(), PRIORITY_NORMAL);\n        if (JVM.isSQLAvailable()) {\n            registerConverter(new SqlTimestampConverter(), PRIORITY_NORMAL);\n            registerConverter(new SqlTimeConverter(), PRIORITY_NORMAL);\n            registerConverter(new SqlDateConverter(), PRIORITY_NORMAL);\n        }\n        registerConverter(new DynamicProxyConverter(mapper, classLoaderReference), PRIORITY_NORMAL);\n        registerConverter(new JavaClassConverter(classLoaderReference), PRIORITY_NORMAL);\n        registerConverter(new JavaMethodConverter(classLoaderReference), PRIORITY_NORMAL);\n        registerConverter(new JavaFieldConverter(classLoaderReference), PRIORITY_NORMAL);\n\n        if (JVM.isAWTAvailable()) {\n            registerConverter(new FontConverter(mapper), PRIORITY_NORMAL);\n            registerConverter(new ColorConverter(), PRIORITY_NORMAL);\n            registerConverter(new TextAttributeConverter(), PRIORITY_NORMAL);\n        }\n        if (JVM.isSwingAvailable()) {\n            registerConverter(\n                new LookAndFeelConverter(mapper, reflectionProvider), PRIORITY_NORMAL);\n        }\n        registerConverter(new LocaleConverter(), PRIORITY_NORMAL);\n        registerConverter(new GregorianCalendarConverter(), PRIORITY_NORMAL);\n\n        if (JVM.isVersion(4)) {\n            // late bound converters - allows XStream to be compiled on earlier JDKs\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.SubjectConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.ThrowableConverter\",\n                PRIORITY_NORMAL, new Class[]{ConverterLookup.class},\n                new Object[]{converterLookup});\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.StackTraceElementConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.CurrencyConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.RegexPatternConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.CharsetConverter\",\n                PRIORITY_NORMAL, null, null);\n        }\n\n        if (JVM.isVersion(5)) {\n            // late bound converters - allows XStream to be compiled on earlier JDKs\n            if (JVM.loadClassForName(\"javax.xml.datatype.Duration\") != null) {\n                registerConverterDynamically(\n                    \"com.thoughtworks.xstream.converters.extended.DurationConverter\",\n                    PRIORITY_NORMAL, null, null);\n            }\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.enums.EnumConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.enums.EnumSetConverter\", PRIORITY_NORMAL,\n                new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.enums.EnumMapConverter\", PRIORITY_NORMAL,\n                new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.basic.StringBuilderConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.basic.UUIDConverter\", PRIORITY_NORMAL,\n                null, null);\n        }\n        if (JVM.loadClassForName(\"javax.activation.ActivationDataFlavor\") != null) {\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.ActivationDataFlavorConverter\",\n                PRIORITY_NORMAL, null, null);\n        }\n        if (JVM.isVersion(7)) {\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.PathConverter\",\n                    PRIORITY_NORMAL, null, null);\n        }\n        if (JVM.isVersion(8)) {\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ChronologyConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.DurationConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.HijrahDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.JapaneseDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.JapaneseEraConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.InstantConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalDateConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalDateTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalTimeConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.MinguoDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.MonthDayConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.OffsetDateTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.OffsetTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.PeriodConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.SystemClockConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ThaiBuddhistDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ValueRangeConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.WeekFieldsConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.YearConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.YearMonthConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ZonedDateTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ZoneIdConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.reflection.LambdaConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class, ReflectionProvider.class, ClassLoaderReference.class},\n                new Object[]{mapper, reflectionProvider, classLoaderReference});\n        }\n\n        registerConverter(\n            new SelfStreamingInstanceChecker(converterLookup, this), PRIORITY_NORMAL);\n    }\n\n    private void registerConverterDynamically(String className, int priority,\n        Class[] constructorParamTypes, Object[] constructorParamValues) {\n        try {\n            Class type = Class.forName(className, false, classLoaderReference.getReference());\n            Constructor constructor = type.getConstructor(constructorParamTypes);\n            Object instance = constructor.newInstance(constructorParamValues);\n            if (instance instanceof Converter) {\n                registerConverter((Converter)instance, priority);\n            } else if (instance instanceof SingleValueConverter) {\n                registerConverter((SingleValueConverter)instance, priority);\n            }\n        } catch (Exception e) {\n            throw new com.thoughtworks.xstream.InitializationException(\n                \"Could not instantiate converter : \" + className, e);\n        } catch (LinkageError e) {\n            throw new com.thoughtworks.xstream.InitializationException(\n                \"Could not instantiate converter : \" + className, e);\n        }\n    }\n\n    protected void setupImmutableTypes() {\n        if (immutableTypesMapper == null) {\n            return;\n        }\n\n        // primitives are always immutable\n        addImmutableType(boolean.class, false);\n        addImmutableType(Boolean.class, false);\n        addImmutableType(byte.class, false);\n        addImmutableType(Byte.class, false);\n        addImmutableType(char.class, false);\n        addImmutableType(Character.class, false);\n        addImmutableType(double.class, false);\n        addImmutableType(Double.class, false);\n        addImmutableType(float.class, false);\n        addImmutableType(Float.class, false);\n        addImmutableType(int.class, false);\n        addImmutableType(Integer.class, false);\n        addImmutableType(long.class, false);\n        addImmutableType(Long.class, false);\n        addImmutableType(short.class, false);\n        addImmutableType(Short.class, false);\n\n        // additional types\n        addImmutableType(Mapper.Null.class, false);\n        addImmutableType(BigDecimal.class, false);\n        addImmutableType(BigInteger.class, false);\n        addImmutableType(String.class, false);\n        addImmutableType(URL.class, false);\n        addImmutableType(File.class, false);\n        addImmutableType(Class.class, false);\n\n        if (JVM.isVersion(7)) {\n            Class type = JVM.loadClassForName(\"java.nio.file.Paths\");\n            if (type != null) {\n                Method methodGet;\n                try {\n                    methodGet = type.getDeclaredMethod(\"get\", new Class[] {String.class, String[].class});\n                    if (methodGet != null) {\n                        Object path = methodGet.invoke(null, new Object[]{\".\", new String[0]});\n                        if (path != null) {\n                            addImmutableType(path.getClass(), false);\n                        }\n                    }\n                } catch (NoSuchMethodException e) {\n                } catch (SecurityException e) {\n                } catch (IllegalAccessException e) {\n                } catch (InvocationTargetException e) {\n                }\n            }\n        }\n\n        if (JVM.isAWTAvailable()) {\n            addImmutableTypeDynamically(\"java.awt.font.TextAttribute\", false);\n        }\n\n        if (JVM.isVersion(4)) {\n            // late bound types - allows XStream to be compiled on earlier JDKs\n            addImmutableTypeDynamically(\"java.nio.charset.Charset\", true);\n            addImmutableTypeDynamically(\"java.util.Currency\", true);\n        }\n        \n        if (JVM.isVersion(5)) {\n            addImmutableTypeDynamically(\"java.util.UUID\", true);\n        }\n\n        addImmutableType(URI.class, true);\n        addImmutableType(Collections.EMPTY_LIST.getClass(), true);\n        addImmutableType(Collections.EMPTY_SET.getClass(), true);\n        addImmutableType(Collections.EMPTY_MAP.getClass(), true);\n\n        if (JVM.isVersion(8)) {\n            addImmutableTypeDynamically(\"java.time.Duration\", false);\n            addImmutableTypeDynamically(\"java.time.Instant\", false);\n            addImmutableTypeDynamically(\"java.time.LocalDate\", false);\n            addImmutableTypeDynamically(\"java.time.LocalDateTime\", false);\n            addImmutableTypeDynamically(\"java.time.LocalTime\", false);\n            addImmutableTypeDynamically(\"java.time.MonthDay\", false);\n            addImmutableTypeDynamically(\"java.time.OffsetDateTime\", false);\n            addImmutableTypeDynamically(\"java.time.OffsetTime\", false);\n            addImmutableTypeDynamically(\"java.time.Period\", false);\n            addImmutableTypeDynamically(\"java.time.Year\", false);\n            addImmutableTypeDynamically(\"java.time.YearMonth\", false);\n            addImmutableTypeDynamically(\"java.time.ZonedDateTime\", false);\n            addImmutableTypeDynamically(\"java.time.ZoneId\", false);\n            addImmutableTypeDynamically(\"java.time.ZoneOffset\", false);\n            addImmutableTypeDynamically(\"java.time.ZoneRegion\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.HijrahChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.HijrahDate\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.IsoChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.JapaneseChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.JapaneseDate\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.JapaneseEra\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.MinguoChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.MinguoDate\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.ThaiBuddhistChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.ThaiBuddhistDate\", false);\n            addImmutableTypeDynamically(\"java.time.temporal.IsoFields$Field\", false);\n            addImmutableTypeDynamically(\"java.time.temporal.IsoFields$Unit\", false);\n            addImmutableTypeDynamically(\"java.time.temporal.JulianFields$Field\", false);\n        }\n    }\n\n    private void addImmutableTypeDynamically(String className, boolean isReferenceable) {\n        Class type = JVM.loadClassForName(className);\n        if (type != null) {\n            addImmutableType(type, isReferenceable);\n        }\n    }\n\n    public void setMarshallingStrategy(MarshallingStrategy marshallingStrategy) {\n        this.marshallingStrategy = marshallingStrategy;\n    }\n\n    /**\n     * Serialize an object to a pretty-printed XML String.\n     *\n     * @throws XStreamException if the object cannot be serialized\n     */\n    public String toXML(Object obj) {\n        Writer writer = new StringWriter();\n        toXML(obj, writer);\n        return writer.toString();\n    }\n\n    /**\n     * Serialize an object to the given Writer as pretty-printed XML. The Writer will be flushed\n     * afterwards and in case of an exception.\n     * \n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void toXML(Object obj, Writer out) {\n        HierarchicalStreamWriter writer = hierarchicalStreamDriver.createWriter(out);\n        try {\n            marshal(obj, writer);\n        } finally {\n            writer.flush();\n        }\n    }\n\n    /**\n     * Serialize an object to the given OutputStream as pretty-printed XML. The OutputStream\n     * will be flushed afterwards and in case of an exception.\n     * \n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void toXML(Object obj, OutputStream out) {\n        HierarchicalStreamWriter writer = hierarchicalStreamDriver.createWriter(out);\n        try {\n            marshal(obj, writer);\n        } finally {\n            writer.flush();\n        }\n    }\n\n    /**\n     * Serialize and object to a hierarchical data structure (such as XML).\n     *\n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void marshal(Object obj, HierarchicalStreamWriter writer) {\n        marshal(obj, writer, null);\n    }\n\n    /**\n     * Serialize and object to a hierarchical data structure (such as XML).\n     * \n     * @param dataHolder Extra data you can use to pass to your converters. Use this as you\n     *            want. If not present, XStream shall create one lazily as needed.\n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void marshal(Object obj, HierarchicalStreamWriter writer, DataHolder dataHolder) {\n        marshallingStrategy.marshal(writer, obj, converterLookup, mapper, dataHolder);\n    }\n\n    /**\n     * Deserialize an object from an XML String.\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(String xml) {\n        return fromXML(new StringReader(xml));\n    }\n\n    /**\n     * Deserialize an object from an XML Reader.\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(Reader reader) {\n        return unmarshal(hierarchicalStreamDriver.createReader(reader), null);\n    }\n\n    /**\n     * Deserialize an object from an XML InputStream.\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(InputStream input) {\n        return unmarshal(hierarchicalStreamDriver.createReader(input), null);\n    }\n\n    /**\n     * Deserialize an object from a URL.\n     * \n     * Depending on the parser implementation, some might take the file path as SystemId to\n     * resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(URL url) {\n        return fromXML(url, null);\n    }\n\n    /**\n     * Deserialize an object from a file.\n     * \n     * Depending on the parser implementation, some might take the file path as SystemId to\n     * resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(File file) {\n        return fromXML(file, null);\n    }\n\n    /**\n     * Deserialize an object from an XML String, populating the fields of the given root object\n     * instead of instantiating a new one. Note, that this is a special use case! With the\n     * ReflectionConverter XStream will write directly into the raw memory area of the existing\n     * object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(String xml, Object root) {\n        return fromXML(new StringReader(xml), root);\n    }\n\n    /**\n     * Deserialize an object from an XML Reader, populating the fields of the given root object\n     * instead of instantiating a new one. Note, that this is a special use case! With the\n     * ReflectionConverter XStream will write directly into the raw memory area of the existing\n     * object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(Reader xml, Object root) {\n        return unmarshal(hierarchicalStreamDriver.createReader(xml), root);\n    }\n\n    /**\n     * Deserialize an object from a URL, populating the fields of the given root\n     * object instead of instantiating a new one. Note, that this is a special use case! With\n     * the ReflectionConverter XStream will write directly into the raw memory area of the\n     * existing object. Use with care!\n     * \n     * Depending on the parser implementation, some might take the file path as SystemId to\n     * resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(URL url, Object root) {\n        return unmarshal(hierarchicalStreamDriver.createReader(url), root);\n    }\n\n    /**\n     * Deserialize an object from a file, populating the fields of the given root\n     * object instead of instantiating a new one. Note, that this is a special use case! With\n     * the ReflectionConverter XStream will write directly into the raw memory area of the\n     * existing object. Use with care!\n     * \n     * Depending on the parser implementation, some might take the file path as SystemId to\n     * resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(File file, Object root) {\n        HierarchicalStreamReader reader = hierarchicalStreamDriver.createReader(file);\n        try {\n            return unmarshal(reader, root);\n        } finally {\n            reader.close();\n        }\n    }\n\n    /**\n     * Deserialize an object from an XML InputStream, populating the fields of the given root\n     * object instead of instantiating a new one. Note, that this is a special use case! With\n     * the ReflectionConverter XStream will write directly into the raw memory area of the\n     * existing object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(InputStream input, Object root) {\n        return unmarshal(hierarchicalStreamDriver.createReader(input), root);\n    }\n\n    /**\n     * Deserialize an object from a hierarchical data structure (such as XML).\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object unmarshal(HierarchicalStreamReader reader) {\n        return unmarshal(reader, null, null);\n    }\n\n    /**\n     * Deserialize an object from a hierarchical data structure (such as XML), populating the\n     * fields of the given root object instead of instantiating a new one. Note, that this is a\n     * special use case! With the ReflectionConverter XStream will write directly into the raw\n     * memory area of the existing object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object unmarshal(HierarchicalStreamReader reader, Object root) {\n        return unmarshal(reader, root, null);\n    }\n\n    /**\n     * Deserialize an object from a hierarchical data structure (such as XML).\n     * \n     * @param root If present, the passed in object will have its fields populated, as opposed\n     *            to XStream creating a new instance. Note, that this is a special use case!\n     *            With the ReflectionConverter XStream will write directly into the raw memory\n     *            area of the existing object. Use with care!\n     * @param dataHolder Extra data you can use to pass to your converters. Use this as you\n     *            want. If not present, XStream shall create one lazily as needed.\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object unmarshal(HierarchicalStreamReader reader, Object root, DataHolder dataHolder) {\n        try {\n            if (insecureWarning) {\n                insecureWarning = false;\n                System.err.println(\"Security framework of XStream not initialized, XStream is probably vulnerable.\");\n            }\n            return marshallingStrategy.unmarshal(\n                root, reader, dataHolder, converterLookup, mapper);\n\n        } catch (ConversionException e) {\n            Package pkg = getClass().getPackage();\n            String version = pkg != null ? pkg.getImplementationVersion() : null;\n            e.add(\"version\", version != null ? version : \"not available\");\n            throw e;\n        }\n    }\n\n    /**\n     * Alias a Class to a shorter name to be used in XML elements.\n     *\n     * @param name Short name\n     * @param type Type to be aliased\n     * @throws InitializationException if no {@link ClassAliasingMapper} is available\n     */\n    public void alias(String name, Class type) {\n        if (classAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ClassAliasingMapper.class.getName()\n                + \" available\");\n        }\n        classAliasingMapper.addClassAlias(name, type);\n    }\n\n    /**\n     * Alias a type to a shorter name to be used in XML elements. Any class that is assignable\n     * to this type will be aliased to the same name.\n     * \n     * @param name Short name\n     * @param type Type to be aliased\n     * @since 1.2\n     * @throws InitializationException if no {@link ClassAliasingMapper} is available\n     */\n    public void aliasType(String name, Class type) {\n        if (classAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ClassAliasingMapper.class.getName()\n                + \" available\");\n        }\n        classAliasingMapper.addTypeAlias(name, type);\n    }\n\n    /**\n     * Alias a Class to a shorter name to be used in XML elements.\n     *\n     * @param name Short name\n     * @param type Type to be aliased\n     * @param defaultImplementation Default implementation of type to use if no other specified.\n     * @throws InitializationException if no {@link DefaultImplementationsMapper} or no\n     *             {@link ClassAliasingMapper} is available\n     */\n    public void alias(String name, Class type, Class defaultImplementation) {\n        alias(name, type);\n        addDefaultImplementation(defaultImplementation, type);\n    }\n\n    /**\n     * Alias a package to a shorter name to be used in XML elements.\n     *\n     * @param name Short name\n     * @param pkgName package to be aliased\n     * @throws InitializationException if no {@link DefaultImplementationsMapper} or no\n     *             {@link PackageAliasingMapper} is available\n     * @since 1.3.1\n     */\n    public void aliasPackage(String name, String pkgName) {\n        if (packageAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + PackageAliasingMapper.class.getName()\n                + \" available\");\n        }\n        packageAliasingMapper.addPackageAlias(name, pkgName);\n    }\n\n    /**\n     * Create an alias for a field name.\n     *\n     * @param alias the alias itself\n     * @param definedIn the type that declares the field\n     * @param fieldName the name of the field\n     * @throws InitializationException if no {@link FieldAliasingMapper} is available\n     */\n    public void aliasField(String alias, Class definedIn, String fieldName) {\n        if (fieldAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + FieldAliasingMapper.class.getName()\n                + \" available\");\n        }\n        fieldAliasingMapper.addFieldAlias(alias, definedIn, fieldName);\n    }\n\n    /**\n     * Create an alias for an attribute\n     *\n     * @param alias the alias itself\n     * @param attributeName the name of the attribute\n     * @throws InitializationException if no {@link AttributeAliasingMapper} is available\n     */\n    public void aliasAttribute(String alias, String attributeName) {\n        if (attributeAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeAliasingMapper.class.getName()\n                + \" available\");\n        }\n        attributeAliasingMapper.addAliasFor(attributeName, alias);\n    }\n\n    /**\n     * Create an alias for a system attribute. XStream will not write a system attribute if its\n     * alias is set to <code>null</code>. However, this is not reversible, i.e. deserialization\n     * of the result is likely to fail afterwards and will not produce an object equal to the\n     * originally written one.\n     * \n     * @param alias the alias itself (may be <code>null</code>)\n     * @param systemAttributeName the name of the system attribute\n     * @throws InitializationException if no {@link SystemAttributeAliasingMapper} is available\n     * @since 1.3.1\n     */\n    public void aliasSystemAttribute(String alias, String systemAttributeName) {\n        if (systemAttributeAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + SystemAttributeAliasingMapper.class.getName()\n                + \" available\");\n        }\n        systemAttributeAliasingMapper.addAliasFor(systemAttributeName, alias);\n    }\n\n    /**\n     * Create an alias for an attribute.\n     *\n     * @param definedIn the type where the attribute is defined\n     * @param attributeName the name of the attribute\n     * @param alias the alias itself\n     * @throws InitializationException if no {@link AttributeAliasingMapper} is available\n     * @since 1.2.2\n     */\n    public void aliasAttribute(Class definedIn, String attributeName, String alias) {\n        aliasField(alias, definedIn, attributeName);\n        useAttributeFor(definedIn, attributeName);\n    }\n\n    /**\n     * Use an attribute for a field or a specific type.\n     *\n     * @param fieldName the name of the field\n     * @param type the Class of the type to be rendered as XML attribute\n     * @throws InitializationException if no {@link AttributeMapper} is available\n     * @since 1.2\n     */\n    public void useAttributeFor(String fieldName, Class type) {\n        if (attributeMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeMapper.class.getName()\n                + \" available\");\n        }\n        attributeMapper.addAttributeFor(fieldName, type);\n    }\n\n    /**\n     * Use an attribute for a field declared in a specific type.\n     *\n     * @param fieldName the name of the field\n     * @param definedIn the Class containing such field\n     * @throws InitializationException if no {@link AttributeMapper} is available\n     * @since 1.2.2\n     */\n    public void useAttributeFor(Class definedIn, String fieldName) {\n        if (attributeMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeMapper.class.getName()\n                + \" available\");\n        }\n        attributeMapper.addAttributeFor(definedIn, fieldName);\n    }\n\n    /**\n     * Use an attribute for an arbitrary type.\n     *\n     * @param type the Class of the type to be rendered as XML attribute\n     * @throws InitializationException if no {@link AttributeMapper} is available\n     * @since 1.2\n     */\n    public void useAttributeFor(Class type) {\n        if (attributeMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeMapper.class.getName()\n                + \" available\");\n        }\n        attributeMapper.addAttributeFor(type);\n    }\n\n    /**\n     * Associate a default implementation of a class with an object. Whenever XStream encounters\n     * an instance of this type, it will use the default implementation instead. For example,\n     * java.util.ArrayList is the default implementation of java.util.List.\n     * \n     * @param defaultImplementation\n     * @param ofType\n     * @throws InitializationException if no {@link DefaultImplementationsMapper} is available\n     */\n    public void addDefaultImplementation(Class defaultImplementation, Class ofType) {\n        if (defaultImplementationsMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + DefaultImplementationsMapper.class.getName()\n                + \" available\");\n        }\n        defaultImplementationsMapper.addDefaultImplementation(defaultImplementation, ofType);\n    }\n\n    /**\n     * Add immutable types. The value of the instances of these types will always be written into the stream even if\n     * they appear multiple times. However, references are still supported at deserialization time.\n     *\n     * @throws InitializationException if no {@link ImmutableTypesMapper} is available\n     * @deprecated As of 1.4.9 use {@link #addImmutableType(Class, boolean)}\n     */\n    public void addImmutableType(Class type) {\n        addImmutableType(type, true);\n    }\n\n    /**\n     * Add immutable types. The value of the instances of these types will always be written into the stream even if\n     * they appear multiple times.\n     * <p>\n     * Note, while a reference-keeping marshaller will not write references for immutable types into the stream, a\n     * reference-keeping unmarshaller can still support such references in the stream for compatibility reasons at the\n     * expense of memory consumption. Therefore declare these types only as referenceable if your already persisted\n     * streams do contain such references. Otherwise you may waste a lot of memory during deserialization.\n     * </p>\n     *\n     * @param isReferenceable <code>true</code> if support at deserialization time is required for compatibility at the\n     *            cost of a higher memory footprint, <code>false</code> otherwise\n     * @throws InitializationException if no {@link ImmutableTypesMapper} is available\n     * @since 1.4.9\n     */\n    public void addImmutableType(final Class type, final boolean isReferenceable) {\n        if (immutableTypesMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ImmutableTypesMapper.class.getName()\n                + \" available\");\n        }\n        immutableTypesMapper.addImmutableType(type, isReferenceable);\n    }\n\n    public void registerConverter(Converter converter) {\n        registerConverter(converter, PRIORITY_NORMAL);\n    }\n\n    public void registerConverter(Converter converter, int priority) {\n        if (converterRegistry != null) {\n            converterRegistry.registerConverter(converter, priority);\n        }\n    }\n\n    public void registerConverter(SingleValueConverter converter) {\n        registerConverter(converter, PRIORITY_NORMAL);\n    }\n\n    public void registerConverter(SingleValueConverter converter, int priority) {\n        if (converterRegistry != null) {\n            converterRegistry.registerConverter(\n                new SingleValueConverterWrapper(converter), priority);\n        }\n    }\n\n    /**\n     * Register a local {@link Converter} for a field.\n     *\n     * @param definedIn the class type the field is defined in\n     * @param fieldName the field name\n     * @param converter the converter to use\n     * @since 1.3\n     */\n    public void registerLocalConverter(Class definedIn, String fieldName, Converter converter) {\n        if (localConversionMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + LocalConversionMapper.class.getName()\n                + \" available\");\n        }\n        localConversionMapper.registerLocalConverter(definedIn, fieldName, converter);\n    }\n\n    /**\n     * Register a local {@link SingleValueConverter} for a field.\n     *\n     * @param definedIn the class type the field is defined in\n     * @param fieldName the field name\n     * @param converter the converter to use\n     * @since 1.3\n     */\n    public void registerLocalConverter(Class definedIn, String fieldName,\n        SingleValueConverter converter) {\n        registerLocalConverter(\n            definedIn, fieldName, (Converter)new SingleValueConverterWrapper(converter));\n    }\n\n    /**\n     * Retrieve the {@link Mapper}. This is by default a chain of {@link MapperWrapper\n     * MapperWrappers}.\n     * \n     * @return the mapper\n     * @since 1.2\n     */\n    public Mapper getMapper() {\n        return mapper;\n    }\n\n    /**\n     * Retrieve the {@link ReflectionProvider} in use.\n     *\n     * @return the mapper\n     * @since 1.2.1\n     */\n    public ReflectionProvider getReflectionProvider() {\n        return reflectionProvider;\n    }\n\n    public ConverterLookup getConverterLookup() {\n        return converterLookup;\n    }\n\n    /**\n     * Change mode for dealing with duplicate references. Valid values are\n     * <code>XPATH_ABSOLUTE_REFERENCES</code>, <code>XPATH_RELATIVE_REFERENCES</code>,\n     * <code>XStream.ID_REFERENCES</code> and <code>XStream.NO_REFERENCES</code>.\n     * \n     * @throws IllegalArgumentException if the mode is not one of the declared types\n     * @see #XPATH_ABSOLUTE_REFERENCES\n     * @see #XPATH_RELATIVE_REFERENCES\n     * @see #ID_REFERENCES\n     * @see #NO_REFERENCES\n     */\n    public void setMode(int mode) {\n        switch (mode) {\n        case NO_REFERENCES:\n            setMarshallingStrategy(new TreeMarshallingStrategy());\n            break;\n        case ID_REFERENCES:\n            setMarshallingStrategy(new ReferenceByIdMarshallingStrategy());\n            break;\n        case XPATH_RELATIVE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                ReferenceByXPathMarshallingStrategy.RELATIVE));\n            break;\n        case XPATH_ABSOLUTE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                ReferenceByXPathMarshallingStrategy.ABSOLUTE));\n            break;\n        case SINGLE_NODE_XPATH_RELATIVE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                  ReferenceByXPathMarshallingStrategy.RELATIVE \n                | ReferenceByXPathMarshallingStrategy.SINGLE_NODE));\n            break;\n        case SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                  ReferenceByXPathMarshallingStrategy.ABSOLUTE \n                | ReferenceByXPathMarshallingStrategy.SINGLE_NODE));\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown mode : \" + mode);\n        }\n    }\n\n    /**\n     * Adds a default implicit collection which is used for any unmapped XML tag.\n     *\n     * @param ownerType class owning the implicit collection\n     * @param fieldName name of the field in the ownerType. This field must be a concrete\n     *            collection type or matching the default implementation type of the collection\n     *            type.\n     */\n    public void addImplicitCollection(Class ownerType, String fieldName) {\n        addImplicitCollection(ownerType, fieldName, null, null);\n    }\n\n    /**\n     * Adds implicit collection which is used for all items of the given itemType.\n     *\n     * @param ownerType class owning the implicit collection\n     * @param fieldName name of the field in the ownerType. This field must be a concrete\n     *            collection type or matching the default implementation type of the collection\n     *            type.\n     * @param itemType type of the items to be part of this collection\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available\n     */\n    public void addImplicitCollection(Class ownerType, String fieldName, Class itemType) {\n        addImplicitCollection(ownerType, fieldName, null, itemType);\n    }\n\n    /**\n     * Adds implicit collection which is used for all items of the given element name defined by\n     * itemFieldName.\n     * \n     * @param ownerType class owning the implicit collection\n     * @param fieldName name of the field in the ownerType. This field must be a concrete\n     *            collection type or matching the default implementation type of the collection\n     *            type.\n     * @param itemFieldName element name of the implicit collection\n     * @param itemType item type to be aliases be the itemFieldName\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available\n     */\n    public void addImplicitCollection(Class ownerType, String fieldName, String itemFieldName,\n        Class itemType) {\n        addImplicitMap(ownerType, fieldName, itemFieldName, itemType, null);\n    }\n\n    /**\n     * Adds an implicit array.\n     *\n     * @param ownerType class owning the implicit array\n     * @param fieldName name of the array field\n     * @since 1.4 \n     */\n    public void addImplicitArray(Class ownerType, String fieldName) {\n        addImplicitCollection(ownerType, fieldName);\n    }\n\n    /**\n     * Adds an implicit array which is used for all items of the given itemType when the array\n     * type matches.\n     * \n     * @param ownerType class owning the implicit array\n     * @param fieldName name of the array field in the ownerType\n     * @param itemType type of the items to be part of this array\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available or the\n     * array type does not match the itemType\n     * @since 1.4 \n     */\n    public void addImplicitArray(Class ownerType, String fieldName, Class itemType) {\n        addImplicitCollection(ownerType, fieldName, itemType);\n    }\n\n    /**\n     * Adds an implicit array which is used for all items of the given element name defined by\n     * itemName.\n     * \n     * @param ownerType class owning the implicit array\n     * @param fieldName name of the array field in the ownerType\n     * @param itemName alias name of the items\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available\n     * @since 1.4 \n     */\n    public void addImplicitArray(Class ownerType, String fieldName, String itemName) {\n        addImplicitCollection(ownerType, fieldName, itemName, null);\n    }\n\n    /**\n     * Adds an implicit map.\n     *\n     * @param ownerType class owning the implicit map\n     * @param fieldName name of the field in the ownerType. This field must be a concrete\n     *            map type or matching the default implementation type of the map\n     *            type.\n     * @param itemType type of the items to be part of this map as value\n     * @param keyFieldName the name of the field of the itemType that is used for the key in the map\n     * @since 1.4 \n     */\n    public void addImplicitMap(Class ownerType, String fieldName, Class itemType, String keyFieldName) {\n        addImplicitMap(ownerType, fieldName, null, itemType, keyFieldName);\n    }\n\n    /**\n     * Adds an implicit map.\n     *\n     * @param ownerType class owning the implicit map\n     * @param fieldName name of the field in the ownerType. This field must be a concrete\n     *            map type or matching the default implementation type of the map\n     *            type.\n     * @param itemName alias name of the items\n     * @param itemType type of the items to be part of this map as value\n     * @param keyFieldName the name of the field of the itemType that is used for the key in the map\n     * @since 1.4 \n     */\n    public void addImplicitMap(Class ownerType, String fieldName, String itemName, \n        Class itemType, String keyFieldName) {\n        if (implicitCollectionMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ImplicitCollectionMapper.class.getName()\n                + \" available\");\n        }\n        implicitCollectionMapper.add(ownerType, fieldName, itemName, itemType, keyFieldName);\n    }\n\n    /**\n     * Create a DataHolder that can be used to pass data to the converters. The DataHolder is provided with a call to\n     * {@link #marshal(Object, HierarchicalStreamWriter, DataHolder)},\n     * {@link #unmarshal(HierarchicalStreamReader, Object, DataHolder)},\n     * {@link #createObjectInputStream(HierarchicalStreamReader, DataHolder)} or\n     * {@link #createObjectOutputStream(HierarchicalStreamWriter, String, DataHolder)}.\n     *\n     * @return a new {@link DataHolder}\n     */\n    public DataHolder newDataHolder() {\n        return new MapBackedDataHolder();\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using\n     * XStream.\n     * <p>\n     * To change the name of the root element (from &lt;object-stream&gt;), use\n     * {@link #createObjectOutputStream(java.io.Writer, String)}.\n     * </p>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(Writer writer) throws IOException {\n        return createObjectOutputStream(\n            hierarchicalStreamDriver.createWriter(writer), \"object-stream\");\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using\n     * XStream.\n     * <p>\n     * To change the name of the root element (from &lt;object-stream&gt;), use\n     * {@link #createObjectOutputStream(java.io.Writer, String)}.\n     * </p>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(HierarchicalStreamWriter writer)\n        throws IOException {\n        return createObjectOutputStream(writer, \"object-stream\");\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using\n     * XStream.\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(Writer writer, String rootNodeName)\n        throws IOException {\n        return createObjectOutputStream(\n            hierarchicalStreamDriver.createWriter(writer), rootNodeName);\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the OutputStream\n     * using XStream.\n     * <p>\n     * To change the name of the root element (from &lt;object-stream&gt;), use\n     * {@link #createObjectOutputStream(java.io.Writer, String)}.\n     * </p>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.3\n     */\n    public ObjectOutputStream createObjectOutputStream(OutputStream out) throws IOException {\n        return createObjectOutputStream(\n            hierarchicalStreamDriver.createWriter(out), \"object-stream\");\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the OutputStream\n     * using XStream.\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.3\n     */\n    public ObjectOutputStream createObjectOutputStream(OutputStream out, String rootNodeName)\n        throws IOException {\n        return createObjectOutputStream(\n            hierarchicalStreamDriver.createWriter(out), rootNodeName);\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using\n     * XStream.\n     * <p>\n     * Because an ObjectOutputStream can contain multiple items and XML only allows a single\n     * root node, the stream must be written inside an enclosing node.\n     * </p>\n     * <p>\n     * It is necessary to call ObjectOutputStream.close() when done, otherwise the stream will\n     * be incomplete.\n     * </p>\n     * <h3>Example</h3>\n     *\n     * <pre>\n     *  ObjectOutputStream out = xstream.createObjectOutputStream(aWriter, &quot;things&quot;);\n     *   out.writeInt(123);\n     *   out.writeObject(&quot;Hello&quot;);\n     *   out.writeObject(someObject)\n     *   out.close();\n     * </pre>\n     *\n     * @param writer The writer to serialize the objects to.\n     * @param rootNodeName The name of the root node enclosing the stream of objects.\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(final HierarchicalStreamWriter writer, final String rootNodeName)\n            throws IOException {\n        return createObjectOutputStream(writer, rootNodeName, null);\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using XStream.\n     *\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.4.10\n     */\n    public ObjectOutputStream createObjectOutputStream(final HierarchicalStreamWriter writer, final String rootNodeName,\n            final DataHolder dataHolder) throws IOException {\n        final StatefulWriter statefulWriter = new StatefulWriter(writer);\n        statefulWriter.startNode(rootNodeName, null);\n        return new CustomObjectOutputStream(new CustomObjectOutputStream.StreamCallback() {\n            public void writeToStream(final Object object) {\n                marshal(object, statefulWriter, dataHolder);\n            }\n\n            public void writeFieldsToStream(Map fields) throws NotActiveException {\n                throw new NotActiveException(\"not in call to writeObject\");\n            }\n\n            public void defaultWriteObject() throws NotActiveException {\n                throw new NotActiveException(\"not in call to writeObject\");\n            }\n\n            public void flush() {\n                statefulWriter.flush();\n            }\n\n            public void close() {\n                if (statefulWriter.state() != StatefulWriter.STATE_CLOSED) {\n                    statefulWriter.endNode();\n                    statefulWriter.close();\n                }\n            }\n        });\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from a reader using\n     * XStream.\n     * \n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @since 1.0.3\n     */\n    public ObjectInputStream createObjectInputStream(Reader xmlReader) throws IOException {\n        return createObjectInputStream(hierarchicalStreamDriver.createReader(xmlReader));\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from an InputStream\n     * using XStream.\n     * \n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @since 1.3\n     */\n    public ObjectInputStream createObjectInputStream(InputStream in) throws IOException {\n        return createObjectInputStream(hierarchicalStreamDriver.createReader(in));\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from a reader using XStream.\n     * <p>\n     * It is necessary to call ObjectInputStream.close() when done, otherwise the stream might keep system resources.\n     * </p>\n     * <h3>Example</h3>\n     *\n     * <pre>\n     * ObjectInputStream in = xstream.createObjectOutputStream(aReader);\n     * int a = out.readInt();\n     * Object b = out.readObject();\n     * Object c = out.readObject();\n     * </pre>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @since 1.0.3\n     */\n    public ObjectInputStream createObjectInputStream(final HierarchicalStreamReader reader) throws IOException {\n        return createObjectInputStream(reader, null);\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from a reader using XStream.\n     *\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.4.10\n     */\n    public ObjectInputStream createObjectInputStream(final HierarchicalStreamReader reader, final DataHolder dataHolder)\n            throws IOException {\n        return new CustomObjectInputStream(new CustomObjectInputStream.StreamCallback() {\n            public Object readFromStream() throws EOFException {\n                if (!reader.hasMoreChildren()) {\n                    throw new EOFException();\n                }\n                reader.moveDown();\n                final Object result = unmarshal(reader, dataHolder);\n                reader.moveUp();\n                return result;\n            }\n\n            public Map readFieldsFromStream() throws IOException {\n                throw new NotActiveException(\"not in call to readObject\");\n            }\n\n            public void defaultReadObject() throws NotActiveException {\n                throw new NotActiveException(\"not in call to readObject\");\n            }\n\n            public void registerValidation(ObjectInputValidation validation, int priority)\n                throws NotActiveException {\n                throw new NotActiveException(\"stream inactive\");\n            }\n\n            public void close() {\n                reader.close();\n            }\n        }, classLoaderReference);\n    }\n\n    /**\n     * Change the ClassLoader XStream uses to load classes. Creating an XStream instance it will\n     * register for all kind of classes and types of the current JDK, but not for any 3rd party\n     * type. To ensure that all other types are loaded with your class loader, you should call\n     * this method as early as possible - or consider to provide the class loader directly in\n     * the constructor.\n     * \n     * @since 1.1.1\n     */\n    public void setClassLoader(ClassLoader classLoader) {\n        classLoaderReference.setReference(classLoader);\n    }\n\n    /**\n     * Retrieve the ClassLoader XStream uses to load classes.\n     *\n     * @since 1.1.1\n     */\n    public ClassLoader getClassLoader() {\n        return classLoaderReference.getReference();\n    }\n    \n    /**\n     * Retrieve the reference to this instance' ClassLoader. Use this reference for other\n     * XStream components (like converters) to ensure that they will use a changed ClassLoader\n     * instance automatically.\n     * \n     * @return the reference\n     * @since 1.4.5\n     */\n    public ClassLoaderReference getClassLoaderReference() {\n        return classLoaderReference;\n    }\n\n    /**\n     * Prevents a field from being serialized. To omit a field you must always provide the\n     * declaring type and not necessarily the type that is converted.\n     * \n     * @since 1.1.3\n     * @throws InitializationException if no {@link ElementIgnoringMapper} is available\n     */\n    public void omitField(Class definedIn, String fieldName) {\n        if (elementIgnoringMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ElementIgnoringMapper.class.getName()\n                + \" available\");\n        }\n        elementIgnoringMapper.omitField(definedIn, fieldName);\n    }\n    \n    /**\n     * Ignore all unknown elements.\n     *\n     * @since 1.4.5\n     */\n    public void ignoreUnknownElements() {\n        ignoreUnknownElements(IGNORE_ALL);\n    }\n\n    /**\n     * Add pattern for unknown element names to ignore.\n     *\n     * @param pattern the name pattern as regular expression\n     * @since 1.4.5\n     */\n    public void ignoreUnknownElements(String pattern) {\n        ignoreUnknownElements(Pattern.compile(pattern));\n    }\n\n    /**\n     * Add pattern for unknown element names to ignore.\n     *\n     * @param pattern the name pattern as regular expression\n     * @since 1.4.5\n     */\n    public void ignoreUnknownElements(final Pattern pattern) {\n        if (elementIgnoringMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ElementIgnoringMapper.class.getName()\n                + \" available\");\n        }\n        elementIgnoringMapper.addElementsToIgnore(pattern);\n    }\n\n    /**\n     * Process the annotations of the given types and configure the XStream.\n     *\n     * @param types the types with XStream annotations\n     * @since 1.3\n     */\n    public void processAnnotations(final Class[] types) {\n        if (annotationConfiguration == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ANNOTATION_MAPPER_TYPE\n                + \" available\");\n        }\n        annotationConfiguration.processAnnotations(types);\n    }\n\n    /**\n     * Process the annotations of the given type and configure the XStream. A call of this\n     * method will automatically turn the auto-detection mode for annotations off.\n     * \n     * @param type the type with XStream annotations\n     * @since 1.3\n     */\n    public void processAnnotations(final Class type) {\n        processAnnotations(new Class[]{type});\n    }\n\n    /**\n     * Set the auto-detection mode of the AnnotationMapper. Note that auto-detection implies\n     * that the XStream is configured while it is processing the XML steams. This is a potential\n     * concurrency problem. Also is it technically not possible to detect all class aliases at\n     * deserialization. You have been warned!\n     * \n     * @param mode <code>true</code> if annotations are auto-detected\n     * @since 1.3\n     */\n    public void autodetectAnnotations(boolean mode) {\n        if (annotationConfiguration != null) {\n            annotationConfiguration.autodetectAnnotations(mode);\n        }\n    }\n    \n    /**\n     * Add a new security permission.\n     * \n     * <p>\n     * Permissions are evaluated in the added sequence. An instance of {@link NoTypePermission} or\n     * {@link AnyTypePermission} will implicitly wipe any existing permission.\n     * </p>\n     *\n     * @param permission the permission to add\n     * @since 1.4.7\n     */\n    public void addPermission(TypePermission permission) {\n        if (securityMapper != null) {\n            insecureWarning &= permission != NoTypePermission.NONE;\n            securityMapper.addPermission(permission);\n        }\n    }\n    \n    /**\n     * Add security permission for explicit types by name.\n     *\n     * @param names the type names to allow\n     * @since 1.4.7\n     */\n    public void allowTypes(String[] names) {\n        addPermission(new ExplicitTypePermission(names));\n    }\n    \n    /**\n     * Add security permission for explicit types.\n     *\n     * @param types the types to allow\n     * @since 1.4.7\n     */\n    public void allowTypes(Class[] types) {\n        addPermission(new ExplicitTypePermission(types));\n    }\n    \n    /**\n     * Add security permission for a type hierarchy.\n     *\n     * @param type the base type to allow\n     * @since 1.4.7\n     */\n    public void allowTypeHierarchy(Class type) {\n        addPermission(new TypeHierarchyPermission(type));\n    }\n    \n    /**\n     * Add security permission for types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to allow type names\n     * @since 1.4.7\n     */\n    public void allowTypesByRegExp(String[] regexps) {\n        addPermission(new RegExpTypePermission(regexps));\n    }\n    \n    /**\n     * Add security permission for types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to allow type names\n     * @since 1.4.7\n     */\n    public void allowTypesByRegExp(Pattern[] regexps) {\n        addPermission(new RegExpTypePermission(regexps));\n    }\n    \n    /**\n     * Add security permission for types matching one of the specified wildcard patterns.\n     * <p>\n     * Supported are patterns with path expressions using dot as separator:\n     * </p>\n     * <ul>\n     * <li>?: one non-control character except separator, e.g. for 'java.net.Inet?Address'</li>\n     * <li>*: arbitrary number of non-control characters except separator, e.g. for types in a package like 'java.lang.*'</li>\n     * <li>**: arbitrary number of non-control characters including separator, e.g. for types in a package and subpackages like 'java.lang.**'</li>\n     * </ul>\n     *\n     * @param patterns the patterns to allow type names\n     * @since 1.4.7\n     */\n    public void allowTypesByWildcard(String[] patterns) {\n        addPermission(new WildcardTypePermission(patterns));\n    }\n    \n    /**\n     * Add security permission denying another one.\n     *\n     * @param permission the permission to deny\n     * @since 1.4.7\n     */\n    public void denyPermission(TypePermission permission) {\n        addPermission(new NoPermission(permission));\n    }\n    \n    /**\n     * Add security permission forbidding explicit types by name.\n     *\n     * @param names the type names to forbid\n     * @since 1.4.7\n     */\n    public void denyTypes(String[] names) {\n        denyPermission(new ExplicitTypePermission(names));\n    }\n    \n    /**\n     * Add security permission forbidding explicit types.\n     *\n     * @param types the types to forbid\n     * @since 1.4.7\n     */\n    public void denyTypes(Class[] types) {\n        denyPermission(new ExplicitTypePermission(types));\n    }\n    \n    /**\n     * Add security permission forbidding a type hierarchy.\n     *\n     * @param type the base type to forbid\n     * @since 1.4.7\n     */\n    public void denyTypeHierarchy(Class type) {\n        denyPermission(new TypeHierarchyPermission(type));\n    }\n    \n    /**\n     * Add security permission forbidding types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to forbid type names\n     * @since 1.4.7\n     */\n    public void denyTypesByRegExp(String[] regexps) {\n        denyPermission(new RegExpTypePermission(regexps));\n    }\n    \n    /**\n     * Add security permission forbidding types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to forbid type names\n     * @since 1.4.7\n     */\n    public void denyTypesByRegExp(Pattern[] regexps) {\n        denyPermission(new RegExpTypePermission(regexps));\n    }\n    \n    /**\n     * Add security permission forbidding types matching one of the specified wildcard patterns.\n     * <p>\n     * Supported are patterns with path expressions using dot as separator:\n     * </p>\n     * <ul>\n     * <li>?: one non-control character except separator, e.g. for 'java.net.Inet?Address'</li>\n     * <li>*: arbitrary number of non-control characters except separator, e.g. for types in a package like 'java.lang.*'</li>\n     * <li>**: arbitrary number of non-control characters including separator, e.g. for types in a package and subpackages like 'java.lang.**'</li>\n     * </ul>\n     *\n     * @param patterns the patterns to forbid names\n     * @since 1.4.7\n     */\n    public void denyTypesByWildcard(String[] patterns) {\n        denyPermission(new WildcardTypePermission(patterns));\n    }\n\n    /**\n     * @deprecated As of 1.3, use {@link com.thoughtworks.xstream.InitializationException}\n     *             instead\n     */\n    public static class InitializationException extends XStreamException {\n        /**\n         * @deprecated As of 1.3, use\n         *             {@link com.thoughtworks.xstream.InitializationException#InitializationException(String, Throwable)}\n         *             instead\n         */\n        public InitializationException(String message, Throwable cause) {\n            super(message, cause);\n        }\n\n        /**\n         * @deprecated As of 1.3, use\n         *             {@link com.thoughtworks.xstream.InitializationException#InitializationException(String)}\n         *             instead\n         */\n        public InitializationException(String message) {\n            super(message);\n        }\n    }\n\n    private class InternalBlackList implements Converter {\n\n        public boolean canConvert(final Class type) {\n            return (type == void.class || type == Void.class)\n                || (insecureWarning\n                    && type != null\n                    && (type.getName().equals(\"java.beans.EventHandler\")\n                        || type.getName().endsWith(\"$LazyIterator\")\n                        || type.getName().startsWith(\"javax.crypto.\")));\n        }\n\n        public void marshal(final Object source, final HierarchicalStreamWriter writer,\n                final MarshallingContext context) {\n            throw new ConversionException(\"Security alert. Marshalling rejected.\");\n        }\n\n        public Object unmarshal(final HierarchicalStreamReader reader, final UnmarshallingContext context) {\n            throw new ConversionException(\"Security alert. Unmarshalling rejected.\");\n        }\n    }\n}\n",
        "human_patch_code": "/*\n * Copyright (C) 2003, 2004, 2005, 2006 Joe Walnes.\n * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018 XStream Committers.\n * All rights reserved.\n *\n * The software in this package is published under the terms of the BSD\n * style license a copy of which has been included with this distribution in\n * the LICENSE.txt file.\n *\n * Created on 26. September 2003 by Joe Walnes\n */\npackage com.thoughtworks.xstream;\n\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.NotActiveException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectInputValidation;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.text.DecimalFormatSymbols;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TimeZone;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\n\nimport com.thoughtworks.xstream.converters.ConversionException;\nimport com.thoughtworks.xstream.converters.Converter;\nimport com.thoughtworks.xstream.converters.ConverterLookup;\nimport com.thoughtworks.xstream.converters.ConverterRegistry;\nimport com.thoughtworks.xstream.converters.DataHolder;\nimport com.thoughtworks.xstream.converters.MarshallingContext;\nimport com.thoughtworks.xstream.converters.SingleValueConverter;\nimport com.thoughtworks.xstream.converters.SingleValueConverterWrapper;\nimport com.thoughtworks.xstream.converters.UnmarshallingContext;\nimport com.thoughtworks.xstream.converters.basic.BigDecimalConverter;\nimport com.thoughtworks.xstream.converters.basic.BigIntegerConverter;\nimport com.thoughtworks.xstream.converters.basic.BooleanConverter;\nimport com.thoughtworks.xstream.converters.basic.ByteConverter;\nimport com.thoughtworks.xstream.converters.basic.CharConverter;\nimport com.thoughtworks.xstream.converters.basic.DateConverter;\nimport com.thoughtworks.xstream.converters.basic.DoubleConverter;\nimport com.thoughtworks.xstream.converters.basic.FloatConverter;\nimport com.thoughtworks.xstream.converters.basic.IntConverter;\nimport com.thoughtworks.xstream.converters.basic.LongConverter;\nimport com.thoughtworks.xstream.converters.basic.NullConverter;\nimport com.thoughtworks.xstream.converters.basic.ShortConverter;\nimport com.thoughtworks.xstream.converters.basic.StringBufferConverter;\nimport com.thoughtworks.xstream.converters.basic.StringConverter;\nimport com.thoughtworks.xstream.converters.basic.URIConverter;\nimport com.thoughtworks.xstream.converters.basic.URLConverter;\nimport com.thoughtworks.xstream.converters.collections.ArrayConverter;\nimport com.thoughtworks.xstream.converters.collections.BitSetConverter;\nimport com.thoughtworks.xstream.converters.collections.CharArrayConverter;\nimport com.thoughtworks.xstream.converters.collections.CollectionConverter;\nimport com.thoughtworks.xstream.converters.collections.MapConverter;\nimport com.thoughtworks.xstream.converters.collections.PropertiesConverter;\nimport com.thoughtworks.xstream.converters.collections.SingletonCollectionConverter;\nimport com.thoughtworks.xstream.converters.collections.SingletonMapConverter;\nimport com.thoughtworks.xstream.converters.collections.TreeMapConverter;\nimport com.thoughtworks.xstream.converters.collections.TreeSetConverter;\nimport com.thoughtworks.xstream.converters.extended.ColorConverter;\nimport com.thoughtworks.xstream.converters.extended.DynamicProxyConverter;\nimport com.thoughtworks.xstream.converters.extended.EncodedByteArrayConverter;\nimport com.thoughtworks.xstream.converters.extended.FileConverter;\nimport com.thoughtworks.xstream.converters.extended.FontConverter;\nimport com.thoughtworks.xstream.converters.extended.GregorianCalendarConverter;\nimport com.thoughtworks.xstream.converters.extended.JavaClassConverter;\nimport com.thoughtworks.xstream.converters.extended.JavaFieldConverter;\nimport com.thoughtworks.xstream.converters.extended.JavaMethodConverter;\nimport com.thoughtworks.xstream.converters.extended.LocaleConverter;\nimport com.thoughtworks.xstream.converters.extended.LookAndFeelConverter;\nimport com.thoughtworks.xstream.converters.extended.SqlDateConverter;\nimport com.thoughtworks.xstream.converters.extended.SqlTimeConverter;\nimport com.thoughtworks.xstream.converters.extended.SqlTimestampConverter;\nimport com.thoughtworks.xstream.converters.extended.TextAttributeConverter;\nimport com.thoughtworks.xstream.converters.reflection.ExternalizableConverter;\nimport com.thoughtworks.xstream.converters.reflection.ReflectionConverter;\nimport com.thoughtworks.xstream.converters.reflection.ReflectionProvider;\nimport com.thoughtworks.xstream.converters.reflection.SerializableConverter;\nimport com.thoughtworks.xstream.core.ClassLoaderReference;\nimport com.thoughtworks.xstream.core.DefaultConverterLookup;\nimport com.thoughtworks.xstream.core.JVM;\nimport com.thoughtworks.xstream.core.MapBackedDataHolder;\nimport com.thoughtworks.xstream.core.ReferenceByIdMarshallingStrategy;\nimport com.thoughtworks.xstream.core.ReferenceByXPathMarshallingStrategy;\nimport com.thoughtworks.xstream.core.TreeMarshallingStrategy;\nimport com.thoughtworks.xstream.core.util.CompositeClassLoader;\nimport com.thoughtworks.xstream.core.util.CustomObjectInputStream;\nimport com.thoughtworks.xstream.core.util.CustomObjectOutputStream;\nimport com.thoughtworks.xstream.core.util.SelfStreamingInstanceChecker;\nimport com.thoughtworks.xstream.io.HierarchicalStreamDriver;\nimport com.thoughtworks.xstream.io.HierarchicalStreamReader;\nimport com.thoughtworks.xstream.io.HierarchicalStreamWriter;\nimport com.thoughtworks.xstream.io.StatefulWriter;\nimport com.thoughtworks.xstream.io.xml.XppDriver;\nimport com.thoughtworks.xstream.mapper.AnnotationConfiguration;\nimport com.thoughtworks.xstream.mapper.ArrayMapper;\nimport com.thoughtworks.xstream.mapper.AttributeAliasingMapper;\nimport com.thoughtworks.xstream.mapper.AttributeMapper;\nimport com.thoughtworks.xstream.mapper.CachingMapper;\nimport com.thoughtworks.xstream.mapper.ClassAliasingMapper;\nimport com.thoughtworks.xstream.mapper.DefaultImplementationsMapper;\nimport com.thoughtworks.xstream.mapper.DefaultMapper;\nimport com.thoughtworks.xstream.mapper.DynamicProxyMapper;\nimport com.thoughtworks.xstream.mapper.ElementIgnoringMapper;\nimport com.thoughtworks.xstream.mapper.FieldAliasingMapper;\nimport com.thoughtworks.xstream.mapper.ImmutableTypesMapper;\nimport com.thoughtworks.xstream.mapper.ImplicitCollectionMapper;\nimport com.thoughtworks.xstream.mapper.LocalConversionMapper;\nimport com.thoughtworks.xstream.mapper.Mapper;\nimport com.thoughtworks.xstream.mapper.MapperWrapper;\nimport com.thoughtworks.xstream.mapper.OuterClassMapper;\nimport com.thoughtworks.xstream.mapper.PackageAliasingMapper;\nimport com.thoughtworks.xstream.mapper.SecurityMapper;\nimport com.thoughtworks.xstream.mapper.SystemAttributeAliasingMapper;\nimport com.thoughtworks.xstream.mapper.XStream11XmlFriendlyMapper;\nimport com.thoughtworks.xstream.security.AnyTypePermission;\nimport com.thoughtworks.xstream.security.ArrayTypePermission;\nimport com.thoughtworks.xstream.security.ExplicitTypePermission;\nimport com.thoughtworks.xstream.security.InterfaceTypePermission;\nimport com.thoughtworks.xstream.security.NoPermission;\nimport com.thoughtworks.xstream.security.NoTypePermission;\nimport com.thoughtworks.xstream.security.NullPermission;\nimport com.thoughtworks.xstream.security.PrimitiveTypePermission;\nimport com.thoughtworks.xstream.security.RegExpTypePermission;\nimport com.thoughtworks.xstream.security.TypeHierarchyPermission;\nimport com.thoughtworks.xstream.security.TypePermission;\nimport com.thoughtworks.xstream.security.WildcardTypePermission;\n\n\n/**\n * Simple facade to XStream library, a Java-XML serialization tool.\n * <p>\n * <hr>\n * <b>Example</b><blockquote>\n *\n * <pre>\n * XStream xstream = new XStream();\n * String xml = xstream.toXML(myObject); // serialize to XML\n * Object myObject2 = xstream.fromXML(xml); // deserialize from XML\n * </pre>\n *\n * </blockquote>\n * <hr>\n * \n * <h3>Aliasing classes</h3>\n * \n * <p>\n * To create shorter XML, you can specify aliases for classes using the <code>alias()</code>\n * method. For example, you can shorten all occurrences of element\n * <code>&lt;com.blah.MyThing&gt;</code> to <code>&lt;my-thing&gt;</code> by registering an\n * alias for the class.\n * <p>\n * <hr>\n * <blockquote>\n *\n * <pre>\n * xstream.alias(&quot;my-thing&quot;, MyThing.class);\n * </pre>\n *\n * </blockquote>\n * <hr>\n * \n * <h3>Converters</h3>\n * \n * <p>\n * XStream contains a map of {@link com.thoughtworks.xstream.converters.Converter} instances, each\n * of which acts as a strategy for converting a particular type of class to XML and back again. Out\n * of the box, XStream contains converters for most basic types (String, Date, int, boolean, etc)\n * and collections (Map, List, Set, Properties, etc). For other objects reflection is used to\n * serialize each field recursively.\n * </p>\n * \n * <p>\n * Extra converters can be registered using the <code>registerConverter()</code> method. Some\n * non-standard converters are supplied in the {@link com.thoughtworks.xstream.converters.extended}\n * package and you can create your own by implementing the\n * {@link com.thoughtworks.xstream.converters.Converter} interface.\n * </p>\n * \n * <p>\n * <hr>\n * <b>Example</b><blockquote>\n *\n * <pre>\n * xstream.registerConverter(new SqlTimestampConverter());\n * xstream.registerConverter(new DynamicProxyConverter());\n * </pre>\n *\n * </blockquote>\n * <hr>\n * <p>\n * The converters can be registered with an explicit priority. By default they are registered with \n * XStream.PRIORITY_NORMAL. Converters of same priority will be used in the reverse sequence\n * they have been registered. The default converter, i.e. the converter which will be used if\n * no other registered converter is suitable, can be registered with priority\n * XStream.PRIORITY_VERY_LOW. XStream uses by default the\n * {@link com.thoughtworks.xstream.converters.reflection.ReflectionConverter} as the fallback\n * converter.\n * </p>\n * \n * <p>\n * <hr>\n * <b>Example</b><blockquote>\n *\n * <pre>\n * xstream.registerConverter(new CustomDefaultConverter(), XStream.PRIORITY_VERY_LOW);\n * </pre>\n *\n * </blockquote>\n * <hr>\n * \n * <h3>Object graphs</h3>\n * \n * <p>\n * XStream has support for object graphs; a deserialized object graph will keep references intact,\n * including circular references.\n * </p>\n * \n * <p>\n * XStream can signify references in XML using either relative/absolute XPath or IDs. The mode can be changed using\n * <code>setMode()</code>:\n * </p>\n * \n * <table border='1'>\n * <caption></caption>\n * <tr>\n * <td><code>xstream.setMode(XStream.XPATH_RELATIVE_REFERENCES);</code></td>\n * <td><i>(Default)</i> Uses XPath relative references to signify duplicate references. This produces XML\n * with the least clutter.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.XPATH_ABSOLUTE_REFERENCES);</code></td>\n * <td>Uses XPath absolute references to signify duplicate\n * references. This produces XML with the least clutter.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.SINGLE_NODE_XPATH_RELATIVE_REFERENCES);</code></td>\n * <td>Uses XPath relative references to signify duplicate references. The XPath expression ensures that\n * a single node only is selected always.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES);</code></td>\n * <td>Uses XPath absolute references to signify duplicate references.  The XPath expression ensures that\n * a single node only is selected always.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.ID_REFERENCES);</code></td>\n * <td>Uses ID references to signify duplicate references. In some scenarios, such as when using\n * hand-written XML, this is easier to work with.</td>\n * </tr>\n * <tr>\n * <td><code>xstream.setMode(XStream.NO_REFERENCES);</code></td>\n * <td>This disables object graph support and treats the object structure like a tree. Duplicate\n * references are treated as two separate objects and circular references cause an exception. This\n * is slightly faster and uses less memory than the other two modes.</td>\n * </tr>\n * </table>\n * <h3>Thread safety</h3>\n * <p>\n * The XStream instance is thread-safe. That is, once the XStream instance has been created and\n * configured, it may be shared across multiple threads allowing objects to be\n * serialized/deserialized concurrently. <em>Note, that this only applies if annotations are not \n * auto-detected on-the-fly.</em>\n * </p>\n * <h3>Implicit collections</h3>\n * \n * <p>\n * To avoid the need for special tags for collections, you can define implicit collections using one\n * of the <code>addImplicitCollection</code> methods.\n * </p>\n *\n * @author Joe Walnes\n * @author J&ouml;rg Schaible\n * @author Mauro Talevi\n * @author Guilherme Silveira\n */\npublic class XStream {\n\n    // CAUTION: The sequence of the fields is intentional for an optimal XML output of a\n    // self-serialization!\n    private ReflectionProvider reflectionProvider;\n    private HierarchicalStreamDriver hierarchicalStreamDriver;\n    private ClassLoaderReference classLoaderReference;\n    private MarshallingStrategy marshallingStrategy;\n    private ConverterLookup converterLookup;\n    private ConverterRegistry converterRegistry;\n    private Mapper mapper;\n\n    private PackageAliasingMapper packageAliasingMapper;\n    private ClassAliasingMapper classAliasingMapper;\n    private FieldAliasingMapper fieldAliasingMapper;\n    private ElementIgnoringMapper elementIgnoringMapper;\n    private AttributeAliasingMapper attributeAliasingMapper;\n    private SystemAttributeAliasingMapper systemAttributeAliasingMapper;\n    private AttributeMapper attributeMapper;\n    private DefaultImplementationsMapper defaultImplementationsMapper;\n    private ImmutableTypesMapper immutableTypesMapper;\n    private ImplicitCollectionMapper implicitCollectionMapper;\n    private LocalConversionMapper localConversionMapper;\n    private SecurityMapper securityMapper;\n    private AnnotationConfiguration annotationConfiguration;\n\n    private transient boolean securityInitialized;\n    private transient boolean securityWarningGiven;\n\n    public static final int NO_REFERENCES = 1001;\n    public static final int ID_REFERENCES = 1002;\n    public static final int XPATH_RELATIVE_REFERENCES = 1003;\n    public static final int XPATH_ABSOLUTE_REFERENCES = 1004;\n    public static final int SINGLE_NODE_XPATH_RELATIVE_REFERENCES = 1005;\n    public static final int SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES = 1006;\n\n    public static final int PRIORITY_VERY_HIGH = 10000;\n    public static final int PRIORITY_NORMAL = 0;\n    public static final int PRIORITY_LOW = -10;\n    public static final int PRIORITY_VERY_LOW = -20;\n\n    private static final String ANNOTATION_MAPPER_TYPE = \"com.thoughtworks.xstream.mapper.AnnotationMapper\";\n    private static final Pattern IGNORE_ALL = Pattern.compile(\".*\");\n\n    /**\n     * Constructs a default XStream.\n     * <p>\n     * The instance will use the {@link XppDriver} as default and tries to determine the best\n     * match for the {@link ReflectionProvider} on its own.\n     * </p>\n     *\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream() {\n        this(null, (Mapper)null, new XppDriver());\n    }\n\n    /**\n     * Constructs an XStream with a special {@link ReflectionProvider}.\n     * <p>\n     * The instance will use the {@link XppDriver} as default.\n     * </p>\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching reflection provider\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream(ReflectionProvider reflectionProvider) {\n        this(reflectionProvider, (Mapper)null, new XppDriver());\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver}.\n     * <p>\n     * The instance will tries to determine the best match for the {@link ReflectionProvider} on\n     * its own.\n     * </p>\n     *\n     * @param hierarchicalStreamDriver the driver instance\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream(HierarchicalStreamDriver hierarchicalStreamDriver) {\n        this(null, (Mapper)null, hierarchicalStreamDriver);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver} and\n     * {@link ReflectionProvider}.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param hierarchicalStreamDriver the driver instance\n     * @throws InitializationException in case of an initialization problem\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver hierarchicalStreamDriver) {\n        this(reflectionProvider, (Mapper)null, hierarchicalStreamDriver);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider} and a prepared {@link Mapper} chain.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default\n     *            chain\n     * @param driver the driver instance\n     * @throws InitializationException in case of an initialization problem\n     * @deprecated As of 1.3, use\n     *             {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoader, Mapper)}\n     *             instead\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, Mapper mapper, HierarchicalStreamDriver driver) {\n        this(reflectionProvider, driver, new CompositeClassLoader(), mapper);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider} and a {@link ClassLoaderReference}.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param driver the driver instance\n     * @param classLoaderReference the reference to the {@link ClassLoader} to use\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.4.5\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoaderReference classLoaderReference) {\n        this(reflectionProvider, driver, classLoaderReference, null);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider} and the {@link ClassLoader} to use.\n     * \n     * @throws InitializationException in case of an initialization problem\n     * @since 1.3\n     * @deprecated As of 1.4.5 use\n     *             {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoaderReference)}\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoader classLoader) {\n        this(reflectionProvider, driver, classLoader, null);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider}, a prepared {@link Mapper} chain and the {@link ClassLoader}\n     * to use.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param driver the driver instance\n     * @param classLoader the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default\n     *            chain\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.3\n     * @deprecated As of 1.4.5 use\n     *             {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoaderReference, Mapper)}\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoader classLoader, Mapper mapper) {\n        this(\n            reflectionProvider, driver, new ClassLoaderReference(classLoader), mapper, new DefaultConverterLookup());\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider}, a prepared {@link Mapper} chain and the\n     * {@link ClassLoaderReference}.\n     * <p>\n     * The {@link ClassLoaderReference} should also be used for the {@link Mapper} chain.\n     * </p>\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param driver the driver instance\n     * @param classLoaderReference the reference to the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default\n     *            chain\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.4.5\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoaderReference classLoaderReference, Mapper mapper) {\n        this(\n            reflectionProvider, driver, classLoaderReference, mapper, new DefaultConverterLookup());\n    }\n    \n    private XStream(\n            ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver, ClassLoaderReference classLoader,\n            Mapper mapper, final DefaultConverterLookup defaultConverterLookup) {\n        this(reflectionProvider, driver, classLoader, mapper, new ConverterLookup() {\n            public Converter lookupConverterForType(Class type) {\n                return defaultConverterLookup.lookupConverterForType(type);\n            }\n        }, new ConverterRegistry() {\n            public void registerConverter(Converter converter, int priority) {\n                defaultConverterLookup.registerConverter(converter, priority);\n            }\n        });\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider}, a prepared {@link Mapper} chain, the\n     * {@link ClassLoaderReference} and an own {@link ConverterLookup} and\n     * {@link ConverterRegistry}.\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param driver the driver instance\n     * @param classLoader the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default\n     *            chain\n     * @param converterLookup the instance that is used to lookup the converters\n     * @param converterRegistry an instance to manage the converter instances\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.3\n     * @deprecated As of 1.4.5 use\n     *             {@link #XStream(ReflectionProvider, HierarchicalStreamDriver, ClassLoaderReference, Mapper, ConverterLookup, ConverterRegistry)}\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoader classLoader, Mapper mapper, ConverterLookup converterLookup,\n        ConverterRegistry converterRegistry) {\n        this(reflectionProvider, driver, new ClassLoaderReference(classLoader), mapper, converterLookup, converterRegistry);\n    }\n\n    /**\n     * Constructs an XStream with a special {@link HierarchicalStreamDriver},\n     * {@link ReflectionProvider}, a prepared {@link Mapper} chain, the\n     * {@link ClassLoaderReference} and an own {@link ConverterLookup} and\n     * {@link ConverterRegistry}.\n     * <p>\n     * The ClassLoaderReference should also be used for the Mapper chain. The ConverterLookup\n     * should access the ConverterRegistry if you intent to register {@link Converter} instances\n     * with XStream facade or you are using annotations.\n     * </p>\n     * \n     * @param reflectionProvider the reflection provider to use or <em>null</em> for best\n     *            matching Provider\n     * @param driver the driver instance\n     * @param classLoaderReference the reference to the {@link ClassLoader} to use\n     * @param mapper the instance with the {@link Mapper} chain or <em>null</em> for the default\n     *            chain\n     * @param converterLookup the instance that is used to lookup the converters\n     * @param converterRegistry an instance to manage the converter instances or <em>null</em>\n     *            to prevent any further registry (including annotations)\n     * @throws InitializationException in case of an initialization problem\n     * @since 1.4.5\n     */\n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoaderReference classLoaderReference, Mapper mapper, ConverterLookup converterLookup,\n        ConverterRegistry converterRegistry) {\n        if (reflectionProvider == null) {\n            reflectionProvider = JVM.newReflectionProvider();\n        }\n        this.reflectionProvider = reflectionProvider;\n        this.hierarchicalStreamDriver = driver;\n        this.classLoaderReference = classLoaderReference;\n        this.converterLookup = converterLookup;\n        this.converterRegistry = converterRegistry;\n        this.mapper = mapper == null ? buildMapper() : mapper;\n\n        setupMappers();\n        setupSecurity();\n        setupAliases();\n        setupDefaultImplementations();\n        setupConverters();\n        setupImmutableTypes();\n        setMode(XPATH_RELATIVE_REFERENCES);\n    }\n\n    private Mapper buildMapper() {\n        Mapper mapper = new DefaultMapper(classLoaderReference);\n        if (useXStream11XmlFriendlyMapper()) {\n            mapper = new XStream11XmlFriendlyMapper(mapper);\n        }\n        mapper = new DynamicProxyMapper(mapper);\n        mapper = new PackageAliasingMapper(mapper);\n        mapper = new ClassAliasingMapper(mapper);\n        mapper = new ElementIgnoringMapper(mapper);\n        mapper = new FieldAliasingMapper(mapper);\n        mapper = new AttributeAliasingMapper(mapper);\n        mapper = new SystemAttributeAliasingMapper(mapper);\n        mapper = new ImplicitCollectionMapper(mapper, reflectionProvider);\n        mapper = new OuterClassMapper(mapper);\n        mapper = new ArrayMapper(mapper);\n        mapper = new DefaultImplementationsMapper(mapper);\n        mapper = new AttributeMapper(mapper, converterLookup, reflectionProvider);\n        if (JVM.isVersion(5)) {\n            mapper = buildMapperDynamically(\n                \"com.thoughtworks.xstream.mapper.EnumMapper\", new Class[]{Mapper.class},\n                new Object[]{mapper});\n        }\n        mapper = new LocalConversionMapper(mapper);\n        mapper = new ImmutableTypesMapper(mapper);\n        if (JVM.isVersion(8)) {\n            mapper = buildMapperDynamically(\"com.thoughtworks.xstream.mapper.LambdaMapper\", new Class[]{Mapper.class},\n                new Object[]{mapper});\n        }\n        mapper = new SecurityMapper(mapper);\n        if (JVM.isVersion(5)) {\n            mapper = buildMapperDynamically(ANNOTATION_MAPPER_TYPE, new Class[]{\n                Mapper.class, ConverterRegistry.class, ConverterLookup.class,\n                ClassLoaderReference.class, ReflectionProvider.class}, new Object[]{\n                mapper, converterRegistry, converterLookup, classLoaderReference,\n                reflectionProvider});\n        }\n        mapper = wrapMapper((MapperWrapper)mapper);\n        mapper = new CachingMapper(mapper);\n        return mapper;\n    }\n\n    private Mapper buildMapperDynamically(String className, Class[] constructorParamTypes,\n        Object[] constructorParamValues) {\n        try {\n            Class type = Class.forName(className, false, classLoaderReference.getReference());\n            Constructor constructor = type.getConstructor(constructorParamTypes);\n            return (Mapper)constructor.newInstance(constructorParamValues);\n        } catch (Exception e) {\n            throw new com.thoughtworks.xstream.InitializationException(\n                \"Could not instantiate mapper : \" + className, e);\n        } catch (LinkageError e) {\n            throw new com.thoughtworks.xstream.InitializationException(\n                \"Could not instantiate mapper : \" + className, e);\n        }\n    }\n\n    protected MapperWrapper wrapMapper(MapperWrapper next) {\n        return next;\n    }\n\n    /**\n     * @deprecated As of 1.4.8\n     */\n    protected boolean useXStream11XmlFriendlyMapper() {\n        return false;\n    }\n\n    private void setupMappers() {\n        packageAliasingMapper = (PackageAliasingMapper)this.mapper\n            .lookupMapperOfType(PackageAliasingMapper.class);\n        classAliasingMapper = (ClassAliasingMapper)this.mapper\n            .lookupMapperOfType(ClassAliasingMapper.class);\n        elementIgnoringMapper = (ElementIgnoringMapper)this.mapper\n            .lookupMapperOfType(ElementIgnoringMapper.class);\n        fieldAliasingMapper = (FieldAliasingMapper)this.mapper\n            .lookupMapperOfType(FieldAliasingMapper.class);\n        attributeMapper = (AttributeMapper)this.mapper\n            .lookupMapperOfType(AttributeMapper.class);\n        attributeAliasingMapper = (AttributeAliasingMapper)this.mapper\n            .lookupMapperOfType(AttributeAliasingMapper.class);\n        systemAttributeAliasingMapper = (SystemAttributeAliasingMapper)this.mapper\n            .lookupMapperOfType(SystemAttributeAliasingMapper.class);\n        implicitCollectionMapper = (ImplicitCollectionMapper)this.mapper\n            .lookupMapperOfType(ImplicitCollectionMapper.class);\n        defaultImplementationsMapper = (DefaultImplementationsMapper)this.mapper\n            .lookupMapperOfType(DefaultImplementationsMapper.class);\n        immutableTypesMapper = (ImmutableTypesMapper)this.mapper\n            .lookupMapperOfType(ImmutableTypesMapper.class);\n        localConversionMapper = (LocalConversionMapper)this.mapper\n            .lookupMapperOfType(LocalConversionMapper.class);\n        securityMapper = (SecurityMapper)this.mapper\n            .lookupMapperOfType(SecurityMapper.class);\n        annotationConfiguration = (AnnotationConfiguration)this.mapper\n            .lookupMapperOfType(AnnotationConfiguration.class);\n    }\n    \n    protected void setupSecurity() {\n        if (securityMapper == null) {\n            return;\n        }\n        \n        addPermission(AnyTypePermission.ANY);\n        securityInitialized = false;\n    }\n\n    /**\n     * Setup the security framework of a XStream instance.\n     * <p>\n     * This method is a pure helper method for XStream 1.4.x. It initializes an XStream instance with a white list of\n     * well-known and simply types of the Java runtime as it is done in XStream 1.5.x by default. This method will do\n     * therefore nothing in XStream 1.5.\n     * </p>\n     * \n     * @param xstream\n     * @since 1.4.10\n     */\n    public static void setupDefaultSecurity(final XStream xstream) {\n        if (!xstream.securityInitialized) {\n            xstream.addPermission(NoTypePermission.NONE);\n            xstream.addPermission(NullPermission.NULL);\n            xstream.addPermission(PrimitiveTypePermission.PRIMITIVES);\n            xstream.addPermission(ArrayTypePermission.ARRAYS);\n            xstream.addPermission(InterfaceTypePermission.INTERFACES);\n            xstream.allowTypeHierarchy(Calendar.class);\n            xstream.allowTypeHierarchy(Collection.class);\n            xstream.allowTypeHierarchy(Map.class);\n            xstream.allowTypeHierarchy(Map.Entry.class);\n            xstream.allowTypeHierarchy(Member.class);\n            xstream.allowTypeHierarchy(Number.class);\n            xstream.allowTypeHierarchy(Throwable.class);\n            xstream.allowTypeHierarchy(TimeZone.class);\n\n            Class type = JVM.loadClassForName(\"java.lang.Enum\");\n            if (type != null) {\n                xstream.allowTypeHierarchy(type);\n            }\n            type = JVM.loadClassForName(\"java.nio.file.Path\");\n            if (type != null) {\n                xstream.allowTypeHierarchy(type);\n            }\n\n            final Set types = new HashSet();\n            types.add(BitSet.class);\n            types.add(Charset.class);\n            types.add(Class.class);\n            types.add(Currency.class);\n            types.add(Date.class);\n            types.add(DecimalFormatSymbols.class);\n            types.add(File.class);\n            types.add(Locale.class);\n            types.add(Object.class);\n            types.add(Pattern.class);\n            types.add(StackTraceElement.class);\n            types.add(String.class);\n            types.add(StringBuffer.class);\n            types.add(JVM.loadClassForName(\"java.lang.StringBuilder\"));\n            types.add(URL.class);\n            types.add(URI.class);\n            types.add(JVM.loadClassForName(\"java.util.UUID\"));\n            if (JVM.isSQLAvailable()) {\n                types.add(JVM.loadClassForName(\"java.sql.Timestamp\"));\n                types.add(JVM.loadClassForName(\"java.sql.Time\"));\n                types.add(JVM.loadClassForName(\"java.sql.Date\"));\n            }\n            if (JVM.isVersion(8)) {\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.Clock\"));\n                types.add(JVM.loadClassForName(\"java.time.Duration\"));\n                types.add(JVM.loadClassForName(\"java.time.Instant\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalDate\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalDateTime\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalTime\"));\n                types.add(JVM.loadClassForName(\"java.time.MonthDay\"));\n                types.add(JVM.loadClassForName(\"java.time.OffsetDateTime\"));\n                types.add(JVM.loadClassForName(\"java.time.OffsetTime\"));\n                types.add(JVM.loadClassForName(\"java.time.Period\"));\n                types.add(JVM.loadClassForName(\"java.time.Ser\"));\n                types.add(JVM.loadClassForName(\"java.time.Year\"));\n                types.add(JVM.loadClassForName(\"java.time.YearMonth\"));\n                types.add(JVM.loadClassForName(\"java.time.ZonedDateTime\"));\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.ZoneId\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.HijrahDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.JapaneseDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.JapaneseEra\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.MinguoDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.Ser\"));\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.chrono.Chronology\"));\n                types.add(JVM.loadClassForName(\"java.time.temporal.ValueRange\"));\n                types.add(JVM.loadClassForName(\"java.time.temporal.WeekFields\"));\n            }\n            types.remove(null);\n\n            final Iterator iter = types.iterator();\n            final Class[] classes = new Class[types.size()];\n            for (int i = 0; i < classes.length; ++i) {\n                classes[i] = (Class)iter.next();\n            }\n            xstream.allowTypes(classes);\n        } else {\n            throw new IllegalArgumentException(\"Security framework of XStream instance already initialized\");\n        }\n    }\n\n    protected void setupAliases() {\n        if (classAliasingMapper == null) {\n            return;\n        }\n\n        alias(\"null\", Mapper.Null.class);\n        alias(\"int\", Integer.class);\n        alias(\"float\", Float.class);\n        alias(\"double\", Double.class);\n        alias(\"long\", Long.class);\n        alias(\"short\", Short.class);\n        alias(\"char\", Character.class);\n        alias(\"byte\", Byte.class);\n        alias(\"boolean\", Boolean.class);\n        alias(\"number\", Number.class);\n        alias(\"object\", Object.class);\n        alias(\"big-int\", BigInteger.class);\n        alias(\"big-decimal\", BigDecimal.class);\n\n        alias(\"string-buffer\", StringBuffer.class);\n        alias(\"string\", String.class);\n        alias(\"java-class\", Class.class);\n        alias(\"method\", Method.class);\n        alias(\"constructor\", Constructor.class);\n        alias(\"field\", Field.class);\n        alias(\"date\", Date.class);\n        alias(\"uri\", URI.class);\n        alias(\"url\", URL.class);\n        alias(\"bit-set\", BitSet.class);\n\n        alias(\"map\", Map.class);\n        alias(\"entry\", Map.Entry.class);\n        alias(\"properties\", Properties.class);\n        alias(\"list\", List.class);\n        alias(\"set\", Set.class);\n        alias(\"sorted-set\", SortedSet.class);\n\n        alias(\"linked-list\", LinkedList.class);\n        alias(\"vector\", Vector.class);\n        alias(\"tree-map\", TreeMap.class);\n        alias(\"tree-set\", TreeSet.class);\n        alias(\"hashtable\", Hashtable.class);\n        \n        alias(\"empty-list\", Collections.EMPTY_LIST.getClass());\n        alias(\"empty-map\", Collections.EMPTY_MAP.getClass());\n        alias(\"empty-set\", Collections.EMPTY_SET.getClass());\n        alias(\"singleton-list\", Collections.singletonList(this).getClass());\n        alias(\"singleton-map\", Collections.singletonMap(this, null).getClass());\n        alias(\"singleton-set\", Collections.singleton(this).getClass());\n\n        if (JVM.isAWTAvailable()) {\n            // Instantiating these two classes starts the AWT system, which is undesirable.\n            // Calling loadClass ensures a reference to the class is found but they are not\n            // instantiated.\n            alias(\"awt-color\", JVM.loadClassForName(\"java.awt.Color\", false));\n            alias(\"awt-font\", JVM.loadClassForName(\"java.awt.Font\", false));\n            alias(\"awt-text-attribute\", JVM.loadClassForName(\"java.awt.font.TextAttribute\"));\n        }\n\n        Class type = JVM.loadClassForName(\"javax.activation.ActivationDataFlavor\");\n        if (type != null) {\n            alias(\"activation-data-flavor\", type);\n        }\n\n        if (JVM.isSQLAvailable()) {\n            alias(\"sql-timestamp\", JVM.loadClassForName(\"java.sql.Timestamp\"));\n            alias(\"sql-time\", JVM.loadClassForName(\"java.sql.Time\"));\n            alias(\"sql-date\", JVM.loadClassForName(\"java.sql.Date\"));\n        }\n\n        alias(\"file\", File.class);\n        alias(\"locale\", Locale.class);\n        alias(\"gregorian-calendar\", Calendar.class);\n\n        if (JVM.isVersion(4)) {\n            aliasDynamically(\"auth-subject\", \"javax.security.auth.Subject\");\n            alias(\"linked-hash-map\", JVM.loadClassForName(\"java.util.LinkedHashMap\"));\n            alias(\"linked-hash-set\", JVM.loadClassForName(\"java.util.LinkedHashSet\"));\n            alias(\"trace\", JVM.loadClassForName(\"java.lang.StackTraceElement\"));\n            alias(\"currency\", JVM.loadClassForName(\"java.util.Currency\"));\n            aliasType(\"charset\", JVM.loadClassForName(\"java.nio.charset.Charset\"));\n        }\n\n        if (JVM.isVersion(5)) {\n            aliasDynamically(\"xml-duration\", \"javax.xml.datatype.Duration\");\n            alias(\"concurrent-hash-map\", JVM.loadClassForName(\"java.util.concurrent.ConcurrentHashMap\"));\n            alias(\"enum-set\", JVM.loadClassForName(\"java.util.EnumSet\"));\n            alias(\"enum-map\", JVM.loadClassForName(\"java.util.EnumMap\"));\n            alias(\"string-builder\", JVM.loadClassForName(\"java.lang.StringBuilder\"));\n            alias(\"uuid\", JVM.loadClassForName(\"java.util.UUID\"));\n        }\n        \n        if (JVM.isVersion(7)) {\n            aliasType(\"path\", JVM.loadClassForName(\"java.nio.file.Path\"));\n        }\n\n        if (JVM.isVersion(8)) {\n            alias(\"fixed-clock\", JVM.loadClassForName(\"java.time.Clock$FixedClock\"));\n            alias(\"offset-clock\", JVM.loadClassForName(\"java.time.Clock$OffsetClock\"));\n            alias(\"system-clock\", JVM.loadClassForName(\"java.time.Clock$SystemClock\"));\n            alias(\"tick-clock\", JVM.loadClassForName(\"java.time.Clock$TickClock\"));\n            alias(\"day-of-week\", JVM.loadClassForName(\"java.time.DayOfWeek\"));\n            alias(\"duration\", JVM.loadClassForName(\"java.time.Duration\"));\n            alias(\"instant\", JVM.loadClassForName(\"java.time.Instant\"));\n            alias(\"local-date\", JVM.loadClassForName(\"java.time.LocalDate\"));\n            alias(\"local-date-time\", JVM.loadClassForName(\"java.time.LocalDateTime\"));\n            alias(\"local-time\", JVM.loadClassForName(\"java.time.LocalTime\"));\n            alias(\"month\", JVM.loadClassForName(\"java.time.Month\"));\n            alias(\"month-day\", JVM.loadClassForName(\"java.time.MonthDay\"));\n            alias(\"offset-date-time\", JVM.loadClassForName(\"java.time.OffsetDateTime\"));\n            alias(\"offset-time\", JVM.loadClassForName(\"java.time.OffsetTime\"));\n            alias(\"period\", JVM.loadClassForName(\"java.time.Period\"));\n            alias(\"year\", JVM.loadClassForName(\"java.time.Year\"));\n            alias(\"year-month\", JVM.loadClassForName(\"java.time.YearMonth\"));\n            alias(\"zoned-date-time\", JVM.loadClassForName(\"java.time.ZonedDateTime\"));\n            aliasType(\"zone-id\", JVM.loadClassForName(\"java.time.ZoneId\"));\n            aliasType(\"chronology\", JVM.loadClassForName(\"java.time.chrono.Chronology\"));\n            alias(\"hijrah-date\", JVM.loadClassForName(\"java.time.chrono.HijrahDate\"));\n            alias(\"hijrah-era\", JVM.loadClassForName(\"java.time.chrono.HijrahEra\"));\n            alias(\"japanese-date\", JVM.loadClassForName(\"java.time.chrono.JapaneseDate\"));\n            alias(\"japanese-era\", JVM.loadClassForName(\"java.time.chrono.JapaneseEra\"));\n            alias(\"minguo-date\", JVM.loadClassForName(\"java.time.chrono.MinguoDate\"));\n            alias(\"minguo-era\", JVM.loadClassForName(\"java.time.chrono.MinguoEra\"));\n            alias(\"thai-buddhist-date\", JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistDate\"));\n            alias(\"thai-buddhist-era\", JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistEra\"));\n            alias(\"chrono-field\", JVM.loadClassForName(\"java.time.temporal.ChronoField\"));\n            alias(\"chrono-unit\", JVM.loadClassForName(\"java.time.temporal.ChronoUnit\"));\n            alias(\"iso-field\", JVM.loadClassForName(\"java.time.temporal.IsoFields$Field\"));\n            alias(\"iso-unit\", JVM.loadClassForName(\"java.time.temporal.IsoFields$Unit\"));\n            alias(\"julian-field\", JVM.loadClassForName(\"java.time.temporal.JulianFields$Field\"));\n            alias(\"temporal-value-range\", JVM.loadClassForName(\"java.time.temporal.ValueRange\"));\n            alias(\"week-fields\", JVM.loadClassForName(\"java.time.temporal.WeekFields\"));\n        }\n\n        if (JVM.loadClassForName(\"java.lang.invoke.SerializedLambda\") != null) {\n            aliasDynamically(\"serialized-lambda\", \"java.lang.invoke.SerializedLambda\");\n        }\n    }\n\n    private void aliasDynamically(String alias, String className) {\n        Class type = JVM.loadClassForName(className);\n        if (type != null) {\n            alias(alias, type);\n        }\n    }\n\n    protected void setupDefaultImplementations() {\n        if (defaultImplementationsMapper == null) {\n            return;\n        }\n        addDefaultImplementation(HashMap.class, Map.class);\n        addDefaultImplementation(ArrayList.class, List.class);\n        addDefaultImplementation(HashSet.class, Set.class);\n        addDefaultImplementation(TreeSet.class, SortedSet.class);\n        addDefaultImplementation(GregorianCalendar.class, Calendar.class);\n    }\n\n    protected void setupConverters() {\n        registerConverter(\n            new ReflectionConverter(mapper, reflectionProvider), PRIORITY_VERY_LOW);\n\n        registerConverter(\n            new SerializableConverter(mapper, reflectionProvider, classLoaderReference), PRIORITY_LOW);\n        registerConverter(new ExternalizableConverter(mapper, classLoaderReference), PRIORITY_LOW);\n        registerConverter(new InternalBlackList(), PRIORITY_LOW);\n\n        registerConverter(new NullConverter(), PRIORITY_VERY_HIGH);\n        registerConverter(new IntConverter(), PRIORITY_NORMAL);\n        registerConverter(new FloatConverter(), PRIORITY_NORMAL);\n        registerConverter(new DoubleConverter(), PRIORITY_NORMAL);\n        registerConverter(new LongConverter(), PRIORITY_NORMAL);\n        registerConverter(new ShortConverter(), PRIORITY_NORMAL);\n        registerConverter((Converter)new CharConverter(), PRIORITY_NORMAL);\n        registerConverter(new BooleanConverter(), PRIORITY_NORMAL);\n        registerConverter(new ByteConverter(), PRIORITY_NORMAL);\n\n        registerConverter(new StringConverter(), PRIORITY_NORMAL);\n        registerConverter(new StringBufferConverter(), PRIORITY_NORMAL);\n        registerConverter(new DateConverter(), PRIORITY_NORMAL);\n        registerConverter(new BitSetConverter(), PRIORITY_NORMAL);\n        registerConverter(new URIConverter(), PRIORITY_NORMAL);\n        registerConverter(new URLConverter(), PRIORITY_NORMAL);\n        registerConverter(new BigIntegerConverter(), PRIORITY_NORMAL);\n        registerConverter(new BigDecimalConverter(), PRIORITY_NORMAL);\n\n        registerConverter(new ArrayConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new CharArrayConverter(), PRIORITY_NORMAL);\n        registerConverter(new CollectionConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new MapConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new TreeMapConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new TreeSetConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new SingletonCollectionConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new SingletonMapConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new PropertiesConverter(), PRIORITY_NORMAL);\n        registerConverter((Converter)new EncodedByteArrayConverter(), PRIORITY_NORMAL);\n\n        registerConverter(new FileConverter(), PRIORITY_NORMAL);\n        if (JVM.isSQLAvailable()) {\n            registerConverter(new SqlTimestampConverter(), PRIORITY_NORMAL);\n            registerConverter(new SqlTimeConverter(), PRIORITY_NORMAL);\n            registerConverter(new SqlDateConverter(), PRIORITY_NORMAL);\n        }\n        registerConverter(new DynamicProxyConverter(mapper, classLoaderReference), PRIORITY_NORMAL);\n        registerConverter(new JavaClassConverter(classLoaderReference), PRIORITY_NORMAL);\n        registerConverter(new JavaMethodConverter(classLoaderReference), PRIORITY_NORMAL);\n        registerConverter(new JavaFieldConverter(classLoaderReference), PRIORITY_NORMAL);\n\n        if (JVM.isAWTAvailable()) {\n            registerConverter(new FontConverter(mapper), PRIORITY_NORMAL);\n            registerConverter(new ColorConverter(), PRIORITY_NORMAL);\n            registerConverter(new TextAttributeConverter(), PRIORITY_NORMAL);\n        }\n        if (JVM.isSwingAvailable()) {\n            registerConverter(\n                new LookAndFeelConverter(mapper, reflectionProvider), PRIORITY_NORMAL);\n        }\n        registerConverter(new LocaleConverter(), PRIORITY_NORMAL);\n        registerConverter(new GregorianCalendarConverter(), PRIORITY_NORMAL);\n\n        if (JVM.isVersion(4)) {\n            // late bound converters - allows XStream to be compiled on earlier JDKs\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.SubjectConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.ThrowableConverter\",\n                PRIORITY_NORMAL, new Class[]{ConverterLookup.class},\n                new Object[]{converterLookup});\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.StackTraceElementConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.CurrencyConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.RegexPatternConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.CharsetConverter\",\n                PRIORITY_NORMAL, null, null);\n        }\n\n        if (JVM.isVersion(5)) {\n            // late bound converters - allows XStream to be compiled on earlier JDKs\n            if (JVM.loadClassForName(\"javax.xml.datatype.Duration\") != null) {\n                registerConverterDynamically(\n                    \"com.thoughtworks.xstream.converters.extended.DurationConverter\",\n                    PRIORITY_NORMAL, null, null);\n            }\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.enums.EnumConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.enums.EnumSetConverter\", PRIORITY_NORMAL,\n                new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.enums.EnumMapConverter\", PRIORITY_NORMAL,\n                new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.basic.StringBuilderConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.basic.UUIDConverter\", PRIORITY_NORMAL,\n                null, null);\n        }\n        if (JVM.loadClassForName(\"javax.activation.ActivationDataFlavor\") != null) {\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.ActivationDataFlavorConverter\",\n                PRIORITY_NORMAL, null, null);\n        }\n        if (JVM.isVersion(7)) {\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.PathConverter\",\n                    PRIORITY_NORMAL, null, null);\n        }\n        if (JVM.isVersion(8)) {\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ChronologyConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.DurationConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.HijrahDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.JapaneseDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.JapaneseEraConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.InstantConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalDateConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalDateTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalTimeConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.MinguoDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.MonthDayConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.OffsetDateTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.OffsetTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.PeriodConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.SystemClockConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ThaiBuddhistDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ValueRangeConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.WeekFieldsConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.YearConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.YearMonthConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ZonedDateTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ZoneIdConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.reflection.LambdaConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class, ReflectionProvider.class, ClassLoaderReference.class},\n                new Object[]{mapper, reflectionProvider, classLoaderReference});\n        }\n\n        registerConverter(\n            new SelfStreamingInstanceChecker(converterLookup, this), PRIORITY_NORMAL);\n    }\n\n    private void registerConverterDynamically(String className, int priority,\n        Class[] constructorParamTypes, Object[] constructorParamValues) {\n        try {\n            Class type = Class.forName(className, false, classLoaderReference.getReference());\n            Constructor constructor = type.getConstructor(constructorParamTypes);\n            Object instance = constructor.newInstance(constructorParamValues);\n            if (instance instanceof Converter) {\n                registerConverter((Converter)instance, priority);\n            } else if (instance instanceof SingleValueConverter) {\n                registerConverter((SingleValueConverter)instance, priority);\n            }\n        } catch (Exception e) {\n            throw new com.thoughtworks.xstream.InitializationException(\n                \"Could not instantiate converter : \" + className, e);\n        } catch (LinkageError e) {\n            throw new com.thoughtworks.xstream.InitializationException(\n                \"Could not instantiate converter : \" + className, e);\n        }\n    }\n\n    protected void setupImmutableTypes() {\n        if (immutableTypesMapper == null) {\n            return;\n        }\n\n        // primitives are always immutable\n        addImmutableType(boolean.class, false);\n        addImmutableType(Boolean.class, false);\n        addImmutableType(byte.class, false);\n        addImmutableType(Byte.class, false);\n        addImmutableType(char.class, false);\n        addImmutableType(Character.class, false);\n        addImmutableType(double.class, false);\n        addImmutableType(Double.class, false);\n        addImmutableType(float.class, false);\n        addImmutableType(Float.class, false);\n        addImmutableType(int.class, false);\n        addImmutableType(Integer.class, false);\n        addImmutableType(long.class, false);\n        addImmutableType(Long.class, false);\n        addImmutableType(short.class, false);\n        addImmutableType(Short.class, false);\n\n        // additional types\n        addImmutableType(Mapper.Null.class, false);\n        addImmutableType(BigDecimal.class, false);\n        addImmutableType(BigInteger.class, false);\n        addImmutableType(String.class, false);\n        addImmutableType(URL.class, false);\n        addImmutableType(File.class, false);\n        addImmutableType(Class.class, false);\n\n        if (JVM.isVersion(7)) {\n            Class type = JVM.loadClassForName(\"java.nio.file.Paths\");\n            if (type != null) {\n                Method methodGet;\n                try {\n                    methodGet = type.getDeclaredMethod(\"get\", new Class[] {String.class, String[].class});\n                    if (methodGet != null) {\n                        Object path = methodGet.invoke(null, new Object[]{\".\", new String[0]});\n                        if (path != null) {\n                            addImmutableType(path.getClass(), false);\n                        }\n                    }\n                } catch (NoSuchMethodException e) {\n                } catch (SecurityException e) {\n                } catch (IllegalAccessException e) {\n                } catch (InvocationTargetException e) {\n                }\n            }\n        }\n\n        if (JVM.isAWTAvailable()) {\n            addImmutableTypeDynamically(\"java.awt.font.TextAttribute\", false);\n        }\n\n        if (JVM.isVersion(4)) {\n            // late bound types - allows XStream to be compiled on earlier JDKs\n            addImmutableTypeDynamically(\"java.nio.charset.Charset\", true);\n            addImmutableTypeDynamically(\"java.util.Currency\", true);\n        }\n        \n        if (JVM.isVersion(5)) {\n            addImmutableTypeDynamically(\"java.util.UUID\", true);\n        }\n\n        addImmutableType(URI.class, true);\n        addImmutableType(Collections.EMPTY_LIST.getClass(), true);\n        addImmutableType(Collections.EMPTY_SET.getClass(), true);\n        addImmutableType(Collections.EMPTY_MAP.getClass(), true);\n\n        if (JVM.isVersion(8)) {\n            addImmutableTypeDynamically(\"java.time.Duration\", false);\n            addImmutableTypeDynamically(\"java.time.Instant\", false);\n            addImmutableTypeDynamically(\"java.time.LocalDate\", false);\n            addImmutableTypeDynamically(\"java.time.LocalDateTime\", false);\n            addImmutableTypeDynamically(\"java.time.LocalTime\", false);\n            addImmutableTypeDynamically(\"java.time.MonthDay\", false);\n            addImmutableTypeDynamically(\"java.time.OffsetDateTime\", false);\n            addImmutableTypeDynamically(\"java.time.OffsetTime\", false);\n            addImmutableTypeDynamically(\"java.time.Period\", false);\n            addImmutableTypeDynamically(\"java.time.Year\", false);\n            addImmutableTypeDynamically(\"java.time.YearMonth\", false);\n            addImmutableTypeDynamically(\"java.time.ZonedDateTime\", false);\n            addImmutableTypeDynamically(\"java.time.ZoneId\", false);\n            addImmutableTypeDynamically(\"java.time.ZoneOffset\", false);\n            addImmutableTypeDynamically(\"java.time.ZoneRegion\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.HijrahChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.HijrahDate\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.IsoChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.JapaneseChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.JapaneseDate\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.JapaneseEra\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.MinguoChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.MinguoDate\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.ThaiBuddhistChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.ThaiBuddhistDate\", false);\n            addImmutableTypeDynamically(\"java.time.temporal.IsoFields$Field\", false);\n            addImmutableTypeDynamically(\"java.time.temporal.IsoFields$Unit\", false);\n            addImmutableTypeDynamically(\"java.time.temporal.JulianFields$Field\", false);\n        }\n    }\n\n    private void addImmutableTypeDynamically(String className, boolean isReferenceable) {\n        Class type = JVM.loadClassForName(className);\n        if (type != null) {\n            addImmutableType(type, isReferenceable);\n        }\n    }\n\n    public void setMarshallingStrategy(MarshallingStrategy marshallingStrategy) {\n        this.marshallingStrategy = marshallingStrategy;\n    }\n\n    /**\n     * Serialize an object to a pretty-printed XML String.\n     *\n     * @throws XStreamException if the object cannot be serialized\n     */\n    public String toXML(Object obj) {\n        Writer writer = new StringWriter();\n        toXML(obj, writer);\n        return writer.toString();\n    }\n\n    /**\n     * Serialize an object to the given Writer as pretty-printed XML. The Writer will be flushed\n     * afterwards and in case of an exception.\n     * \n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void toXML(Object obj, Writer out) {\n        HierarchicalStreamWriter writer = hierarchicalStreamDriver.createWriter(out);\n        try {\n            marshal(obj, writer);\n        } finally {\n            writer.flush();\n        }\n    }\n\n    /**\n     * Serialize an object to the given OutputStream as pretty-printed XML. The OutputStream\n     * will be flushed afterwards and in case of an exception.\n     * \n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void toXML(Object obj, OutputStream out) {\n        HierarchicalStreamWriter writer = hierarchicalStreamDriver.createWriter(out);\n        try {\n            marshal(obj, writer);\n        } finally {\n            writer.flush();\n        }\n    }\n\n    /**\n     * Serialize and object to a hierarchical data structure (such as XML).\n     *\n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void marshal(Object obj, HierarchicalStreamWriter writer) {\n        marshal(obj, writer, null);\n    }\n\n    /**\n     * Serialize and object to a hierarchical data structure (such as XML).\n     * \n     * @param dataHolder Extra data you can use to pass to your converters. Use this as you\n     *            want. If not present, XStream shall create one lazily as needed.\n     * @throws XStreamException if the object cannot be serialized\n     */\n    public void marshal(Object obj, HierarchicalStreamWriter writer, DataHolder dataHolder) {\n        marshallingStrategy.marshal(writer, obj, converterLookup, mapper, dataHolder);\n    }\n\n    /**\n     * Deserialize an object from an XML String.\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(String xml) {\n        return fromXML(new StringReader(xml));\n    }\n\n    /**\n     * Deserialize an object from an XML Reader.\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(Reader reader) {\n        return unmarshal(hierarchicalStreamDriver.createReader(reader), null);\n    }\n\n    /**\n     * Deserialize an object from an XML InputStream.\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(InputStream input) {\n        return unmarshal(hierarchicalStreamDriver.createReader(input), null);\n    }\n\n    /**\n     * Deserialize an object from a URL.\n     * \n     * Depending on the parser implementation, some might take the file path as SystemId to\n     * resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(URL url) {\n        return fromXML(url, null);\n    }\n\n    /**\n     * Deserialize an object from a file.\n     * \n     * Depending on the parser implementation, some might take the file path as SystemId to\n     * resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(File file) {\n        return fromXML(file, null);\n    }\n\n    /**\n     * Deserialize an object from an XML String, populating the fields of the given root object\n     * instead of instantiating a new one. Note, that this is a special use case! With the\n     * ReflectionConverter XStream will write directly into the raw memory area of the existing\n     * object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(String xml, Object root) {\n        return fromXML(new StringReader(xml), root);\n    }\n\n    /**\n     * Deserialize an object from an XML Reader, populating the fields of the given root object\n     * instead of instantiating a new one. Note, that this is a special use case! With the\n     * ReflectionConverter XStream will write directly into the raw memory area of the existing\n     * object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(Reader xml, Object root) {\n        return unmarshal(hierarchicalStreamDriver.createReader(xml), root);\n    }\n\n    /**\n     * Deserialize an object from a URL, populating the fields of the given root\n     * object instead of instantiating a new one. Note, that this is a special use case! With\n     * the ReflectionConverter XStream will write directly into the raw memory area of the\n     * existing object. Use with care!\n     * \n     * Depending on the parser implementation, some might take the file path as SystemId to\n     * resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(URL url, Object root) {\n        return unmarshal(hierarchicalStreamDriver.createReader(url), root);\n    }\n\n    /**\n     * Deserialize an object from a file, populating the fields of the given root\n     * object instead of instantiating a new one. Note, that this is a special use case! With\n     * the ReflectionConverter XStream will write directly into the raw memory area of the\n     * existing object. Use with care!\n     * \n     * Depending on the parser implementation, some might take the file path as SystemId to\n     * resolve additional references.\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     * @since 1.4\n     */\n    public Object fromXML(File file, Object root) {\n        HierarchicalStreamReader reader = hierarchicalStreamDriver.createReader(file);\n        try {\n            return unmarshal(reader, root);\n        } finally {\n            reader.close();\n        }\n    }\n\n    /**\n     * Deserialize an object from an XML InputStream, populating the fields of the given root\n     * object instead of instantiating a new one. Note, that this is a special use case! With\n     * the ReflectionConverter XStream will write directly into the raw memory area of the\n     * existing object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object fromXML(InputStream input, Object root) {\n        return unmarshal(hierarchicalStreamDriver.createReader(input), root);\n    }\n\n    /**\n     * Deserialize an object from a hierarchical data structure (such as XML).\n     *\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object unmarshal(HierarchicalStreamReader reader) {\n        return unmarshal(reader, null, null);\n    }\n\n    /**\n     * Deserialize an object from a hierarchical data structure (such as XML), populating the\n     * fields of the given root object instead of instantiating a new one. Note, that this is a\n     * special use case! With the ReflectionConverter XStream will write directly into the raw\n     * memory area of the existing object. Use with care!\n     * \n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object unmarshal(HierarchicalStreamReader reader, Object root) {\n        return unmarshal(reader, root, null);\n    }\n\n    /**\n     * Deserialize an object from a hierarchical data structure (such as XML).\n     * \n     * @param root If present, the passed in object will have its fields populated, as opposed\n     *            to XStream creating a new instance. Note, that this is a special use case!\n     *            With the ReflectionConverter XStream will write directly into the raw memory\n     *            area of the existing object. Use with care!\n     * @param dataHolder Extra data you can use to pass to your converters. Use this as you\n     *            want. If not present, XStream shall create one lazily as needed.\n     * @throws XStreamException if the object cannot be deserialized\n     */\n    public Object unmarshal(HierarchicalStreamReader reader, Object root, DataHolder dataHolder) {\n        try {\n            if (!securityInitialized && !securityWarningGiven) {\n                securityWarningGiven = true;\n                System.err.println(\"Security framework of XStream not initialized, XStream is probably vulnerable.\");\n            }\n            return marshallingStrategy.unmarshal(\n                root, reader, dataHolder, converterLookup, mapper);\n\n        } catch (ConversionException e) {\n            Package pkg = getClass().getPackage();\n            String version = pkg != null ? pkg.getImplementationVersion() : null;\n            e.add(\"version\", version != null ? version : \"not available\");\n            throw e;\n        }\n    }\n\n    /**\n     * Alias a Class to a shorter name to be used in XML elements.\n     *\n     * @param name Short name\n     * @param type Type to be aliased\n     * @throws InitializationException if no {@link ClassAliasingMapper} is available\n     */\n    public void alias(String name, Class type) {\n        if (classAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ClassAliasingMapper.class.getName()\n                + \" available\");\n        }\n        classAliasingMapper.addClassAlias(name, type);\n    }\n\n    /**\n     * Alias a type to a shorter name to be used in XML elements. Any class that is assignable\n     * to this type will be aliased to the same name.\n     * \n     * @param name Short name\n     * @param type Type to be aliased\n     * @since 1.2\n     * @throws InitializationException if no {@link ClassAliasingMapper} is available\n     */\n    public void aliasType(String name, Class type) {\n        if (classAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ClassAliasingMapper.class.getName()\n                + \" available\");\n        }\n        classAliasingMapper.addTypeAlias(name, type);\n    }\n\n    /**\n     * Alias a Class to a shorter name to be used in XML elements.\n     *\n     * @param name Short name\n     * @param type Type to be aliased\n     * @param defaultImplementation Default implementation of type to use if no other specified.\n     * @throws InitializationException if no {@link DefaultImplementationsMapper} or no\n     *             {@link ClassAliasingMapper} is available\n     */\n    public void alias(String name, Class type, Class defaultImplementation) {\n        alias(name, type);\n        addDefaultImplementation(defaultImplementation, type);\n    }\n\n    /**\n     * Alias a package to a shorter name to be used in XML elements.\n     *\n     * @param name Short name\n     * @param pkgName package to be aliased\n     * @throws InitializationException if no {@link DefaultImplementationsMapper} or no\n     *             {@link PackageAliasingMapper} is available\n     * @since 1.3.1\n     */\n    public void aliasPackage(String name, String pkgName) {\n        if (packageAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + PackageAliasingMapper.class.getName()\n                + \" available\");\n        }\n        packageAliasingMapper.addPackageAlias(name, pkgName);\n    }\n\n    /**\n     * Create an alias for a field name.\n     *\n     * @param alias the alias itself\n     * @param definedIn the type that declares the field\n     * @param fieldName the name of the field\n     * @throws InitializationException if no {@link FieldAliasingMapper} is available\n     */\n    public void aliasField(String alias, Class definedIn, String fieldName) {\n        if (fieldAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + FieldAliasingMapper.class.getName()\n                + \" available\");\n        }\n        fieldAliasingMapper.addFieldAlias(alias, definedIn, fieldName);\n    }\n\n    /**\n     * Create an alias for an attribute\n     *\n     * @param alias the alias itself\n     * @param attributeName the name of the attribute\n     * @throws InitializationException if no {@link AttributeAliasingMapper} is available\n     */\n    public void aliasAttribute(String alias, String attributeName) {\n        if (attributeAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeAliasingMapper.class.getName()\n                + \" available\");\n        }\n        attributeAliasingMapper.addAliasFor(attributeName, alias);\n    }\n\n    /**\n     * Create an alias for a system attribute. XStream will not write a system attribute if its\n     * alias is set to <code>null</code>. However, this is not reversible, i.e. deserialization\n     * of the result is likely to fail afterwards and will not produce an object equal to the\n     * originally written one.\n     * \n     * @param alias the alias itself (may be <code>null</code>)\n     * @param systemAttributeName the name of the system attribute\n     * @throws InitializationException if no {@link SystemAttributeAliasingMapper} is available\n     * @since 1.3.1\n     */\n    public void aliasSystemAttribute(String alias, String systemAttributeName) {\n        if (systemAttributeAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + SystemAttributeAliasingMapper.class.getName()\n                + \" available\");\n        }\n        systemAttributeAliasingMapper.addAliasFor(systemAttributeName, alias);\n    }\n\n    /**\n     * Create an alias for an attribute.\n     *\n     * @param definedIn the type where the attribute is defined\n     * @param attributeName the name of the attribute\n     * @param alias the alias itself\n     * @throws InitializationException if no {@link AttributeAliasingMapper} is available\n     * @since 1.2.2\n     */\n    public void aliasAttribute(Class definedIn, String attributeName, String alias) {\n        aliasField(alias, definedIn, attributeName);\n        useAttributeFor(definedIn, attributeName);\n    }\n\n    /**\n     * Use an attribute for a field or a specific type.\n     *\n     * @param fieldName the name of the field\n     * @param type the Class of the type to be rendered as XML attribute\n     * @throws InitializationException if no {@link AttributeMapper} is available\n     * @since 1.2\n     */\n    public void useAttributeFor(String fieldName, Class type) {\n        if (attributeMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeMapper.class.getName()\n                + \" available\");\n        }\n        attributeMapper.addAttributeFor(fieldName, type);\n    }\n\n    /**\n     * Use an attribute for a field declared in a specific type.\n     *\n     * @param fieldName the name of the field\n     * @param definedIn the Class containing such field\n     * @throws InitializationException if no {@link AttributeMapper} is available\n     * @since 1.2.2\n     */\n    public void useAttributeFor(Class definedIn, String fieldName) {\n        if (attributeMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeMapper.class.getName()\n                + \" available\");\n        }\n        attributeMapper.addAttributeFor(definedIn, fieldName);\n    }\n\n    /**\n     * Use an attribute for an arbitrary type.\n     *\n     * @param type the Class of the type to be rendered as XML attribute\n     * @throws InitializationException if no {@link AttributeMapper} is available\n     * @since 1.2\n     */\n    public void useAttributeFor(Class type) {\n        if (attributeMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeMapper.class.getName()\n                + \" available\");\n        }\n        attributeMapper.addAttributeFor(type);\n    }\n\n    /**\n     * Associate a default implementation of a class with an object. Whenever XStream encounters\n     * an instance of this type, it will use the default implementation instead. For example,\n     * java.util.ArrayList is the default implementation of java.util.List.\n     * \n     * @param defaultImplementation\n     * @param ofType\n     * @throws InitializationException if no {@link DefaultImplementationsMapper} is available\n     */\n    public void addDefaultImplementation(Class defaultImplementation, Class ofType) {\n        if (defaultImplementationsMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + DefaultImplementationsMapper.class.getName()\n                + \" available\");\n        }\n        defaultImplementationsMapper.addDefaultImplementation(defaultImplementation, ofType);\n    }\n\n    /**\n     * Add immutable types. The value of the instances of these types will always be written into the stream even if\n     * they appear multiple times. However, references are still supported at deserialization time.\n     *\n     * @throws InitializationException if no {@link ImmutableTypesMapper} is available\n     * @deprecated As of 1.4.9 use {@link #addImmutableType(Class, boolean)}\n     */\n    public void addImmutableType(Class type) {\n        addImmutableType(type, true);\n    }\n\n    /**\n     * Add immutable types. The value of the instances of these types will always be written into the stream even if\n     * they appear multiple times.\n     * <p>\n     * Note, while a reference-keeping marshaller will not write references for immutable types into the stream, a\n     * reference-keeping unmarshaller can still support such references in the stream for compatibility reasons at the\n     * expense of memory consumption. Therefore declare these types only as referenceable if your already persisted\n     * streams do contain such references. Otherwise you may waste a lot of memory during deserialization.\n     * </p>\n     *\n     * @param isReferenceable <code>true</code> if support at deserialization time is required for compatibility at the\n     *            cost of a higher memory footprint, <code>false</code> otherwise\n     * @throws InitializationException if no {@link ImmutableTypesMapper} is available\n     * @since 1.4.9\n     */\n    public void addImmutableType(final Class type, final boolean isReferenceable) {\n        if (immutableTypesMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ImmutableTypesMapper.class.getName()\n                + \" available\");\n        }\n        immutableTypesMapper.addImmutableType(type, isReferenceable);\n    }\n\n    public void registerConverter(Converter converter) {\n        registerConverter(converter, PRIORITY_NORMAL);\n    }\n\n    public void registerConverter(Converter converter, int priority) {\n        if (converterRegistry != null) {\n            converterRegistry.registerConverter(converter, priority);\n        }\n    }\n\n    public void registerConverter(SingleValueConverter converter) {\n        registerConverter(converter, PRIORITY_NORMAL);\n    }\n\n    public void registerConverter(SingleValueConverter converter, int priority) {\n        if (converterRegistry != null) {\n            converterRegistry.registerConverter(\n                new SingleValueConverterWrapper(converter), priority);\n        }\n    }\n\n    /**\n     * Register a local {@link Converter} for a field.\n     *\n     * @param definedIn the class type the field is defined in\n     * @param fieldName the field name\n     * @param converter the converter to use\n     * @since 1.3\n     */\n    public void registerLocalConverter(Class definedIn, String fieldName, Converter converter) {\n        if (localConversionMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + LocalConversionMapper.class.getName()\n                + \" available\");\n        }\n        localConversionMapper.registerLocalConverter(definedIn, fieldName, converter);\n    }\n\n    /**\n     * Register a local {@link SingleValueConverter} for a field.\n     *\n     * @param definedIn the class type the field is defined in\n     * @param fieldName the field name\n     * @param converter the converter to use\n     * @since 1.3\n     */\n    public void registerLocalConverter(Class definedIn, String fieldName,\n        SingleValueConverter converter) {\n        registerLocalConverter(\n            definedIn, fieldName, (Converter)new SingleValueConverterWrapper(converter));\n    }\n\n    /**\n     * Retrieve the {@link Mapper}. This is by default a chain of {@link MapperWrapper\n     * MapperWrappers}.\n     * \n     * @return the mapper\n     * @since 1.2\n     */\n    public Mapper getMapper() {\n        return mapper;\n    }\n\n    /**\n     * Retrieve the {@link ReflectionProvider} in use.\n     *\n     * @return the mapper\n     * @since 1.2.1\n     */\n    public ReflectionProvider getReflectionProvider() {\n        return reflectionProvider;\n    }\n\n    public ConverterLookup getConverterLookup() {\n        return converterLookup;\n    }\n\n    /**\n     * Change mode for dealing with duplicate references. Valid values are\n     * <code>XPATH_ABSOLUTE_REFERENCES</code>, <code>XPATH_RELATIVE_REFERENCES</code>,\n     * <code>XStream.ID_REFERENCES</code> and <code>XStream.NO_REFERENCES</code>.\n     * \n     * @throws IllegalArgumentException if the mode is not one of the declared types\n     * @see #XPATH_ABSOLUTE_REFERENCES\n     * @see #XPATH_RELATIVE_REFERENCES\n     * @see #ID_REFERENCES\n     * @see #NO_REFERENCES\n     */\n    public void setMode(int mode) {\n        switch (mode) {\n        case NO_REFERENCES:\n            setMarshallingStrategy(new TreeMarshallingStrategy());\n            break;\n        case ID_REFERENCES:\n            setMarshallingStrategy(new ReferenceByIdMarshallingStrategy());\n            break;\n        case XPATH_RELATIVE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                ReferenceByXPathMarshallingStrategy.RELATIVE));\n            break;\n        case XPATH_ABSOLUTE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                ReferenceByXPathMarshallingStrategy.ABSOLUTE));\n            break;\n        case SINGLE_NODE_XPATH_RELATIVE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                  ReferenceByXPathMarshallingStrategy.RELATIVE \n                | ReferenceByXPathMarshallingStrategy.SINGLE_NODE));\n            break;\n        case SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                  ReferenceByXPathMarshallingStrategy.ABSOLUTE \n                | ReferenceByXPathMarshallingStrategy.SINGLE_NODE));\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown mode : \" + mode);\n        }\n    }\n\n    /**\n     * Adds a default implicit collection which is used for any unmapped XML tag.\n     *\n     * @param ownerType class owning the implicit collection\n     * @param fieldName name of the field in the ownerType. This field must be a concrete\n     *            collection type or matching the default implementation type of the collection\n     *            type.\n     */\n    public void addImplicitCollection(Class ownerType, String fieldName) {\n        addImplicitCollection(ownerType, fieldName, null, null);\n    }\n\n    /**\n     * Adds implicit collection which is used for all items of the given itemType.\n     *\n     * @param ownerType class owning the implicit collection\n     * @param fieldName name of the field in the ownerType. This field must be a concrete\n     *            collection type or matching the default implementation type of the collection\n     *            type.\n     * @param itemType type of the items to be part of this collection\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available\n     */\n    public void addImplicitCollection(Class ownerType, String fieldName, Class itemType) {\n        addImplicitCollection(ownerType, fieldName, null, itemType);\n    }\n\n    /**\n     * Adds implicit collection which is used for all items of the given element name defined by\n     * itemFieldName.\n     * \n     * @param ownerType class owning the implicit collection\n     * @param fieldName name of the field in the ownerType. This field must be a concrete\n     *            collection type or matching the default implementation type of the collection\n     *            type.\n     * @param itemFieldName element name of the implicit collection\n     * @param itemType item type to be aliases be the itemFieldName\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available\n     */\n    public void addImplicitCollection(Class ownerType, String fieldName, String itemFieldName,\n        Class itemType) {\n        addImplicitMap(ownerType, fieldName, itemFieldName, itemType, null);\n    }\n\n    /**\n     * Adds an implicit array.\n     *\n     * @param ownerType class owning the implicit array\n     * @param fieldName name of the array field\n     * @since 1.4 \n     */\n    public void addImplicitArray(Class ownerType, String fieldName) {\n        addImplicitCollection(ownerType, fieldName);\n    }\n\n    /**\n     * Adds an implicit array which is used for all items of the given itemType when the array\n     * type matches.\n     * \n     * @param ownerType class owning the implicit array\n     * @param fieldName name of the array field in the ownerType\n     * @param itemType type of the items to be part of this array\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available or the\n     * array type does not match the itemType\n     * @since 1.4 \n     */\n    public void addImplicitArray(Class ownerType, String fieldName, Class itemType) {\n        addImplicitCollection(ownerType, fieldName, itemType);\n    }\n\n    /**\n     * Adds an implicit array which is used for all items of the given element name defined by\n     * itemName.\n     * \n     * @param ownerType class owning the implicit array\n     * @param fieldName name of the array field in the ownerType\n     * @param itemName alias name of the items\n     * @throws InitializationException if no {@link ImplicitCollectionMapper} is available\n     * @since 1.4 \n     */\n    public void addImplicitArray(Class ownerType, String fieldName, String itemName) {\n        addImplicitCollection(ownerType, fieldName, itemName, null);\n    }\n\n    /**\n     * Adds an implicit map.\n     *\n     * @param ownerType class owning the implicit map\n     * @param fieldName name of the field in the ownerType. This field must be a concrete\n     *            map type or matching the default implementation type of the map\n     *            type.\n     * @param itemType type of the items to be part of this map as value\n     * @param keyFieldName the name of the field of the itemType that is used for the key in the map\n     * @since 1.4 \n     */\n    public void addImplicitMap(Class ownerType, String fieldName, Class itemType, String keyFieldName) {\n        addImplicitMap(ownerType, fieldName, null, itemType, keyFieldName);\n    }\n\n    /**\n     * Adds an implicit map.\n     *\n     * @param ownerType class owning the implicit map\n     * @param fieldName name of the field in the ownerType. This field must be a concrete\n     *            map type or matching the default implementation type of the map\n     *            type.\n     * @param itemName alias name of the items\n     * @param itemType type of the items to be part of this map as value\n     * @param keyFieldName the name of the field of the itemType that is used for the key in the map\n     * @since 1.4 \n     */\n    public void addImplicitMap(Class ownerType, String fieldName, String itemName, \n        Class itemType, String keyFieldName) {\n        if (implicitCollectionMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ImplicitCollectionMapper.class.getName()\n                + \" available\");\n        }\n        implicitCollectionMapper.add(ownerType, fieldName, itemName, itemType, keyFieldName);\n    }\n\n    /**\n     * Create a DataHolder that can be used to pass data to the converters. The DataHolder is provided with a call to\n     * {@link #marshal(Object, HierarchicalStreamWriter, DataHolder)},\n     * {@link #unmarshal(HierarchicalStreamReader, Object, DataHolder)},\n     * {@link #createObjectInputStream(HierarchicalStreamReader, DataHolder)} or\n     * {@link #createObjectOutputStream(HierarchicalStreamWriter, String, DataHolder)}.\n     *\n     * @return a new {@link DataHolder}\n     */\n    public DataHolder newDataHolder() {\n        return new MapBackedDataHolder();\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using\n     * XStream.\n     * <p>\n     * To change the name of the root element (from &lt;object-stream&gt;), use\n     * {@link #createObjectOutputStream(java.io.Writer, String)}.\n     * </p>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(Writer writer) throws IOException {\n        return createObjectOutputStream(\n            hierarchicalStreamDriver.createWriter(writer), \"object-stream\");\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using\n     * XStream.\n     * <p>\n     * To change the name of the root element (from &lt;object-stream&gt;), use\n     * {@link #createObjectOutputStream(java.io.Writer, String)}.\n     * </p>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(HierarchicalStreamWriter writer)\n        throws IOException {\n        return createObjectOutputStream(writer, \"object-stream\");\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using\n     * XStream.\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(Writer writer, String rootNodeName)\n        throws IOException {\n        return createObjectOutputStream(\n            hierarchicalStreamDriver.createWriter(writer), rootNodeName);\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the OutputStream\n     * using XStream.\n     * <p>\n     * To change the name of the root element (from &lt;object-stream&gt;), use\n     * {@link #createObjectOutputStream(java.io.Writer, String)}.\n     * </p>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.3\n     */\n    public ObjectOutputStream createObjectOutputStream(OutputStream out) throws IOException {\n        return createObjectOutputStream(\n            hierarchicalStreamDriver.createWriter(out), \"object-stream\");\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the OutputStream\n     * using XStream.\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.3\n     */\n    public ObjectOutputStream createObjectOutputStream(OutputStream out, String rootNodeName)\n        throws IOException {\n        return createObjectOutputStream(\n            hierarchicalStreamDriver.createWriter(out), rootNodeName);\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using\n     * XStream.\n     * <p>\n     * Because an ObjectOutputStream can contain multiple items and XML only allows a single\n     * root node, the stream must be written inside an enclosing node.\n     * </p>\n     * <p>\n     * It is necessary to call ObjectOutputStream.close() when done, otherwise the stream will\n     * be incomplete.\n     * </p>\n     * <h3>Example</h3>\n     *\n     * <pre>\n     *  ObjectOutputStream out = xstream.createObjectOutputStream(aWriter, &quot;things&quot;);\n     *   out.writeInt(123);\n     *   out.writeObject(&quot;Hello&quot;);\n     *   out.writeObject(someObject)\n     *   out.close();\n     * </pre>\n     *\n     * @param writer The writer to serialize the objects to.\n     * @param rootNodeName The name of the root node enclosing the stream of objects.\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.0.3\n     */\n    public ObjectOutputStream createObjectOutputStream(final HierarchicalStreamWriter writer, final String rootNodeName)\n            throws IOException {\n        return createObjectOutputStream(writer, rootNodeName, null);\n    }\n\n    /**\n     * Creates an ObjectOutputStream that serializes a stream of objects to the writer using XStream.\n     *\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.4.10\n     */\n    public ObjectOutputStream createObjectOutputStream(final HierarchicalStreamWriter writer, final String rootNodeName,\n            final DataHolder dataHolder) throws IOException {\n        final StatefulWriter statefulWriter = new StatefulWriter(writer);\n        statefulWriter.startNode(rootNodeName, null);\n        return new CustomObjectOutputStream(new CustomObjectOutputStream.StreamCallback() {\n            public void writeToStream(final Object object) {\n                marshal(object, statefulWriter, dataHolder);\n            }\n\n            public void writeFieldsToStream(Map fields) throws NotActiveException {\n                throw new NotActiveException(\"not in call to writeObject\");\n            }\n\n            public void defaultWriteObject() throws NotActiveException {\n                throw new NotActiveException(\"not in call to writeObject\");\n            }\n\n            public void flush() {\n                statefulWriter.flush();\n            }\n\n            public void close() {\n                if (statefulWriter.state() != StatefulWriter.STATE_CLOSED) {\n                    statefulWriter.endNode();\n                    statefulWriter.close();\n                }\n            }\n        });\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from a reader using\n     * XStream.\n     * \n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @since 1.0.3\n     */\n    public ObjectInputStream createObjectInputStream(Reader xmlReader) throws IOException {\n        return createObjectInputStream(hierarchicalStreamDriver.createReader(xmlReader));\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from an InputStream\n     * using XStream.\n     * \n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @since 1.3\n     */\n    public ObjectInputStream createObjectInputStream(InputStream in) throws IOException {\n        return createObjectInputStream(hierarchicalStreamDriver.createReader(in));\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from a reader using XStream.\n     * <p>\n     * It is necessary to call ObjectInputStream.close() when done, otherwise the stream might keep system resources.\n     * </p>\n     * <h3>Example</h3>\n     *\n     * <pre>\n     * ObjectInputStream in = xstream.createObjectOutputStream(aReader);\n     * int a = out.readInt();\n     * Object b = out.readObject();\n     * Object c = out.readObject();\n     * </pre>\n     * \n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter,\n     *      String)\n     * @since 1.0.3\n     */\n    public ObjectInputStream createObjectInputStream(final HierarchicalStreamReader reader) throws IOException {\n        return createObjectInputStream(reader, null);\n    }\n\n    /**\n     * Creates an ObjectInputStream that deserializes a stream of objects from a reader using XStream.\n     *\n     * @see #createObjectOutputStream(com.thoughtworks.xstream.io.HierarchicalStreamWriter, String)\n     * @see #createObjectInputStream(com.thoughtworks.xstream.io.HierarchicalStreamReader)\n     * @since 1.4.10\n     */\n    public ObjectInputStream createObjectInputStream(final HierarchicalStreamReader reader, final DataHolder dataHolder)\n            throws IOException {\n        return new CustomObjectInputStream(new CustomObjectInputStream.StreamCallback() {\n            public Object readFromStream() throws EOFException {\n                if (!reader.hasMoreChildren()) {\n                    throw new EOFException();\n                }\n                reader.moveDown();\n                final Object result = unmarshal(reader, dataHolder);\n                reader.moveUp();\n                return result;\n            }\n\n            public Map readFieldsFromStream() throws IOException {\n                throw new NotActiveException(\"not in call to readObject\");\n            }\n\n            public void defaultReadObject() throws NotActiveException {\n                throw new NotActiveException(\"not in call to readObject\");\n            }\n\n            public void registerValidation(ObjectInputValidation validation, int priority)\n                throws NotActiveException {\n                throw new NotActiveException(\"stream inactive\");\n            }\n\n            public void close() {\n                reader.close();\n            }\n        }, classLoaderReference);\n    }\n\n    /**\n     * Change the ClassLoader XStream uses to load classes. Creating an XStream instance it will\n     * register for all kind of classes and types of the current JDK, but not for any 3rd party\n     * type. To ensure that all other types are loaded with your class loader, you should call\n     * this method as early as possible - or consider to provide the class loader directly in\n     * the constructor.\n     * \n     * @since 1.1.1\n     */\n    public void setClassLoader(ClassLoader classLoader) {\n        classLoaderReference.setReference(classLoader);\n    }\n\n    /**\n     * Retrieve the ClassLoader XStream uses to load classes.\n     *\n     * @since 1.1.1\n     */\n    public ClassLoader getClassLoader() {\n        return classLoaderReference.getReference();\n    }\n    \n    /**\n     * Retrieve the reference to this instance' ClassLoader. Use this reference for other\n     * XStream components (like converters) to ensure that they will use a changed ClassLoader\n     * instance automatically.\n     * \n     * @return the reference\n     * @since 1.4.5\n     */\n    public ClassLoaderReference getClassLoaderReference() {\n        return classLoaderReference;\n    }\n\n    /**\n     * Prevents a field from being serialized. To omit a field you must always provide the\n     * declaring type and not necessarily the type that is converted.\n     * \n     * @since 1.1.3\n     * @throws InitializationException if no {@link ElementIgnoringMapper} is available\n     */\n    public void omitField(Class definedIn, String fieldName) {\n        if (elementIgnoringMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ElementIgnoringMapper.class.getName()\n                + \" available\");\n        }\n        elementIgnoringMapper.omitField(definedIn, fieldName);\n    }\n    \n    /**\n     * Ignore all unknown elements.\n     *\n     * @since 1.4.5\n     */\n    public void ignoreUnknownElements() {\n        ignoreUnknownElements(IGNORE_ALL);\n    }\n\n    /**\n     * Add pattern for unknown element names to ignore.\n     *\n     * @param pattern the name pattern as regular expression\n     * @since 1.4.5\n     */\n    public void ignoreUnknownElements(String pattern) {\n        ignoreUnknownElements(Pattern.compile(pattern));\n    }\n\n    /**\n     * Add pattern for unknown element names to ignore.\n     *\n     * @param pattern the name pattern as regular expression\n     * @since 1.4.5\n     */\n    public void ignoreUnknownElements(final Pattern pattern) {\n        if (elementIgnoringMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ElementIgnoringMapper.class.getName()\n                + \" available\");\n        }\n        elementIgnoringMapper.addElementsToIgnore(pattern);\n    }\n\n    /**\n     * Process the annotations of the given types and configure the XStream.\n     *\n     * @param types the types with XStream annotations\n     * @since 1.3\n     */\n    public void processAnnotations(final Class[] types) {\n        if (annotationConfiguration == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ANNOTATION_MAPPER_TYPE\n                + \" available\");\n        }\n        annotationConfiguration.processAnnotations(types);\n    }\n\n    /**\n     * Process the annotations of the given type and configure the XStream. A call of this\n     * method will automatically turn the auto-detection mode for annotations off.\n     * \n     * @param type the type with XStream annotations\n     * @since 1.3\n     */\n    public void processAnnotations(final Class type) {\n        processAnnotations(new Class[]{type});\n    }\n\n    /**\n     * Set the auto-detection mode of the AnnotationMapper. Note that auto-detection implies\n     * that the XStream is configured while it is processing the XML steams. This is a potential\n     * concurrency problem. Also is it technically not possible to detect all class aliases at\n     * deserialization. You have been warned!\n     * \n     * @param mode <code>true</code> if annotations are auto-detected\n     * @since 1.3\n     */\n    public void autodetectAnnotations(boolean mode) {\n        if (annotationConfiguration != null) {\n            annotationConfiguration.autodetectAnnotations(mode);\n        }\n    }\n    \n    /**\n     * Add a new security permission.\n     * \n     * <p>\n     * Permissions are evaluated in the added sequence. An instance of {@link NoTypePermission} or\n     * {@link AnyTypePermission} will implicitly wipe any existing permission.\n     * </p>\n     *\n     * @param permission the permission to add\n     * @since 1.4.7\n     */\n    public void addPermission(TypePermission permission) {\n        if (securityMapper != null) {\n            if (permission == AnyTypePermission.ANY)\n                securityInitialized = false;\n            else if (permission == NoTypePermission.NONE) {\n                securityInitialized = true;\n            }\n            securityInitialized = true;\n            securityMapper.addPermission(permission);\n        }\n    }\n    \n    /**\n     * Add security permission for explicit types by name.\n     *\n     * @param names the type names to allow\n     * @since 1.4.7\n     */\n    public void allowTypes(String[] names) {\n        addPermission(new ExplicitTypePermission(names));\n    }\n    \n    /**\n     * Add security permission for explicit types.\n     *\n     * @param types the types to allow\n     * @since 1.4.7\n     */\n    public void allowTypes(Class[] types) {\n        addPermission(new ExplicitTypePermission(types));\n    }\n    \n    /**\n     * Add security permission for a type hierarchy.\n     *\n     * @param type the base type to allow\n     * @since 1.4.7\n     */\n    public void allowTypeHierarchy(Class type) {\n        addPermission(new TypeHierarchyPermission(type));\n    }\n    \n    /**\n     * Add security permission for types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to allow type names\n     * @since 1.4.7\n     */\n    public void allowTypesByRegExp(String[] regexps) {\n        addPermission(new RegExpTypePermission(regexps));\n    }\n    \n    /**\n     * Add security permission for types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to allow type names\n     * @since 1.4.7\n     */\n    public void allowTypesByRegExp(Pattern[] regexps) {\n        addPermission(new RegExpTypePermission(regexps));\n    }\n    \n    /**\n     * Add security permission for types matching one of the specified wildcard patterns.\n     * <p>\n     * Supported are patterns with path expressions using dot as separator:\n     * </p>\n     * <ul>\n     * <li>?: one non-control character except separator, e.g. for 'java.net.Inet?Address'</li>\n     * <li>*: arbitrary number of non-control characters except separator, e.g. for types in a package like 'java.lang.*'</li>\n     * <li>**: arbitrary number of non-control characters including separator, e.g. for types in a package and subpackages like 'java.lang.**'</li>\n     * </ul>\n     *\n     * @param patterns the patterns to allow type names\n     * @since 1.4.7\n     */\n    public void allowTypesByWildcard(String[] patterns) {\n        addPermission(new WildcardTypePermission(patterns));\n    }\n    \n    /**\n     * Add security permission denying another one.\n     *\n     * @param permission the permission to deny\n     * @since 1.4.7\n     */\n    public void denyPermission(TypePermission permission) {\n        addPermission(new NoPermission(permission));\n    }\n    \n    /**\n     * Add security permission forbidding explicit types by name.\n     *\n     * @param names the type names to forbid\n     * @since 1.4.7\n     */\n    public void denyTypes(String[] names) {\n        denyPermission(new ExplicitTypePermission(names));\n    }\n    \n    /**\n     * Add security permission forbidding explicit types.\n     *\n     * @param types the types to forbid\n     * @since 1.4.7\n     */\n    public void denyTypes(Class[] types) {\n        denyPermission(new ExplicitTypePermission(types));\n    }\n    \n    /**\n     * Add security permission forbidding a type hierarchy.\n     *\n     * @param type the base type to forbid\n     * @since 1.4.7\n     */\n    public void denyTypeHierarchy(Class type) {\n        denyPermission(new TypeHierarchyPermission(type));\n    }\n    \n    /**\n     * Add security permission forbidding types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to forbid type names\n     * @since 1.4.7\n     */\n    public void denyTypesByRegExp(String[] regexps) {\n        denyPermission(new RegExpTypePermission(regexps));\n    }\n    \n    /**\n     * Add security permission forbidding types matching one of the specified regular expressions.\n     *\n     * @param regexps the regular expressions to forbid type names\n     * @since 1.4.7\n     */\n    public void denyTypesByRegExp(Pattern[] regexps) {\n        denyPermission(new RegExpTypePermission(regexps));\n    }\n    \n    /**\n     * Add security permission forbidding types matching one of the specified wildcard patterns.\n     * <p>\n     * Supported are patterns with path expressions using dot as separator:\n     * </p>\n     * <ul>\n     * <li>?: one non-control character except separator, e.g. for 'java.net.Inet?Address'</li>\n     * <li>*: arbitrary number of non-control characters except separator, e.g. for types in a package like 'java.lang.*'</li>\n     * <li>**: arbitrary number of non-control characters including separator, e.g. for types in a package and subpackages like 'java.lang.**'</li>\n     * </ul>\n     *\n     * @param patterns the patterns to forbid names\n     * @since 1.4.7\n     */\n    public void denyTypesByWildcard(String[] patterns) {\n        denyPermission(new WildcardTypePermission(patterns));\n    }\n\n    private Object readResolve() {\n        securityWarningGiven = true;\n        return this;\n    }\n\n    /**\n     * @deprecated As of 1.3, use {@link com.thoughtworks.xstream.InitializationException}\n     *             instead\n     */\n    public static class InitializationException extends XStreamException {\n        /**\n         * @deprecated As of 1.3, use\n         *             {@link com.thoughtworks.xstream.InitializationException#InitializationException(String, Throwable)}\n         *             instead\n         */\n        public InitializationException(String message, Throwable cause) {\n            super(message, cause);\n        }\n\n        /**\n         * @deprecated As of 1.3, use\n         *             {@link com.thoughtworks.xstream.InitializationException#InitializationException(String)}\n         *             instead\n         */\n        public InitializationException(String message) {\n            super(message);\n        }\n    }\n\n    private class InternalBlackList implements Converter {\n\n        public boolean canConvert(final Class type) {\n            return (type == void.class || type == Void.class)\n                || (!securityInitialized\n                    && type != null\n                    && (type.getName().equals(\"java.beans.EventHandler\")\n                        || type.getName().endsWith(\"$LazyIterator\")\n                        || type.getName().startsWith(\"javax.crypto.\")));\n        }\n\n        public void marshal(final Object source, final HierarchicalStreamWriter writer,\n                final MarshallingContext context) {\n            throw new ConversionException(\"Security alert. Marshalling rejected.\");\n        }\n\n        public Object unmarshal(final HierarchicalStreamReader reader, final UnmarshallingContext context) {\n            throw new ConversionException(\"Security alert. Unmarshalling rejected.\");\n        }\n    }\n}\n"
      }
    ],
    "file_count": 1
  },
  "VUL4J-79": {
    "vul_id": "VUL4J-79",
    "cve_id": "CVE-2018-1002201",
    "project": "zeroturnaround_zt-zip",
    "build_system": "Maven",
    "compile_cmd": "mvn -DskipTests clean install",
    "test_cmd": "mvn test -Dtest=org.zeroturnaround.zip.DirectoryTraversalMaliciousTest",
    "test_all_cmd": "mvn test",
    "human_patch_url": "https://github.com/zeroturnaround/zt-zip/commit/759b72f33bc8f4d69f84f09fcb7f010ad45d6fff",
    "vulnerable_files": [
      {
        "file_path": "src/main/java/org/zeroturnaround/zip/ZipUtil.java",
        "file_name": "ZipUtil.java",
        "vulnerable_code": "/**\n *    Copyright (C) 2012 ZeroTurnaround LLC <support@zeroturnaround.com>\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\npackage org.zeroturnaround.zip;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.zip.Deflater;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipInputStream;\nimport java.util.zip.ZipOutputStream;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.zeroturnaround.zip.commons.FileUtils;\nimport org.zeroturnaround.zip.commons.FilenameUtils;\nimport org.zeroturnaround.zip.commons.IOUtils;\nimport org.zeroturnaround.zip.transform.ZipEntryTransformer;\nimport org.zeroturnaround.zip.transform.ZipEntryTransformerEntry;\n\n/**\n * ZIP file manipulation utilities.\n *\n * @author Rein Raudj\u00e4rv\n * @author Innokenty Shuvalov\n *\n * @see #containsEntry(File, String)\n * @see #unpackEntry(File, String)\n * @see #unpack(File, File)\n * @see #pack(File, File)\n */\npublic final class ZipUtil {\n\n  private static final String PATH_SEPARATOR = \"/\";\n\n  /** Default compression level */\n  public static final int DEFAULT_COMPRESSION_LEVEL = Deflater.DEFAULT_COMPRESSION;\n\n  // Use / instead of . to work around an issue with Maven Shade Plugin\n  private static final Logger log = LoggerFactory.getLogger(\"org/zeroturnaround/zip/ZipUtil\".replace('/', '.')); // NOSONAR\n\n  private ZipUtil() {\n  }\n\n  /* Extracting single entries from ZIP files. */\n\n  /**\n   * Checks if the ZIP file contains the given entry.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return <code>true</code> if the ZIP file contains the given entry.\n   */\n  public static boolean containsEntry(File zip, String name) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      return zf.getEntry(name) != null;\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Returns the compression method of a given entry of the ZIP file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return Returns <code>ZipEntry.STORED</code>, <code>ZipEntry.DEFLATED</code> or -1 if\n   *         the ZIP file does not contain the given entry.\n   * @deprecated The compression level cannot be retrieved. This method exists only to ensure backwards compatibility with ZipUtil version 1.9, which returned the compression\n   *             method, not the level.\n   */\n  @Deprecated\n  public static int getCompressionLevelOfEntry(File zip, String name) {\n    return getCompressionMethodOfEntry(zip, name);\n  }\n\n  /**\n   * Returns the compression method of a given entry of the ZIP file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return Returns <code>ZipEntry.STORED</code>, <code>ZipEntry.DEFLATED</code> or -1 if\n   *         the ZIP file does not contain the given entry.\n   */\n  public static int getCompressionMethodOfEntry(File zip, String name) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      ZipEntry zipEntry = zf.getEntry(name);\n      if (zipEntry == null) {\n        return -1;\n      }\n      return zipEntry.getMethod();\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Checks if the ZIP file contains any of the given entries.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param names\n   *          entry names.\n   * @return <code>true</code> if the ZIP file contains any of the given\n   *         entries.\n   */\n  public static boolean containsAnyEntry(File zip, String[] names) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      for (int i = 0; i < names.length; i++) {\n        if (zf.getEntry(names[i]) != null) {\n          return true;\n        }\n      }\n      return false;\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Unpacks a single entry from a ZIP file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return contents of the entry or <code>null</code> if it was not found.\n   */\n  public static byte[] unpackEntry(File zip, String name) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      return doUnpackEntry(zf, name);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Unpacks a single entry from a ZIP file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   *\n   * @param charset\n   *          charset to be used to process the zip\n   *\n   * @return contents of the entry or <code>null</code> if it was not found.\n   */\n  public static byte[] unpackEntry(File zip, String name, Charset charset) {\n    ZipFile zf = null;\n    try {\n      if (charset != null) {\n        zf = new ZipFile(zip, charset);\n      }\n      else {\n        zf = new ZipFile(zip);\n      }\n      return doUnpackEntry(zf, name);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Unpacks a single entry from a ZIP file.\n   *\n   * @param zf\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return contents of the entry or <code>null</code> if it was not found.\n   */\n  public static byte[] unpackEntry(ZipFile zf, String name) {\n    try {\n      return doUnpackEntry(zf, name);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Unpacks a single entry from a ZIP file.\n   *\n   * @param zf\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return contents of the entry or <code>null</code> if it was not found.\n   */\n  private static byte[] doUnpackEntry(ZipFile zf, String name) throws IOException {\n    ZipEntry ze = zf.getEntry(name);\n    if (ze == null) {\n      return null; // entry not found\n    }\n\n    InputStream is = zf.getInputStream(ze);\n    try {\n      return IOUtils.toByteArray(is);\n    }\n    finally {\n      IOUtils.closeQuietly(is);\n    }\n  }\n\n  /**\n   * Unpacks a single entry from a ZIP stream.\n   *\n   * @param is\n   *          ZIP stream.\n   * @param name\n   *          entry name.\n   * @return contents of the entry or <code>null</code> if it was not found.\n   */\n  public static byte[] unpackEntry(InputStream is, String name) {\n    ByteArrayUnpacker action = new ByteArrayUnpacker();\n    if (!handle(is, name, action))\n      return null; // entry not found\n    return action.getBytes();\n  }\n\n  /**\n   * Copies an entry into a byte array.\n   *\n   * @author Rein Raudj\u00e4rv\n   */\n  private static class ByteArrayUnpacker implements ZipEntryCallback {\n\n    private byte[] bytes;\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      bytes = IOUtils.toByteArray(in);\n    }\n\n    public byte[] getBytes() {\n      return bytes;\n    }\n\n  }\n\n  /**\n   * Unpacks a single file from a ZIP archive to a file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @param file\n   *          target file to be created or overwritten.\n   * @return <code>true</code> if the entry was found and unpacked,\n   *         <code>false</code> if the entry was not found.\n   */\n  public static boolean unpackEntry(File zip, String name, File file) {\n    return unpackEntry(zip, name, file, null);\n  }\n\n  /**\n   * Unpacks a single file from a ZIP archive to a file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @param file\n   *          target file to be created or overwritten.\n   * @param charset\n   *          charset to be used processing the zip\n   *\n   * @return <code>true</code> if the entry was found and unpacked,\n   *         <code>false</code> if the entry was not found.\n   */\n  public static boolean unpackEntry(File zip, String name, File file, Charset charset) {\n    ZipFile zf = null;\n    try {\n      if (charset != null) {\n        zf = new ZipFile(zip, charset);\n      }\n      else {\n        zf = new ZipFile(zip);\n      }\n      return doUnpackEntry(zf, name, file);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Unpacks a single file from a ZIP archive to a file.\n   *\n   * @param zf\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @param file\n   *          target file to be created or overwritten.\n   * @return <code>true</code> if the entry was found and unpacked,\n   *         <code>false</code> if the entry was not found.\n   */\n  public static boolean unpackEntry(ZipFile zf, String name, File file) {\n    try {\n      return doUnpackEntry(zf, name, file);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Unpacks a single file from a ZIP archive to a file.\n   *\n   * @param zf\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @param file\n   *          target file to be created or overwritten.\n   * @return <code>true</code> if the entry was found and unpacked,\n   *         <code>false</code> if the entry was not found.\n   */\n  private static boolean doUnpackEntry(ZipFile zf, String name, File file) throws IOException {\n    if (log.isTraceEnabled()) {\n      log.trace(\"Extracting '\" + zf.getName() + \"' entry '\" + name + \"' into '\" + file + \"'.\");\n    }\n\n    ZipEntry ze = zf.getEntry(name);\n    if (ze == null) {\n      return false; // entry not found\n    }\n\n    if (ze.isDirectory() || zf.getInputStream(ze) == null) {\n      if (file.isDirectory()) {\n        return true;\n      }\n      if (file.exists()) {\n        FileUtils.forceDelete(file);\n      }\n      return file.mkdirs();\n    }\n\n    InputStream in = new BufferedInputStream(zf.getInputStream(ze));\n    try {\n      FileUtils.copy(in, file);\n    }\n    finally {\n      IOUtils.closeQuietly(in);\n    }\n    return true;\n  }\n\n  /**\n   * Unpacks a single file from a ZIP stream to a file.\n   *\n   * @param is\n   *          ZIP stream.\n   * @param name\n   *          entry name.\n   * @param file\n   *          target file to be created or overwritten.\n   * @return <code>true</code> if the entry was found and unpacked,\n   *         <code>false</code> if the entry was not found.\n   * @throws java.io.IOException if file is not found or writing to it fails\n   */\n  public static boolean unpackEntry(InputStream is, String name, File file) throws IOException {\n    return handle(is, name, new FileUnpacker(file));\n  }\n\n  /**\n   * Copies an entry into a File.\n   *\n   * @author Rein Raudj\u00e4rv\n   */\n  private static class FileUnpacker implements ZipEntryCallback {\n\n    private final File file;\n\n    public FileUnpacker(File file) {\n      this.file = file;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      FileUtils.copy(in, file);\n    }\n\n  }\n\n  /* Traversing ZIP files */\n\n  /**\n   * Reads the given ZIP file and executes the given action for each entry.\n   * <p>\n   * For each entry the corresponding input stream is also passed to the action. If you want to stop the loop\n   * then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, ZipInfoCallback)\n   */\n  public static void iterate(File zip, ZipEntryCallback action) {\n    iterate(zip, action, null);\n  }\n\n  /**\n   * Reads the given ZIP file and executes the given action for each entry.\n   * <p>\n   * For each entry the corresponding input stream is also passed to the action. If you want to stop the loop\n   * then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @param charset\n   *          Charset used to processed the ZipFile with\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, ZipInfoCallback)\n   */\n  public static void iterate(File zip, ZipEntryCallback action, Charset charset) {\n    ZipFile zf = null;\n    try {\n      if (charset == null) {\n        zf = new ZipFile(zip);\n      }\n      else {\n        zf = new ZipFile(zip, charset);\n      }\n\n      Enumeration<? extends ZipEntry> en = zf.entries();\n      while (en.hasMoreElements()) {\n        ZipEntry e = (ZipEntry) en.nextElement();\n\n        InputStream is = zf.getInputStream(e);\n        try {\n          action.process(is, e);\n        }\n        catch (IOException ze) {\n          throw new ZipException(\"Failed to process zip entry '\" + e.getName() + \"' with action \" + action, ze);\n        }\n        catch (ZipBreakException ex) {\n          break;\n        }\n        finally {\n          IOUtils.closeQuietly(is);\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Reads the given ZIP file and executes the given action for each given entry.\n   * <p>\n   * For each given entry the corresponding input stream is also passed to the action. If you want to stop the loop then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param entryNames\n   *          names of entries to iterate\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, String[], ZipInfoCallback)\n   */\n  public static void iterate(File zip, String[] entryNames, ZipEntryCallback action) {\n    iterate(zip, entryNames, action, null);\n  }\n\n  /**\n   * Reads the given ZIP file and executes the given action for each given entry.\n   * <p>\n   * For each given entry the corresponding input stream is also passed to the action. If you want to stop the loop then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param entryNames\n   *          names of entries to iterate\n   * @param action\n   *          action to be called for each entry.\n   * @param charset\n   *          charset used to process the zip file\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, String[], ZipInfoCallback)\n   */\n  public static void iterate(File zip, String[] entryNames, ZipEntryCallback action, Charset charset) {\n    ZipFile zf = null;\n    try {\n      if (charset == null) {\n        zf = new ZipFile(zip);\n      }\n      else {\n        zf = new ZipFile(zip, charset);\n      }\n\n      for (int i = 0; i < entryNames.length; i++) {\n        ZipEntry e = zf.getEntry(entryNames[i]);\n        if (e == null) {\n          continue;\n        }\n        InputStream is = zf.getInputStream(e);\n        try {\n          action.process(is, e);\n        }\n        catch (IOException ze) {\n          throw new ZipException(\"Failed to process zip entry '\" + e.getName() + \" with action \" + action, ze);\n        }\n        catch (ZipBreakException ex) {\n          break;\n        }\n        finally {\n          IOUtils.closeQuietly(is);\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Scans the given ZIP file and executes the given action for each entry.\n   * <p>\n   * Only the meta-data without the actual data is read. If you want to stop the loop\n   * then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipInfoCallback\n   * @see #iterate(File, ZipEntryCallback)\n   */\n  public static void iterate(File zip, ZipInfoCallback action) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n\n      Enumeration<? extends ZipEntry> en = zf.entries();\n      while (en.hasMoreElements()) {\n        ZipEntry e = (ZipEntry) en.nextElement();\n        try {\n          action.process(e);\n        }\n        catch (IOException ze) {\n          throw new ZipException(\"Failed to process zip entry '\" + e.getName() + \" with action \" + action, ze);\n        }\n        catch (ZipBreakException ex) {\n          break;\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Scans the given ZIP file and executes the given action for each given entry.\n   * <p>\n   * Only the meta-data without the actual data is read. If you want to stop the loop then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param entryNames\n   *          names of entries to iterate\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipInfoCallback\n   * @see #iterate(File, String[], ZipEntryCallback)\n   */\n  public static void iterate(File zip, String[] entryNames, ZipInfoCallback action) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n\n      for (int i = 0; i < entryNames.length; i++) {\n        ZipEntry e = zf.getEntry(entryNames[i]);\n        if (e == null) {\n          continue;\n        }\n        try {\n          action.process(e);\n        }\n        catch (IOException ze) {\n          throw new ZipException(\"Failed to process zip entry '\" + e.getName() + \" with action \" + action, ze);\n        }\n        catch (ZipBreakException ex) {\n          break;\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Reads the given ZIP stream and executes the given action for each entry.\n   * <p>\n   * For each entry the corresponding input stream is also passed to the action. If you want to stop the loop\n   * then throw a ZipBreakException.\n   *\n   * @param is\n   *          input ZIP stream (it will not be closed automatically).\n   * @param action\n   *          action to be called for each entry.\n   * @param charset\n   *          charset to process entries in\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, ZipEntryCallback)\n   */\n  public static void iterate(InputStream is, ZipEntryCallback action, Charset charset) {\n    try {\n      ZipInputStream in = null;\n      try {\n        in = newCloseShieldZipInputStream(is, charset);\n        ZipEntry entry;\n        while ((entry = in.getNextEntry()) != null) {\n          try {\n            action.process(in, entry);\n          }\n          catch (IOException ze) {\n            throw new ZipException(\"Failed to process zip entry '\" + entry.getName() + \" with action \" + action, ze);\n          }\n          catch (ZipBreakException ex) {\n            break;\n          }\n        }\n      }\n      finally {\n        if (in != null) {\n          in.close();\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * See {@link #iterate(InputStream, ZipEntryCallback, Charset)}. This method\n   * is a shorthand for a version where no Charset is specified.\n   *\n   * @param is\n   *          input ZIP stream (it will not be closed automatically).\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, ZipEntryCallback)\n   */\n  public static void iterate(InputStream is, ZipEntryCallback action) {\n    iterate(is, action, null);\n  }\n\n  /**\n   * Reads the given ZIP stream and executes the given action for each given entry.\n   * <p>\n   * For each given entry the corresponding input stream is also passed to the action. If you want to stop the loop then throw a ZipBreakException.\n   *\n   * @param is\n   *          input ZIP stream (it will not be closed automatically).\n   * @param entryNames\n   *          names of entries to iterate\n   * @param action\n   *          action to be called for each entry.\n   * @param charset\n   *          charset to process entries in\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, String[], ZipEntryCallback)\n   */\n  public static void iterate(InputStream is, String[] entryNames, ZipEntryCallback action, Charset charset) {\n    Set<String> namesSet = new HashSet<String>();\n    for (int i = 0; i < entryNames.length; i++) {\n      namesSet.add(entryNames[i]);\n    }\n    try {\n      ZipInputStream in = null;\n      try {\n        in = newCloseShieldZipInputStream(is, charset);\n        ZipEntry entry;\n        while ((entry = in.getNextEntry()) != null) {\n          if (!namesSet.contains(entry.getName())) {\n            // skip the unnecessary entry\n            continue;\n          }\n          try {\n            action.process(in, entry);\n          }\n          catch (IOException ze) {\n            throw new ZipException(\"Failed to process zip entry '\" + entry.getName() + \" with action \" + action, ze);\n          }\n          catch (ZipBreakException ex) {\n            break;\n          }\n        }\n      }\n      finally {\n        if (in != null) {\n          in.close();\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * See @link{ {@link #iterate(InputStream, ZipEntryCallback, Charset)}. It is a\n   * shorthand where no Charset is specified.\n   *\n   * @param is\n   *          input ZIP stream (it will not be closed automatically).\n   * @param entryNames\n   *          names of entries to iterate\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, String[], ZipEntryCallback)\n   */\n  public static void iterate(InputStream is, String[] entryNames, ZipEntryCallback action) {\n    iterate(is, entryNames, action, null);\n  }\n\n  /**\n   * Creates a new {@link ZipInputStream} based on the given {@link InputStream}. It will be buffered and close-shielded.\n   * Closing the result stream flushes the buffers and frees up resources of the {@link ZipInputStream}. However the source stream itself remains open.\n   */\n  private static ZipInputStream newCloseShieldZipInputStream(final InputStream is, Charset charset) {\n    InputStream in = new BufferedInputStream(new CloseShieldInputStream(is));\n    if (charset == null) {\n      return new ZipInputStream(in);\n    }\n    return ZipFileUtil.createZipInputStream(in, charset);\n  }\n\n  /**\n   * Reads the given ZIP file and executes the given action for a single entry.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param name\n   *          entry name.\n   * @param action\n   *          action to be called for this entry.\n   * @return <code>true</code> if the entry was found, <code>false</code> if the\n   *         entry was not found.\n   *\n   * @see ZipEntryCallback\n   */\n  public static boolean handle(File zip, String name, ZipEntryCallback action) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n\n      ZipEntry ze = zf.getEntry(name);\n      if (ze == null) {\n        return false; // entry not found\n      }\n\n      InputStream in = new BufferedInputStream(zf.getInputStream(ze));\n      try {\n        action.process(in, ze);\n      }\n      finally {\n        IOUtils.closeQuietly(in);\n      }\n      return true;\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Reads the given ZIP stream and executes the given action for a single\n   * entry.\n   *\n   * @param is\n   *          input ZIP stream (it will not be closed automatically).\n   * @param name\n   *          entry name.\n   * @param action\n   *          action to be called for this entry.\n   * @return <code>true</code> if the entry was found, <code>false</code> if the\n   *         entry was not found.\n   *\n   * @see ZipEntryCallback\n   */\n  public static boolean handle(InputStream is, String name, ZipEntryCallback action) {\n    SingleZipEntryCallback helper = new SingleZipEntryCallback(name, action);\n    iterate(is, helper);\n    return helper.found();\n  }\n\n  /**\n   * ZipEntryCallback which is only applied to single entry.\n   *\n   * @author Rein Raudj\u00e4rv\n   */\n  private static class SingleZipEntryCallback implements ZipEntryCallback {\n\n    private final String name;\n\n    private final ZipEntryCallback action;\n\n    private boolean found;\n\n    public SingleZipEntryCallback(String name, ZipEntryCallback action) {\n      this.name = name;\n      this.action = action;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      if (name.equals(zipEntry.getName())) {\n        found = true;\n        action.process(in, zipEntry);\n      }\n    }\n\n    public boolean found() {\n      return found;\n    }\n\n  }\n\n  /* Extracting whole ZIP files. */\n\n  /**\n   * Unpacks a ZIP file to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   */\n  public static void unpack(File zip, final File outputDir) {\n    unpack(zip, outputDir, IdentityNameMapper.INSTANCE);\n  }\n\n  /**\n   * Unpacks a ZIP file to the given directory using a specific Charset\n   * for the input file.\n   *\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   *\n   * @param charset\n   *          charset used to unpack the zip file\n   */\n  public static void unpack(File zip, final File outputDir, Charset charset) {\n    unpack(zip, outputDir, IdentityNameMapper.INSTANCE, charset);\n  }\n\n  /**\n   * Unpacks a ZIP file to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param charset\n   *          charset used to process the zip file\n   */\n  public static void unpack(File zip, File outputDir, NameMapper mapper, Charset charset) {\n    log.debug(\"Extracting '{}' into '{}'.\", zip, outputDir);\n    iterate(zip, new Unpacker(outputDir, mapper), charset);\n  }\n\n  /**\n   * Unpacks a ZIP file to the given directory using a specific Charset\n   * for the input file.\n   *\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void unpack(File zip, File outputDir, NameMapper mapper) {\n    log.debug(\"Extracting '{}' into '{}'.\", zip, outputDir);\n    iterate(zip, new Unpacker(outputDir, mapper));\n  }\n\n  /**\n   * Unwraps a ZIP file to the given directory shaving of root dir.\n   * If there are multiple root dirs or entries in the root of zip,\n   * ZipException is thrown.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   */\n  public static void unwrap(File zip, final File outputDir) {\n    unwrap(zip, outputDir, IdentityNameMapper.INSTANCE);\n  }\n\n  /**\n   * Unwraps a ZIP file to the given directory shaving of root dir.\n   * If there are multiple root dirs or entries in the root of zip,\n   * ZipException is thrown.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void unwrap(File zip, File outputDir, NameMapper mapper) {\n    log.debug(\"Unwrapping '{}' into '{}'.\", zip, outputDir);\n    iterate(zip, new Unwraper(outputDir, mapper));\n  }\n\n  /**\n   * Unpacks a ZIP stream to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   */\n  public static void unpack(InputStream is, File outputDir) {\n    unpack(is, outputDir, IdentityNameMapper.INSTANCE, null);\n  }\n\n  /**\n   * Unpacks a ZIP stream to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param charset\n   *          charset used to process the zip stream\n   */\n  public static void unpack(InputStream is, File outputDir, Charset charset) {\n    unpack(is, outputDir, IdentityNameMapper.INSTANCE, charset);\n  }\n\n  /**\n   * Unpacks a ZIP stream to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void unpack(InputStream is, File outputDir, NameMapper mapper) {\n    unpack(is, outputDir, mapper, null);\n  }\n\n  /**\n   * Unpacks a ZIP stream to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param charset\n   *          charset to use when unpacking the stream\n   */\n  public static void unpack(InputStream is, File outputDir, NameMapper mapper, Charset charset) {\n    log.debug(\"Extracting {} into '{}'.\", is, outputDir);\n    iterate(is, new Unpacker(outputDir, mapper), charset);\n  }\n\n  /**\n   * Unwraps a ZIP file to the given directory shaving of root dir.\n   * If there are multiple root dirs or entries in the root of zip,\n   * ZipException is thrown.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   */\n  public static void unwrap(InputStream is, File outputDir) {\n    unwrap(is, outputDir, IdentityNameMapper.INSTANCE);\n  }\n\n  /**\n   * Unwraps a ZIP file to the given directory shaving of root dir.\n   * If there are multiple root dirs or entries in the root of zip,\n   * ZipException is thrown.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void unwrap(InputStream is, File outputDir, NameMapper mapper) {\n    log.debug(\"Unwrapping {} into '{}'.\", is, outputDir);\n    iterate(is, new Unwraper(outputDir, mapper));\n  }\n\n  /**\n   * Unpacks each ZIP entry.\n   *\n   * @author Rein Raudj\u00e4rv\n   */\n  private static class Unpacker implements ZipEntryCallback {\n\n    private final File outputDir;\n    private final NameMapper mapper;\n\n    public Unpacker(File outputDir, NameMapper mapper) {\n      this.outputDir = outputDir;\n      this.mapper = mapper;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      String name = mapper.map(zipEntry.getName());\n      if (name != null) {\n        File file = new File(outputDir, name);\n        if (zipEntry.isDirectory()) {\n          FileUtils.forceMkdir(file);\n        }\n        else {\n          FileUtils.forceMkdir(file.getParentFile());\n\n          if (log.isDebugEnabled() && file.exists()) {\n            log.debug(\"Overwriting file '{}'.\", zipEntry.getName());\n          }\n\n          FileUtils.copy(in, file);\n        }\n\n        ZTFilePermissions permissions = ZipEntryUtil.getZTFilePermissions(zipEntry);\n        if (permissions != null) {\n          ZTFilePermissionsUtil.getDefaultStategy().setPermissions(file, permissions);\n        }\n      }\n    }\n  }\n\n  /**\n   * Unpacks each ZIP entries. Presumes they are packed with the backslash separator.\n   * Some archives can have this problem if they are created with some software\n   * that is not following the ZIP specification.\n   *\n   * @since zt-zip 1.9\n   */\n  public static class BackslashUnpacker implements ZipEntryCallback {\n\n    private final File outputDir;\n    private final NameMapper mapper;\n\n    public BackslashUnpacker(File outputDir, NameMapper mapper) {\n      this.outputDir = outputDir;\n      this.mapper = mapper;\n    }\n\n    public BackslashUnpacker(File outputDir) {\n      this(outputDir, IdentityNameMapper.INSTANCE);\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      String name = mapper.map(zipEntry.getName());\n      if (name != null) {\n        /**\n         * We assume that EVERY backslash will denote a directory\n         * separator. Also such broken archives don't have entries that\n         * are just directories. Everything is a file. See the example\n         *\n         * Archive: backSlashTest.zip\n         * testing: testDirectory\\testfileInTestDirectory.txt OK\n         * testing: testDirectory\\testSubdirectory\\testFileInTestSubdirectory.txt OK\n         * No errors detected in compressed data of backSlashTest.zip.\n         */\n        if (name.indexOf('\\\\') != -1) {\n          File parentDirectory = outputDir;\n          String[] dirs = name.split(\"\\\\\\\\\");\n\n          // lets create all the directories and the last entry is the file as EVERY entry is a file\n          for (int i = 0; i < dirs.length - 1; i++) {\n            File file = new File(parentDirectory, dirs[i]);\n            if (!file.exists()) {\n              FileUtils.forceMkdir(file);\n            }\n            parentDirectory = file;\n          }\n          File destFile = new File(parentDirectory, dirs[dirs.length - 1]);\n          FileUtils.copy(in, destFile);\n        }\n        // it could be that there are just top level files that the unpacker is used for\n        else {\n          File destFile = new File(outputDir, name);\n          FileUtils.copy(in, destFile);\n        }\n      }\n    }\n  }\n\n  /**\n   * Unwraps entries excluding a single parent dir. If there are multiple roots\n   * ZipException is thrown.\n   *\n   * @author Oleg Shelajev\n   */\n  private static class Unwraper implements ZipEntryCallback {\n\n    private final File outputDir;\n    private final NameMapper mapper;\n    private String rootDir;\n\n    public Unwraper(File outputDir, NameMapper mapper) {\n      this.outputDir = outputDir;\n      this.mapper = mapper;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      String root = getRootName(zipEntry.getName());\n      if (rootDir == null) {\n        rootDir = root;\n      }\n      else if (!rootDir.equals(root)) {\n        throw new ZipException(\"Unwrapping with multiple roots is not supported, roots: \" + rootDir + \", \" + root);\n      }\n\n      String name = mapper.map(getUnrootedName(root, zipEntry.getName()));\n      if (name != null) {\n        File file = new File(outputDir, name);\n        if (zipEntry.isDirectory()) {\n          FileUtils.forceMkdir(file);\n        }\n        else {\n          FileUtils.forceMkdir(file.getParentFile());\n\n          if (log.isDebugEnabled() && file.exists()) {\n            log.debug(\"Overwriting file '{}'.\", zipEntry.getName());\n          }\n\n          FileUtils.copy(in, file);\n        }\n      }\n    }\n\n    private String getUnrootedName(String root, String name) {\n      return name.substring(root.length());\n    }\n\n    private String getRootName(final String name) {\n      String newName = name.substring(FilenameUtils.getPrefixLength(name));\n      int idx = newName.indexOf(PATH_SEPARATOR);\n      if (idx < 0) {\n        throw new ZipException(\"Entry \" + newName + \" from the root of the zip is not supported\");\n      }\n      return newName.substring(0, newName.indexOf(PATH_SEPARATOR));\n    }\n  }\n\n  /**\n   * Unpacks a ZIP file to its own location.\n   * <p>\n   * The ZIP file will be first renamed (using a temporary name). After the\n   * extraction it will be deleted.\n   *\n   * @param zip\n   *          input ZIP file as well as the target directory.\n   *\n   * @see #unpack(File, File)\n   */\n  public static void explode(File zip) {\n    try {\n      // Find a new unique name is the same directory\n      File tempFile = FileUtils.getTempFileFor(zip);\n\n      // Rename the archive\n      FileUtils.moveFile(zip, tempFile);\n\n      // Unpack it\n      unpack(tempFile, zip);\n\n      // Delete the archive\n      if (!tempFile.delete()) {\n        throw new IOException(\"Unable to delete file: \" + tempFile);\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /* Compressing single entries to ZIP files. */\n\n  /**\n   * Compresses the given file into a ZIP file with single entry.\n   *\n   * @param file file to be compressed.\n   * @return ZIP file created.\n   */\n  public static byte[] packEntry(File file) {\n    log.trace(\"Compressing '{}' into a ZIP file with single entry.\", file);\n\n    ByteArrayOutputStream result = new ByteArrayOutputStream();\n    try {\n      ZipOutputStream out = new ZipOutputStream(result);\n      ZipEntry entry = ZipEntryUtil.fromFile(file.getName(), file);\n      InputStream in = new BufferedInputStream(new FileInputStream(file));\n      try {\n        ZipEntryUtil.addEntry(entry, in, out);\n      }\n      finally {\n        IOUtils.closeQuietly(in);\n      }\n      out.close();\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    return result.toByteArray();\n  }\n\n  /* Compressing ZIP files. */\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   * Will not include the root directory name in the archive.\n   *\n   * @param rootDir\n   *          root directory.\n   * @param zip\n   *          ZIP file that will be created or overwritten.\n   */\n  public static void pack(File rootDir, File zip) {\n    pack(rootDir, zip, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   * Will not include the root directory name in the archive.\n   *\n   * @param rootDir\n   *          root directory.\n   * @param zip\n   *          ZIP file that will be created or overwritten.\n   * @param compressionLevel\n   *          compression level\n   */\n  public static void pack(File rootDir, File zip, int compressionLevel) {\n    pack(rootDir, zip, IdentityNameMapper.INSTANCE, compressionLevel);\n  }\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   * Will not include the root directory name in the archive.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param targetZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param preserveRoot\n   *          true if the resulted archive should have the top directory entry\n   */\n  public static void pack(final File sourceDir, final File targetZipFile, final boolean preserveRoot) {\n    if (preserveRoot) {\n      final String parentName = sourceDir.getName();\n      pack(sourceDir, targetZipFile, new NameMapper() {\n        public String map(String name) {\n          return parentName + PATH_SEPARATOR + name;\n        }\n      });\n    }\n    else {\n      pack(sourceDir, targetZipFile);\n    }\n  }\n\n  /**\n   * Compresses the given file into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param fileToPack\n   *          file that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   */\n  public static void packEntry(File fileToPack, File destZipFile) {\n    packEntry(fileToPack, destZipFile, IdentityNameMapper.INSTANCE);\n  }\n\n  /**\n   * Compresses the given file into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param fileToPack\n   *          file that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param fileName\n   *          the name for the file inside the archive\n   */\n  public static void packEntry(File fileToPack, File destZipFile, final String fileName) {\n    packEntry(fileToPack, destZipFile, new NameMapper() {\n      public String map(String name) {\n        return fileName;\n      }\n    });\n  }\n\n  /**\n   * Compresses the given file into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param fileToPack\n   *          file that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void packEntry(File fileToPack, File destZipFile, NameMapper mapper) {\n    packEntries(new File[] { fileToPack }, destZipFile, mapper);\n  }\n\n  /**\n   * Compresses the given files into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param filesToPack\n   *          files that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   */\n  public static void packEntries(File[] filesToPack, File destZipFile) {\n    packEntries(filesToPack, destZipFile, IdentityNameMapper.INSTANCE);\n  }\n\n  /**\n   * Compresses the given files into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param filesToPack\n   *          files that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void packEntries(File[] filesToPack, File destZipFile, NameMapper mapper) {\n    packEntries(filesToPack, destZipFile, mapper, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses the given files into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param filesToPack\n   *          files that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param compressionLevel\n   *          ZIP file compression level (speed versus filesize), e.g. <code>Deflater.NO_COMPRESSION</code>, <code>Deflater.BEST_SPEED</code>, or\n   *          <code>Deflater.BEST_COMPRESSION</code>\n   */\n  public static void packEntries(File[] filesToPack, File destZipFile, int compressionLevel) {\n    packEntries(filesToPack, destZipFile, IdentityNameMapper.INSTANCE, compressionLevel);\n  }\n\n  /**\n   * Compresses the given files into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param filesToPack\n   *          files that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param compressionLevel\n   *          ZIP file compression level (speed versus filesize), e.g. <code>Deflater.NO_COMPRESSION</code>, <code>Deflater.BEST_SPEED</code>, or\n   *          <code>Deflater.BEST_COMPRESSION</code>\n   */\n  public static void packEntries(File[] filesToPack, File destZipFile, NameMapper mapper, int compressionLevel) {\n    log.debug(\"Compressing '{}' into '{}'.\", filesToPack, destZipFile);\n\n    ZipOutputStream out = null;\n    FileOutputStream fos = null;\n    try {\n      fos = new FileOutputStream(destZipFile);\n      out = new ZipOutputStream(new BufferedOutputStream(fos));\n      out.setLevel(compressionLevel);\n\n      for (int i = 0; i < filesToPack.length; i++) {\n        File fileToPack = filesToPack[i];\n\n        ZipEntry zipEntry = ZipEntryUtil.fromFile(mapper.map(fileToPack.getName()), fileToPack);\n        out.putNextEntry(zipEntry);\n        FileUtils.copy(fileToPack, out);\n        out.closeEntry();\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(out);\n      IOUtils.closeQuietly(fos);\n    }\n  }\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param targetZip\n   *          ZIP file that will be created or overwritten.\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void pack(File sourceDir, File targetZip, NameMapper mapper) {\n    pack(sourceDir, targetZip, mapper, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param targetZip\n   *          ZIP file that will be created or overwritten.\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param compressionLevel\n   *          compression level\n   */\n  public static void pack(File sourceDir, File targetZip, NameMapper mapper, int compressionLevel) {\n    log.debug(\"Compressing '{}' into '{}'.\", sourceDir, targetZip);\n    if (!sourceDir.exists()) {\n      throw new ZipException(\"Given file '\" + sourceDir + \"' doesn't exist!\");\n    }\n    ZipOutputStream out = null;\n    try {\n      out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(targetZip)));\n      out.setLevel(compressionLevel);\n      pack(sourceDir, out, mapper, \"\", true);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(out);\n    }\n  }\n\n  /**\n   * Compresses the given directory and all of its sub-directories into the passed in\n   * stream. It is the responsibility of the caller to close the passed in\n   * stream properly.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param os\n   *          output stream (will be buffered in this method).\n   *\n   * @since 1.10\n   */\n  public static void pack(File sourceDir, OutputStream os) {\n    pack(sourceDir, os, IdentityNameMapper.INSTANCE, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses the given directory and all of its sub-directories into the passed in\n   * stream. It is the responsibility of the caller to close the passed in\n   * stream properly.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param os\n   *          output stream (will be buffered in this method).\n   * @param compressionLevel\n   *          compression level\n   *\n   * @since 1.10\n   */\n  public static void pack(File sourceDir, OutputStream os, int compressionLevel) {\n    pack(sourceDir, os, IdentityNameMapper.INSTANCE, compressionLevel);\n  }\n\n  /**\n   * Compresses the given directory and all of its sub-directories into the passed in\n   * stream. It is the responsibility of the caller to close the passed in\n   * stream properly.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param os\n   *          output stream (will be buffered in this method).\n   * @param mapper\n   *          call-back for renaming the entries.\n   *\n   * @since 1.10\n   */\n  public static void pack(File sourceDir, OutputStream os, NameMapper mapper) {\n    pack(sourceDir, os, mapper, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses the given directory and all of its sub-directories into the passed in\n   * stream. It is the responsibility of the caller to close the passed in\n   * stream properly.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param os\n   *          output stream (will be buffered in this method).\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param compressionLevel\n   *          compression level\n   *\n   * @since 1.10\n   */\n  public static void pack(File sourceDir, OutputStream os, NameMapper mapper, int compressionLevel) {\n    log.debug(\"Compressing '{}' into a stream.\", sourceDir);\n    if (!sourceDir.exists()) {\n      throw new ZipException(\"Given file '\" + sourceDir + \"' doesn't exist!\");\n    }\n    ZipOutputStream out = null;\n    IOException error = null;\n    try {\n      out = new ZipOutputStream(new BufferedOutputStream(os));\n      out.setLevel(compressionLevel);\n      pack(sourceDir, out, mapper, \"\", true);\n    }\n    catch (IOException e) {\n      error = e;\n    }\n    finally {\n      if (out != null && error == null) {\n        try {\n          out.finish();\n          out.flush();\n        }\n        catch (IOException e) {\n          error = e;\n        }\n      }\n    }\n    if (error != null) {\n      throw ZipExceptionUtil.rethrow(error);\n    }\n  }\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   *\n   * @param dir\n   *          root directory.\n   * @param out\n   *          ZIP output stream.\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param pathPrefix\n   *          prefix to be used for the entries.\n   * @param mustHaveChildren\n   *          if true, but directory to pack doesn't have any files, throw an exception.\n   */\n  private static void pack(File dir, ZipOutputStream out, NameMapper mapper, String pathPrefix, boolean mustHaveChildren) throws IOException {\n    String[] filenames = dir.list();\n    if (filenames == null) {\n      if (!dir.exists()) {\n        throw new ZipException(\"Given file '\" + dir + \"' doesn't exist!\");\n      }\n      throw new IOException(\"Given file is not a directory '\" + dir + \"'\");\n    }\n\n    if (mustHaveChildren && filenames.length == 0) {\n      throw new ZipException(\"Given directory '\" + dir + \"' doesn't contain any files!\");\n    }\n\n    for (int i = 0; i < filenames.length; i++) {\n      String filename = filenames[i];\n      File file = new File(dir, filename);\n      boolean isDir = file.isDirectory();\n      String path = pathPrefix + file.getName(); // NOSONAR\n      if (isDir) {\n        path += PATH_SEPARATOR; // NOSONAR\n      }\n\n      // Create a ZIP entry\n      String name = mapper.map(path);\n      if (name != null) {\n        ZipEntry zipEntry = ZipEntryUtil.fromFile(name, file);\n\n        out.putNextEntry(zipEntry);\n\n        // Copy the file content\n        if (!isDir) {\n          FileUtils.copy(file, out);\n        }\n\n        out.closeEntry();\n      }\n\n      // Traverse the directory\n      if (isDir) {\n        pack(file, out, mapper, path, false);\n      }\n    }\n  }\n\n  /**\n   * Repacks a provided ZIP file into a new ZIP with a given compression level.\n   * <p>\n   *\n   * @param srcZip\n   *          source ZIP file.\n   * @param dstZip\n   *          destination ZIP file.\n   * @param compressionLevel\n   *          compression level.\n   */\n  public static void repack(File srcZip, File dstZip, int compressionLevel) {\n\n    log.debug(\"Repacking '{}' into '{}'.\", srcZip, dstZip);\n\n    RepackZipEntryCallback callback = new RepackZipEntryCallback(dstZip, compressionLevel);\n\n    try {\n      iterate(srcZip, callback);\n    }\n    finally {\n      callback.closeStream();\n    }\n  }\n\n  /**\n   * Repacks a provided ZIP input stream into a ZIP file with a given compression level.\n   * <p>\n   *\n   * @param is\n   *          ZIP input stream.\n   * @param dstZip\n   *          destination ZIP file.\n   * @param compressionLevel\n   *          compression level.\n   */\n  public static void repack(InputStream is, File dstZip, int compressionLevel) {\n\n    log.debug(\"Repacking from input stream into '{}'.\", dstZip);\n\n    RepackZipEntryCallback callback = new RepackZipEntryCallback(dstZip, compressionLevel);\n\n    try {\n      iterate(is, callback);\n    }\n    finally {\n      callback.closeStream();\n    }\n  }\n\n  /**\n   * Repacks a provided ZIP file and replaces old file with the new one.\n   * <p>\n   *\n   * @param zip\n   *          source ZIP file to be repacked and replaced.\n   * @param compressionLevel\n   *          compression level.\n   */\n  public static void repack(File zip, int compressionLevel) {\n    try {\n      File tmpZip = FileUtils.getTempFileFor(zip);\n\n      repack(zip, tmpZip, compressionLevel);\n\n      // Delete original zip\n      if (!zip.delete()) {\n        throw new IOException(\"Unable to delete the file: \" + zip);\n      }\n\n      // Rename the archive\n      FileUtils.moveFile(tmpZip, zip);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * RepackZipEntryCallback used in repacking methods.\n   *\n   * @author Pavel Grigorenko\n   */\n  private static final class RepackZipEntryCallback implements ZipEntryCallback {\n\n    private ZipOutputStream out;\n\n    private RepackZipEntryCallback(File dstZip, int compressionLevel) {\n      try {\n        this.out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(dstZip)));\n        this.out.setLevel(compressionLevel);\n      }\n      catch (IOException e) {\n        ZipExceptionUtil.rethrow(e);\n      }\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      ZipEntryUtil.copyEntry(zipEntry, in, out);\n    }\n\n    private void closeStream() {\n      IOUtils.closeQuietly(out);\n    }\n  }\n\n  /**\n   * Compresses a given directory in its own location.\n   * <p>\n   * A ZIP file will be first created with a temporary name. After the\n   * compressing the directory will be deleted and the ZIP file will be renamed\n   * as the original directory.\n   *\n   * @param dir\n   *          input directory as well as the target ZIP file.\n   *\n   * @see #pack(File, File)\n   */\n  public static void unexplode(File dir) {\n    unexplode(dir, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses a given directory in its own location.\n   * <p>\n   * A ZIP file will be first created with a temporary name. After the\n   * compressing the directory will be deleted and the ZIP file will be renamed\n   * as the original directory.\n   *\n   * @param dir\n   *          input directory as well as the target ZIP file.\n   * @param compressionLevel\n   *          compression level\n   *\n   * @see #pack(File, File)\n   */\n  public static void unexplode(File dir, int compressionLevel) {\n    try {\n      // Find a new unique name is the same directory\n      File zip = FileUtils.getTempFileFor(dir);\n\n      // Pack it\n      pack(dir, zip, compressionLevel);\n\n      // Delete the directory\n      FileUtils.deleteDirectory(dir);\n\n      // Rename the archive\n      FileUtils.moveFile(zip, dir);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Compresses the given entries into an output stream.\n   *\n   * @param entries\n   *          ZIP entries added.\n   * @param os\n   *          output stream for the new ZIP (does not have to be buffered)\n   *\n   * @since 1.9\n   */\n  public static void pack(ZipEntrySource[] entries, OutputStream os) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Creating stream from {}.\", Arrays.asList(entries));\n    }\n    pack(entries, os, false);\n  }\n\n  private static void pack(ZipEntrySource[] entries, OutputStream os, boolean closeStream) {\n    try {\n      ZipOutputStream out = new ZipOutputStream(os);\n      for (int i = 0; i < entries.length; i++) {\n        addEntry(entries[i], out);\n      }\n      out.flush();\n      out.finish();\n      if (closeStream) {\n        out.close();\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Compresses the given entries into a new ZIP file.\n   *\n   * @param entries\n   *          ZIP entries added.\n   * @param zip\n   *          new ZIP file created.\n   */\n  public static void pack(ZipEntrySource[] entries, File zip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Creating '{}' from {}.\", zip, Arrays.asList(entries));\n    }\n\n    OutputStream out = null;\n    try {\n      out = new BufferedOutputStream(new FileOutputStream(zip));\n      pack(entries, out, true);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(out);\n    }\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with one new entry.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param file\n   *          new entry to be added.\n   * @param destZip\n   *          new ZIP file created.\n   */\n  public static void addEntry(File zip, String path, File file, File destZip) {\n    addEntry(zip, new FileSource(path, file), destZip);\n  }\n\n  /**\n   * Changes a zip file, adds one new entry in-place.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param file\n   *          new entry to be added.\n   */\n  public static void addEntry(final File zip, final String path, final File file) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntry(zip, path, file, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with one new entry.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @param destZip\n   *          new ZIP file created.\n   */\n  public static void addEntry(File zip, String path, byte[] bytes, File destZip) {\n    addEntry(zip, new ByteSource(path, bytes), destZip);\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with one new entry.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @param destZip\n   *          new ZIP file created.\n   * @param compressionMethod\n   *          the new compression method (<code>ZipEntry.STORED</code> or <code>ZipEntry.DEFLATED</code>).\n   */\n  public static void addEntry(File zip, String path, byte[] bytes, File destZip, final int compressionMethod) {\n    addEntry(zip, new ByteSource(path, bytes, compressionMethod), destZip);\n  }\n\n  /**\n   * Changes a zip file, adds one new entry in-place.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   */\n  public static void addEntry(final File zip, final String path, final byte[] bytes) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntry(zip, path, bytes, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Changes a zip file, adds one new entry in-place.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @param compressionMethod\n   *          the new compression method (<code>ZipEntry.STORED</code> or <code>ZipEntry.DEFLATED</code>).\n   */\n  public static void addEntry(final File zip, final String path, final byte[] bytes, final int compressionMethod) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntry(zip, path, bytes, tmpFile, compressionMethod);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with one new entry.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entry\n   *          new ZIP entry appended.\n   * @param destZip\n   *          new ZIP file created.\n   */\n  public static void addEntry(File zip, ZipEntrySource entry, File destZip) {\n    addEntries(zip, new ZipEntrySource[] { entry }, destZip);\n  }\n\n  /**\n   * Changes a zip file, adds one new entry in-place.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entry\n   *          new ZIP entry appended.\n   */\n  public static void addEntry(final File zip, final ZipEntrySource entry) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntry(zip, entry, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with new entries.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          new ZIP entries appended.\n   * @param destZip\n   *          new ZIP file created.\n   */\n  public static void addEntries(File zip, ZipEntrySource[] entries, File destZip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and adding \" + Arrays.asList(entries) + \".\");\n    }\n\n    OutputStream destOut = null;\n    try {\n      destOut = new BufferedOutputStream(new FileOutputStream(destZip));\n      addEntries(zip, entries, destOut);\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(destOut);\n    }\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with new entries.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          new ZIP entries appended.\n   * @param destOut\n   *          new ZIP destination output stream\n   */\n  public static void addEntries(File zip, ZipEntrySource[] entries, OutputStream destOut) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to a stream and adding \" + Arrays.asList(entries) + \".\");\n    }\n\n    ZipOutputStream out = null;\n    try {\n      out = new ZipOutputStream(destOut);\n      copyEntries(zip, out);\n      for (int i = 0; i < entries.length; i++) {\n        addEntry(entries[i], out);\n      }\n      out.finish();\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with new entries.\n   *\n   * @param is\n   *          an existing ZIP input stream.\n   * @param entries\n   *          new ZIP entries appended.\n   * @param destOut\n   *          new ZIP destination output stream\n   *\n   * @since 1.9\n   */\n  public static void addEntries(InputStream is, ZipEntrySource[] entries, OutputStream destOut) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying input stream to an output stream and adding \" + Arrays.asList(entries) + \".\");\n    }\n\n    ZipOutputStream out = null;\n    try {\n      out = new ZipOutputStream(destOut);\n      copyEntries(is, out);\n      for (int i = 0; i < entries.length; i++) {\n        addEntry(entries[i], out);\n      }\n      out.finish();\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Changes a zip file it with with new entries. in-place.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          new ZIP entries appended.\n   */\n  public static void addEntries(final File zip, final ZipEntrySource[] entries) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntries(zip, entries, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and removes entry with a given path.\n   *\n   * @param zip\n   *          an existing ZIP file (only read)\n   * @param path\n   *          path of the entry to remove\n   * @param destZip\n   *          new ZIP file created.\n   * @since 1.7\n   */\n  public static void removeEntry(File zip, String path, File destZip) {\n    removeEntries(zip, new String[] { path }, destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: removes entry with a given path.\n   *\n   * @param zip\n   *          an existing ZIP file\n   * @param path\n   *          path of the entry to remove\n   * @since 1.7\n   */\n  public static void removeEntry(final File zip, final String path) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        removeEntry(zip, path, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and removes entries with given paths.\n   *\n   * @param zip\n   *          an existing ZIP file (only read)\n   * @param paths\n   *          paths of the entries to remove\n   * @param destZip\n   *          new ZIP file created.\n   * @since 1.7\n   */\n  public static void removeEntries(File zip, String[] paths, File destZip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and removing paths \" + Arrays.asList(paths) + \".\");\n    }\n\n    ZipOutputStream out = null;\n    try {\n      out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(destZip)));\n      copyEntries(zip, out, new HashSet<String>(Arrays.asList(paths)));\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(out);\n    }\n  }\n\n  /**\n   * Changes an existing ZIP file: removes entries with given paths.\n   *\n   * @param zip\n   *          an existing ZIP file\n   * @param paths\n   *          paths of the entries to remove\n   * @since 1.7\n   */\n  public static void removeEntries(final File zip, final String[] paths) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        removeEntries(zip, paths, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies all entries from one ZIP file to another.\n   *\n   * @param zip\n   *          source ZIP file.\n   * @param out\n   *          target ZIP stream.\n   */\n  private static void copyEntries(File zip, final ZipOutputStream out) {\n    // this one doesn't call copyEntries with ignoredEntries, because that has poorer performance\n    final Set<String> names = new HashSet<String>();\n    iterate(zip, new ZipEntryCallback() {\n      public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n        String entryName = zipEntry.getName();\n        if (names.add(entryName)) {\n          ZipEntryUtil.copyEntry(zipEntry, in, out);\n        }\n        else if (log.isDebugEnabled()) {\n          log.debug(\"Duplicate entry: {}\", entryName);\n        }\n      }\n    });\n  }\n\n  /**\n   * Copies all entries from one ZIP stream to another.\n   *\n   * @param is\n   *          source stream (contains ZIP file).\n   * @param out\n   *          target ZIP stream.\n   */\n  private static void copyEntries(InputStream is, final ZipOutputStream out) {\n    // this one doesn't call copyEntries with ignoredEntries, because that has poorer performance\n    final Set<String> names = new HashSet<String>();\n    iterate(is, new ZipEntryCallback() {\n      public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n        String entryName = zipEntry.getName();\n        if (names.add(entryName)) {\n          ZipEntryUtil.copyEntry(zipEntry, in, out);\n        }\n        else if (log.isDebugEnabled()) {\n          log.debug(\"Duplicate entry: {}\", entryName);\n        }\n      }\n    });\n  }\n\n  /**\n   * Copies all entries from one ZIP file to another, ignoring entries with path in ignoredEntries\n   *\n   * @param zip\n   *          source ZIP file.\n   * @param out\n   *          target ZIP stream.\n   * @param ignoredEntries\n   *          paths of entries not to copy\n   */\n  private static void copyEntries(File zip, final ZipOutputStream out, final Set<String> ignoredEntries) {\n    final Set<String> names = new HashSet<String>();\n    final Set<String> dirNames = filterDirEntries(zip, ignoredEntries);\n    iterate(zip, new ZipEntryCallback() {\n      public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n        String entryName = zipEntry.getName();\n        if (ignoredEntries.contains(entryName)) {\n          return;\n        }\n\n        for (String dirName : dirNames) {\n          if (entryName.startsWith(dirName)) {\n            return;\n          }\n        }\n\n        if (names.add(entryName)) {\n          ZipEntryUtil.copyEntry(zipEntry, in, out);\n        }\n        else if (log.isDebugEnabled()) {\n          log.debug(\"Duplicate entry: {}\", entryName);\n        }\n      }\n    });\n  }\n\n  /**\n   *\n   * @param zip\n   *          zip file to traverse\n   * @param names\n   *          names of entries to filter dirs from\n   * @return Set<String> names of entries that are dirs.\n   *\n   */\n  static Set<String> filterDirEntries(File zip, Collection<String> names) {\n    Set<String> dirs = new HashSet<String>();\n    if (zip == null) {\n      return dirs;\n    }\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      for (String entryName : names) {\n        ZipEntry entry = zf.getEntry(entryName);\n        if (entry != null) {\n          if (entry.isDirectory()) {\n            dirs.add(entry.getName());\n          }\n          else if (zf.getInputStream(entry) == null) {\n            // no input stream means that this is a dir.\n            dirs.add(entry.getName() + PATH_SEPARATOR);\n          }\n        }\n      }\n\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n    return dirs;\n  }\n\n  /**\n   * Copies an existing ZIP file and replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param file\n   *          new entry.\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(File zip, String path, File file, File destZip) {\n    return replaceEntry(zip, new FileSource(path, file), destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file.\n   * @param path\n   *          new ZIP entry path.\n   * @param file\n   *          new entry.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(final File zip, final String path, final File file) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntry(zip, new FileSource(path, file), tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(File zip, String path, byte[] bytes, File destZip) {\n    return replaceEntry(zip, new ByteSource(path, bytes), destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file.\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(final File zip, final String path, final byte[] bytes) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntry(zip, new ByteSource(path, bytes), tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Changes an existing ZIP file: replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file.\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @param compressionMethod\n   *          the new compression method (<code>ZipEntry.STORED</code> or <code>ZipEntry.DEFLATED</code>).\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(final File zip, final String path, final byte[] bytes,\n      final int compressionMethod) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntry(zip, new ByteSource(path, bytes, compressionMethod), tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entry\n   *          new ZIP entry.\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(File zip, ZipEntrySource entry, File destZip) {\n    return replaceEntries(zip, new ZipEntrySource[] { entry }, destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file.\n   * @param entry\n   *          new ZIP entry.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(final File zip, final ZipEntrySource entry) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntry(zip, entry, tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and replaces the given entries in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          new ZIP entries to be replaced with.\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if at least one entry was replaced.\n   */\n  public static boolean replaceEntries(File zip, ZipEntrySource[] entries, File destZip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and replacing entries \" + Arrays.asList(entries) + \".\");\n    }\n\n    final Map<String, ZipEntrySource> entryByPath = entriesByPath(entries);\n    final int entryCount = entryByPath.size();\n    try {\n      final ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(destZip)));\n      try {\n        final Set<String> names = new HashSet<String>();\n        iterate(zip, new ZipEntryCallback() {\n          public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n            if (names.add(zipEntry.getName())) {\n              ZipEntrySource entry = (ZipEntrySource) entryByPath.remove(zipEntry.getName());\n              if (entry != null) {\n                addEntry(entry, out);\n              }\n              else {\n                ZipEntryUtil.copyEntry(zipEntry, in, out);\n              }\n            }\n            else if (log.isDebugEnabled()) {\n              log.debug(\"Duplicate entry: {}\", zipEntry.getName());\n            }\n          }\n        });\n      }\n      finally {\n        IOUtils.closeQuietly(out);\n      }\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n    return entryByPath.size() < entryCount;\n  }\n\n  /**\n   * Changes an existing ZIP file: replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file.\n   * @param entries\n   *          new ZIP entries to be replaced with.\n   * @return <code>true</code> if at least one entry was replaced.\n   */\n  public static boolean replaceEntries(final File zip, final ZipEntrySource[] entries) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntries(zip, entries, tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and adds/replaces the given entries in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          ZIP entries to be replaced or added.\n   * @param destZip\n   *          new ZIP file created.\n   */\n  public static void addOrReplaceEntries(File zip, ZipEntrySource[] entries, File destZip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and adding/replacing entries \" + Arrays.asList(entries)\n          + \".\");\n    }\n\n    final Map<String, ZipEntrySource> entryByPath = entriesByPath(entries);\n    try {\n      final ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(destZip)));\n      try {\n        // Copy and replace entries\n        final Set<String> names = new HashSet<String>();\n        iterate(zip, new ZipEntryCallback() {\n          public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n            if (names.add(zipEntry.getName())) {\n              ZipEntrySource entry = (ZipEntrySource) entryByPath.remove(zipEntry.getName());\n              if (entry != null) {\n                addEntry(entry, out);\n              }\n              else {\n                ZipEntryUtil.copyEntry(zipEntry, in, out);\n              }\n            }\n            else if (log.isDebugEnabled()) {\n              log.debug(\"Duplicate entry: {}\", zipEntry.getName());\n            }\n          }\n        });\n\n        // Add new entries\n        for (ZipEntrySource zipEntrySource : entryByPath.values()) {\n          addEntry(zipEntrySource, out);\n        }\n      }\n      finally {\n        IOUtils.closeQuietly(out);\n      }\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Changes a ZIP file: adds/replaces the given entries in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          ZIP entries to be replaced or added.\n   */\n  public static void addOrReplaceEntries(final File zip, final ZipEntrySource[] entries) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addOrReplaceEntries(zip, entries, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * @return given entries indexed by path.\n   */\n  static Map<String, ZipEntrySource> entriesByPath(ZipEntrySource... entries) {\n    Map<String, ZipEntrySource> result = new HashMap<String, ZipEntrySource>();\n    for (int i = 0; i < entries.length; i++) {\n      ZipEntrySource source = entries[i];\n      result.put(source.getPath(), source);\n    }\n    return result;\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param transformer\n   *          transformer for the given ZIP entry.\n   * @param destZip\n   *          new ZIP file created.\n   * @throws IllegalArgumentException if the destination is the same as the location\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(File zip, String path, ZipEntryTransformer transformer, File destZip) {\n    if(zip.equals(destZip)){throw new IllegalArgumentException(\"Input (\" +zip.getAbsolutePath()+ \") is the same as the destination!\" +\n            \"Please use the transformEntry method without destination for in-place transformation.\" );}\n    return transformEntry(zip, new ZipEntryTransformerEntry(path, transformer), destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: transforms a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param transformer\n   *          transformer for the given ZIP entry.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(final File zip, final String path, final ZipEntryTransformer transformer) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return transformEntry(zip, path, transformer, tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entry\n   *          transformer for a ZIP entry.\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(File zip, ZipEntryTransformerEntry entry, File destZip) {\n    return transformEntries(zip, new ZipEntryTransformerEntry[] { entry }, destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: transforms a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entry\n   *          transformer for a ZIP entry.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(final File zip, final ZipEntryTransformerEntry entry) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return transformEntry(zip, entry, tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms the given entries in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          ZIP entry transformers.\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if at least one entry was replaced.\n   */\n  public static boolean transformEntries(File zip, ZipEntryTransformerEntry[] entries, File destZip) {\n    if (log.isDebugEnabled())\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and transforming entries \" + Arrays.asList(entries) + \".\");\n\n    try {\n      ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(destZip)));\n      try {\n        TransformerZipEntryCallback action = new TransformerZipEntryCallback(Arrays.asList(entries), out);\n        iterate(zip, action);\n        return action.found();\n      }\n      finally {\n        IOUtils.closeQuietly(out);\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Changes an existing ZIP file: transforms a given entries in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          ZIP entry transformers.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntries(final File zip, final ZipEntryTransformerEntry[] entries) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return transformEntries(zip, entries, tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms a given entry in it.\n   *\n   * @param is\n   *          a ZIP input stream.\n   * @param path\n   *          new ZIP entry path.\n   * @param transformer\n   *          transformer for the given ZIP entry.\n   * @param os\n   *          a ZIP output stream.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(InputStream is, String path, ZipEntryTransformer transformer, OutputStream os) {\n    return transformEntry(is, new ZipEntryTransformerEntry(path, transformer), os);\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms a given entry in it.\n   *\n   * @param is\n   *          a ZIP input stream.\n   * @param entry\n   *          transformer for a ZIP entry.\n   * @param os\n   *          a ZIP output stream.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(InputStream is, ZipEntryTransformerEntry entry, OutputStream os) {\n    return transformEntries(is, new ZipEntryTransformerEntry[] { entry }, os);\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms the given entries in it.\n   *\n   * @param is\n   *          a ZIP input stream.\n   * @param entries\n   *          ZIP entry transformers.\n   * @param os\n   *          a ZIP output stream.\n   * @return <code>true</code> if at least one entry was replaced.\n   */\n  public static boolean transformEntries(InputStream is, ZipEntryTransformerEntry[] entries, OutputStream os) {\n    if (log.isDebugEnabled())\n      log.debug(\"Copying '\" + is + \"' to '\" + os + \"' and transforming entries \" + Arrays.asList(entries) + \".\");\n\n    try {\n      ZipOutputStream out = new ZipOutputStream(os);\n      TransformerZipEntryCallback action = new TransformerZipEntryCallback(Arrays.asList(entries), out);\n      iterate(is, action);\n      // Finishes writing the contents of the ZIP output stream without closing\n      // the underlying stream.\n      out.finish();\n      return action.found();\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  private static class TransformerZipEntryCallback implements ZipEntryCallback {\n\n    private final Map<String, ZipEntryTransformer> entryByPath;\n    private final int entryCount;\n    private final ZipOutputStream out;\n    private final Set<String> names = new HashSet<String>();\n\n    public TransformerZipEntryCallback(List<ZipEntryTransformerEntry> entries, ZipOutputStream out) {\n      entryByPath = transformersByPath(entries);\n      entryCount = entryByPath.size();\n      this.out = out;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      if (names.add(zipEntry.getName())) {\n        ZipEntryTransformer entry = (ZipEntryTransformer) entryByPath.remove(zipEntry.getName());\n        if (entry != null) {\n          entry.transform(in, zipEntry, out);\n        }\n        else {\n          ZipEntryUtil.copyEntry(zipEntry, in, out);\n        }\n      }\n      else if (log.isDebugEnabled()) {\n        log.debug(\"Duplicate entry: {}\", zipEntry.getName());\n      }\n    }\n\n    /**\n     * @return <code>true</code> if at least one entry was replaced.\n     */\n    public boolean found() {\n      return entryByPath.size() < entryCount;\n    }\n\n  }\n\n  /**\n   * @return transformers by path.\n   */\n  static Map<String, ZipEntryTransformer> transformersByPath(List<ZipEntryTransformerEntry> entries) {\n    Map<String, ZipEntryTransformer> result = new HashMap<String, ZipEntryTransformer>();\n    for (ZipEntryTransformerEntry entry : entries) {\n      result.put(entry.getPath(), entry.getTransformer());\n    }\n    return result;\n  }\n\n  /**\n   * Adds a given ZIP entry to a ZIP file.\n   *\n   * @param entry\n   *          new ZIP entry.\n   * @param out\n   *          target ZIP stream.\n   */\n  private static void addEntry(ZipEntrySource entry, ZipOutputStream out) throws IOException {\n    out.putNextEntry(entry.getEntry());\n    InputStream in = entry.getInputStream();\n    if (in != null) {\n      try {\n        IOUtils.copy(in, out);\n      }\n      finally {\n        IOUtils.closeQuietly(in);\n      }\n    }\n    out.closeEntry();\n  }\n\n  /* Comparing two ZIP files. */\n\n  /**\n   * Compares two ZIP files and returns <code>true</code> if they contain same\n   * entries.\n   * <p>\n   * First the two files are compared byte-by-byte. If a difference is found the\n   * corresponding entries of both ZIP files are compared. Thus if same contents\n   * is packed differently the two archives may still be the same.\n   * </p>\n   * <p>\n   * Two archives are considered the same if\n   * <ol>\n   * <li>they contain same number of entries,</li>\n   * <li>for each entry in the first archive there exists an entry with the same\n   * in the second archive</li>\n   * <li>for each entry in the first archive and the entry with the same name in\n   * the second archive\n   * <ol>\n   * <li>both are either directories or files,</li>\n   * <li>both have the same size,</li>\n   * <li>both have the same CRC,</li>\n   * <li>both have the same contents (compared byte-by-byte).</li>\n   * </ol>\n   * </li>\n   * </ol>\n   *\n   * @param f1\n   *          first ZIP file.\n   * @param f2\n   *          second ZIP file.\n   * @return <code>true</code> if the two ZIP files contain same entries,\n   *         <code>false</code> if a difference was found or an error occurred\n   *         during the comparison.\n   */\n  public static boolean archiveEquals(File f1, File f2) {\n    try {\n      // Check the files byte-by-byte\n      if (FileUtils.contentEquals(f1, f2)) {\n        return true;\n      }\n\n      log.debug(\"Comparing archives '{}' and '{}'...\", f1, f2);\n\n      long start = System.currentTimeMillis();\n      boolean result = archiveEqualsInternal(f1, f2);\n      long time = System.currentTimeMillis() - start;\n      if (time > 0) {\n        log.debug(\"Archives compared in \" + time + \" ms.\");\n      }\n      return result;\n    }\n    catch (Exception e) {\n      log.debug(\"Could not compare '\" + f1 + \"' and '\" + f2 + \"':\", e);\n      return false;\n    }\n  }\n\n  private static boolean archiveEqualsInternal(File f1, File f2) throws IOException {\n    ZipFile zf1 = null;\n    ZipFile zf2 = null;\n    try {\n      zf1 = new ZipFile(f1);\n      zf2 = new ZipFile(f2);\n\n      // Check the number of entries\n      if (zf1.size() != zf2.size()) {\n        log.debug(\"Number of entries changed (\" + zf1.size() + \" vs \" + zf2.size() + \").\");\n        return false;\n      }\n      /*\n       * As there are same number of entries in both archives we can traverse\n       * all entries of one of the archives and get the corresponding entries\n       * from the other archive.\n       *\n       * If a corresponding entry is missing from the second archive the\n       * archives are different and we finish the comparison.\n       *\n       * We guarantee that no entry of the second archive is skipped as there\n       * are same number of unique entries in both archives.\n       */\n      Enumeration<? extends ZipEntry> en = zf1.entries();\n      while (en.hasMoreElements()) {\n        ZipEntry e1 = (ZipEntry) en.nextElement();\n        String path = e1.getName();\n        ZipEntry e2 = zf2.getEntry(path);\n\n        // Check meta data\n        if (!metaDataEquals(path, e1, e2)) {\n          return false;\n        }\n\n        // Check the content\n        InputStream is1 = null;\n        InputStream is2 = null;\n        try {\n          is1 = zf1.getInputStream(e1);\n          is2 = zf2.getInputStream(e2);\n\n          if (!IOUtils.contentEquals(is1, is2)) {\n            log.debug(\"Entry '{}' content changed.\", path);\n            return false;\n          }\n        }\n        finally {\n          IOUtils.closeQuietly(is1);\n          IOUtils.closeQuietly(is2);\n        }\n      }\n    }\n    finally {\n      closeQuietly(zf1);\n      closeQuietly(zf2);\n    }\n\n    log.debug(\"Archives are the same.\");\n\n    return true;\n  }\n\n  /**\n   * Compares meta-data of two ZIP entries.\n   * <p>\n   * Two entries are considered the same if\n   * <ol>\n   * <li>both entries exist,</li>\n   * <li>both entries are either directories or files,</li>\n   * <li>both entries have the same size,</li>\n   * <li>both entries have the same CRC.</li>\n   * </ol>\n   *\n   * @param path\n   *          name of the entries.\n   * @param e1\n   *          first entry (required).\n   * @param e2\n   *          second entry (may be <code>null</code>).\n   * @return <code>true</code> if no difference was found.\n   */\n  private static boolean metaDataEquals(String path, ZipEntry e1, ZipEntry e2) throws IOException {\n    // Check if the same entry exists in the second archive\n    if (e2 == null) {\n      log.debug(\"Entry '{}' removed.\", path);\n      return false;\n    }\n\n    // Check the directory flag\n    if (e1.isDirectory()) {\n      if (e2.isDirectory()) {\n        return true; // Let's skip the directory as there is nothing to compare\n      }\n      else {\n        log.debug(\"Entry '{}' not a directory any more.\", path);\n        return false;\n      }\n    }\n    else if (e2.isDirectory()) {\n      log.debug(\"Entry '{}' now a directory.\", path);\n      return false;\n    }\n\n    // Check the size\n    long size1 = e1.getSize();\n    long size2 = e2.getSize();\n    if (size1 != -1 && size2 != -1 && size1 != size2) {\n      log.debug(\"Entry '\" + path + \"' size changed (\" + size1 + \" vs \" + size2 + \").\");\n      return false;\n    }\n\n    // Check the CRC\n    long crc1 = e1.getCrc();\n    long crc2 = e2.getCrc();\n    if (crc1 != -1 && crc2 != -1 && crc1 != crc2) {\n      log.debug(\"Entry '\" + path + \"' CRC changed (\" + crc1 + \" vs \" + crc2 + \").\");\n      return false;\n    }\n\n    // Check the time (ignored, logging only)\n    if (log.isTraceEnabled()) {\n      long time1 = e1.getTime();\n      long time2 = e2.getTime();\n      if (time1 != -1 && time2 != -1 && time1 != time2) {\n        log.trace(\"Entry '\" + path + \"' time changed (\" + new Date(time1) + \" vs \" + new Date(time2) + \").\");\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Compares same entry in two ZIP files (byte-by-byte).\n   *\n   * @param f1\n   *          first ZIP file.\n   * @param f2\n   *          second ZIP file.\n   * @param path\n   *          name of the entry.\n   * @return <code>true</code> if the contents of the entry was same in both ZIP\n   *         files.\n   */\n  public static boolean entryEquals(File f1, File f2, String path) {\n    return entryEquals(f1, f2, path, path);\n  }\n\n  /**\n   * Compares two ZIP entries (byte-by-byte). .\n   *\n   * @param f1\n   *          first ZIP file.\n   * @param f2\n   *          second ZIP file.\n   * @param path1\n   *          name of the first entry.\n   * @param path2\n   *          name of the second entry.\n   * @return <code>true</code> if the contents of the entries were same.\n   */\n  public static boolean entryEquals(File f1, File f2, String path1, String path2) {\n    ZipFile zf1 = null;\n    ZipFile zf2 = null;\n\n    try {\n      zf1 = new ZipFile(f1);\n      zf2 = new ZipFile(f2);\n\n      return doEntryEquals(zf1, zf2, path1, path2);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf1);\n      closeQuietly(zf2);\n    }\n  }\n\n  /**\n   * Compares two ZIP entries (byte-by-byte). .\n   *\n   * @param zf1\n   *          first ZIP file.\n   * @param zf2\n   *          second ZIP file.\n   * @param path1\n   *          name of the first entry.\n   * @param path2\n   *          name of the second entry.\n   * @return <code>true</code> if the contents of the entries were same.\n   */\n  public static boolean entryEquals(ZipFile zf1, ZipFile zf2, String path1, String path2) {\n    try {\n      return doEntryEquals(zf1, zf2, path1, path2);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Compares two ZIP entries (byte-by-byte). .\n   *\n   * @param zf1\n   *          first ZIP file.\n   * @param zf2\n   *          second ZIP file.\n   * @param path1\n   *          name of the first entry.\n   * @param path2\n   *          name of the second entry.\n   * @return <code>true</code> if the contents of the entries were same.\n   */\n  private static boolean doEntryEquals(ZipFile zf1, ZipFile zf2, String path1, String path2) throws IOException {\n    InputStream is1 = null;\n    InputStream is2 = null;\n    try {\n      ZipEntry e1 = zf1.getEntry(path1);\n      ZipEntry e2 = zf2.getEntry(path2);\n\n      if (e1 == null && e2 == null) {\n        return true;\n      }\n\n      if (e1 == null || e2 == null) {\n        return false;\n      }\n\n      is1 = zf1.getInputStream(e1);\n      is2 = zf2.getInputStream(e2);\n      if (is1 == null && is2 == null) {\n        return true;\n      }\n      if (is1 == null || is2 == null) {\n        return false;\n      }\n\n      return IOUtils.contentEquals(is1, is2);\n    }\n    finally {\n      IOUtils.closeQuietly(is1);\n      IOUtils.closeQuietly(is2);\n    }\n  }\n\n  /**\n   * Closes the ZIP file while ignoring any errors.\n   *\n   * @param zf\n   *          ZIP file to be closed.\n   */\n  public static void closeQuietly(ZipFile zf) {\n    try {\n      if (zf != null) {\n        zf.close();\n      }\n    }\n    catch (IOException e) {\n    }\n  }\n\n  /**\n   * Simple helper to make inplace operation easier\n   *\n   * @author shelajev\n   */\n  private abstract static class InPlaceAction {\n\n    /**\n     * @return true if something has been changed during the action.\n     */\n    abstract boolean act(File tmpFile);\n  }\n\n  /**\n   *\n   * This method provides a general infrastructure for in-place operations.\n   * It creates temp file as a destination, then invokes the action on source and destination.\n   * Then it copies the result back into src file.\n   *\n   * @param src - source zip file we want to modify\n   * @param action - action which actually modifies the archives\n   *\n   * @return result of the action\n   */\n  private static boolean operateInPlace(File src, InPlaceAction action) {\n    File tmp = null;\n    try {\n      tmp = File.createTempFile(\"zt-zip-tmp\", \".zip\");\n      boolean result = action.act(tmp);\n      if (result) { // else nothing changes\n        FileUtils.forceDelete(src);\n        FileUtils.moveFile(tmp, src);\n      }\n      return result;\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      FileUtils.deleteQuietly(tmp);\n    }\n  }\n\n}\n",
        "human_patch_code": "/**\n *    Copyright (C) 2012 ZeroTurnaround LLC <support@zeroturnaround.com>\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\npackage org.zeroturnaround.zip;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.zip.Deflater;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipInputStream;\nimport java.util.zip.ZipOutputStream;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.zeroturnaround.zip.commons.FileUtils;\nimport org.zeroturnaround.zip.commons.FilenameUtils;\nimport org.zeroturnaround.zip.commons.IOUtils;\nimport org.zeroturnaround.zip.transform.ZipEntryTransformer;\nimport org.zeroturnaround.zip.transform.ZipEntryTransformerEntry;\n\n/**\n * ZIP file manipulation utilities.\n *\n * @author Rein Raudj\u00e4rv\n * @author Innokenty Shuvalov\n *\n * @see #containsEntry(File, String)\n * @see #unpackEntry(File, String)\n * @see #unpack(File, File)\n * @see #pack(File, File)\n */\npublic final class ZipUtil {\n\n  private static final String PATH_SEPARATOR = \"/\";\n\n  /** Default compression level */\n  public static final int DEFAULT_COMPRESSION_LEVEL = Deflater.DEFAULT_COMPRESSION;\n\n  // Use / instead of . to work around an issue with Maven Shade Plugin\n  private static final Logger log = LoggerFactory.getLogger(\"org/zeroturnaround/zip/ZipUtil\".replace('/', '.')); // NOSONAR\n\n  private ZipUtil() {\n  }\n\n  /* Extracting single entries from ZIP files. */\n\n  /**\n   * Checks if the ZIP file contains the given entry.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return <code>true</code> if the ZIP file contains the given entry.\n   */\n  public static boolean containsEntry(File zip, String name) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      return zf.getEntry(name) != null;\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Returns the compression method of a given entry of the ZIP file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return Returns <code>ZipEntry.STORED</code>, <code>ZipEntry.DEFLATED</code> or -1 if\n   *         the ZIP file does not contain the given entry.\n   * @deprecated The compression level cannot be retrieved. This method exists only to ensure backwards compatibility with ZipUtil version 1.9, which returned the compression\n   *             method, not the level.\n   */\n  @Deprecated\n  public static int getCompressionLevelOfEntry(File zip, String name) {\n    return getCompressionMethodOfEntry(zip, name);\n  }\n\n  /**\n   * Returns the compression method of a given entry of the ZIP file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return Returns <code>ZipEntry.STORED</code>, <code>ZipEntry.DEFLATED</code> or -1 if\n   *         the ZIP file does not contain the given entry.\n   */\n  public static int getCompressionMethodOfEntry(File zip, String name) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      ZipEntry zipEntry = zf.getEntry(name);\n      if (zipEntry == null) {\n        return -1;\n      }\n      return zipEntry.getMethod();\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Checks if the ZIP file contains any of the given entries.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param names\n   *          entry names.\n   * @return <code>true</code> if the ZIP file contains any of the given\n   *         entries.\n   */\n  public static boolean containsAnyEntry(File zip, String[] names) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      for (int i = 0; i < names.length; i++) {\n        if (zf.getEntry(names[i]) != null) {\n          return true;\n        }\n      }\n      return false;\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Unpacks a single entry from a ZIP file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return contents of the entry or <code>null</code> if it was not found.\n   */\n  public static byte[] unpackEntry(File zip, String name) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      return doUnpackEntry(zf, name);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Unpacks a single entry from a ZIP file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   *\n   * @param charset\n   *          charset to be used to process the zip\n   *\n   * @return contents of the entry or <code>null</code> if it was not found.\n   */\n  public static byte[] unpackEntry(File zip, String name, Charset charset) {\n    ZipFile zf = null;\n    try {\n      if (charset != null) {\n        zf = new ZipFile(zip, charset);\n      }\n      else {\n        zf = new ZipFile(zip);\n      }\n      return doUnpackEntry(zf, name);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Unpacks a single entry from a ZIP file.\n   *\n   * @param zf\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return contents of the entry or <code>null</code> if it was not found.\n   */\n  public static byte[] unpackEntry(ZipFile zf, String name) {\n    try {\n      return doUnpackEntry(zf, name);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Unpacks a single entry from a ZIP file.\n   *\n   * @param zf\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @return contents of the entry or <code>null</code> if it was not found.\n   */\n  private static byte[] doUnpackEntry(ZipFile zf, String name) throws IOException {\n    ZipEntry ze = zf.getEntry(name);\n    if (ze == null) {\n      return null; // entry not found\n    }\n\n    InputStream is = zf.getInputStream(ze);\n    try {\n      return IOUtils.toByteArray(is);\n    }\n    finally {\n      IOUtils.closeQuietly(is);\n    }\n  }\n\n  /**\n   * Unpacks a single entry from a ZIP stream.\n   *\n   * @param is\n   *          ZIP stream.\n   * @param name\n   *          entry name.\n   * @return contents of the entry or <code>null</code> if it was not found.\n   */\n  public static byte[] unpackEntry(InputStream is, String name) {\n    ByteArrayUnpacker action = new ByteArrayUnpacker();\n    if (!handle(is, name, action))\n      return null; // entry not found\n    return action.getBytes();\n  }\n\n  /**\n   * Copies an entry into a byte array.\n   *\n   * @author Rein Raudj\u00e4rv\n   */\n  private static class ByteArrayUnpacker implements ZipEntryCallback {\n\n    private byte[] bytes;\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      bytes = IOUtils.toByteArray(in);\n    }\n\n    public byte[] getBytes() {\n      return bytes;\n    }\n\n  }\n\n  /**\n   * Unpacks a single file from a ZIP archive to a file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @param file\n   *          target file to be created or overwritten.\n   * @return <code>true</code> if the entry was found and unpacked,\n   *         <code>false</code> if the entry was not found.\n   */\n  public static boolean unpackEntry(File zip, String name, File file) {\n    return unpackEntry(zip, name, file, null);\n  }\n\n  /**\n   * Unpacks a single file from a ZIP archive to a file.\n   *\n   * @param zip\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @param file\n   *          target file to be created or overwritten.\n   * @param charset\n   *          charset to be used processing the zip\n   *\n   * @return <code>true</code> if the entry was found and unpacked,\n   *         <code>false</code> if the entry was not found.\n   */\n  public static boolean unpackEntry(File zip, String name, File file, Charset charset) {\n    ZipFile zf = null;\n    try {\n      if (charset != null) {\n        zf = new ZipFile(zip, charset);\n      }\n      else {\n        zf = new ZipFile(zip);\n      }\n      return doUnpackEntry(zf, name, file);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Unpacks a single file from a ZIP archive to a file.\n   *\n   * @param zf\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @param file\n   *          target file to be created or overwritten.\n   * @return <code>true</code> if the entry was found and unpacked,\n   *         <code>false</code> if the entry was not found.\n   */\n  public static boolean unpackEntry(ZipFile zf, String name, File file) {\n    try {\n      return doUnpackEntry(zf, name, file);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Unpacks a single file from a ZIP archive to a file.\n   *\n   * @param zf\n   *          ZIP file.\n   * @param name\n   *          entry name.\n   * @param file\n   *          target file to be created or overwritten.\n   * @return <code>true</code> if the entry was found and unpacked,\n   *         <code>false</code> if the entry was not found.\n   */\n  private static boolean doUnpackEntry(ZipFile zf, String name, File file) throws IOException {\n    if (log.isTraceEnabled()) {\n      log.trace(\"Extracting '\" + zf.getName() + \"' entry '\" + name + \"' into '\" + file + \"'.\");\n    }\n\n    ZipEntry ze = zf.getEntry(name);\n    if (ze == null) {\n      return false; // entry not found\n    }\n\n    if (ze.isDirectory() || zf.getInputStream(ze) == null) {\n      if (file.isDirectory()) {\n        return true;\n      }\n      if (file.exists()) {\n        FileUtils.forceDelete(file);\n      }\n      return file.mkdirs();\n    }\n\n    InputStream in = new BufferedInputStream(zf.getInputStream(ze));\n    try {\n      FileUtils.copy(in, file);\n    }\n    finally {\n      IOUtils.closeQuietly(in);\n    }\n    return true;\n  }\n\n  /**\n   * Unpacks a single file from a ZIP stream to a file.\n   *\n   * @param is\n   *          ZIP stream.\n   * @param name\n   *          entry name.\n   * @param file\n   *          target file to be created or overwritten.\n   * @return <code>true</code> if the entry was found and unpacked,\n   *         <code>false</code> if the entry was not found.\n   * @throws java.io.IOException if file is not found or writing to it fails\n   */\n  public static boolean unpackEntry(InputStream is, String name, File file) throws IOException {\n    return handle(is, name, new FileUnpacker(file));\n  }\n\n  /**\n   * Copies an entry into a File.\n   *\n   * @author Rein Raudj\u00e4rv\n   */\n  private static class FileUnpacker implements ZipEntryCallback {\n\n    private final File file;\n\n    public FileUnpacker(File file) {\n      this.file = file;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      FileUtils.copy(in, file);\n    }\n\n  }\n\n  /* Traversing ZIP files */\n\n  /**\n   * Reads the given ZIP file and executes the given action for each entry.\n   * <p>\n   * For each entry the corresponding input stream is also passed to the action. If you want to stop the loop\n   * then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, ZipInfoCallback)\n   */\n  public static void iterate(File zip, ZipEntryCallback action) {\n    iterate(zip, action, null);\n  }\n\n  /**\n   * Reads the given ZIP file and executes the given action for each entry.\n   * <p>\n   * For each entry the corresponding input stream is also passed to the action. If you want to stop the loop\n   * then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @param charset\n   *          Charset used to processed the ZipFile with\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, ZipInfoCallback)\n   */\n  public static void iterate(File zip, ZipEntryCallback action, Charset charset) {\n    ZipFile zf = null;\n    try {\n      if (charset == null) {\n        zf = new ZipFile(zip);\n      }\n      else {\n        zf = new ZipFile(zip, charset);\n      }\n\n      Enumeration<? extends ZipEntry> en = zf.entries();\n      while (en.hasMoreElements()) {\n        ZipEntry e = (ZipEntry) en.nextElement();\n\n        InputStream is = zf.getInputStream(e);\n        try {\n          action.process(is, e);\n        }\n        catch (IOException ze) {\n          throw new ZipException(\"Failed to process zip entry '\" + e.getName() + \"' with action \" + action, ze);\n        }\n        catch (ZipBreakException ex) {\n          break;\n        }\n        finally {\n          IOUtils.closeQuietly(is);\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Reads the given ZIP file and executes the given action for each given entry.\n   * <p>\n   * For each given entry the corresponding input stream is also passed to the action. If you want to stop the loop then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param entryNames\n   *          names of entries to iterate\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, String[], ZipInfoCallback)\n   */\n  public static void iterate(File zip, String[] entryNames, ZipEntryCallback action) {\n    iterate(zip, entryNames, action, null);\n  }\n\n  /**\n   * Reads the given ZIP file and executes the given action for each given entry.\n   * <p>\n   * For each given entry the corresponding input stream is also passed to the action. If you want to stop the loop then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param entryNames\n   *          names of entries to iterate\n   * @param action\n   *          action to be called for each entry.\n   * @param charset\n   *          charset used to process the zip file\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, String[], ZipInfoCallback)\n   */\n  public static void iterate(File zip, String[] entryNames, ZipEntryCallback action, Charset charset) {\n    ZipFile zf = null;\n    try {\n      if (charset == null) {\n        zf = new ZipFile(zip);\n      }\n      else {\n        zf = new ZipFile(zip, charset);\n      }\n\n      for (int i = 0; i < entryNames.length; i++) {\n        ZipEntry e = zf.getEntry(entryNames[i]);\n        if (e == null) {\n          continue;\n        }\n        InputStream is = zf.getInputStream(e);\n        try {\n          action.process(is, e);\n        }\n        catch (IOException ze) {\n          throw new ZipException(\"Failed to process zip entry '\" + e.getName() + \" with action \" + action, ze);\n        }\n        catch (ZipBreakException ex) {\n          break;\n        }\n        finally {\n          IOUtils.closeQuietly(is);\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Scans the given ZIP file and executes the given action for each entry.\n   * <p>\n   * Only the meta-data without the actual data is read. If you want to stop the loop\n   * then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipInfoCallback\n   * @see #iterate(File, ZipEntryCallback)\n   */\n  public static void iterate(File zip, ZipInfoCallback action) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n\n      Enumeration<? extends ZipEntry> en = zf.entries();\n      while (en.hasMoreElements()) {\n        ZipEntry e = (ZipEntry) en.nextElement();\n        try {\n          action.process(e);\n        }\n        catch (IOException ze) {\n          throw new ZipException(\"Failed to process zip entry '\" + e.getName() + \" with action \" + action, ze);\n        }\n        catch (ZipBreakException ex) {\n          break;\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Scans the given ZIP file and executes the given action for each given entry.\n   * <p>\n   * Only the meta-data without the actual data is read. If you want to stop the loop then throw a ZipBreakException.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param entryNames\n   *          names of entries to iterate\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipInfoCallback\n   * @see #iterate(File, String[], ZipEntryCallback)\n   */\n  public static void iterate(File zip, String[] entryNames, ZipInfoCallback action) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n\n      for (int i = 0; i < entryNames.length; i++) {\n        ZipEntry e = zf.getEntry(entryNames[i]);\n        if (e == null) {\n          continue;\n        }\n        try {\n          action.process(e);\n        }\n        catch (IOException ze) {\n          throw new ZipException(\"Failed to process zip entry '\" + e.getName() + \" with action \" + action, ze);\n        }\n        catch (ZipBreakException ex) {\n          break;\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Reads the given ZIP stream and executes the given action for each entry.\n   * <p>\n   * For each entry the corresponding input stream is also passed to the action. If you want to stop the loop\n   * then throw a ZipBreakException.\n   *\n   * @param is\n   *          input ZIP stream (it will not be closed automatically).\n   * @param action\n   *          action to be called for each entry.\n   * @param charset\n   *          charset to process entries in\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, ZipEntryCallback)\n   */\n  public static void iterate(InputStream is, ZipEntryCallback action, Charset charset) {\n    try {\n      ZipInputStream in = null;\n      try {\n        in = newCloseShieldZipInputStream(is, charset);\n        ZipEntry entry;\n        while ((entry = in.getNextEntry()) != null) {\n          try {\n            action.process(in, entry);\n          }\n          catch (IOException ze) {\n            throw new ZipException(\"Failed to process zip entry '\" + entry.getName() + \" with action \" + action, ze);\n          }\n          catch (ZipBreakException ex) {\n            break;\n          }\n        }\n      }\n      finally {\n        if (in != null) {\n          in.close();\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * See {@link #iterate(InputStream, ZipEntryCallback, Charset)}. This method\n   * is a shorthand for a version where no Charset is specified.\n   *\n   * @param is\n   *          input ZIP stream (it will not be closed automatically).\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, ZipEntryCallback)\n   */\n  public static void iterate(InputStream is, ZipEntryCallback action) {\n    iterate(is, action, null);\n  }\n\n  /**\n   * Reads the given ZIP stream and executes the given action for each given entry.\n   * <p>\n   * For each given entry the corresponding input stream is also passed to the action. If you want to stop the loop then throw a ZipBreakException.\n   *\n   * @param is\n   *          input ZIP stream (it will not be closed automatically).\n   * @param entryNames\n   *          names of entries to iterate\n   * @param action\n   *          action to be called for each entry.\n   * @param charset\n   *          charset to process entries in\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, String[], ZipEntryCallback)\n   */\n  public static void iterate(InputStream is, String[] entryNames, ZipEntryCallback action, Charset charset) {\n    Set<String> namesSet = new HashSet<String>();\n    for (int i = 0; i < entryNames.length; i++) {\n      namesSet.add(entryNames[i]);\n    }\n    try {\n      ZipInputStream in = null;\n      try {\n        in = newCloseShieldZipInputStream(is, charset);\n        ZipEntry entry;\n        while ((entry = in.getNextEntry()) != null) {\n          if (!namesSet.contains(entry.getName())) {\n            // skip the unnecessary entry\n            continue;\n          }\n          try {\n            action.process(in, entry);\n          }\n          catch (IOException ze) {\n            throw new ZipException(\"Failed to process zip entry '\" + entry.getName() + \" with action \" + action, ze);\n          }\n          catch (ZipBreakException ex) {\n            break;\n          }\n        }\n      }\n      finally {\n        if (in != null) {\n          in.close();\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * See @link{ {@link #iterate(InputStream, ZipEntryCallback, Charset)}. It is a\n   * shorthand where no Charset is specified.\n   *\n   * @param is\n   *          input ZIP stream (it will not be closed automatically).\n   * @param entryNames\n   *          names of entries to iterate\n   * @param action\n   *          action to be called for each entry.\n   *\n   * @see ZipEntryCallback\n   * @see #iterate(File, String[], ZipEntryCallback)\n   */\n  public static void iterate(InputStream is, String[] entryNames, ZipEntryCallback action) {\n    iterate(is, entryNames, action, null);\n  }\n\n  /**\n   * Creates a new {@link ZipInputStream} based on the given {@link InputStream}. It will be buffered and close-shielded.\n   * Closing the result stream flushes the buffers and frees up resources of the {@link ZipInputStream}. However the source stream itself remains open.\n   */\n  private static ZipInputStream newCloseShieldZipInputStream(final InputStream is, Charset charset) {\n    InputStream in = new BufferedInputStream(new CloseShieldInputStream(is));\n    if (charset == null) {\n      return new ZipInputStream(in);\n    }\n    return ZipFileUtil.createZipInputStream(in, charset);\n  }\n\n  /**\n   * Reads the given ZIP file and executes the given action for a single entry.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param name\n   *          entry name.\n   * @param action\n   *          action to be called for this entry.\n   * @return <code>true</code> if the entry was found, <code>false</code> if the\n   *         entry was not found.\n   *\n   * @see ZipEntryCallback\n   */\n  public static boolean handle(File zip, String name, ZipEntryCallback action) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n\n      ZipEntry ze = zf.getEntry(name);\n      if (ze == null) {\n        return false; // entry not found\n      }\n\n      InputStream in = new BufferedInputStream(zf.getInputStream(ze));\n      try {\n        action.process(in, ze);\n      }\n      finally {\n        IOUtils.closeQuietly(in);\n      }\n      return true;\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  /**\n   * Reads the given ZIP stream and executes the given action for a single\n   * entry.\n   *\n   * @param is\n   *          input ZIP stream (it will not be closed automatically).\n   * @param name\n   *          entry name.\n   * @param action\n   *          action to be called for this entry.\n   * @return <code>true</code> if the entry was found, <code>false</code> if the\n   *         entry was not found.\n   *\n   * @see ZipEntryCallback\n   */\n  public static boolean handle(InputStream is, String name, ZipEntryCallback action) {\n    SingleZipEntryCallback helper = new SingleZipEntryCallback(name, action);\n    iterate(is, helper);\n    return helper.found();\n  }\n\n  /**\n   * ZipEntryCallback which is only applied to single entry.\n   *\n   * @author Rein Raudj\u00e4rv\n   */\n  private static class SingleZipEntryCallback implements ZipEntryCallback {\n\n    private final String name;\n\n    private final ZipEntryCallback action;\n\n    private boolean found;\n\n    public SingleZipEntryCallback(String name, ZipEntryCallback action) {\n      this.name = name;\n      this.action = action;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      if (name.equals(zipEntry.getName())) {\n        found = true;\n        action.process(in, zipEntry);\n      }\n    }\n\n    public boolean found() {\n      return found;\n    }\n\n  }\n\n  /* Extracting whole ZIP files. */\n\n  /**\n   * Unpacks a ZIP file to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   */\n  public static void unpack(File zip, final File outputDir) {\n    unpack(zip, outputDir, IdentityNameMapper.INSTANCE);\n  }\n\n  /**\n   * Unpacks a ZIP file to the given directory using a specific Charset\n   * for the input file.\n   *\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   *\n   * @param charset\n   *          charset used to unpack the zip file\n   */\n  public static void unpack(File zip, final File outputDir, Charset charset) {\n    unpack(zip, outputDir, IdentityNameMapper.INSTANCE, charset);\n  }\n\n  /**\n   * Unpacks a ZIP file to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param charset\n   *          charset used to process the zip file\n   */\n  public static void unpack(File zip, File outputDir, NameMapper mapper, Charset charset) {\n    log.debug(\"Extracting '{}' into '{}'.\", zip, outputDir);\n    iterate(zip, new Unpacker(outputDir, mapper), charset);\n  }\n\n  /**\n   * Unpacks a ZIP file to the given directory using a specific Charset\n   * for the input file.\n   *\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void unpack(File zip, File outputDir, NameMapper mapper) {\n    log.debug(\"Extracting '{}' into '{}'.\", zip, outputDir);\n    iterate(zip, new Unpacker(outputDir, mapper));\n  }\n\n  /**\n   * Unwraps a ZIP file to the given directory shaving of root dir.\n   * If there are multiple root dirs or entries in the root of zip,\n   * ZipException is thrown.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   */\n  public static void unwrap(File zip, final File outputDir) {\n    unwrap(zip, outputDir, IdentityNameMapper.INSTANCE);\n  }\n\n  /**\n   * Unwraps a ZIP file to the given directory shaving of root dir.\n   * If there are multiple root dirs or entries in the root of zip,\n   * ZipException is thrown.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param zip\n   *          input ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void unwrap(File zip, File outputDir, NameMapper mapper) {\n    log.debug(\"Unwrapping '{}' into '{}'.\", zip, outputDir);\n    iterate(zip, new Unwraper(outputDir, mapper));\n  }\n\n  /**\n   * Unpacks a ZIP stream to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   */\n  public static void unpack(InputStream is, File outputDir) {\n    unpack(is, outputDir, IdentityNameMapper.INSTANCE, null);\n  }\n\n  /**\n   * Unpacks a ZIP stream to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param charset\n   *          charset used to process the zip stream\n   */\n  public static void unpack(InputStream is, File outputDir, Charset charset) {\n    unpack(is, outputDir, IdentityNameMapper.INSTANCE, charset);\n  }\n\n  /**\n   * Unpacks a ZIP stream to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void unpack(InputStream is, File outputDir, NameMapper mapper) {\n    unpack(is, outputDir, mapper, null);\n  }\n\n  /**\n   * Unpacks a ZIP stream to the given directory.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param charset\n   *          charset to use when unpacking the stream\n   */\n  public static void unpack(InputStream is, File outputDir, NameMapper mapper, Charset charset) {\n    log.debug(\"Extracting {} into '{}'.\", is, outputDir);\n    iterate(is, new Unpacker(outputDir, mapper), charset);\n  }\n\n  /**\n   * Unwraps a ZIP file to the given directory shaving of root dir.\n   * If there are multiple root dirs or entries in the root of zip,\n   * ZipException is thrown.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   */\n  public static void unwrap(InputStream is, File outputDir) {\n    unwrap(is, outputDir, IdentityNameMapper.INSTANCE);\n  }\n\n  /**\n   * Unwraps a ZIP file to the given directory shaving of root dir.\n   * If there are multiple root dirs or entries in the root of zip,\n   * ZipException is thrown.\n   * <p>\n   * The output directory must not be a file.\n   *\n   * @param is\n   *          inputstream for ZIP file.\n   * @param outputDir\n   *          output directory (created automatically if not found).\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void unwrap(InputStream is, File outputDir, NameMapper mapper) {\n    log.debug(\"Unwrapping {} into '{}'.\", is, outputDir);\n    iterate(is, new Unwraper(outputDir, mapper));\n  }\n\n  /**\n   * Unpacks each ZIP entry.\n   *\n   * @author Rein Raudj\u00e4rv\n   */\n  private static class Unpacker implements ZipEntryCallback {\n\n    private final File outputDir;\n    private final NameMapper mapper;\n\n    public Unpacker(File outputDir, NameMapper mapper) {\n      this.outputDir = outputDir;\n      this.mapper = mapper;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      String name = mapper.map(zipEntry.getName());\n      if (name != null) {\n        File file = new File(outputDir, name);\n\n        /* If we see the relative traversal string of \"..\" we need to make sure\n         * that the outputdir + name doesn't leave the outputdir. See\n         * DirectoryTraversalMaliciousTest for details.\n         */\n        if (name.indexOf(\"..\") != -1 && !file.getCanonicalPath().startsWith(outputDir.getCanonicalPath())) {\n          throw new ZipException(\"The file \"+name+\" is trying to leave the target output directory of \"+outputDir+\". Ignoring this file.\");\n        }\n\n        if (zipEntry.isDirectory()) {\n          FileUtils.forceMkdir(file);\n        }\n        else {\n          FileUtils.forceMkdir(file.getParentFile());\n\n          if (log.isDebugEnabled() && file.exists()) {\n            log.debug(\"Overwriting file '{}'.\", zipEntry.getName());\n          }\n\n          FileUtils.copy(in, file);\n        }\n\n        ZTFilePermissions permissions = ZipEntryUtil.getZTFilePermissions(zipEntry);\n        if (permissions != null) {\n          ZTFilePermissionsUtil.getDefaultStategy().setPermissions(file, permissions);\n        }\n      }\n    }\n  }\n\n  /**\n   * Unpacks each ZIP entries. Presumes they are packed with the backslash separator.\n   * Some archives can have this problem if they are created with some software\n   * that is not following the ZIP specification.\n   *\n   * @since zt-zip 1.9\n   */\n  public static class BackslashUnpacker implements ZipEntryCallback {\n\n    private final File outputDir;\n    private final NameMapper mapper;\n\n    public BackslashUnpacker(File outputDir, NameMapper mapper) {\n      this.outputDir = outputDir;\n      this.mapper = mapper;\n    }\n\n    public BackslashUnpacker(File outputDir) {\n      this(outputDir, IdentityNameMapper.INSTANCE);\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      String name = mapper.map(zipEntry.getName());\n      if (name != null) {\n        /**\n         * We assume that EVERY backslash will denote a directory\n         * separator. Also such broken archives don't have entries that\n         * are just directories. Everything is a file. See the example\n         *\n         * Archive: backSlashTest.zip\n         * testing: testDirectory\\testfileInTestDirectory.txt OK\n         * testing: testDirectory\\testSubdirectory\\testFileInTestSubdirectory.txt OK\n         * No errors detected in compressed data of backSlashTest.zip.\n         */\n        if (name.indexOf('\\\\') != -1) {\n          File parentDirectory = outputDir;\n          String[] dirs = name.split(\"\\\\\\\\\");\n\n          // lets create all the directories and the last entry is the file as EVERY entry is a file\n          for (int i = 0; i < dirs.length - 1; i++) {\n            File file = new File(parentDirectory, dirs[i]);\n            if (!file.exists()) {\n              FileUtils.forceMkdir(file);\n            }\n            parentDirectory = file;\n          }\n          File destFile = new File(parentDirectory, dirs[dirs.length - 1]);\n\n          /* If we see the relative traversal string of \"..\" we need to make sure\n           * that the outputdir + name doesn't leave the outputdir. See\n           * DirectoryTraversalMaliciousTest for details.\n           */\n          if (name.indexOf(\"..\") != -1 && !destFile.getCanonicalPath().startsWith(outputDir.getCanonicalPath())) {\n            throw new ZipException(\"The file \"+name+\" is trying to leave the target output directory of \"+outputDir+\". Ignoring this file.\");\n          }\n\n          FileUtils.copy(in, destFile);\n        }\n        // it could be that there are just top level files that the unpacker is used for\n        else {\n          File destFile = new File(outputDir, name);\n\n          /* If we see the relative traversal string of \"..\" we need to make sure\n           * that the outputdir + name doesn't leave the outputdir. See\n           * DirectoryTraversalMaliciousTest for details.\n           */\n          if (name.indexOf(\"..\") != -1 && !destFile.getCanonicalPath().startsWith(outputDir.getCanonicalPath())) {\n            throw new ZipException(\"The file \"+name+\" is trying to leave the target output directory of \"+outputDir+\". Ignoring this file.\");\n          }\n\n          FileUtils.copy(in, destFile);\n        }\n      }\n    }\n  }\n\n  /**\n   * Unwraps entries excluding a single parent dir. If there are multiple roots\n   * ZipException is thrown.\n   *\n   * @author Oleg Shelajev\n   */\n  private static class Unwraper implements ZipEntryCallback {\n\n    private final File outputDir;\n    private final NameMapper mapper;\n    private String rootDir;\n\n    public Unwraper(File outputDir, NameMapper mapper) {\n      this.outputDir = outputDir;\n      this.mapper = mapper;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      String root = getRootName(zipEntry.getName());\n      if (rootDir == null) {\n        rootDir = root;\n      }\n      else if (!rootDir.equals(root)) {\n        throw new ZipException(\"Unwrapping with multiple roots is not supported, roots: \" + rootDir + \", \" + root);\n      }\n\n      String name = mapper.map(getUnrootedName(root, zipEntry.getName()));\n      if (name != null) {\n        File file = new File(outputDir, name);\n\n        /* If we see the relative traversal string of \"..\" we need to make sure\n         * that the outputdir + name doesn't leave the outputdir. See\n         * DirectoryTraversalMaliciousTest for details.\n         */\n        if (name.indexOf(\"..\") != -1 && !file.getCanonicalPath().startsWith(outputDir.getCanonicalPath())) {\n          throw new ZipException(\"The file \"+name+\" is trying to leave the target output directory of \"+outputDir+\". Ignoring this file.\");\n        }\n\n        if (zipEntry.isDirectory()) {\n          FileUtils.forceMkdir(file);\n        }\n        else {\n          FileUtils.forceMkdir(file.getParentFile());\n\n          if (log.isDebugEnabled() && file.exists()) {\n            log.debug(\"Overwriting file '{}'.\", zipEntry.getName());\n          }\n\n          FileUtils.copy(in, file);\n        }\n      }\n    }\n\n    private String getUnrootedName(String root, String name) {\n      return name.substring(root.length());\n    }\n\n    private String getRootName(final String name) {\n      String newName = name.substring(FilenameUtils.getPrefixLength(name));\n      int idx = newName.indexOf(PATH_SEPARATOR);\n      if (idx < 0) {\n        throw new ZipException(\"Entry \" + newName + \" from the root of the zip is not supported\");\n      }\n      return newName.substring(0, newName.indexOf(PATH_SEPARATOR));\n    }\n  }\n\n  /**\n   * Unpacks a ZIP file to its own location.\n   * <p>\n   * The ZIP file will be first renamed (using a temporary name). After the\n   * extraction it will be deleted.\n   *\n   * @param zip\n   *          input ZIP file as well as the target directory.\n   *\n   * @see #unpack(File, File)\n   */\n  public static void explode(File zip) {\n    try {\n      // Find a new unique name is the same directory\n      File tempFile = FileUtils.getTempFileFor(zip);\n\n      // Rename the archive\n      FileUtils.moveFile(zip, tempFile);\n\n      // Unpack it\n      unpack(tempFile, zip);\n\n      // Delete the archive\n      if (!tempFile.delete()) {\n        throw new IOException(\"Unable to delete file: \" + tempFile);\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /* Compressing single entries to ZIP files. */\n\n  /**\n   * Compresses the given file into a ZIP file with single entry.\n   *\n   * @param file file to be compressed.\n   * @return ZIP file created.\n   */\n  public static byte[] packEntry(File file) {\n    log.trace(\"Compressing '{}' into a ZIP file with single entry.\", file);\n\n    ByteArrayOutputStream result = new ByteArrayOutputStream();\n    try {\n      ZipOutputStream out = new ZipOutputStream(result);\n      ZipEntry entry = ZipEntryUtil.fromFile(file.getName(), file);\n      InputStream in = new BufferedInputStream(new FileInputStream(file));\n      try {\n        ZipEntryUtil.addEntry(entry, in, out);\n      }\n      finally {\n        IOUtils.closeQuietly(in);\n      }\n      out.close();\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    return result.toByteArray();\n  }\n\n  /* Compressing ZIP files. */\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   * Will not include the root directory name in the archive.\n   *\n   * @param rootDir\n   *          root directory.\n   * @param zip\n   *          ZIP file that will be created or overwritten.\n   */\n  public static void pack(File rootDir, File zip) {\n    pack(rootDir, zip, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   * Will not include the root directory name in the archive.\n   *\n   * @param rootDir\n   *          root directory.\n   * @param zip\n   *          ZIP file that will be created or overwritten.\n   * @param compressionLevel\n   *          compression level\n   */\n  public static void pack(File rootDir, File zip, int compressionLevel) {\n    pack(rootDir, zip, IdentityNameMapper.INSTANCE, compressionLevel);\n  }\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   * Will not include the root directory name in the archive.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param targetZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param preserveRoot\n   *          true if the resulted archive should have the top directory entry\n   */\n  public static void pack(final File sourceDir, final File targetZipFile, final boolean preserveRoot) {\n    if (preserveRoot) {\n      final String parentName = sourceDir.getName();\n      pack(sourceDir, targetZipFile, new NameMapper() {\n        public String map(String name) {\n          return parentName + PATH_SEPARATOR + name;\n        }\n      });\n    }\n    else {\n      pack(sourceDir, targetZipFile);\n    }\n  }\n\n  /**\n   * Compresses the given file into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param fileToPack\n   *          file that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   */\n  public static void packEntry(File fileToPack, File destZipFile) {\n    packEntry(fileToPack, destZipFile, IdentityNameMapper.INSTANCE);\n  }\n\n  /**\n   * Compresses the given file into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param fileToPack\n   *          file that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param fileName\n   *          the name for the file inside the archive\n   */\n  public static void packEntry(File fileToPack, File destZipFile, final String fileName) {\n    packEntry(fileToPack, destZipFile, new NameMapper() {\n      public String map(String name) {\n        return fileName;\n      }\n    });\n  }\n\n  /**\n   * Compresses the given file into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param fileToPack\n   *          file that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void packEntry(File fileToPack, File destZipFile, NameMapper mapper) {\n    packEntries(new File[] { fileToPack }, destZipFile, mapper);\n  }\n\n  /**\n   * Compresses the given files into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param filesToPack\n   *          files that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   */\n  public static void packEntries(File[] filesToPack, File destZipFile) {\n    packEntries(filesToPack, destZipFile, IdentityNameMapper.INSTANCE);\n  }\n\n  /**\n   * Compresses the given files into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param filesToPack\n   *          files that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void packEntries(File[] filesToPack, File destZipFile, NameMapper mapper) {\n    packEntries(filesToPack, destZipFile, mapper, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses the given files into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param filesToPack\n   *          files that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param compressionLevel\n   *          ZIP file compression level (speed versus filesize), e.g. <code>Deflater.NO_COMPRESSION</code>, <code>Deflater.BEST_SPEED</code>, or\n   *          <code>Deflater.BEST_COMPRESSION</code>\n   */\n  public static void packEntries(File[] filesToPack, File destZipFile, int compressionLevel) {\n    packEntries(filesToPack, destZipFile, IdentityNameMapper.INSTANCE, compressionLevel);\n  }\n\n  /**\n   * Compresses the given files into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param filesToPack\n   *          files that needs to be zipped.\n   * @param destZipFile\n   *          ZIP file that will be created or overwritten.\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param compressionLevel\n   *          ZIP file compression level (speed versus filesize), e.g. <code>Deflater.NO_COMPRESSION</code>, <code>Deflater.BEST_SPEED</code>, or\n   *          <code>Deflater.BEST_COMPRESSION</code>\n   */\n  public static void packEntries(File[] filesToPack, File destZipFile, NameMapper mapper, int compressionLevel) {\n    log.debug(\"Compressing '{}' into '{}'.\", filesToPack, destZipFile);\n\n    ZipOutputStream out = null;\n    FileOutputStream fos = null;\n    try {\n      fos = new FileOutputStream(destZipFile);\n      out = new ZipOutputStream(new BufferedOutputStream(fos));\n      out.setLevel(compressionLevel);\n\n      for (int i = 0; i < filesToPack.length; i++) {\n        File fileToPack = filesToPack[i];\n\n        ZipEntry zipEntry = ZipEntryUtil.fromFile(mapper.map(fileToPack.getName()), fileToPack);\n        out.putNextEntry(zipEntry);\n        FileUtils.copy(fileToPack, out);\n        out.closeEntry();\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(out);\n      IOUtils.closeQuietly(fos);\n    }\n  }\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param targetZip\n   *          ZIP file that will be created or overwritten.\n   * @param mapper\n   *          call-back for renaming the entries.\n   */\n  public static void pack(File sourceDir, File targetZip, NameMapper mapper) {\n    pack(sourceDir, targetZip, mapper, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   * <p>\n   * The ZIP file must not be a directory and its parent directory must exist.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param targetZip\n   *          ZIP file that will be created or overwritten.\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param compressionLevel\n   *          compression level\n   */\n  public static void pack(File sourceDir, File targetZip, NameMapper mapper, int compressionLevel) {\n    log.debug(\"Compressing '{}' into '{}'.\", sourceDir, targetZip);\n    if (!sourceDir.exists()) {\n      throw new ZipException(\"Given file '\" + sourceDir + \"' doesn't exist!\");\n    }\n    ZipOutputStream out = null;\n    try {\n      out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(targetZip)));\n      out.setLevel(compressionLevel);\n      pack(sourceDir, out, mapper, \"\", true);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(out);\n    }\n  }\n\n  /**\n   * Compresses the given directory and all of its sub-directories into the passed in\n   * stream. It is the responsibility of the caller to close the passed in\n   * stream properly.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param os\n   *          output stream (will be buffered in this method).\n   *\n   * @since 1.10\n   */\n  public static void pack(File sourceDir, OutputStream os) {\n    pack(sourceDir, os, IdentityNameMapper.INSTANCE, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses the given directory and all of its sub-directories into the passed in\n   * stream. It is the responsibility of the caller to close the passed in\n   * stream properly.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param os\n   *          output stream (will be buffered in this method).\n   * @param compressionLevel\n   *          compression level\n   *\n   * @since 1.10\n   */\n  public static void pack(File sourceDir, OutputStream os, int compressionLevel) {\n    pack(sourceDir, os, IdentityNameMapper.INSTANCE, compressionLevel);\n  }\n\n  /**\n   * Compresses the given directory and all of its sub-directories into the passed in\n   * stream. It is the responsibility of the caller to close the passed in\n   * stream properly.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param os\n   *          output stream (will be buffered in this method).\n   * @param mapper\n   *          call-back for renaming the entries.\n   *\n   * @since 1.10\n   */\n  public static void pack(File sourceDir, OutputStream os, NameMapper mapper) {\n    pack(sourceDir, os, mapper, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses the given directory and all of its sub-directories into the passed in\n   * stream. It is the responsibility of the caller to close the passed in\n   * stream properly.\n   *\n   * @param sourceDir\n   *          root directory.\n   * @param os\n   *          output stream (will be buffered in this method).\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param compressionLevel\n   *          compression level\n   *\n   * @since 1.10\n   */\n  public static void pack(File sourceDir, OutputStream os, NameMapper mapper, int compressionLevel) {\n    log.debug(\"Compressing '{}' into a stream.\", sourceDir);\n    if (!sourceDir.exists()) {\n      throw new ZipException(\"Given file '\" + sourceDir + \"' doesn't exist!\");\n    }\n    ZipOutputStream out = null;\n    IOException error = null;\n    try {\n      out = new ZipOutputStream(new BufferedOutputStream(os));\n      out.setLevel(compressionLevel);\n      pack(sourceDir, out, mapper, \"\", true);\n    }\n    catch (IOException e) {\n      error = e;\n    }\n    finally {\n      if (out != null && error == null) {\n        try {\n          out.finish();\n          out.flush();\n        }\n        catch (IOException e) {\n          error = e;\n        }\n      }\n    }\n    if (error != null) {\n      throw ZipExceptionUtil.rethrow(error);\n    }\n  }\n\n  /**\n   * Compresses the given directory and all its sub-directories into a ZIP file.\n   *\n   * @param dir\n   *          root directory.\n   * @param out\n   *          ZIP output stream.\n   * @param mapper\n   *          call-back for renaming the entries.\n   * @param pathPrefix\n   *          prefix to be used for the entries.\n   * @param mustHaveChildren\n   *          if true, but directory to pack doesn't have any files, throw an exception.\n   */\n  private static void pack(File dir, ZipOutputStream out, NameMapper mapper, String pathPrefix, boolean mustHaveChildren) throws IOException {\n    String[] filenames = dir.list();\n    if (filenames == null) {\n      if (!dir.exists()) {\n        throw new ZipException(\"Given file '\" + dir + \"' doesn't exist!\");\n      }\n      throw new IOException(\"Given file is not a directory '\" + dir + \"'\");\n    }\n\n    if (mustHaveChildren && filenames.length == 0) {\n      throw new ZipException(\"Given directory '\" + dir + \"' doesn't contain any files!\");\n    }\n\n    for (int i = 0; i < filenames.length; i++) {\n      String filename = filenames[i];\n      File file = new File(dir, filename);\n      boolean isDir = file.isDirectory();\n      String path = pathPrefix + file.getName(); // NOSONAR\n      if (isDir) {\n        path += PATH_SEPARATOR; // NOSONAR\n      }\n\n      // Create a ZIP entry\n      String name = mapper.map(path);\n      if (name != null) {\n        ZipEntry zipEntry = ZipEntryUtil.fromFile(name, file);\n\n        out.putNextEntry(zipEntry);\n\n        // Copy the file content\n        if (!isDir) {\n          FileUtils.copy(file, out);\n        }\n\n        out.closeEntry();\n      }\n\n      // Traverse the directory\n      if (isDir) {\n        pack(file, out, mapper, path, false);\n      }\n    }\n  }\n\n  /**\n   * Repacks a provided ZIP file into a new ZIP with a given compression level.\n   * <p>\n   *\n   * @param srcZip\n   *          source ZIP file.\n   * @param dstZip\n   *          destination ZIP file.\n   * @param compressionLevel\n   *          compression level.\n   */\n  public static void repack(File srcZip, File dstZip, int compressionLevel) {\n\n    log.debug(\"Repacking '{}' into '{}'.\", srcZip, dstZip);\n\n    RepackZipEntryCallback callback = new RepackZipEntryCallback(dstZip, compressionLevel);\n\n    try {\n      iterate(srcZip, callback);\n    }\n    finally {\n      callback.closeStream();\n    }\n  }\n\n  /**\n   * Repacks a provided ZIP input stream into a ZIP file with a given compression level.\n   * <p>\n   *\n   * @param is\n   *          ZIP input stream.\n   * @param dstZip\n   *          destination ZIP file.\n   * @param compressionLevel\n   *          compression level.\n   */\n  public static void repack(InputStream is, File dstZip, int compressionLevel) {\n\n    log.debug(\"Repacking from input stream into '{}'.\", dstZip);\n\n    RepackZipEntryCallback callback = new RepackZipEntryCallback(dstZip, compressionLevel);\n\n    try {\n      iterate(is, callback);\n    }\n    finally {\n      callback.closeStream();\n    }\n  }\n\n  /**\n   * Repacks a provided ZIP file and replaces old file with the new one.\n   * <p>\n   *\n   * @param zip\n   *          source ZIP file to be repacked and replaced.\n   * @param compressionLevel\n   *          compression level.\n   */\n  public static void repack(File zip, int compressionLevel) {\n    try {\n      File tmpZip = FileUtils.getTempFileFor(zip);\n\n      repack(zip, tmpZip, compressionLevel);\n\n      // Delete original zip\n      if (!zip.delete()) {\n        throw new IOException(\"Unable to delete the file: \" + zip);\n      }\n\n      // Rename the archive\n      FileUtils.moveFile(tmpZip, zip);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * RepackZipEntryCallback used in repacking methods.\n   *\n   * @author Pavel Grigorenko\n   */\n  private static final class RepackZipEntryCallback implements ZipEntryCallback {\n\n    private ZipOutputStream out;\n\n    private RepackZipEntryCallback(File dstZip, int compressionLevel) {\n      try {\n        this.out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(dstZip)));\n        this.out.setLevel(compressionLevel);\n      }\n      catch (IOException e) {\n        ZipExceptionUtil.rethrow(e);\n      }\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      ZipEntryUtil.copyEntry(zipEntry, in, out);\n    }\n\n    private void closeStream() {\n      IOUtils.closeQuietly(out);\n    }\n  }\n\n  /**\n   * Compresses a given directory in its own location.\n   * <p>\n   * A ZIP file will be first created with a temporary name. After the\n   * compressing the directory will be deleted and the ZIP file will be renamed\n   * as the original directory.\n   *\n   * @param dir\n   *          input directory as well as the target ZIP file.\n   *\n   * @see #pack(File, File)\n   */\n  public static void unexplode(File dir) {\n    unexplode(dir, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  /**\n   * Compresses a given directory in its own location.\n   * <p>\n   * A ZIP file will be first created with a temporary name. After the\n   * compressing the directory will be deleted and the ZIP file will be renamed\n   * as the original directory.\n   *\n   * @param dir\n   *          input directory as well as the target ZIP file.\n   * @param compressionLevel\n   *          compression level\n   *\n   * @see #pack(File, File)\n   */\n  public static void unexplode(File dir, int compressionLevel) {\n    try {\n      // Find a new unique name is the same directory\n      File zip = FileUtils.getTempFileFor(dir);\n\n      // Pack it\n      pack(dir, zip, compressionLevel);\n\n      // Delete the directory\n      FileUtils.deleteDirectory(dir);\n\n      // Rename the archive\n      FileUtils.moveFile(zip, dir);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Compresses the given entries into an output stream.\n   *\n   * @param entries\n   *          ZIP entries added.\n   * @param os\n   *          output stream for the new ZIP (does not have to be buffered)\n   *\n   * @since 1.9\n   */\n  public static void pack(ZipEntrySource[] entries, OutputStream os) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Creating stream from {}.\", Arrays.asList(entries));\n    }\n    pack(entries, os, false);\n  }\n\n  private static void pack(ZipEntrySource[] entries, OutputStream os, boolean closeStream) {\n    try {\n      ZipOutputStream out = new ZipOutputStream(os);\n      for (int i = 0; i < entries.length; i++) {\n        addEntry(entries[i], out);\n      }\n      out.flush();\n      out.finish();\n      if (closeStream) {\n        out.close();\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Compresses the given entries into a new ZIP file.\n   *\n   * @param entries\n   *          ZIP entries added.\n   * @param zip\n   *          new ZIP file created.\n   */\n  public static void pack(ZipEntrySource[] entries, File zip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Creating '{}' from {}.\", zip, Arrays.asList(entries));\n    }\n\n    OutputStream out = null;\n    try {\n      out = new BufferedOutputStream(new FileOutputStream(zip));\n      pack(entries, out, true);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(out);\n    }\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with one new entry.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param file\n   *          new entry to be added.\n   * @param destZip\n   *          new ZIP file created.\n   */\n  public static void addEntry(File zip, String path, File file, File destZip) {\n    addEntry(zip, new FileSource(path, file), destZip);\n  }\n\n  /**\n   * Changes a zip file, adds one new entry in-place.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param file\n   *          new entry to be added.\n   */\n  public static void addEntry(final File zip, final String path, final File file) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntry(zip, path, file, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with one new entry.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @param destZip\n   *          new ZIP file created.\n   */\n  public static void addEntry(File zip, String path, byte[] bytes, File destZip) {\n    addEntry(zip, new ByteSource(path, bytes), destZip);\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with one new entry.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @param destZip\n   *          new ZIP file created.\n   * @param compressionMethod\n   *          the new compression method (<code>ZipEntry.STORED</code> or <code>ZipEntry.DEFLATED</code>).\n   */\n  public static void addEntry(File zip, String path, byte[] bytes, File destZip, final int compressionMethod) {\n    addEntry(zip, new ByteSource(path, bytes, compressionMethod), destZip);\n  }\n\n  /**\n   * Changes a zip file, adds one new entry in-place.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   */\n  public static void addEntry(final File zip, final String path, final byte[] bytes) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntry(zip, path, bytes, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Changes a zip file, adds one new entry in-place.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @param compressionMethod\n   *          the new compression method (<code>ZipEntry.STORED</code> or <code>ZipEntry.DEFLATED</code>).\n   */\n  public static void addEntry(final File zip, final String path, final byte[] bytes, final int compressionMethod) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntry(zip, path, bytes, tmpFile, compressionMethod);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with one new entry.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entry\n   *          new ZIP entry appended.\n   * @param destZip\n   *          new ZIP file created.\n   */\n  public static void addEntry(File zip, ZipEntrySource entry, File destZip) {\n    addEntries(zip, new ZipEntrySource[] { entry }, destZip);\n  }\n\n  /**\n   * Changes a zip file, adds one new entry in-place.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entry\n   *          new ZIP entry appended.\n   */\n  public static void addEntry(final File zip, final ZipEntrySource entry) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntry(zip, entry, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with new entries.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          new ZIP entries appended.\n   * @param destZip\n   *          new ZIP file created.\n   */\n  public static void addEntries(File zip, ZipEntrySource[] entries, File destZip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and adding \" + Arrays.asList(entries) + \".\");\n    }\n\n    OutputStream destOut = null;\n    try {\n      destOut = new BufferedOutputStream(new FileOutputStream(destZip));\n      addEntries(zip, entries, destOut);\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(destOut);\n    }\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with new entries.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          new ZIP entries appended.\n   * @param destOut\n   *          new ZIP destination output stream\n   */\n  public static void addEntries(File zip, ZipEntrySource[] entries, OutputStream destOut) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to a stream and adding \" + Arrays.asList(entries) + \".\");\n    }\n\n    ZipOutputStream out = null;\n    try {\n      out = new ZipOutputStream(destOut);\n      copyEntries(zip, out);\n      for (int i = 0; i < entries.length; i++) {\n        addEntry(entries[i], out);\n      }\n      out.finish();\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Copies an existing ZIP file and appends it with new entries.\n   *\n   * @param is\n   *          an existing ZIP input stream.\n   * @param entries\n   *          new ZIP entries appended.\n   * @param destOut\n   *          new ZIP destination output stream\n   *\n   * @since 1.9\n   */\n  public static void addEntries(InputStream is, ZipEntrySource[] entries, OutputStream destOut) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying input stream to an output stream and adding \" + Arrays.asList(entries) + \".\");\n    }\n\n    ZipOutputStream out = null;\n    try {\n      out = new ZipOutputStream(destOut);\n      copyEntries(is, out);\n      for (int i = 0; i < entries.length; i++) {\n        addEntry(entries[i], out);\n      }\n      out.finish();\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Changes a zip file it with with new entries. in-place.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          new ZIP entries appended.\n   */\n  public static void addEntries(final File zip, final ZipEntrySource[] entries) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntries(zip, entries, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and removes entry with a given path.\n   *\n   * @param zip\n   *          an existing ZIP file (only read)\n   * @param path\n   *          path of the entry to remove\n   * @param destZip\n   *          new ZIP file created.\n   * @since 1.7\n   */\n  public static void removeEntry(File zip, String path, File destZip) {\n    removeEntries(zip, new String[] { path }, destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: removes entry with a given path.\n   *\n   * @param zip\n   *          an existing ZIP file\n   * @param path\n   *          path of the entry to remove\n   * @since 1.7\n   */\n  public static void removeEntry(final File zip, final String path) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        removeEntry(zip, path, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and removes entries with given paths.\n   *\n   * @param zip\n   *          an existing ZIP file (only read)\n   * @param paths\n   *          paths of the entries to remove\n   * @param destZip\n   *          new ZIP file created.\n   * @since 1.7\n   */\n  public static void removeEntries(File zip, String[] paths, File destZip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and removing paths \" + Arrays.asList(paths) + \".\");\n    }\n\n    ZipOutputStream out = null;\n    try {\n      out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(destZip)));\n      copyEntries(zip, out, new HashSet<String>(Arrays.asList(paths)));\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(out);\n    }\n  }\n\n  /**\n   * Changes an existing ZIP file: removes entries with given paths.\n   *\n   * @param zip\n   *          an existing ZIP file\n   * @param paths\n   *          paths of the entries to remove\n   * @since 1.7\n   */\n  public static void removeEntries(final File zip, final String[] paths) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        removeEntries(zip, paths, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Copies all entries from one ZIP file to another.\n   *\n   * @param zip\n   *          source ZIP file.\n   * @param out\n   *          target ZIP stream.\n   */\n  private static void copyEntries(File zip, final ZipOutputStream out) {\n    // this one doesn't call copyEntries with ignoredEntries, because that has poorer performance\n    final Set<String> names = new HashSet<String>();\n    iterate(zip, new ZipEntryCallback() {\n      public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n        String entryName = zipEntry.getName();\n        if (names.add(entryName)) {\n          ZipEntryUtil.copyEntry(zipEntry, in, out);\n        }\n        else if (log.isDebugEnabled()) {\n          log.debug(\"Duplicate entry: {}\", entryName);\n        }\n      }\n    });\n  }\n\n  /**\n   * Copies all entries from one ZIP stream to another.\n   *\n   * @param is\n   *          source stream (contains ZIP file).\n   * @param out\n   *          target ZIP stream.\n   */\n  private static void copyEntries(InputStream is, final ZipOutputStream out) {\n    // this one doesn't call copyEntries with ignoredEntries, because that has poorer performance\n    final Set<String> names = new HashSet<String>();\n    iterate(is, new ZipEntryCallback() {\n      public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n        String entryName = zipEntry.getName();\n        if (names.add(entryName)) {\n          ZipEntryUtil.copyEntry(zipEntry, in, out);\n        }\n        else if (log.isDebugEnabled()) {\n          log.debug(\"Duplicate entry: {}\", entryName);\n        }\n      }\n    });\n  }\n\n  /**\n   * Copies all entries from one ZIP file to another, ignoring entries with path in ignoredEntries\n   *\n   * @param zip\n   *          source ZIP file.\n   * @param out\n   *          target ZIP stream.\n   * @param ignoredEntries\n   *          paths of entries not to copy\n   */\n  private static void copyEntries(File zip, final ZipOutputStream out, final Set<String> ignoredEntries) {\n    final Set<String> names = new HashSet<String>();\n    final Set<String> dirNames = filterDirEntries(zip, ignoredEntries);\n    iterate(zip, new ZipEntryCallback() {\n      public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n        String entryName = zipEntry.getName();\n        if (ignoredEntries.contains(entryName)) {\n          return;\n        }\n\n        for (String dirName : dirNames) {\n          if (entryName.startsWith(dirName)) {\n            return;\n          }\n        }\n\n        if (names.add(entryName)) {\n          ZipEntryUtil.copyEntry(zipEntry, in, out);\n        }\n        else if (log.isDebugEnabled()) {\n          log.debug(\"Duplicate entry: {}\", entryName);\n        }\n      }\n    });\n  }\n\n  /**\n   *\n   * @param zip\n   *          zip file to traverse\n   * @param names\n   *          names of entries to filter dirs from\n   * @return Set<String> names of entries that are dirs.\n   *\n   */\n  static Set<String> filterDirEntries(File zip, Collection<String> names) {\n    Set<String> dirs = new HashSet<String>();\n    if (zip == null) {\n      return dirs;\n    }\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      for (String entryName : names) {\n        ZipEntry entry = zf.getEntry(entryName);\n        if (entry != null) {\n          if (entry.isDirectory()) {\n            dirs.add(entry.getName());\n          }\n          else if (zf.getInputStream(entry) == null) {\n            // no input stream means that this is a dir.\n            dirs.add(entry.getName() + PATH_SEPARATOR);\n          }\n        }\n      }\n\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n    return dirs;\n  }\n\n  /**\n   * Copies an existing ZIP file and replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param file\n   *          new entry.\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(File zip, String path, File file, File destZip) {\n    return replaceEntry(zip, new FileSource(path, file), destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file.\n   * @param path\n   *          new ZIP entry path.\n   * @param file\n   *          new entry.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(final File zip, final String path, final File file) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntry(zip, new FileSource(path, file), tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(File zip, String path, byte[] bytes, File destZip) {\n    return replaceEntry(zip, new ByteSource(path, bytes), destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file.\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(final File zip, final String path, final byte[] bytes) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntry(zip, new ByteSource(path, bytes), tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Changes an existing ZIP file: replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file.\n   * @param path\n   *          new ZIP entry path.\n   * @param bytes\n   *          new entry bytes (or <code>null</code> if directory).\n   * @param compressionMethod\n   *          the new compression method (<code>ZipEntry.STORED</code> or <code>ZipEntry.DEFLATED</code>).\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(final File zip, final String path, final byte[] bytes,\n      final int compressionMethod) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntry(zip, new ByteSource(path, bytes, compressionMethod), tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entry\n   *          new ZIP entry.\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(File zip, ZipEntrySource entry, File destZip) {\n    return replaceEntries(zip, new ZipEntrySource[] { entry }, destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file.\n   * @param entry\n   *          new ZIP entry.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean replaceEntry(final File zip, final ZipEntrySource entry) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntry(zip, entry, tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and replaces the given entries in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          new ZIP entries to be replaced with.\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if at least one entry was replaced.\n   */\n  public static boolean replaceEntries(File zip, ZipEntrySource[] entries, File destZip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and replacing entries \" + Arrays.asList(entries) + \".\");\n    }\n\n    final Map<String, ZipEntrySource> entryByPath = entriesByPath(entries);\n    final int entryCount = entryByPath.size();\n    try {\n      final ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(destZip)));\n      try {\n        final Set<String> names = new HashSet<String>();\n        iterate(zip, new ZipEntryCallback() {\n          public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n            if (names.add(zipEntry.getName())) {\n              ZipEntrySource entry = (ZipEntrySource) entryByPath.remove(zipEntry.getName());\n              if (entry != null) {\n                addEntry(entry, out);\n              }\n              else {\n                ZipEntryUtil.copyEntry(zipEntry, in, out);\n              }\n            }\n            else if (log.isDebugEnabled()) {\n              log.debug(\"Duplicate entry: {}\", zipEntry.getName());\n            }\n          }\n        });\n      }\n      finally {\n        IOUtils.closeQuietly(out);\n      }\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n    return entryByPath.size() < entryCount;\n  }\n\n  /**\n   * Changes an existing ZIP file: replaces a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file.\n   * @param entries\n   *          new ZIP entries to be replaced with.\n   * @return <code>true</code> if at least one entry was replaced.\n   */\n  public static boolean replaceEntries(final File zip, final ZipEntrySource[] entries) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntries(zip, entries, tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and adds/replaces the given entries in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          ZIP entries to be replaced or added.\n   * @param destZip\n   *          new ZIP file created.\n   */\n  public static void addOrReplaceEntries(File zip, ZipEntrySource[] entries, File destZip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and adding/replacing entries \" + Arrays.asList(entries)\n          + \".\");\n    }\n\n    final Map<String, ZipEntrySource> entryByPath = entriesByPath(entries);\n    try {\n      final ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(destZip)));\n      try {\n        // Copy and replace entries\n        final Set<String> names = new HashSet<String>();\n        iterate(zip, new ZipEntryCallback() {\n          public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n            if (names.add(zipEntry.getName())) {\n              ZipEntrySource entry = (ZipEntrySource) entryByPath.remove(zipEntry.getName());\n              if (entry != null) {\n                addEntry(entry, out);\n              }\n              else {\n                ZipEntryUtil.copyEntry(zipEntry, in, out);\n              }\n            }\n            else if (log.isDebugEnabled()) {\n              log.debug(\"Duplicate entry: {}\", zipEntry.getName());\n            }\n          }\n        });\n\n        // Add new entries\n        for (ZipEntrySource zipEntrySource : entryByPath.values()) {\n          addEntry(zipEntrySource, out);\n        }\n      }\n      finally {\n        IOUtils.closeQuietly(out);\n      }\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Changes a ZIP file: adds/replaces the given entries in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          ZIP entries to be replaced or added.\n   */\n  public static void addOrReplaceEntries(final File zip, final ZipEntrySource[] entries) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addOrReplaceEntries(zip, entries, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * @return given entries indexed by path.\n   */\n  static Map<String, ZipEntrySource> entriesByPath(ZipEntrySource... entries) {\n    Map<String, ZipEntrySource> result = new HashMap<String, ZipEntrySource>();\n    for (int i = 0; i < entries.length; i++) {\n      ZipEntrySource source = entries[i];\n      result.put(source.getPath(), source);\n    }\n    return result;\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param transformer\n   *          transformer for the given ZIP entry.\n   * @param destZip\n   *          new ZIP file created.\n   * @throws IllegalArgumentException if the destination is the same as the location\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(File zip, String path, ZipEntryTransformer transformer, File destZip) {\n    if(zip.equals(destZip)){throw new IllegalArgumentException(\"Input (\" +zip.getAbsolutePath()+ \") is the same as the destination!\" +\n            \"Please use the transformEntry method without destination for in-place transformation.\" );}\n    return transformEntry(zip, new ZipEntryTransformerEntry(path, transformer), destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: transforms a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param path\n   *          new ZIP entry path.\n   * @param transformer\n   *          transformer for the given ZIP entry.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(final File zip, final String path, final ZipEntryTransformer transformer) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return transformEntry(zip, path, transformer, tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entry\n   *          transformer for a ZIP entry.\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(File zip, ZipEntryTransformerEntry entry, File destZip) {\n    return transformEntries(zip, new ZipEntryTransformerEntry[] { entry }, destZip);\n  }\n\n  /**\n   * Changes an existing ZIP file: transforms a given entry in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entry\n   *          transformer for a ZIP entry.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(final File zip, final ZipEntryTransformerEntry entry) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return transformEntry(zip, entry, tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms the given entries in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          ZIP entry transformers.\n   * @param destZip\n   *          new ZIP file created.\n   * @return <code>true</code> if at least one entry was replaced.\n   */\n  public static boolean transformEntries(File zip, ZipEntryTransformerEntry[] entries, File destZip) {\n    if (log.isDebugEnabled())\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and transforming entries \" + Arrays.asList(entries) + \".\");\n\n    try {\n      ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(destZip)));\n      try {\n        TransformerZipEntryCallback action = new TransformerZipEntryCallback(Arrays.asList(entries), out);\n        iterate(zip, action);\n        return action.found();\n      }\n      finally {\n        IOUtils.closeQuietly(out);\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Changes an existing ZIP file: transforms a given entries in it.\n   *\n   * @param zip\n   *          an existing ZIP file (only read).\n   * @param entries\n   *          ZIP entry transformers.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntries(final File zip, final ZipEntryTransformerEntry[] entries) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return transformEntries(zip, entries, tmpFile);\n      }\n    });\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms a given entry in it.\n   *\n   * @param is\n   *          a ZIP input stream.\n   * @param path\n   *          new ZIP entry path.\n   * @param transformer\n   *          transformer for the given ZIP entry.\n   * @param os\n   *          a ZIP output stream.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(InputStream is, String path, ZipEntryTransformer transformer, OutputStream os) {\n    return transformEntry(is, new ZipEntryTransformerEntry(path, transformer), os);\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms a given entry in it.\n   *\n   * @param is\n   *          a ZIP input stream.\n   * @param entry\n   *          transformer for a ZIP entry.\n   * @param os\n   *          a ZIP output stream.\n   * @return <code>true</code> if the entry was replaced.\n   */\n  public static boolean transformEntry(InputStream is, ZipEntryTransformerEntry entry, OutputStream os) {\n    return transformEntries(is, new ZipEntryTransformerEntry[] { entry }, os);\n  }\n\n  /**\n   * Copies an existing ZIP file and transforms the given entries in it.\n   *\n   * @param is\n   *          a ZIP input stream.\n   * @param entries\n   *          ZIP entry transformers.\n   * @param os\n   *          a ZIP output stream.\n   * @return <code>true</code> if at least one entry was replaced.\n   */\n  public static boolean transformEntries(InputStream is, ZipEntryTransformerEntry[] entries, OutputStream os) {\n    if (log.isDebugEnabled())\n      log.debug(\"Copying '\" + is + \"' to '\" + os + \"' and transforming entries \" + Arrays.asList(entries) + \".\");\n\n    try {\n      ZipOutputStream out = new ZipOutputStream(os);\n      TransformerZipEntryCallback action = new TransformerZipEntryCallback(Arrays.asList(entries), out);\n      iterate(is, action);\n      // Finishes writing the contents of the ZIP output stream without closing\n      // the underlying stream.\n      out.finish();\n      return action.found();\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  private static class TransformerZipEntryCallback implements ZipEntryCallback {\n\n    private final Map<String, ZipEntryTransformer> entryByPath;\n    private final int entryCount;\n    private final ZipOutputStream out;\n    private final Set<String> names = new HashSet<String>();\n\n    public TransformerZipEntryCallback(List<ZipEntryTransformerEntry> entries, ZipOutputStream out) {\n      entryByPath = transformersByPath(entries);\n      entryCount = entryByPath.size();\n      this.out = out;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      if (names.add(zipEntry.getName())) {\n        ZipEntryTransformer entry = (ZipEntryTransformer) entryByPath.remove(zipEntry.getName());\n        if (entry != null) {\n          entry.transform(in, zipEntry, out);\n        }\n        else {\n          ZipEntryUtil.copyEntry(zipEntry, in, out);\n        }\n      }\n      else if (log.isDebugEnabled()) {\n        log.debug(\"Duplicate entry: {}\", zipEntry.getName());\n      }\n    }\n\n    /**\n     * @return <code>true</code> if at least one entry was replaced.\n     */\n    public boolean found() {\n      return entryByPath.size() < entryCount;\n    }\n\n  }\n\n  /**\n   * @return transformers by path.\n   */\n  static Map<String, ZipEntryTransformer> transformersByPath(List<ZipEntryTransformerEntry> entries) {\n    Map<String, ZipEntryTransformer> result = new HashMap<String, ZipEntryTransformer>();\n    for (ZipEntryTransformerEntry entry : entries) {\n      result.put(entry.getPath(), entry.getTransformer());\n    }\n    return result;\n  }\n\n  /**\n   * Adds a given ZIP entry to a ZIP file.\n   *\n   * @param entry\n   *          new ZIP entry.\n   * @param out\n   *          target ZIP stream.\n   */\n  private static void addEntry(ZipEntrySource entry, ZipOutputStream out) throws IOException {\n    out.putNextEntry(entry.getEntry());\n    InputStream in = entry.getInputStream();\n    if (in != null) {\n      try {\n        IOUtils.copy(in, out);\n      }\n      finally {\n        IOUtils.closeQuietly(in);\n      }\n    }\n    out.closeEntry();\n  }\n\n  /* Comparing two ZIP files. */\n\n  /**\n   * Compares two ZIP files and returns <code>true</code> if they contain same\n   * entries.\n   * <p>\n   * First the two files are compared byte-by-byte. If a difference is found the\n   * corresponding entries of both ZIP files are compared. Thus if same contents\n   * is packed differently the two archives may still be the same.\n   * </p>\n   * <p>\n   * Two archives are considered the same if\n   * <ol>\n   * <li>they contain same number of entries,</li>\n   * <li>for each entry in the first archive there exists an entry with the same\n   * in the second archive</li>\n   * <li>for each entry in the first archive and the entry with the same name in\n   * the second archive\n   * <ol>\n   * <li>both are either directories or files,</li>\n   * <li>both have the same size,</li>\n   * <li>both have the same CRC,</li>\n   * <li>both have the same contents (compared byte-by-byte).</li>\n   * </ol>\n   * </li>\n   * </ol>\n   *\n   * @param f1\n   *          first ZIP file.\n   * @param f2\n   *          second ZIP file.\n   * @return <code>true</code> if the two ZIP files contain same entries,\n   *         <code>false</code> if a difference was found or an error occurred\n   *         during the comparison.\n   */\n  public static boolean archiveEquals(File f1, File f2) {\n    try {\n      // Check the files byte-by-byte\n      if (FileUtils.contentEquals(f1, f2)) {\n        return true;\n      }\n\n      log.debug(\"Comparing archives '{}' and '{}'...\", f1, f2);\n\n      long start = System.currentTimeMillis();\n      boolean result = archiveEqualsInternal(f1, f2);\n      long time = System.currentTimeMillis() - start;\n      if (time > 0) {\n        log.debug(\"Archives compared in \" + time + \" ms.\");\n      }\n      return result;\n    }\n    catch (Exception e) {\n      log.debug(\"Could not compare '\" + f1 + \"' and '\" + f2 + \"':\", e);\n      return false;\n    }\n  }\n\n  private static boolean archiveEqualsInternal(File f1, File f2) throws IOException {\n    ZipFile zf1 = null;\n    ZipFile zf2 = null;\n    try {\n      zf1 = new ZipFile(f1);\n      zf2 = new ZipFile(f2);\n\n      // Check the number of entries\n      if (zf1.size() != zf2.size()) {\n        log.debug(\"Number of entries changed (\" + zf1.size() + \" vs \" + zf2.size() + \").\");\n        return false;\n      }\n      /*\n       * As there are same number of entries in both archives we can traverse\n       * all entries of one of the archives and get the corresponding entries\n       * from the other archive.\n       *\n       * If a corresponding entry is missing from the second archive the\n       * archives are different and we finish the comparison.\n       *\n       * We guarantee that no entry of the second archive is skipped as there\n       * are same number of unique entries in both archives.\n       */\n      Enumeration<? extends ZipEntry> en = zf1.entries();\n      while (en.hasMoreElements()) {\n        ZipEntry e1 = (ZipEntry) en.nextElement();\n        String path = e1.getName();\n        ZipEntry e2 = zf2.getEntry(path);\n\n        // Check meta data\n        if (!metaDataEquals(path, e1, e2)) {\n          return false;\n        }\n\n        // Check the content\n        InputStream is1 = null;\n        InputStream is2 = null;\n        try {\n          is1 = zf1.getInputStream(e1);\n          is2 = zf2.getInputStream(e2);\n\n          if (!IOUtils.contentEquals(is1, is2)) {\n            log.debug(\"Entry '{}' content changed.\", path);\n            return false;\n          }\n        }\n        finally {\n          IOUtils.closeQuietly(is1);\n          IOUtils.closeQuietly(is2);\n        }\n      }\n    }\n    finally {\n      closeQuietly(zf1);\n      closeQuietly(zf2);\n    }\n\n    log.debug(\"Archives are the same.\");\n\n    return true;\n  }\n\n  /**\n   * Compares meta-data of two ZIP entries.\n   * <p>\n   * Two entries are considered the same if\n   * <ol>\n   * <li>both entries exist,</li>\n   * <li>both entries are either directories or files,</li>\n   * <li>both entries have the same size,</li>\n   * <li>both entries have the same CRC.</li>\n   * </ol>\n   *\n   * @param path\n   *          name of the entries.\n   * @param e1\n   *          first entry (required).\n   * @param e2\n   *          second entry (may be <code>null</code>).\n   * @return <code>true</code> if no difference was found.\n   */\n  private static boolean metaDataEquals(String path, ZipEntry e1, ZipEntry e2) throws IOException {\n    // Check if the same entry exists in the second archive\n    if (e2 == null) {\n      log.debug(\"Entry '{}' removed.\", path);\n      return false;\n    }\n\n    // Check the directory flag\n    if (e1.isDirectory()) {\n      if (e2.isDirectory()) {\n        return true; // Let's skip the directory as there is nothing to compare\n      }\n      else {\n        log.debug(\"Entry '{}' not a directory any more.\", path);\n        return false;\n      }\n    }\n    else if (e2.isDirectory()) {\n      log.debug(\"Entry '{}' now a directory.\", path);\n      return false;\n    }\n\n    // Check the size\n    long size1 = e1.getSize();\n    long size2 = e2.getSize();\n    if (size1 != -1 && size2 != -1 && size1 != size2) {\n      log.debug(\"Entry '\" + path + \"' size changed (\" + size1 + \" vs \" + size2 + \").\");\n      return false;\n    }\n\n    // Check the CRC\n    long crc1 = e1.getCrc();\n    long crc2 = e2.getCrc();\n    if (crc1 != -1 && crc2 != -1 && crc1 != crc2) {\n      log.debug(\"Entry '\" + path + \"' CRC changed (\" + crc1 + \" vs \" + crc2 + \").\");\n      return false;\n    }\n\n    // Check the time (ignored, logging only)\n    if (log.isTraceEnabled()) {\n      long time1 = e1.getTime();\n      long time2 = e2.getTime();\n      if (time1 != -1 && time2 != -1 && time1 != time2) {\n        log.trace(\"Entry '\" + path + \"' time changed (\" + new Date(time1) + \" vs \" + new Date(time2) + \").\");\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Compares same entry in two ZIP files (byte-by-byte).\n   *\n   * @param f1\n   *          first ZIP file.\n   * @param f2\n   *          second ZIP file.\n   * @param path\n   *          name of the entry.\n   * @return <code>true</code> if the contents of the entry was same in both ZIP\n   *         files.\n   */\n  public static boolean entryEquals(File f1, File f2, String path) {\n    return entryEquals(f1, f2, path, path);\n  }\n\n  /**\n   * Compares two ZIP entries (byte-by-byte). .\n   *\n   * @param f1\n   *          first ZIP file.\n   * @param f2\n   *          second ZIP file.\n   * @param path1\n   *          name of the first entry.\n   * @param path2\n   *          name of the second entry.\n   * @return <code>true</code> if the contents of the entries were same.\n   */\n  public static boolean entryEquals(File f1, File f2, String path1, String path2) {\n    ZipFile zf1 = null;\n    ZipFile zf2 = null;\n\n    try {\n      zf1 = new ZipFile(f1);\n      zf2 = new ZipFile(f2);\n\n      return doEntryEquals(zf1, zf2, path1, path2);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf1);\n      closeQuietly(zf2);\n    }\n  }\n\n  /**\n   * Compares two ZIP entries (byte-by-byte). .\n   *\n   * @param zf1\n   *          first ZIP file.\n   * @param zf2\n   *          second ZIP file.\n   * @param path1\n   *          name of the first entry.\n   * @param path2\n   *          name of the second entry.\n   * @return <code>true</code> if the contents of the entries were same.\n   */\n  public static boolean entryEquals(ZipFile zf1, ZipFile zf2, String path1, String path2) {\n    try {\n      return doEntryEquals(zf1, zf2, path1, path2);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  /**\n   * Compares two ZIP entries (byte-by-byte). .\n   *\n   * @param zf1\n   *          first ZIP file.\n   * @param zf2\n   *          second ZIP file.\n   * @param path1\n   *          name of the first entry.\n   * @param path2\n   *          name of the second entry.\n   * @return <code>true</code> if the contents of the entries were same.\n   */\n  private static boolean doEntryEquals(ZipFile zf1, ZipFile zf2, String path1, String path2) throws IOException {\n    InputStream is1 = null;\n    InputStream is2 = null;\n    try {\n      ZipEntry e1 = zf1.getEntry(path1);\n      ZipEntry e2 = zf2.getEntry(path2);\n\n      if (e1 == null && e2 == null) {\n        return true;\n      }\n\n      if (e1 == null || e2 == null) {\n        return false;\n      }\n\n      is1 = zf1.getInputStream(e1);\n      is2 = zf2.getInputStream(e2);\n      if (is1 == null && is2 == null) {\n        return true;\n      }\n      if (is1 == null || is2 == null) {\n        return false;\n      }\n\n      return IOUtils.contentEquals(is1, is2);\n    }\n    finally {\n      IOUtils.closeQuietly(is1);\n      IOUtils.closeQuietly(is2);\n    }\n  }\n\n  /**\n   * Closes the ZIP file while ignoring any errors.\n   *\n   * @param zf\n   *          ZIP file to be closed.\n   */\n  public static void closeQuietly(ZipFile zf) {\n    try {\n      if (zf != null) {\n        zf.close();\n      }\n    }\n    catch (IOException e) {\n    }\n  }\n\n  /**\n   * Simple helper to make inplace operation easier\n   *\n   * @author shelajev\n   */\n  private abstract static class InPlaceAction {\n\n    /**\n     * @return true if something has been changed during the action.\n     */\n    abstract boolean act(File tmpFile);\n  }\n\n  /**\n   *\n   * This method provides a general infrastructure for in-place operations.\n   * It creates temp file as a destination, then invokes the action on source and destination.\n   * Then it copies the result back into src file.\n   *\n   * @param src - source zip file we want to modify\n   * @param action - action which actually modifies the archives\n   *\n   * @return result of the action\n   */\n  private static boolean operateInPlace(File src, InPlaceAction action) {\n    File tmp = null;\n    try {\n      tmp = File.createTempFile(\"zt-zip-tmp\", \".zip\");\n      boolean result = action.act(tmp);\n      if (result) { // else nothing changes\n        FileUtils.forceDelete(src);\n        FileUtils.moveFile(tmp, src);\n      }\n      return result;\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      FileUtils.deleteQuietly(tmp);\n    }\n  }\n\n}\n"
      }
    ],
    "file_count": 1
  }
}